const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Introduction-DvteuFWO.js","./index-DOjqn9OY.js","./preload-helper-UZRgTS1n.js","./blocks-CGJKxwwC.js","./index-B5vH9_xk.js","./AccuDrawWidget.stories-DHbN83QP.js","./appui-react-CwKstaKu.js","./Key.enum-szt-ThaG.js","./client-H2bURNxP.js","./appui-react-2Kh3cum9.css","./AppUiStory-iS4J_UUr.js","./Utils-98Mhw6iN.js","./AppUiStory-CUteeFJi.css","./AutoSuggest.stories-B9ZKojap.js","./Decorators-BYkUmcDF.js","./Decorators-BfZu5j7o.css","./UiCore-zf9AMQ6q.js","./UiCore-DmYJAcBk.css","./AutoSuggest-CCGguE4H.css","./BackstageAppButton.stories-B_HqUb33.js","./BackstageAppButton-CL8vcI1t.js","./BackstageComposer.stories-Dfx1kj2J.js","./BackstageComposer-Bj6rodcd.js","./Calculator.stories-BxnNPcW7.js","./CardPopup.stories-CUisyLSp.js","./Save-DXxEIe5w.js","./ContextMenu.stories-D0loS307.js","./DivWithOutsideClick-JEHURlpk.js","./IconComponent-CF-TjIxv.js","./IconComponent-DBVUWmpg.css","./ContextMenu-D3lXQv3e.css","./Editors.stories-CQRbvIjt.js","./FilterBuilder.stories-F3GCH2q_.js","./MessageCenterField.stories-J8YIz5V8.js","./MessageCenterField-Bf7zrLgF.js","./NavigationAidHost.stories-Cq8HSary.js","./ViewportContent-CuLdatWF.js","./PropertyGrid.stories-Dg_yKaUZ.js","./UiComponents-4UD49Gne.js","./SubscriptionScheduler-BaQb_QQF.js","./QuantityFormat.stories-BL35cfab.js","./SolarTimeline.stories-DwAuQi2R.js","./PlayButton-BP9Jyqmf.js","./SolarTimeline-CKcL-yzK.css","./StatusBarComposer.stories-DWRFO4hp.js","./2D-DG565mhe.js","./3D-h_91nPrk.js","./Activity-CLwJx90p.js","./Android-vjhXQeS9.js","./Timeline.stories-DVoKpkb4.js","./Timeline-Bul7ryCz.css","./ToolAssistanceField.stories-BhCBz7zK.js","./ToolAssistanceField-C0zlguYr.js","./ToolSettingsPopup.stories-C8JyXdmO.js","./ToolbarComposer.stories-C62gg-YR.js","./createBumpEvent-BRKTskA4.js","./ToolbarPopup.stories-GE2AshOF.js","./TreeWidget.stories-B_pd7tdY.js","./ViewSelector.stories-CRRtP9yU.js","./BlockText.stories-BmdXpvwb.js","./StyledText-Davkq7YV.js","./ChecklistBox.stories-CwA3bCQ6.js","./ChecklistBox-CG1ZwFLT.css","./Dialog.stories-B-Yl8V_R.js","./Dialog-vjRVfAcq.js","./useTranslation-B3Le11CI.js","./Dialog-Bn5a8OnB.css","./DisabledText.stories-AtjTUZ-O.js","./ElementSeparator.stories-7vjMo9m9.js","./Orientation-6E0suNXD.js","./ElementSeparator-By-OmSBM.css","./ExpandableList.stories-CkSdUE0R.js","./GlobalDialog.stories-DCPDo5sL.js","./Icon.stories-Bwk1YnUQ.js","./IconInput.stories-BJFleBqT.js","./IconInput-2BP0U2bT.css","./ImageCheckBox.stories-CfMSj6_V.js","./ImageCheckBox-DPnh3nAY.css","./InputLabel.stories-C-qoCTvu.js","./Listbox.stories-wYDbgscu.js","./Listbox-0-yYd-NW.css","./LoadingBar.stories-DSmyYOur.js","./LoadingBar-DhbEkBG1.js","./LoadingBar-CPETIlEQ.css","./LoadingPrompt.stories-Vscz9A9G.js","./LoadingSpinner-DfDgllRL.js","./LoadingSpinner-JtT_Szr2.css","./LoadingStatus-2D9Cqoqk.js","./LoadingStatus-BwAtRc2f.css","./LoadingPrompt-CJOFArY3.css","./LoadingSpinner.stories-BHlpVKoT.js","./LoadingStatus.stories-CQ0nSHpq.js","./NumberInput.stories-CeG6z1-f.js","./NumberInput-dnkhDHfu.css","./RadialMenu.stories-BYvjp1bK.js","./SearchBox.stories-CcfIljEd.js","./SearchBox-CiLLlsxi.css","./Tabs.stories-BKJPFRHA.js","./Tabs-qVbpNoMb.js","./UnderlinedButton.stories-DzhNL0J3.js","./UnderlinedButton-BCaSl4Od.css","./VerticalTabs.stories-BwNvPsZK.js","./Active.stories-Cuhjn2Zw.js","./ConfigurableUiContent.stories-B-2jQo8q.js","./Frontstage.stories-BrPIHJa0.js","./Modal.stories-Sf6rriYu.js","./Nested.stories-CBwcTQkD.js","./SplitViewport.stories-BR0wyoAE.js","./ToolSettings.stories-D4OjtTsH.js","./LockPropertyTool-E3MQ_j6Y.js","./StoryTool-BnD4dGwH.js","./Visibility.stories-CcREanHb.js","./InputField.stories-s6QUryIH.js","./OutputMessage.stories-_iMqGjTd.js","./OutputPrompt.stories-Dtt2b-0Y.js","./useIsBackstageOpen-DHKACSLb.js","./useIsBackstageOpen.stories-DWXmtAjx.js","./KeyboardShortcuts.stories-CrIQTeDX.js","./ControlWidgetVisibility.stories-DOCz-5_f.js","./EnableMaximizedWidget.stories-BF3JHdDK.js","./ReparentPopoutWidgets.stories-DnWn2Oav.js","./ToolSettingsKeyPressCommit.stories-QgbVUiHL.js","./ToolSettingsLockButton.stories-hvK6P-5L.js","./WidgetActionDropdown.stories-D13w0Q-I.js","./WidgetTabActions.stories-DAL_TXkH.js","./CanFloat.stories-DvV74e_S.js","./CanPopout.stories-DMwVqL16.js","./EmptyState.stories-DCD6aLtU.js","./Widget.stories-cpoTz0Px.js","./WidgetContentLayout.Body.stories-CztbveAA.js","./WidgetContentLayout.Header.stories-DJHwFGn0.js","./WidgetContentLayout.stories-BTw7k4IQ.js","./react-18-DZdtAi6r.js","./DocsRenderer-GHJI37HO-BKB2fj9D.js","./styles-DQtb7xJ6.css"])))=>i.map(i=>d[i]);
import { _ as __vitePreload } from "./preload-helper-UZRgTS1n.js";
function _mergeNamespaces(n2, m) {
  for (var i2 = 0; i2 < m.length; i2++) {
    const e2 = m[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d = Object.getOwnPropertyDescriptor(e2, k2);
          if (d) {
            Object.defineProperty(n2, k2, d.get ? d : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var define_process_env_default = {};
var __create$3 = Object.create;
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$3 = Object.getOwnPropertyNames;
var __getProtoOf$3 = Object.getPrototypeOf, __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __require$2 = /* @__PURE__ */ ((x2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require < "u" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS$3 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames$3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export$4 = (target, all) => {
  for (var name in all)
    __defProp$5(target, name, { get: all[name], enumerable: true });
}, __copyProps$3 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames$3(from))
      !__hasOwnProp$4.call(to, key) && key !== except && __defProp$5(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable });
  return to;
};
var __toESM$3 = (mod, isNodeMode, target) => (target = mod != null ? __create$3(__getProtoOf$3(mod)) : {}, __copyProps$3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp$5(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_tiny_isequal = __commonJS$3({
  "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true }), exports.isEqual = /* @__PURE__ */ function() {
      var e2 = Object.prototype.toString, r2 = Object.getPrototypeOf, t22 = Object.getOwnPropertySymbols ? function(e3) {
        return Object.keys(e3).concat(Object.getOwnPropertySymbols(e3));
      } : Object.keys;
      return function(n2, a2) {
        return function n3(a3, c2, u3) {
          var i2, s3, l2, o2 = e2.call(a3), f4 = e2.call(c2);
          if (a3 === c2) return true;
          if (a3 == null || c2 == null) return false;
          if (u3.indexOf(a3) > -1 && u3.indexOf(c2) > -1) return true;
          if (u3.push(a3, c2), o2 != f4 || (i2 = t22(a3), s3 = t22(c2), i2.length != s3.length || i2.some(function(e3) {
            return !n3(a3[e3], c2[e3], u3);
          }))) return false;
          switch (o2.slice(8, -1)) {
            case "Symbol":
              return a3.valueOf() == c2.valueOf();
            case "Date":
            case "Number":
              return +a3 == +c2 || +a3 != +a3 && +c2 != +c2;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + a3 == "" + c2;
            case "Set":
            case "Map":
              i2 = a3.entries(), s3 = c2.entries();
              do
                if (!n3((l2 = i2.next()).value, s3.next().value, u3)) return false;
              while (!l2.done);
              return true;
            case "ArrayBuffer":
              a3 = new Uint8Array(a3), c2 = new Uint8Array(c2);
            case "DataView":
              a3 = new Uint8Array(a3.buffer), c2 = new Uint8Array(c2.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (a3.length != c2.length) return false;
              for (l2 = 0; l2 < a3.length; l2++) if ((l2 in a3 || l2 in c2) && (l2 in a3 != l2 in c2 || !n3(a3[l2], c2[l2], u3))) return false;
              return true;
            case "Object":
              return n3(r2(a3), r2(c2), u3);
            default:
              return false;
          }
        }(n2, a2, []);
      };
    }();
  }
});
var require_min_indent = __commonJS$3({
  "../node_modules/min-indent/index.js"(exports, module2) {
    module2.exports = (string) => {
      let match = string.match(/^[ \t]*(?=\S)/gm);
      return match ? match.reduce((r2, a2) => Math.min(r2, a2.length), 1 / 0) : 0;
    };
  }
});
var require_strip_indent = __commonJS$3({
  "../node_modules/strip-indent/index.js"(exports, module2) {
    var minIndent = require_min_indent();
    module2.exports = (string) => {
      let indent2 = minIndent(string);
      if (indent2 === 0)
        return string;
      let regex = new RegExp(`^[ \\t]{${indent2}}`, "gm");
      return string.replace(regex, "");
    };
  }
});
var require_indent_string = __commonJS$3({
  "../node_modules/indent-string/index.js"(exports, module2) {
    module2.exports = (string, count2 = 1, options) => {
      if (options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      }, typeof string != "string")
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      if (typeof count2 != "number")
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count2}\``
        );
      if (typeof options.indent != "string")
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      if (count2 === 0)
        return string;
      let regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count2));
    };
  }
});
var require_redent = __commonJS$3({
  "../node_modules/redent/index.js"(exports, module2) {
    var stripIndent = require_strip_indent(), indentString = require_indent_string();
    module2.exports = (string, count2 = 0, options) => indentString(stripIndent(string), count2, options);
  }
});
var require_iteratorProxy = __commonJS$3({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this, index2 = 0, iter = {
        "@@iterator": function() {
          return iter;
        },
        next: function() {
          if (index2 < values.length) {
            var value = values[index2];
            return index2 = index2 + 1, {
              done: false,
              value
            };
          } else
            return {
              done: true
            };
        }
      };
      return iter;
    }
    exports.default = iteratorProxy;
  }
});
var require_iterationDecorator = __commonJS$3({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _typeof5(o2) {
      "@babel/helpers - typeof";
      return _typeof5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof5(o2);
    }
    function iterationDecorator(collection, entries) {
      return typeof Symbol == "function" && _typeof5(Symbol.iterator) === "symbol" && Object.defineProperty(collection, Symbol.iterator, {
        value: _iteratorProxy.default.bind(entries)
      }), collection;
    }
  }
});
var require_ariaPropsMap = __commonJS$3({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray2(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray2(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray2(r2, a2);
        var t22 = {}.toString.call(r2).slice(8, -1);
        return t22 === "Object" && r2.constructor && (t22 = r2.constructor.name), t22 === "Map" || t22 === "Set" ? Array.from(r2) : t22 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t22) ? _arrayLikeToArray2(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray2(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t22 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t22 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t22 = t22.call(r2)).next, l2 === 0) {
            if (Object(t22) !== t22) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t22)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && t22.return != null && (u3 = t22.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var properties = [["aria-activedescendant", {
      type: "id"
    }], ["aria-atomic", {
      type: "boolean"
    }], ["aria-autocomplete", {
      type: "token",
      values: ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      type: "string"
    }], ["aria-brailleroledescription", {
      type: "string"
    }], ["aria-busy", {
      type: "boolean"
    }], ["aria-checked", {
      type: "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      type: "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      type: "idlist"
    }], ["aria-description", {
      type: "string"
    }], ["aria-details", {
      type: "id"
    }], ["aria-disabled", {
      type: "boolean"
    }], ["aria-dropeffect", {
      type: "tokenlist",
      values: ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      type: "id"
    }], ["aria-expanded", {
      type: "boolean",
      allowundefined: true
    }], ["aria-flowto", {
      type: "idlist"
    }], ["aria-grabbed", {
      type: "boolean",
      allowundefined: true
    }], ["aria-haspopup", {
      type: "token",
      values: [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      type: "boolean",
      allowundefined: true
    }], ["aria-invalid", {
      type: "token",
      values: ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      type: "string"
    }], ["aria-labelledby", {
      type: "idlist"
    }], ["aria-level", {
      type: "integer"
    }], ["aria-live", {
      type: "token",
      values: ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      type: "boolean"
    }], ["aria-multiselectable", {
      type: "boolean"
    }], ["aria-orientation", {
      type: "token",
      values: ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      type: "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      type: "integer"
    }], ["aria-pressed", {
      type: "tristate"
    }], ["aria-readonly", {
      type: "boolean"
    }], ["aria-relevant", {
      type: "tokenlist",
      values: ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      type: "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      type: "boolean",
      allowundefined: true
    }], ["aria-setsize", {
      type: "integer"
    }], ["aria-sort", {
      type: "token",
      values: ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      type: "number"
    }], ["aria-valuemin", {
      type: "number"
    }], ["aria-valuenow", {
      type: "number"
    }], ["aria-valuetext", {
      type: "string"
    }]], ariaPropsMap = {
      entries: function() {
        return properties;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key = _properties$_i[0], values = _properties$_i[1];
          fn3.call(thisArg, values, key, properties);
        }
      },
      get: function(key) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!ariaPropsMap.get(key);
      },
      keys: function() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});
var require_domMap = __commonJS$3({
  "../node_modules/aria-query/lib/domMap.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray2(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray2(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray2(r2, a2);
        var t22 = {}.toString.call(r2).slice(8, -1);
        return t22 === "Object" && r2.constructor && (t22 = r2.constructor.name), t22 === "Map" || t22 === "Set" ? Array.from(r2) : t22 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t22) ? _arrayLikeToArray2(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray2(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t22 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t22 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t22 = t22.call(r2)).next, l2 === 0) {
            if (Object(t22) !== t22) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t22)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && t22.return != null && (u3 = t22.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]], domMap = {
      entries: function() {
        return dom;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key = _dom$_i[0], values = _dom$_i[1];
          fn3.call(thisArg, values, key, dom);
        }
      },
      get: function(key) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!domMap.get(key);
      },
      keys: function() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});
var require_commandRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    exports.default = commandRole;
  }
});
var require_compositeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    exports.default = compositeRole;
  }
});
var require_inputRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    exports.default = inputRole;
  }
});
var require_landmarkRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = landmarkRole;
  }
});
var require_rangeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = rangeRole;
  }
});
var require_roletypeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    exports.default = roletypeRole;
  }
});
var require_sectionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = sectionRole;
  }
});
var require_sectionheadRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = sectionheadRole;
  }
});
var require_selectRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    exports.default = selectRole;
  }
});
var require_structureRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    exports.default = structureRole;
  }
});
var require_widgetRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    exports.default = widgetRole;
  }
});
var require_windowRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    exports.default = windowRole;
  }
});
var require_ariaAbstractRoles = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole()), _compositeRole = _interopRequireDefault(require_compositeRole()), _inputRole = _interopRequireDefault(require_inputRole()), _landmarkRole = _interopRequireDefault(require_landmarkRole()), _rangeRole = _interopRequireDefault(require_rangeRole()), _roletypeRole = _interopRequireDefault(require_roletypeRole()), _sectionRole = _interopRequireDefault(require_sectionRole()), _sectionheadRole = _interopRequireDefault(require_sectionheadRole()), _selectRole = _interopRequireDefault(require_selectRole()), _structureRole = _interopRequireDefault(require_structureRole()), _widgetRole = _interopRequireDefault(require_widgetRole()), _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    exports.default = ariaAbstractRoles;
  }
});
var require_alertRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = alertRole;
  }
});
var require_alertdialogRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    exports.default = alertdialogRole;
  }
});
var require_applicationRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = applicationRole;
  }
});
var require_articleRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    exports.default = articleRole;
  }
});
var require_bannerRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = bannerRole;
  }
});
var require_blockquoteRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = blockquoteRole;
  }
});
var require_buttonRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    exports.default = buttonRole;
  }
});
var require_captionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = captionRole;
  }
});
var require_cellRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = cellRole;
  }
});
var require_checkboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    exports.default = checkboxRole;
  }
});
var require_codeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = codeRole;
  }
});
var require_columnheaderRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    exports.default = columnheaderRole;
  }
});
var require_comboboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    exports.default = comboboxRole;
  }
});
var require_complementaryRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = complementaryRole;
  }
});
var require_contentinfoRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = contentinfoRole;
  }
});
var require_definitionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = definitionRole;
  }
});
var require_deletionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = deletionRole;
  }
});
var require_dialogRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    exports.default = dialogRole;
  }
});
var require_directoryRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    exports.default = directoryRole;
  }
});
var require_documentRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = documentRole;
  }
});
var require_emphasisRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = emphasisRole;
  }
});
var require_feedRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    exports.default = feedRole;
  }
});
var require_figureRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = figureRole;
  }
});
var require_formRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = formRole;
  }
});
var require_genericRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = genericRole;
  }
});
var require_gridRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    exports.default = gridRole;
  }
});
var require_gridcellRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    exports.default = gridcellRole;
  }
});
var require_groupRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = groupRole;
  }
});
var require_headingRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    exports.default = headingRole;
  }
});
var require_imgRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = imgRole;
  }
});
var require_insertionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = insertionRole;
  }
});
var require_linkRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    exports.default = linkRole;
  }
});
var require_listRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = listRole;
  }
});
var require_listboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    exports.default = listboxRole;
  }
});
var require_listitemRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = listitemRole;
  }
});
var require_logRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = logRole;
  }
});
var require_mainRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = mainRole;
  }
});
var require_markRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = markRole;
  }
});
var require_marqueeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = marqueeRole;
  }
});
var require_mathRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = mathRole;
  }
});
var require_menuRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    exports.default = menuRole;
  }
});
var require_menubarRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    exports.default = menubarRole;
  }
});
var require_menuitemRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    exports.default = menuitemRole;
  }
});
var require_menuitemcheckboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    exports.default = menuitemcheckboxRole;
  }
});
var require_menuitemradioRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    exports.default = menuitemradioRole;
  }
});
var require_meterRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    exports.default = meterRole;
  }
});
var require_navigationRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = navigationRole;
  }
});
var require_noneRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    exports.default = noneRole;
  }
});
var require_noteRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = noteRole;
  }
});
var require_optionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    exports.default = optionRole;
  }
});
var require_paragraphRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = paragraphRole;
  }
});
var require_presentationRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = presentationRole;
  }
});
var require_progressbarRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    exports.default = progressbarRole;
  }
});
var require_radioRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    exports.default = radioRole;
  }
});
var require_radiogroupRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    exports.default = radiogroupRole;
  }
});
var require_regionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = regionRole;
  }
});
var require_rowRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    exports.default = rowRole;
  }
});
var require_rowgroupRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = rowgroupRole;
  }
});
var require_rowheaderRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    exports.default = rowheaderRole;
  }
});
var require_scrollbarRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    exports.default = scrollbarRole;
  }
});
var require_searchRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = searchRole;
  }
});
var require_searchboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    exports.default = searchboxRole;
  }
});
var require_separatorRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    exports.default = separatorRole;
  }
});
var require_sliderRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    exports.default = sliderRole;
  }
});
var require_spinbuttonRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    exports.default = spinbuttonRole;
  }
});
var require_statusRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = statusRole;
  }
});
var require_strongRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = strongRole;
  }
});
var require_subscriptRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = subscriptRole;
  }
});
var require_superscriptRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = superscriptRole;
  }
});
var require_switchRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    exports.default = switchRole;
  }
});
var require_tabRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    exports.default = tabRole;
  }
});
var require_tableRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = tableRole;
  }
});
var require_tablistRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    exports.default = tablistRole;
  }
});
var require_tabpanelRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = tabpanelRole;
  }
});
var require_termRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = termRole;
  }
});
var require_textboxRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    exports.default = textboxRole;
  }
});
var require_timeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = timeRole;
  }
});
var require_timerRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    exports.default = timerRole;
  }
});
var require_toolbarRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    exports.default = toolbarRole;
  }
});
var require_tooltipRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = tooltipRole;
  }
});
var require_treeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    exports.default = treeRole;
  }
});
var require_treegridRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    exports.default = treegridRole;
  }
});
var require_treeitemRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    exports.default = treeitemRole;
  }
});
var require_ariaLiteralRoles = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole()), _alertdialogRole = _interopRequireDefault(require_alertdialogRole()), _applicationRole = _interopRequireDefault(require_applicationRole()), _articleRole = _interopRequireDefault(require_articleRole()), _bannerRole = _interopRequireDefault(require_bannerRole()), _blockquoteRole = _interopRequireDefault(require_blockquoteRole()), _buttonRole = _interopRequireDefault(require_buttonRole()), _captionRole = _interopRequireDefault(require_captionRole()), _cellRole = _interopRequireDefault(require_cellRole()), _checkboxRole = _interopRequireDefault(require_checkboxRole()), _codeRole = _interopRequireDefault(require_codeRole()), _columnheaderRole = _interopRequireDefault(require_columnheaderRole()), _comboboxRole = _interopRequireDefault(require_comboboxRole()), _complementaryRole = _interopRequireDefault(require_complementaryRole()), _contentinfoRole = _interopRequireDefault(require_contentinfoRole()), _definitionRole = _interopRequireDefault(require_definitionRole()), _deletionRole = _interopRequireDefault(require_deletionRole()), _dialogRole = _interopRequireDefault(require_dialogRole()), _directoryRole = _interopRequireDefault(require_directoryRole()), _documentRole = _interopRequireDefault(require_documentRole()), _emphasisRole = _interopRequireDefault(require_emphasisRole()), _feedRole = _interopRequireDefault(require_feedRole()), _figureRole = _interopRequireDefault(require_figureRole()), _formRole = _interopRequireDefault(require_formRole()), _genericRole = _interopRequireDefault(require_genericRole()), _gridRole = _interopRequireDefault(require_gridRole()), _gridcellRole = _interopRequireDefault(require_gridcellRole()), _groupRole = _interopRequireDefault(require_groupRole()), _headingRole = _interopRequireDefault(require_headingRole()), _imgRole = _interopRequireDefault(require_imgRole()), _insertionRole = _interopRequireDefault(require_insertionRole()), _linkRole = _interopRequireDefault(require_linkRole()), _listRole = _interopRequireDefault(require_listRole()), _listboxRole = _interopRequireDefault(require_listboxRole()), _listitemRole = _interopRequireDefault(require_listitemRole()), _logRole = _interopRequireDefault(require_logRole()), _mainRole = _interopRequireDefault(require_mainRole()), _markRole = _interopRequireDefault(require_markRole()), _marqueeRole = _interopRequireDefault(require_marqueeRole()), _mathRole = _interopRequireDefault(require_mathRole()), _menuRole = _interopRequireDefault(require_menuRole()), _menubarRole = _interopRequireDefault(require_menubarRole()), _menuitemRole = _interopRequireDefault(require_menuitemRole()), _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole()), _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole()), _meterRole = _interopRequireDefault(require_meterRole()), _navigationRole = _interopRequireDefault(require_navigationRole()), _noneRole = _interopRequireDefault(require_noneRole()), _noteRole = _interopRequireDefault(require_noteRole()), _optionRole = _interopRequireDefault(require_optionRole()), _paragraphRole = _interopRequireDefault(require_paragraphRole()), _presentationRole = _interopRequireDefault(require_presentationRole()), _progressbarRole = _interopRequireDefault(require_progressbarRole()), _radioRole = _interopRequireDefault(require_radioRole()), _radiogroupRole = _interopRequireDefault(require_radiogroupRole()), _regionRole = _interopRequireDefault(require_regionRole()), _rowRole = _interopRequireDefault(require_rowRole()), _rowgroupRole = _interopRequireDefault(require_rowgroupRole()), _rowheaderRole = _interopRequireDefault(require_rowheaderRole()), _scrollbarRole = _interopRequireDefault(require_scrollbarRole()), _searchRole = _interopRequireDefault(require_searchRole()), _searchboxRole = _interopRequireDefault(require_searchboxRole()), _separatorRole = _interopRequireDefault(require_separatorRole()), _sliderRole = _interopRequireDefault(require_sliderRole()), _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole()), _statusRole = _interopRequireDefault(require_statusRole()), _strongRole = _interopRequireDefault(require_strongRole()), _subscriptRole = _interopRequireDefault(require_subscriptRole()), _superscriptRole = _interopRequireDefault(require_superscriptRole()), _switchRole = _interopRequireDefault(require_switchRole()), _tabRole = _interopRequireDefault(require_tabRole()), _tableRole = _interopRequireDefault(require_tableRole()), _tablistRole = _interopRequireDefault(require_tablistRole()), _tabpanelRole = _interopRequireDefault(require_tabpanelRole()), _termRole = _interopRequireDefault(require_termRole()), _textboxRole = _interopRequireDefault(require_textboxRole()), _timeRole = _interopRequireDefault(require_timeRole()), _timerRole = _interopRequireDefault(require_timerRole()), _toolbarRole = _interopRequireDefault(require_toolbarRole()), _tooltipRole = _interopRequireDefault(require_tooltipRole()), _treeRole = _interopRequireDefault(require_treeRole()), _treegridRole = _interopRequireDefault(require_treegridRole()), _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    exports.default = ariaLiteralRoles;
  }
});
var require_docAbstractRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docAbstractRole;
  }
});
var require_docAcknowledgmentsRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docAcknowledgmentsRole;
  }
});
var require_docAfterwordRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docAfterwordRole;
  }
});
var require_docAppendixRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docAppendixRole;
  }
});
var require_docBacklinkRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    exports.default = docBacklinkRole;
  }
});
var require_docBiblioentryRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    exports.default = docBiblioentryRole;
  }
});
var require_docBibliographyRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docBibliographyRole;
  }
});
var require_docBibliorefRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    exports.default = docBibliorefRole;
  }
});
var require_docChapterRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docChapterRole;
  }
});
var require_docColophonRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docColophonRole;
  }
});
var require_docConclusionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docConclusionRole;
  }
});
var require_docCoverRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    exports.default = docCoverRole;
  }
});
var require_docCreditRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docCreditRole;
  }
});
var require_docCreditsRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docCreditsRole;
  }
});
var require_docDedicationRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docDedicationRole;
  }
});
var require_docEndnoteRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    exports.default = docEndnoteRole;
  }
});
var require_docEndnotesRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docEndnotesRole;
  }
});
var require_docEpigraphRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docEpigraphRole;
  }
});
var require_docEpilogueRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docEpilogueRole;
  }
});
var require_docErrataRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docErrataRole;
  }
});
var require_docExampleRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docExampleRole;
  }
});
var require_docFootnoteRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docFootnoteRole;
  }
});
var require_docForewordRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docForewordRole;
  }
});
var require_docGlossaryRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docGlossaryRole;
  }
});
var require_docGlossrefRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    exports.default = docGlossrefRole;
  }
});
var require_docIndexRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    exports.default = docIndexRole;
  }
});
var require_docIntroductionRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docIntroductionRole;
  }
});
var require_docNoterefRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    exports.default = docNoterefRole;
  }
});
var require_docNoticeRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    exports.default = docNoticeRole;
  }
});
var require_docPagebreakRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    exports.default = docPagebreakRole;
  }
});
var require_docPagefooterRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docPagefooterRole;
  }
});
var require_docPageheaderRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docPageheaderRole;
  }
});
var require_docPagelistRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    exports.default = docPagelistRole;
  }
});
var require_docPartRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docPartRole;
  }
});
var require_docPrefaceRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docPrefaceRole;
  }
});
var require_docPrologueRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    exports.default = docPrologueRole;
  }
});
var require_docPullquoteRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    exports.default = docPullquoteRole;
  }
});
var require_docQnaRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    exports.default = docQnaRole;
  }
});
var require_docSubtitleRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    exports.default = docSubtitleRole;
  }
});
var require_docTipRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    exports.default = docTipRole;
  }
});
var require_docTocRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    exports.default = docTocRole;
  }
});
var require_ariaDpubRoles = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole()), _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole()), _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole()), _docAppendixRole = _interopRequireDefault(require_docAppendixRole()), _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole()), _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole()), _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole()), _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole()), _docChapterRole = _interopRequireDefault(require_docChapterRole()), _docColophonRole = _interopRequireDefault(require_docColophonRole()), _docConclusionRole = _interopRequireDefault(require_docConclusionRole()), _docCoverRole = _interopRequireDefault(require_docCoverRole()), _docCreditRole = _interopRequireDefault(require_docCreditRole()), _docCreditsRole = _interopRequireDefault(require_docCreditsRole()), _docDedicationRole = _interopRequireDefault(require_docDedicationRole()), _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole()), _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole()), _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole()), _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole()), _docErrataRole = _interopRequireDefault(require_docErrataRole()), _docExampleRole = _interopRequireDefault(require_docExampleRole()), _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole()), _docForewordRole = _interopRequireDefault(require_docForewordRole()), _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole()), _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole()), _docIndexRole = _interopRequireDefault(require_docIndexRole()), _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole()), _docNoterefRole = _interopRequireDefault(require_docNoterefRole()), _docNoticeRole = _interopRequireDefault(require_docNoticeRole()), _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole()), _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole()), _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole()), _docPagelistRole = _interopRequireDefault(require_docPagelistRole()), _docPartRole = _interopRequireDefault(require_docPartRole()), _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole()), _docPrologueRole = _interopRequireDefault(require_docPrologueRole()), _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole()), _docQnaRole = _interopRequireDefault(require_docQnaRole()), _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole()), _docTipRole = _interopRequireDefault(require_docTipRole()), _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    exports.default = ariaDpubRoles;
  }
});
var require_graphicsDocumentRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    exports.default = graphicsDocumentRole;
  }
});
var require_graphicsObjectRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    exports.default = graphicsObjectRole;
  }
});
var require_graphicsSymbolRole = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    exports.default = graphicsSymbolRole;
  }
});
var require_ariaGraphicsRoles = __commonJS$3({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole()), _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole()), _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    exports.default = ariaGraphicsRoles;
  }
});
var require_rolesMap = __commonJS$3({
  "../node_modules/aria-query/lib/rolesMap.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles()), _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles()), _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles()), _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles()), _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _createForOfIteratorHelper(r2, e2) {
      var t22 = typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (!t22) {
        if (Array.isArray(r2) || (t22 = _unsupportedIterableToArray2(r2)) || e2) {
          t22 && (r2 = t22);
          var _n = 0, F = function() {
          };
          return { s: F, n: function() {
            return _n >= r2.length ? { done: true } : { done: false, value: r2[_n++] };
          }, e: function(r3) {
            throw r3;
          }, f: F };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var o2, a2 = true, u3 = false;
      return { s: function() {
        t22 = t22.call(r2);
      }, n: function() {
        var r3 = t22.next();
        return a2 = r3.done, r3;
      }, e: function(r3) {
        u3 = true, o2 = r3;
      }, f: function() {
        try {
          a2 || t22.return == null || t22.return();
        } finally {
          if (u3) throw o2;
        }
      } };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray2(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray2(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray2(r2, a2);
        var t22 = {}.toString.call(r2).slice(8, -1);
        return t22 === "Object" && r2.constructor && (t22 = r2.constructor.name), t22 === "Map" || t22 === "Set" ? Array.from(r2) : t22 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t22) ? _arrayLikeToArray2(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray2(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t22 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t22 != null) {
        var e2, n2, i2, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i2 = (t22 = t22.call(r2)).next, l2 === 0) {
            if (Object(t22) !== t22) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i2.call(t22)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && t22.return != null && (u3 = t22.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roles3 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles3.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1], _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value, _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function() {
              var superClassName = _step2.value, superClassRoleTuple = roles3.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              })[0];
              if (superClassRoleTuple)
                for (var superClassDefinition = superClassRoleTuple[1], _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop = _Object$keys[_i];
                  Object.prototype.hasOwnProperty.call(roleDefinition.props, prop) || (roleDefinition.props[prop] = superClassDefinition.props[prop]);
                }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; )
              _loop();
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function() {
        return roles3;
      },
      forEach: function(fn3) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator3 = _createForOfIteratorHelper(roles3), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
            fn3.call(thisArg, values, key, roles3);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function(key) {
        var item = roles3.filter(function(tuple) {
          return tuple[0] === key;
        })[0];
        return item && item[1];
      },
      has: function(key) {
        return !!rolesMap.get(key);
      },
      keys: function() {
        return roles3.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
          return key;
        });
      },
      values: function() {
        return roles3.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});
var require_elementRoleMap = __commonJS$3({
  "../node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray2(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray2(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray2(r2, a2);
        var t22 = {}.toString.call(r2).slice(8, -1);
        return t22 === "Object" && r2.constructor && (t22 = r2.constructor.name), t22 === "Map" || t22 === "Set" ? Array.from(r2) : t22 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t22) ? _arrayLikeToArray2(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray2(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t22 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t22 != null) {
        var e2, n2, i3, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i3 = (t22 = t22.call(r2)).next, l2 === 0) {
            if (Object(t22) !== t22) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i3.call(t22)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && t22.return != null && (u3 = t22.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var elementRoles3 = [], keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++)
      if (key = keys2[i2], role = _rolesMap.default.get(key), role)
        for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), _loop = function() {
          var relation = concepts[k2];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles3.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0], roles3;
              elementRoleRelation ? roles3 = elementRoleRelation[1] : roles3 = [];
              for (var isUnique = true, _i = 0; _i < roles3.length; _i++)
                if (roles3[_i] === key) {
                  isUnique = false;
                  break;
                }
              isUnique && roles3.push(key), elementRoleRelation || elementRoles3.push([concept, roles3]);
            }
          }
        }, k2 = 0; k2 < concepts.length; k2++)
          _loop();
    var key, role, concepts, _loop, k2, i2, elementRoleMap = {
      entries: function() {
        return elementRoles3;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i2 = 0, _elementRoles = elementRoles3; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn3.call(thisArg, values, _key, elementRoles3);
        }
      },
      get: function(key2) {
        var item = elementRoles3.filter(function(tuple) {
          return key2.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key2.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      },
      has: function(key2) {
        return !!elementRoleMap.get(key2);
      },
      keys: function() {
        return elementRoles3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function() {
        return elementRoles3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    function ariaRoleRelationConceptEquals(a2, b2) {
      return a2.name === b2.name && ariaRoleRelationConstraintsEquals(a2.constraints, b2.constraints) && ariaRoleRelationConceptAttributeEquals(a2.attributes, b2.attributes);
    }
    function ariaRoleRelationConstraintsEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0 || a2 !== void 0 && b2 === void 0)
        return false;
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length)
          return false;
        for (var _i3 = 0; _i3 < a2.length; _i3++)
          if (a2[_i3] !== b2[_i3])
            return false;
      }
      return true;
    }
    function ariaRoleRelationConceptAttributeEquals(a2, b2) {
      if (a2 === void 0 && b2 !== void 0 || a2 !== void 0 && b2 === void 0)
        return false;
      if (a2 !== void 0 && b2 !== void 0) {
        if (a2.length !== b2.length)
          return false;
        for (var _i4 = 0; _i4 < a2.length; _i4++) {
          if (a2[_i4].name !== b2[_i4].name || a2[_i4].value !== b2[_i4].value || a2[_i4].constraints === void 0 && b2[_i4].constraints !== void 0 || a2[_i4].constraints !== void 0 && b2[_i4].constraints === void 0)
            return false;
          if (a2[_i4].constraints !== void 0 && b2[_i4].constraints !== void 0) {
            if (a2[_i4].constraints.length !== b2[_i4].constraints.length)
              return false;
            for (var j2 = 0; j2 < a2[_i4].constraints.length; j2++)
              if (a2[_i4].constraints[j2] !== b2[_i4].constraints[j2])
                return false;
          }
        }
      }
      return true;
    }
    exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});
var require_roleElementMap = __commonJS$3({
  "../node_modules/aria-query/lib/roleElementMap.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray2(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray2(r2, a2) {
      if (r2) {
        if (typeof r2 == "string") return _arrayLikeToArray2(r2, a2);
        var t22 = {}.toString.call(r2).slice(8, -1);
        return t22 === "Object" && r2.constructor && (t22 = r2.constructor.name), t22 === "Map" || t22 === "Set" ? Array.from(r2) : t22 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t22) ? _arrayLikeToArray2(r2, a2) : void 0;
      }
    }
    function _arrayLikeToArray2(r2, a2) {
      (a2 == null || a2 > r2.length) && (a2 = r2.length);
      for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t22 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
      if (t22 != null) {
        var e2, n2, i3, u3, a2 = [], f4 = true, o2 = false;
        try {
          if (i3 = (t22 = t22.call(r2)).next, l2 === 0) {
            if (Object(t22) !== t22) return;
            f4 = false;
          } else for (; !(f4 = (e2 = i3.call(t22)).done) && (a2.push(e2.value), a2.length !== l2); f4 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f4 && t22.return != null && (u3 = t22.return(), Object(u3) !== u3)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a2;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roleElement = [], keys2 = _rolesMap.default.keys();
    for (i2 = 0; i2 < keys2.length; i2++)
      if (key = keys2[i2], role = _rolesMap.default.get(key), relationConcepts = [], role) {
        for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), k2 = 0; k2 < concepts.length; k2++)
          relation = concepts[k2], relation.module === "HTML" && (concept = relation.concept, concept != null && relationConcepts.push(concept));
        relationConcepts.length > 0 && roleElement.push([key, relationConcepts]);
      }
    var key, role, relationConcepts, concepts, relation, concept, k2, i2, roleElementMap = {
      entries: function() {
        return roleElement;
      },
      forEach: function(fn3) {
        for (var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn3.call(thisArg, values, _key, roleElement);
        }
      },
      get: function(key2) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key2;
        })[0];
        return item && item[1];
      },
      has: function(key2) {
        return !!roleElementMap.get(key2);
      },
      keys: function() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});
var require_lib = __commonJS$3({
  "../node_modules/aria-query/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap()), _domMap = _interopRequireDefault(require_domMap()), _rolesMap = _interopRequireDefault(require_rolesMap()), _elementRoleMap = _interopRequireDefault(require_elementRoleMap()), _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    exports.aria = _ariaPropsMap.default;
    exports.dom = _domMap.default;
    exports.roles = _rolesMap.default;
    exports.elementRoles = _elementRoleMap.default;
    exports.roleElements = _roleElementMap.default;
  }
});
var require_picocolors_browser = __commonJS$3({
  "../node_modules/picocolors/picocolors.browser.js"(exports, module2) {
    var x2 = String, create = function() {
      return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2, blackBright: x2, redBright: x2, greenBright: x2, yellowBright: x2, blueBright: x2, magentaBright: x2, cyanBright: x2, whiteBright: x2, bgBlackBright: x2, bgRedBright: x2, bgGreenBright: x2, bgYellowBright: x2, bgBlueBright: x2, bgMagentaBright: x2, bgCyanBright: x2, bgWhiteBright: x2 };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});
var require_css_escape = __commonJS$3({
  "../node_modules/css.escape/css.escape.js"(exports, module2) {
    (function(root2, factory) {
      typeof exports == "object" ? module2.exports = factory(root2) : typeof define == "function" && define.amd ? define([], factory.bind(root2, root2)) : factory(root2);
    })(typeof global < "u" ? global : exports, function(root2) {
      if (root2.CSS && root2.CSS.escape)
        return root2.CSS.escape;
      var cssEscape = function(value) {
        if (arguments.length == 0)
          throw new TypeError("`CSS.escape` requires an argument.");
        for (var string = String(value), length = string.length, index2 = -1, codeUnit, result = "", firstCodeUnit = string.charCodeAt(0); ++index2 < length; ) {
          if (codeUnit = string.charCodeAt(index2), codeUnit == 0) {
            result += "";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, []
            codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), []
            index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
            index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
          ) {
            result += "\\" + codeUnit.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, []
            index2 == 0 && length == 1 && codeUnit == 45
          ) {
            result += "\\" + string.charAt(index2);
            continue;
          }
          if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
            result += string.charAt(index2);
            continue;
          }
          result += "\\" + string.charAt(index2);
        }
        return result;
      };
      return root2.CSS || (root2.CSS = {}), root2.CSS.escape = cssEscape, cssEscape;
    });
  }
});
var require_ansi_styles = __commonJS$3({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(exports, module2) {
    var wrapAnsi256 = (offset2 = 0) => (code) => `\x1B[${38 + offset2};5;${code}m`, wrapAnsi16m = (offset2 = 0) => (red, green, blue) => `\x1B[${38 + offset2};2;${red};${green};${blue}m`;
    function assembleStyles() {
      let codes = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (let [groupName, group] of Object.entries(styles3)) {
        for (let [styleName, style] of Object.entries(group))
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }, group[styleName] = styles3[styleName], codes.set(style[0], style[1]);
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: false
        });
      }
      return Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi256 = wrapAnsi256(), styles3.color.ansi16m = wrapAnsi16m(), styles3.bgColor.ansi256 = wrapAnsi256(10), styles3.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: (red, green, blue) => red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5),
          enumerable: false
        },
        hexToRgb: {
          value: (hex3) => {
            let matches5 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex3.toString(16));
            if (!matches5)
              return [0, 0, 0];
            let { colorString } = matches5.groups;
            colorString.length === 3 && (colorString = colorString.split("").map((character) => character + character).join(""));
            let integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex3) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex3)),
          enumerable: false
        }
      }), styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});
var require_collections = __commonJS$3({
  "../node_modules/pretty-format/build/collections.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printIteratorEntries = printIteratorEntries2;
    exports.printIteratorValues = printIteratorValues2;
    exports.printListItems = printListItems2;
    exports.printObjectProperties = printObjectProperties2;
    var getKeysOfEnumerableProperties2 = (object, compareKeys) => {
      let keys2 = Object.keys(object).sort(compareKeys);
      return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(object).forEach((symbol) => {
        Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
      }), keys2;
    };
    function printIteratorEntries2(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
      let result = "", current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (; !current.done; ) {
          let name = printer2(
            current.value[0],
            config4,
            indentationNext,
            depth,
            refs
          ), value = printer2(
            current.value[1],
            config4,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value, current = iterator.next(), current.done ? config4.min || (result += ",") : result += "," + config4.spacingInner;
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printIteratorValues2(iterator, config4, indentation, depth, refs, printer2) {
      let result = "", current = iterator.next();
      if (!current.done) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (; !current.done; )
          result += indentationNext + printer2(current.value, config4, indentationNext, depth, refs), current = iterator.next(), current.done ? config4.min || (result += ",") : result += "," + config4.spacingInner;
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printListItems2(list, config4, indentation, depth, refs, printer2) {
      let result = "";
      if (list.length) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < list.length; i2++)
          result += indentationNext, i2 in list && (result += printer2(list[i2], config4, indentationNext, depth, refs)), i2 < list.length - 1 ? result += "," + config4.spacingInner : config4.min || (result += ",");
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
    function printObjectProperties2(val, config4, indentation, depth, refs, printer2) {
      let result = "", keys2 = getKeysOfEnumerableProperties2(val, config4.compareKeys);
      if (keys2.length) {
        result += config4.spacingOuter;
        let indentationNext = indentation + config4.indent;
        for (let i2 = 0; i2 < keys2.length; i2++) {
          let key = keys2[i2], name = printer2(key, config4, indentationNext, depth, refs), value = printer2(val[key], config4, indentationNext, depth, refs);
          result += indentationNext + name + ": " + value, i2 < keys2.length - 1 ? result += "," + config4.spacingInner : config4.min || (result += ",");
        }
        result += config4.spacingOuter + indentation;
      }
      return result;
    }
  }
});
var require_AsymmetricMatcher = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), global22 = function() {
      return typeof globalThis < "u" ? globalThis : typeof global22 < "u" ? global22 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    }(), Symbol3 = global22["jest-symbol-do-not-touch"] || global22.Symbol, asymmetricMatcher2 = typeof Symbol3 == "function" && Symbol3.for ? Symbol3.for("jest.asymmetricMatcher") : 1267621, SPACE2 = " ", serialize2 = (val, config4, indentation, depth, refs, printer2) => {
      let stringedValue = val.toString();
      return stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining" ? ++depth > config4.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE2 + "[" + (0, _collections.printListItems)(
        val.sample,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining" ? ++depth > config4.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE2 + "{" + (0, _collections.printObjectProperties)(
        val.sample,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining" ? stringedValue + SPACE2 + printer2(val.sample, config4, indentation, depth, refs) : val.toAsymmetricMatcher();
    };
    exports.serialize = serialize2;
    var test3 = (val) => val && val.$$typeof === asymmetricMatcher2;
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_ansi_regex = __commonJS$3({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(exports, module2) {
    module2.exports = ({ onlyFirst = false } = {}) => {
      let pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});
var require_ConvertAnsi = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _ansiRegex = _interopRequireDefault(require_ansi_regex()), _ansiStyles = _interopRequireDefault(require_ansi_styles());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match) => {
      switch (match) {
        case _ansiStyles.default.red.close:
        case _ansiStyles.default.green.close:
        case _ansiStyles.default.cyan.close:
        case _ansiStyles.default.gray.close:
        case _ansiStyles.default.white.close:
        case _ansiStyles.default.yellow.close:
        case _ansiStyles.default.bgRed.close:
        case _ansiStyles.default.bgGreen.close:
        case _ansiStyles.default.bgYellow.close:
        case _ansiStyles.default.inverse.close:
        case _ansiStyles.default.dim.close:
        case _ansiStyles.default.bold.close:
        case _ansiStyles.default.reset.open:
        case _ansiStyles.default.reset.close:
          return "</>";
        case _ansiStyles.default.red.open:
          return "<red>";
        case _ansiStyles.default.green.open:
          return "<green>";
        case _ansiStyles.default.cyan.open:
          return "<cyan>";
        case _ansiStyles.default.gray.open:
          return "<gray>";
        case _ansiStyles.default.white.open:
          return "<white>";
        case _ansiStyles.default.yellow.open:
          return "<yellow>";
        case _ansiStyles.default.bgRed.open:
          return "<bgRed>";
        case _ansiStyles.default.bgGreen.open:
          return "<bgGreen>";
        case _ansiStyles.default.bgYellow.open:
          return "<bgYellow>";
        case _ansiStyles.default.inverse.open:
          return "<inverse>";
        case _ansiStyles.default.dim.open:
          return "<dim>";
        case _ansiStyles.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), test3 = (val) => typeof val == "string" && !!val.match((0, _ansiRegex.default)());
    exports.test = test3;
    var serialize2 = (val, config4, indentation, depth, refs, printer2) => printer2(toHumanReadableAnsi(val), config4, indentation, depth, refs);
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_DOMCollection = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), SPACE2 = " ", OBJECT_NAMES2 = ["DOMStringMap", "NamedNodeMap"], ARRAY_REGEXP2 = /^(HTML\w*Collection|NodeList)$/, testName2 = (name) => OBJECT_NAMES2.indexOf(name) !== -1 || ARRAY_REGEXP2.test(name), test3 = (val) => val && val.constructor && !!val.constructor.name && testName2(val.constructor.name);
    exports.test = test3;
    var isNamedNodeMap2 = (collection) => collection.constructor.name === "NamedNodeMap", serialize2 = (collection, config4, indentation, depth, refs, printer2) => {
      let name = collection.constructor.name;
      return ++depth > config4.maxDepth ? "[" + name + "]" : (config4.min ? "" : name + SPACE2) + (OBJECT_NAMES2.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
        isNamedNodeMap2(collection) ? Array.from(collection).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection },
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : "[" + (0, _collections.printListItems)(
        Array.from(collection),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]");
    };
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_escapeHTML = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escapeHTML3;
    function escapeHTML3(str2) {
      return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});
var require_markup = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var printProps3 = (keys2, props, config4, indentation, depth, refs, printer2) => {
      let indentationNext = indentation + config4.indent, colors3 = config4.colors;
      return keys2.map((key) => {
        let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
        return typeof value != "string" && (printed.indexOf(`
`) !== -1 && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = "{" + printed + "}"), config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
      }).join("");
    };
    exports.printProps = printProps3;
    var printChildren3 = (children, config4, indentation, depth, refs, printer2) => children.map(
      (child) => config4.spacingOuter + indentation + (typeof child == "string" ? printText3(child, config4) : printer2(child, config4, indentation, depth, refs))
    ).join("");
    exports.printChildren = printChildren3;
    var printText3 = (text, config4) => {
      let contentColor = config4.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    };
    exports.printText = printText3;
    var printComment3 = (comment, config4) => {
      let commentColor = config4.colors.comment;
      return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
    };
    exports.printComment = printComment3;
    var printElement3 = (type5, printedProps, printedChildren, config4, indentation) => {
      let tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
    };
    exports.printElement = printElement3;
    var printElementAsLeaf3 = (type5, config4) => {
      let tagColor = config4.colors.tag;
      return tagColor.open + "<" + type5 + tagColor.close + " " + tagColor.open + " />" + tagColor.close;
    };
    exports.printElementAsLeaf = printElementAsLeaf3;
  }
});
var require_DOMElement = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup(), ELEMENT_NODE3 = 1, TEXT_NODE3 = 3, COMMENT_NODE3 = 8, FRAGMENT_NODE3 = 11, ELEMENT_REGEXP3 = /^((HTML|SVG)\w*)?Element$/, testHasAttribute2 = (val) => {
      try {
        return typeof val.hasAttribute == "function" && val.hasAttribute("is");
      } catch {
        return false;
      }
    }, testNode3 = (val) => {
      let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute2(val);
      return nodeType === ELEMENT_NODE3 && (ELEMENT_REGEXP3.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE3 && constructorName === "Text" || nodeType === COMMENT_NODE3 && constructorName === "Comment" || nodeType === FRAGMENT_NODE3 && constructorName === "DocumentFragment";
    }, test3 = (val) => {
      var _val$constructor;
      return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode3(val);
    };
    exports.test = test3;
    function nodeIsText3(node) {
      return node.nodeType === TEXT_NODE3;
    }
    function nodeIsComment3(node) {
      return node.nodeType === COMMENT_NODE3;
    }
    function nodeIsFragment3(node) {
      return node.nodeType === FRAGMENT_NODE3;
    }
    var serialize2 = (node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText3(node))
        return (0, _markup.printText)(node.data, config4);
      if (nodeIsComment3(node))
        return (0, _markup.printComment)(node.data, config4);
      let type5 = nodeIsFragment3(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      return ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(type5, config4) : (0, _markup.printElement)(
        type5,
        (0, _markup.printProps)(
          nodeIsFragment3(node) ? [] : Array.from(node.attributes).map((attr2) => attr2.name).sort(),
          nodeIsFragment3(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config4,
          indentation + config4.indent,
          depth,
          refs,
          printer2
        ),
        config4,
        indentation
      );
    };
    exports.serialize = serialize2;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_Immutable = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _collections = require_collections(), IS_ITERABLE_SENTINEL2 = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL3 = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL3 = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL2 = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL3 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL2 = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL2 = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL3 = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL2 = "@@__IMMUTABLE_STACK__@@", getImmutableName2 = (name) => "Immutable." + name, printAsLeaf2 = (name) => "[" + name + "]", SPACE2 = " ", LAZY2 = "", printImmutableEntries2 = (val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
      val.entries(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "}";
    function getRecordEntries2(val) {
      let i2 = 0;
      return {
        next() {
          if (i2 < val._keys.length) {
            let key = val._keys[i2++];
            return {
              done: false,
              value: [key, val.get(key)]
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
    var printImmutableRecord2 = (val, config4, indentation, depth, refs, printer2) => {
      let name = getImmutableName2(val._name || "Record");
      return ++depth > config4.maxDepth ? printAsLeaf2(name) : name + SPACE2 + "{" + (0, _collections.printIteratorEntries)(
        getRecordEntries2(val),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }, printImmutableSeq2 = (val, config4, indentation, depth, refs, printer2) => {
      let name = getImmutableName2("Seq");
      return ++depth > config4.maxDepth ? printAsLeaf2(name) : val[IS_KEYED_SENTINEL3] ? name + SPACE2 + "{" + // from Immutable collection of entries or from ECMAScript object
      (val._iter || val._object ? (0, _collections.printIteratorEntries)(
        val.entries(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) : LAZY2) + "}" : name + SPACE2 + "[" + (val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) : LAZY2) + "]";
    }, printImmutableValues2 = (val, config4, indentation, depth, refs, printer2, type5) => ++depth > config4.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : getImmutableName2(type5) + SPACE2 + "[" + (0, _collections.printIteratorValues)(
      val.values(),
      config4,
      indentation,
      depth,
      refs,
      printer2
    ) + "]", serialize2 = (val, config4, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL2] ? printImmutableEntries2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      val[IS_ORDERED_SENTINEL3] ? "OrderedMap" : "Map"
    ) : val[IS_LIST_SENTINEL3] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      "List"
    ) : val[IS_SET_SENTINEL3] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      val[IS_ORDERED_SENTINEL3] ? "OrderedSet" : "Set"
    ) : val[IS_STACK_SENTINEL2] ? printImmutableValues2(
      val,
      config4,
      indentation,
      depth,
      refs,
      printer2,
      "Stack"
    ) : val[IS_SEQ_SENTINEL2] ? printImmutableSeq2(val, config4, indentation, depth, refs, printer2) : printImmutableRecord2(val, config4, indentation, depth, refs, printer2);
    exports.serialize = serialize2;
    var test3 = (val) => val && (val[IS_ITERABLE_SENTINEL2] === true || val[IS_RECORD_SENTINEL2] === true);
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_react_is_production_min$1 = __commonJS$3({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    var b2 = 60103, c2 = 60106, d = 60107, e2 = 60108, f4 = 60114, g2 = 60109, h3 = 60110, k2 = 60112, l2 = 60113, m3 = 60120, n2 = 60115, p2 = 60116, q = 60121, r2 = 60122, u3 = 60117, v2 = 60129, w2 = 60131;
    typeof Symbol == "function" && Symbol.for && (x2 = Symbol.for, b2 = x2("react.element"), c2 = x2("react.portal"), d = x2("react.fragment"), e2 = x2("react.strict_mode"), f4 = x2("react.profiler"), g2 = x2("react.provider"), h3 = x2("react.context"), k2 = x2("react.forward_ref"), l2 = x2("react.suspense"), m3 = x2("react.suspense_list"), n2 = x2("react.memo"), p2 = x2("react.lazy"), q = x2("react.block"), r2 = x2("react.server.block"), u3 = x2("react.fundamental"), v2 = x2("react.debug_trace_mode"), w2 = x2("react.legacy_hidden"));
    var x2;
    function y2(a2) {
      if (typeof a2 == "object" && a2 !== null) {
        var t22 = a2.$$typeof;
        switch (t22) {
          case b2:
            switch (a2 = a2.type, a2) {
              case d:
              case f4:
              case e2:
              case l2:
              case m3:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case h3:
                  case k2:
                  case p2:
                  case n2:
                  case g2:
                    return a2;
                  default:
                    return t22;
                }
            }
          case c2:
            return t22;
        }
      }
    }
    var z = g2, A = b2, B2 = k2, C2 = d, D2 = p2, E2 = n2, F = c2, G = f4, H = e2, I = l2;
    exports.ContextConsumer = h3;
    exports.ContextProvider = z;
    exports.Element = A;
    exports.ForwardRef = B2;
    exports.Fragment = C2;
    exports.Lazy = D2;
    exports.Memo = E2;
    exports.Portal = F;
    exports.Profiler = G;
    exports.StrictMode = H;
    exports.Suspense = I;
    exports.isAsyncMode = function() {
      return false;
    };
    exports.isConcurrentMode = function() {
      return false;
    };
    exports.isContextConsumer = function(a2) {
      return y2(a2) === h3;
    };
    exports.isContextProvider = function(a2) {
      return y2(a2) === g2;
    };
    exports.isElement = function(a2) {
      return typeof a2 == "object" && a2 !== null && a2.$$typeof === b2;
    };
    exports.isForwardRef = function(a2) {
      return y2(a2) === k2;
    };
    exports.isFragment = function(a2) {
      return y2(a2) === d;
    };
    exports.isLazy = function(a2) {
      return y2(a2) === p2;
    };
    exports.isMemo = function(a2) {
      return y2(a2) === n2;
    };
    exports.isPortal = function(a2) {
      return y2(a2) === c2;
    };
    exports.isProfiler = function(a2) {
      return y2(a2) === f4;
    };
    exports.isStrictMode = function(a2) {
      return y2(a2) === e2;
    };
    exports.isSuspense = function(a2) {
      return y2(a2) === l2;
    };
    exports.isValidElementType = function(a2) {
      return typeof a2 == "string" || typeof a2 == "function" || a2 === d || a2 === f4 || a2 === v2 || a2 === e2 || a2 === l2 || a2 === m3 || a2 === w2 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === p2 || a2.$$typeof === n2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === k2 || a2.$$typeof === u3 || a2.$$typeof === q || a2[0] === r2);
    };
    exports.typeOf = y2;
  }
});
var require_react_is$1 = __commonJS$3({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(exports, module2) {
    module2.exports = require_react_is_production_min$1();
  }
});
var require_ReactElement = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var ReactIs2 = _interopRequireWildcard(require_react_is$1()), _markup = require_markup();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap != "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    var getChildren2 = (arg, children = []) => (Array.isArray(arg) ? arg.forEach((item) => {
      getChildren2(item, children);
    }) : arg != null && arg !== false && children.push(arg), children), getType4 = (element) => {
      let type5 = element.type;
      if (typeof type5 == "string")
        return type5;
      if (typeof type5 == "function")
        return type5.displayName || type5.name || "Unknown";
      if (ReactIs2.isFragment(element))
        return "React.Fragment";
      if (ReactIs2.isSuspense(element))
        return "React.Suspense";
      if (typeof type5 == "object" && type5 !== null) {
        if (ReactIs2.isContextProvider(element))
          return "Context.Provider";
        if (ReactIs2.isContextConsumer(element))
          return "Context.Consumer";
        if (ReactIs2.isForwardRef(element)) {
          if (type5.displayName)
            return type5.displayName;
          let functionName = type5.render.displayName || type5.render.name || "";
          return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
        }
        if (ReactIs2.isMemo(element)) {
          let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
          return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, getPropKeys2 = (element) => {
      let { props } = element;
      return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
    }, serialize2 = (element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(getType4(element), config4) : (0, _markup.printElement)(
      getType4(element),
      (0, _markup.printProps)(
        getPropKeys2(element),
        element.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      (0, _markup.printChildren)(
        getChildren2(element.props.children),
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ),
      config4,
      indentation
    );
    exports.serialize = serialize2;
    var test3 = (val) => val != null && ReactIs2.isElement(val);
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_ReactTestComponent = __commonJS$3({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.test = exports.serialize = exports.default = void 0;
    var _markup = require_markup(), global22 = function() {
      return typeof globalThis < "u" ? globalThis : typeof global22 < "u" ? global22 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    }(), Symbol3 = global22["jest-symbol-do-not-touch"] || global22.Symbol, testSymbol2 = typeof Symbol3 == "function" && Symbol3.for ? Symbol3.for("react.test.json") : 245830487, getPropKeys2 = (object) => {
      let { props } = object;
      return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
    }, serialize2 = (object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config4) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys2(object),
        object.props,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config4,
        indentation + config4.indent,
        depth,
        refs,
        printer2
      ) : "",
      config4,
      indentation
    );
    exports.serialize = serialize2;
    var test3 = (val) => val && val.$$typeof === testSymbol2;
    exports.test = test3;
    var plugin2 = {
      serialize: serialize2,
      test: test3
    }, _default = plugin2;
    exports.default = _default;
  }
});
var require_build = __commonJS$3({
  "../node_modules/pretty-format/build/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.DEFAULT_OPTIONS = void 0;
    exports.format = format4;
    exports.plugins = void 0;
    var _ansiStyles = _interopRequireDefault(require_ansi_styles()), _collections = require_collections(), _AsymmetricMatcher = _interopRequireDefault(
      require_AsymmetricMatcher()
    ), _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi()), _DOMCollection = _interopRequireDefault(require_DOMCollection()), _DOMElement = _interopRequireDefault(require_DOMElement()), _Immutable = _interopRequireDefault(require_Immutable()), _ReactElement = _interopRequireDefault(require_ReactElement()), _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toString5 = Object.prototype.toString, toISOString2 = Date.prototype.toISOString, errorToString2 = Error.prototype.toString, regExpToString2 = RegExp.prototype.toString, getConstructorName3 = (val) => typeof val.constructor == "function" && val.constructor.name || "Object", isWindow2 = (val) => typeof window < "u" && val === window, SYMBOL_REGEXP2 = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP2 = /\n/gi, PrettyFormatPluginError2 = class extends Error {
      constructor(message, stack2) {
        super(message), this.stack = stack2, this.name = this.constructor.name;
      }
    };
    function isToStringedArrayType2(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    function printNumber2(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt2(val) {
      return `${val}n`;
    }
    function printFunction2(val, printFunctionName) {
      return printFunctionName ? "[Function " + (val.name || "anonymous") + "]" : "[Function]";
    }
    function printSymbol2(val) {
      return String(val).replace(SYMBOL_REGEXP2, "Symbol($1)");
    }
    function printError2(val) {
      return "[" + errorToString2.call(val) + "]";
    }
    function printBasicValue2(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false)
        return "" + val;
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      let typeOf = typeof val;
      if (typeOf === "number")
        return printNumber2(val);
      if (typeOf === "bigint")
        return printBigInt2(val);
      if (typeOf === "string")
        return escapeString ? '"' + val.replace(/"|\\/g, "\\$&") + '"' : '"' + val + '"';
      if (typeOf === "function")
        return printFunction2(val, printFunctionName);
      if (typeOf === "symbol")
        return printSymbol2(val);
      let toStringed = toString5.call(val);
      return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction2(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol2(val) : toStringed === "[object Date]" ? isNaN(+val) ? "Date { NaN }" : toISOString2.call(val) : toStringed === "[object Error]" ? printError2(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString2.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : regExpToString2.call(val) : val instanceof Error ? printError2(val) : null;
    }
    function printComplexValue2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1)
        return "[Circular]";
      refs = refs.slice(), refs.push(val);
      let hitMaxDepth = ++depth > config4.maxDepth, min2 = config4.min;
      if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
        return printer2(val.toJSON(), config4, indentation, depth, refs, true);
      let toStringed = toString5.call(val);
      return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : (min2 ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : isToStringedArrayType2(toStringed) ? hitMaxDepth ? "[" + val.constructor.name + "]" : (min2 || !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "]" : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
        val.entries(),
        config4,
        indentation,
        depth,
        refs,
        printer2,
        " => "
      ) + "}" : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
        val.values(),
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}" : hitMaxDepth || isWindow2(val) ? "[" + getConstructorName3(val) + "]" : (min2 || !config4.printBasicPrototype && getConstructorName3(val) === "Object" ? "" : getConstructorName3(val) + " ") + "{" + (0, _collections.printObjectProperties)(
        val,
        config4,
        indentation,
        depth,
        refs,
        printer2
      ) + "}";
    }
    function isNewPlugin2(plugin2) {
      return plugin2.serialize != null;
    }
    function printPlugin2(plugin2, val, config4, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin2(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer2) : plugin2.print(
          val,
          (valChild) => printer2(valChild, config4, indentation, depth, refs),
          (str2) => {
            let indentationNext = indentation + config4.indent;
            return indentationNext + str2.replace(NEWLINE_REGEXP2, `
` + indentationNext);
          },
          {
            edgeSpacing: config4.spacingOuter,
            min: config4.min,
            spacing: config4.spacingInner
          },
          config4.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError2(error.message, error.stack);
      }
      if (typeof printed != "string")
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      return printed;
    }
    function findPlugin2(plugins4, val) {
      for (let p2 = 0; p2 < plugins4.length; p2++)
        try {
          if (plugins4[p2].test(val))
            return plugins4[p2];
        } catch (error) {
          throw new PrettyFormatPluginError2(error.message, error.stack);
        }
      return null;
    }
    function printer2(val, config4, indentation, depth, refs, hasCalledToJSON) {
      let plugin2 = findPlugin2(config4.plugins, val);
      if (plugin2 !== null)
        return printPlugin2(plugin2, val, config4, indentation, depth, refs);
      let basicResult = printBasicValue2(
        val,
        config4.printFunctionName,
        config4.escapeRegex,
        config4.escapeString
      );
      return basicResult !== null ? basicResult : printComplexValue2(
        val,
        config4,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME2 = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    }, DEFAULT_THEME_KEYS2 = Object.keys(DEFAULT_THEME2), DEFAULT_OPTIONS2 = {
      callToJSON: true,
      compareKeys: void 0,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: 1 / 0,
      min: false,
      plugins: [],
      printBasicPrototype: true,
      printFunctionName: true,
      theme: DEFAULT_THEME2
    };
    exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS2;
    function validateOptions3(options) {
      if (Object.keys(options).forEach((key) => {
        if (!DEFAULT_OPTIONS2.hasOwnProperty(key))
          throw new Error(`pretty-format: Unknown option "${key}".`);
      }), options.min && options.indent !== void 0 && options.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      if (options.theme !== void 0) {
        if (options.theme === null)
          throw new Error('pretty-format: Option "theme" must not be null.');
        if (typeof options.theme != "object")
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
      }
    }
    var getColorsHighlight2 = (options) => DEFAULT_THEME_KEYS2.reduce((colors3, key) => {
      let value = options.theme && options.theme[key] !== void 0 ? options.theme[key] : DEFAULT_THEME2[key], color = value && _ansiStyles.default[value];
      if (color && typeof color.close == "string" && typeof color.open == "string")
        colors3[key] = color;
      else
        throw new Error(
          `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
        );
      return colors3;
    }, /* @__PURE__ */ Object.create(null)), getColorsEmpty2 = () => DEFAULT_THEME_KEYS2.reduce((colors3, key) => (colors3[key] = {
      close: "",
      open: ""
    }, colors3), /* @__PURE__ */ Object.create(null)), getPrintFunctionName2 = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS2.printFunctionName, getEscapeRegex2 = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS2.escapeRegex, getEscapeString2 = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS2.escapeString, getConfig4 = (options) => {
      var _options$printBasicPr;
      return {
        callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS2.callToJSON,
        colors: options && options.highlight ? getColorsHighlight2(options) : getColorsEmpty2(),
        compareKeys: options && typeof options.compareKeys == "function" ? options.compareKeys : DEFAULT_OPTIONS2.compareKeys,
        escapeRegex: getEscapeRegex2(options),
        escapeString: getEscapeString2(options),
        indent: options && options.min ? "" : createIndent2(
          options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS2.indent
        ),
        maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS2.maxDepth,
        min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS2.min,
        plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS2.plugins,
        printBasicPrototype: (_options$printBasicPr = options?.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : true,
        printFunctionName: getPrintFunctionName2(options),
        spacingInner: options && options.min ? " " : `
`,
        spacingOuter: options && options.min ? "" : `
`
      };
    };
    function createIndent2(indent2) {
      return new Array(indent2 + 1).join(" ");
    }
    function format4(val, options) {
      if (options && (validateOptions3(options), options.plugins)) {
        let plugin2 = findPlugin2(options.plugins, val);
        if (plugin2 !== null)
          return printPlugin2(plugin2, val, getConfig4(options), "", 0, []);
      }
      let basicResult = printBasicValue2(
        val,
        getPrintFunctionName2(options),
        getEscapeRegex2(options),
        getEscapeString2(options)
      );
      return basicResult !== null ? basicResult : printComplexValue2(val, getConfig4(options), "", 0, []);
    }
    var plugins3 = {
      AsymmetricMatcher: _AsymmetricMatcher.default,
      ConvertAnsi: _ConvertAnsi.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    exports.plugins = plugins3;
    var _default = format4;
    exports.default = _default;
  }
});
var require_lz_string = __commonJS$3({
  "../node_modules/lz-string/libs/lz-string.js"(exports, module2) {
    var LZString = function() {
      var f4 = String.fromCharCode, keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i2 = 0; i2 < alphabet.length; i2++)
            baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input2) {
          if (input2 == null) return "";
          var res = LZString2._compress(input2, 6, function(a2) {
            return keyStrBase64.charAt(a2);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input2) {
          return input2 == null ? "" : input2 == "" ? null : LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input2.charAt(index2));
          });
        },
        compressToUTF16: function(input2) {
          return input2 == null ? "" : LZString2._compress(input2, 15, function(a2) {
            return f4(a2 + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          for (var compressed = LZString2.compress(uncompressed), buf = new Uint8Array(compressed.length * 2), i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
            var current_value = compressed.charCodeAt(i2);
            buf[i2 * 2] = current_value >>> 8, buf[i2 * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed == null)
            return LZString2.decompress(compressed);
          for (var buf = new Array(compressed.length / 2), i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++)
            buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
          var result = [];
          return buf.forEach(function(c2) {
            result.push(f4(c2));
          }), LZString2.decompress(result.join(""));
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input2) {
          return input2 == null ? "" : LZString2._compress(input2, 6, function(a2) {
            return keyStrUriSafe.charAt(a2);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input2) {
          return input2 == null ? "" : input2 == "" ? null : (input2 = input2.replace(/ /g, "+"), LZString2._decompress(input2.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input2.charAt(index2));
          }));
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a2) {
            return f4(a2);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1)
            if (context_c = uncompressed.charAt(ii), Object.prototype.hasOwnProperty.call(context_dictionary, context_c) || (context_dictionary[context_c] = context_dictSize++, context_dictionaryToCreate[context_c] = true), context_wc = context_w + context_c, Object.prototype.hasOwnProperty.call(context_dictionary, context_wc))
              context_w = context_wc;
            else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i2 = 0; i2 < context_numBits; i2++)
                    context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
                  for (value = context_w.charCodeAt(0), i2 = 0; i2 < 8; i2++)
                    context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
                } else {
                  for (value = 1, i2 = 0; i2 < context_numBits; i2++)
                    context_data_val = context_data_val << 1 | value, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = 0;
                  for (value = context_w.charCodeAt(0), i2 = 0; i2 < 16; i2++)
                    context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
                }
                context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
              } else
                for (value = context_dictionary[context_w], i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), context_dictionary[context_wc] = context_dictSize++, context_w = String(context_c);
            }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
                for (value = context_w.charCodeAt(0), i2 = 0; i2 < 8; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              } else {
                for (value = 1, i2 = 0; i2 < context_numBits; i2++)
                  context_data_val = context_data_val << 1 | value, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = 0;
                for (value = context_w.charCodeAt(0), i2 = 0; i2 < 16; i2++)
                  context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
              }
              context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
            } else
              for (value = context_dictionary[context_w], i2 = 0; i2 < context_numBits; i2++)
                context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
            context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++);
          }
          for (value = 2, i2 = 0; i2 < context_numBits; i2++)
            context_data_val = context_data_val << 1 | value & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value = value >> 1;
          for (; ; )
            if (context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          return context_data.join("");
        },
        decompress: function(compressed) {
          return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w2, bits, resb, maxpower, power, c2, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i2 = 0; i2 < 3; i2 += 1)
            dictionary[i2] = i2;
          for (bits = 0, maxpower = Math.pow(2, 2), power = 1; power != maxpower; )
            resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
          switch (bits) {
            case 0:
              for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; )
                resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
              c2 = f4(bits);
              break;
            case 1:
              for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; )
                resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
              c2 = f4(bits);
              break;
            case 2:
              return "";
          }
          for (dictionary[3] = c2, w2 = c2, result.push(c2); ; ) {
            if (data.index > length)
              return "";
            for (bits = 0, maxpower = Math.pow(2, numBits), power = 1; power != maxpower; )
              resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
            switch (c2 = bits) {
              case 0:
                for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; )
                  resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
                dictionary[dictSize++] = f4(bits), c2 = dictSize - 1, enlargeIn--;
                break;
              case 1:
                for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; )
                  resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
                dictionary[dictSize++] = f4(bits), c2 = dictSize - 1, enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++), dictionary[c2])
              entry = dictionary[c2];
            else if (c2 === dictSize)
              entry = w2 + w2.charAt(0);
            else
              return null;
            result.push(entry), dictionary[dictSize++] = w2 + entry.charAt(0), enlargeIn--, w2 = entry, enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++);
          }
        }
      };
      return LZString2;
    }();
    typeof define == "function" && define.amd ? define(function() {
      return LZString;
    }) : typeof module2 < "u" && module2 != null ? module2.exports = LZString : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return LZString;
    });
  }
});
var require_memoizerific = __commonJS$3({
  "../node_modules/memoizerific/memoizerific.js"(exports, module2) {
    (function(f4) {
      if (typeof exports == "object" && typeof module2 < "u")
        module2.exports = f4();
      else if (typeof define == "function" && define.amd)
        define([], f4);
      else {
        var g2;
        typeof window < "u" ? g2 = window : typeof global < "u" ? g2 = global : typeof self < "u" ? g2 = self : g2 = this, g2.memoizerific = f4();
      }
    })(function() {
      return function e2(t22, n2, r2) {
        function s3(o3, u3) {
          if (!n2[o3]) {
            if (!t22[o3]) {
              var a2 = typeof __require$2 == "function" && __require$2;
              if (!u3 && a2) return a2(o3, true);
              if (i2) return i2(o3, true);
              var f4 = new Error("Cannot find module '" + o3 + "'");
              throw f4.code = "MODULE_NOT_FOUND", f4;
            }
            var l2 = n2[o3] = { exports: {} };
            t22[o3][0].call(l2.exports, function(e3) {
              var n3 = t22[o3][1][e3];
              return s3(n3 || e3);
            }, l2, l2.exports, e2, t22, n2, r2);
          }
          return n2[o3].exports;
        }
        for (var i2 = typeof __require$2 == "function" && __require$2, o2 = 0; o2 < r2.length; o2++) s3(r2[o2]);
        return s3;
      }({ 1: [function(_dereq_, module4, exports3) {
        module4.exports = function(forceSimilar) {
          if (typeof Map != "function" || forceSimilar) {
            var Similar = _dereq_("./similar");
            return new Similar();
          } else
            return /* @__PURE__ */ new Map();
        };
      }, { "./similar": 2 }], 2: [function(_dereq_, module4, exports3) {
        function Similar() {
          return this.list = [], this.lastItem = void 0, this.size = 0, this;
        }
        Similar.prototype.get = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key))
            return this.lastItem.val;
          if (index2 = this.indexOf(key), index2 >= 0)
            return this.lastItem = this.list[index2], this.list[index2].val;
        }, Similar.prototype.set = function(key, val) {
          var index2;
          return this.lastItem && this.isEqual(this.lastItem.key, key) ? (this.lastItem.val = val, this) : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], this.list[index2].val = val, this) : (this.lastItem = { key, val }, this.list.push(this.lastItem), this.size++, this));
        }, Similar.prototype.delete = function(key) {
          var index2;
          if (this.lastItem && this.isEqual(this.lastItem.key, key) && (this.lastItem = void 0), index2 = this.indexOf(key), index2 >= 0)
            return this.size--, this.list.splice(index2, 1)[0];
        }, Similar.prototype.has = function(key) {
          var index2;
          return this.lastItem && this.isEqual(this.lastItem.key, key) ? true : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], true) : false);
        }, Similar.prototype.forEach = function(callback, thisArg) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++)
            callback.call(thisArg || this, this.list[i2].val, this.list[i2].key, this);
        }, Similar.prototype.indexOf = function(key) {
          var i2;
          for (i2 = 0; i2 < this.size; i2++)
            if (this.isEqual(this.list[i2].key, key))
              return i2;
          return -1;
        }, Similar.prototype.isEqual = function(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }, module4.exports = Similar;
      }, {}], 3: [function(_dereq_, module4, exports3) {
        var MapOrSimilar = _dereq_("map-or-similar");
        module4.exports = function(limit) {
          var cache = new MapOrSimilar(false), lru = [];
          return function(fn3) {
            var memoizerific = function() {
              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = true, i2;
              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1)
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              for (i2 = 0; i2 < argsLengthMinusOne; i2++) {
                if (lruPath[i2] = {
                  cacheItem: currentCache,
                  arg: arguments[i2]
                }, currentCache.has(arguments[i2])) {
                  currentCache = currentCache.get(arguments[i2]);
                  continue;
                }
                isMemoized = false, newMap = new MapOrSimilar(false), currentCache.set(arguments[i2], newMap), currentCache = newMap;
              }
              return isMemoized && (currentCache.has(arguments[argsLengthMinusOne]) ? fnResult = currentCache.get(arguments[argsLengthMinusOne]) : isMemoized = false), isMemoized || (fnResult = fn3.apply(null, arguments), currentCache.set(arguments[argsLengthMinusOne], fnResult)), limit > 0 && (lruPath[argsLengthMinusOne] = {
                cacheItem: currentCache,
                arg: arguments[argsLengthMinusOne]
              }, isMemoized ? moveToMostRecentLru(lru, lruPath) : lru.push(lruPath), lru.length > limit && removeCachedResult(lru.shift())), memoizerific.wasMemoized = isMemoized, memoizerific.numArgs = argsLengthMinusOne + 1, fnResult;
            };
            return memoizerific.limit = limit, memoizerific.wasMemoized = false, memoizerific.cache = cache, memoizerific.lru = lru, memoizerific;
          };
        };
        function moveToMostRecentLru(lru, lruPath) {
          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i2, ii;
          for (i2 = 0; i2 < lruLen; i2++) {
            for (isMatch = true, ii = 0; ii < lruPathLen; ii++)
              if (!isEqual3(lru[i2][ii].arg, lruPath[ii].arg)) {
                isMatch = false;
                break;
              }
            if (isMatch)
              break;
          }
          lru.push(lru.splice(i2, 1)[0]);
        }
        function removeCachedResult(removedLru) {
          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i2;
          for (currentLru.cacheItem.delete(currentLru.arg), i2 = removedLruLen - 2; i2 >= 0 && (currentLru = removedLru[i2], tmp = currentLru.cacheItem.get(currentLru.arg), !tmp || !tmp.size); i2--)
            currentLru.cacheItem.delete(currentLru.arg);
        }
        function isEqual3(val1, val2) {
          return val1 === val2 || val1 !== val1 && val2 !== val2;
        }
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
});
var require_string_util = __commonJS$3({
  "../node_modules/picoquery/lib/string-util.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeString = encodeString;
    var hexTable = Array.from({ length: 256 }, (_, i2) => "%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase()), noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function encodeString(str2) {
      let len = str2.length;
      if (len === 0)
        return "";
      let out = "", lastPos = 0, i2 = 0;
      outer: for (; i2 < len; i2++) {
        let c2 = str2.charCodeAt(i2);
        for (; c2 < 128; ) {
          if (noEscape[c2] !== 1 && (lastPos < i2 && (out += str2.slice(lastPos, i2)), lastPos = i2 + 1, out += hexTable[c2]), ++i2 === len)
            break outer;
          c2 = str2.charCodeAt(i2);
        }
        if (lastPos < i2 && (out += str2.slice(lastPos, i2)), c2 < 2048) {
          lastPos = i2 + 1, out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i2 + 1, out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        if (++i2, i2 >= len)
          throw new Error("URI malformed");
        let c22 = str2.charCodeAt(i2) & 1023;
        lastPos = i2 + 1, c2 = 65536 + ((c2 & 1023) << 10 | c22), out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      return lastPos === 0 ? str2 : lastPos < len ? out + str2.slice(lastPos) : out;
    }
  }
});
var require_shared = __commonJS$3({
  "../node_modules/picoquery/lib/shared.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
    var string_util_js_1 = require_string_util(), defaultValueSerializer = (value) => {
      switch (typeof value) {
        case "string":
          return (0, string_util_js_1.encodeString)(value);
        case "bigint":
        case "boolean":
          return "" + value;
        case "number":
          if (Number.isFinite(value))
            return value < 1e21 ? "" + value : (0, string_util_js_1.encodeString)("" + value);
          break;
      }
      return value instanceof Date ? (0, string_util_js_1.encodeString)(value.toISOString()) : "";
    };
    exports.defaultValueSerializer = defaultValueSerializer;
    var defaultShouldSerializeObject = (val) => val instanceof Date;
    exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
    var identityFunc = (v2) => v2;
    exports.defaultOptions = {
      nesting: true,
      nestingSyntax: "dot",
      arrayRepeat: false,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: identityFunc,
      valueSerializer: exports.defaultValueSerializer,
      keyDeserializer: identityFunc,
      shouldSerializeObject: exports.defaultShouldSerializeObject
    };
  }
});
var require_object_util = __commonJS$3({
  "../node_modules/picoquery/lib/object-util.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDeepObject = getDeepObject;
    exports.stringifyObject = stringifyObject;
    var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
    function isPrototypeKey(value) {
      return value === "__proto__" || value === "constructor" || value === "prototype";
    }
    function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
      if (isPrototypeKey(key))
        return obj;
      let currObj = obj[key];
      return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
    }
    var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
    function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
      let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === true && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
      if (depth > MAX_DEPTH)
        return "";
      let result = "", firstKey = true, valueIsProbableArray = false;
      for (let key in obj) {
        let value = obj[key];
        if (value === void 0)
          continue;
        let path;
        parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value == "object" && value !== null && !shouldSerializeObject(value) ? (valueIsProbableArray = value.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value, options, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value, key)), firstKey && (firstKey = false);
      }
      return result;
    }
  }
});
var require_decode_uri_component = __commonJS$3({
  "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeURIComponent = decodeURIComponent2;
    var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      let percentPosition = uri.indexOf("%");
      if (percentPosition === -1)
        return uri;
      let length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
      for (; percentPosition > -1 && percentPosition < length; ) {
        let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type5 = UTF8_DATA[byte];
        if (state3 = UTF8_DATA[256 + state3 + type5], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type5], state3 === UTF8_ACCEPT)
          decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
        else {
          if (state3 === UTF8_REJECT)
            return null;
          if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function hexCodeToInt(c2, shift2) {
      let i2 = HEX[c2];
      return i2 === void 0 ? 255 : i2 << shift2;
    }
  }
});
var require_parse = __commonJS$3({
  "../node_modules/picoquery/lib/parse.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0;
    exports.parse = parse6;
    var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = (key) => {
      let asNumber = Number(key);
      return Number.isNaN(asNumber) ? key : asNumber;
    };
    exports.numberKeyDeserializer = numberKeyDeserializer;
    var numberValueDeserializer = (value) => {
      let asNumber = Number(value);
      return Number.isNaN(asNumber) ? value : asNumber;
    };
    exports.numberValueDeserializer = numberValueDeserializer;
    var regexPlus = /\+/g, Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function computeKeySlice(input2, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
      let chunk = input2.substring(startIndex, endIndex);
      return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
    }
    function parse6(input2, options) {
      let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty();
      if (typeof input2 != "string")
        return result;
      let inputLength = input2.length, value = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, keyIsDot = false, hasBothKeyValuePair = false, c2 = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
      for (let i2 = 0; i2 < inputLength + 1; i2++) {
        if (c2 = i2 !== inputLength ? input2.charCodeAt(i2) : charDelimiter, c2 === charDelimiter) {
          if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i2), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
            hasBothKeyValuePair && (value = input2.slice(equalityIndex + 1, i2), valueHasPlus && (value = value.replace(regexPlus, " ")), shouldDecodeValue && (value = (0, decode_uri_component_js_1.decodeURIComponent)(value) || value));
            let newValue = valueDeserializer(value, currentKey);
            if (arrayRepeat) {
              let currentValue = currentObj[currentKey];
              currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
            } else
              currentObj[currentKey] = newValue;
          }
          value = "", startingIndex = i2, equalityIndex = i2, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, keyIsDot = false, arrayRepeatBracketIndex = -1, keySeparatorIndex = i2, currentObj = result, lastKey = void 0, currentKey = "";
        } else c2 === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false), keySeparatorIndex = i2, keyIsDot = false)) : c2 === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false), keyIsDot = true, keySeparatorIndex = i2) : c2 === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input2, keySeparatorIndex + 1, i2, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = false, shouldDecodeKey = false, keyIsDot = false), keySeparatorIndex = i2) : c2 === 61 ? equalityIndex <= startingIndex ? equalityIndex = i2 : shouldDecodeValue = true : c2 === 43 ? equalityIndex > startingIndex ? valueHasPlus = true : keyHasPlus = true : c2 === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = true : shouldDecodeKey = true);
        prevIndex = i2, prevChar = c2;
      }
      return result;
    }
  }
});
var require_stringify = __commonJS$3({
  "../node_modules/picoquery/lib/stringify.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = stringify5;
    var object_util_js_1 = require_object_util();
    function stringify5(input2, options) {
      if (input2 === null || typeof input2 != "object")
        return "";
      let optionsObj = options ?? {};
      return (0, object_util_js_1.stringifyObject)(input2, optionsObj);
    }
  }
});
var require_main = __commonJS$3({
  "../node_modules/picoquery/lib/main.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      k22 === void 0 && (k22 = k2);
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: true, get: function() {
        return m3[k2];
      } }), Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      k22 === void 0 && (k22 = k2), o2[k22] = m3[k2];
    }), __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2) && __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    __exportStar(require_shared(), exports);
  }
});
var require_entities = __commonJS$3({
  "../node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "", aacute: "", Abreve: "", abreve: "", ac: "", acd: "", acE: "", Acirc: "", acirc: "", acute: "", Acy: "", acy: "", AElig: "", aelig: "", af: "", Afr: "", afr: "", Agrave: "", agrave: "", alefsym: "", aleph: "", Alpha: "", alpha: "", Amacr: "", amacr: "", amalg: "", amp: "&", AMP: "&", andand: "", And: "", and: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angmsd: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", Aogon: "", aogon: "", Aopf: "", aopf: "", apacir: "", ap: "", apE: "", ape: "", apid: "", apos: "'", ApplyFunction: "", approx: "", approxeq: "", Aring: "", aring: "", Ascr: "", ascr: "", Assign: "", ast: "*", asymp: "", asympeq: "", Atilde: "", atilde: "", Auml: "", auml: "", awconint: "", awint: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", Backslash: "", Barv: "", barvee: "", barwed: "", Barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", Bcy: "", bcy: "", bdquo: "", becaus: "", because: "", Because: "", bemptyv: "", bepsi: "", bernou: "", Bernoullis: "", Beta: "", beta: "", beth: "", between: "", Bfr: "", bfr: "", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bNot: "", bnot: "", Bopf: "", bopf: "", bot: "", bottom: "", bowtie: "", boxbox: "", boxdl: "", boxdL: "", boxDl: "", boxDL: "", boxdr: "", boxdR: "", boxDr: "", boxDR: "", boxh: "", boxH: "", boxhd: "", boxHd: "", boxhD: "", boxHD: "", boxhu: "", boxHu: "", boxhU: "", boxHU: "", boxminus: "", boxplus: "", boxtimes: "", boxul: "", boxuL: "", boxUl: "", boxUL: "", boxur: "", boxuR: "", boxUr: "", boxUR: "", boxv: "", boxV: "", boxvh: "", boxvH: "", boxVh: "", boxVH: "", boxvl: "", boxvL: "", boxVl: "", boxVL: "", boxvr: "", boxvR: "", boxVr: "", boxVR: "", bprime: "", breve: "", Breve: "", brvbar: "", bscr: "", Bscr: "", bsemi: "", bsim: "", bsime: "", bsolb: "", bsol: "\\", bsolhsub: "", bull: "", bullet: "", bump: "", bumpE: "", bumpe: "", Bumpeq: "", bumpeq: "", Cacute: "", cacute: "", capand: "", capbrcup: "", capcap: "", cap: "", Cap: "", capcup: "", capdot: "", CapitalDifferentialD: "", caps: "", caret: "", caron: "", Cayleys: "", ccaps: "", Ccaron: "", ccaron: "", Ccedil: "", ccedil: "", Ccirc: "", ccirc: "", Cconint: "", ccups: "", ccupssm: "", Cdot: "", cdot: "", cedil: "", Cedilla: "", cemptyv: "", cent: "", centerdot: "", CenterDot: "", cfr: "", Cfr: "", CHcy: "", chcy: "", check: "", checkmark: "", Chi: "", chi: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledast: "", circledcirc: "", circleddash: "", CircleDot: "", circledR: "", circledS: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", cir: "", cirE: "", cire: "", cirfnint: "", cirmid: "", cirscir: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", clubs: "", clubsuit: "", colon: ":", Colon: "", Colone: "", colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", Congruent: "", conint: "", Conint: "", ContourIntegral: "", copf: "", Copf: "", coprod: "", Coproduct: "", copy: "", COPY: "", copysr: "", CounterClockwiseContourIntegral: "", crarr: "", cross: "", Cross: "", Cscr: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cupbrcap: "", cupcap: "", CupCap: "", cup: "", Cup: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dagger: "", Dagger: "", daleth: "", darr: "", Darr: "", dArr: "", dash: "", Dashv: "", dashv: "", dbkarow: "", dblac: "", Dcaron: "", dcaron: "", Dcy: "", dcy: "", ddagger: "", ddarr: "", DD: "", dd: "", DDotrahd: "", ddotseq: "", deg: "", Del: "", Delta: "", delta: "", demptyv: "", dfisht: "", Dfr: "", dfr: "", dHar: "", dharl: "", dharr: "", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", diam: "", diamond: "", Diamond: "", diamondsuit: "", diams: "", die: "", DifferentialD: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", DJcy: "", djcy: "", dlcorn: "", dlcrop: "", dollar: "$", Dopf: "", dopf: "", Dot: "", dot: "", DotDot: "", doteq: "", doteqdot: "", DotEqual: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", DownArrowBar: "", downarrow: "", DownArrow: "", Downarrow: "", DownArrowUpArrow: "", DownBreve: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVectorBar: "", DownLeftVector: "", DownRightTeeVector: "", DownRightVectorBar: "", DownRightVector: "", DownTeeArrow: "", DownTee: "", drbkarow: "", drcorn: "", drcrop: "", Dscr: "", dscr: "", DScy: "", dscy: "", dsol: "", Dstrok: "", dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", DZcy: "", dzcy: "", dzigrarr: "", Eacute: "", eacute: "", easter: "", Ecaron: "", ecaron: "", Ecirc: "", ecirc: "", ecir: "", ecolon: "", Ecy: "", ecy: "", eDDot: "", Edot: "", edot: "", eDot: "", ee: "", efDot: "", Efr: "", efr: "", eg: "", Egrave: "", egrave: "", egs: "", egsdot: "", el: "", Element: "", elinters: "", ell: "", els: "", elsdot: "", Emacr: "", emacr: "", empty: "", emptyset: "", EmptySmallSquare: "", emptyv: "", EmptyVerySmallSquare: "", emsp13: "", emsp14: "", emsp: "", ENG: "", eng: "", ensp: "", Eogon: "", eogon: "", Eopf: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", Epsilon: "", epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", Equal: "", equals: "=", EqualTilde: "", equest: "", Equilibrium: "", equiv: "", equivDD: "", eqvparsl: "", erarr: "", erDot: "", escr: "", Escr: "", esdot: "", Esim: "", esim: "", Eta: "", eta: "", ETH: "", eth: "", Euml: "", euml: "", euro: "", excl: "!", exist: "", Exists: "", expectation: "", exponentiale: "", ExponentialE: "", fallingdotseq: "", Fcy: "", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", Ffr: "", ffr: "", filig: "", FilledSmallSquare: "", FilledVerySmallSquare: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", Fopf: "", fopf: "", forall: "", ForAll: "", fork: "", forkv: "", Fouriertrf: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "", Fscr: "", gacute: "", Gamma: "", gamma: "", Gammad: "", gammad: "", gap: "", Gbreve: "", gbreve: "", Gcedil: "", Gcirc: "", gcirc: "", Gcy: "", gcy: "", Gdot: "", gdot: "", ge: "", gE: "", gEl: "", gel: "", geq: "", geqq: "", geqslant: "", gescc: "", ges: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", Gfr: "", gfr: "", gg: "", Gg: "", ggg: "", gimel: "", GJcy: "", gjcy: "", gla: "", gl: "", glE: "", glj: "", gnap: "", gnapprox: "", gne: "", gnE: "", gneq: "", gneqq: "", gnsim: "", Gopf: "", gopf: "", grave: "`", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", Gscr: "", gscr: "", gsim: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gt: ">", GT: ">", Gt: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", Hacek: "", hairsp: "", half: "", hamilt: "", HARDcy: "", hardcy: "", harrcir: "", harr: "", hArr: "", harrw: "", Hat: "^", hbar: "", Hcirc: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "", Hfr: "", HilbertSpace: "", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "", Hopf: "", horbar: "", HorizontalLine: "", hscr: "", Hscr: "", hslash: "", Hstrok: "", hstrok: "", HumpDownHump: "", HumpEqual: "", hybull: "", hyphen: "", Iacute: "", iacute: "", ic: "", Icirc: "", icirc: "", Icy: "", icy: "", Idot: "", IEcy: "", iecy: "", iexcl: "", iff: "", ifr: "", Ifr: "", Igrave: "", igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", IJlig: "", ijlig: "", Imacr: "", imacr: "", image: "", ImaginaryI: "", imagline: "", imagpart: "", imath: "", Im: "", imof: "", imped: "", Implies: "", incare: "", in: "", infin: "", infintie: "", inodot: "", intcal: "", int: "", Int: "", integers: "", Integral: "", intercal: "", Intersection: "", intlarhk: "", intprod: "", InvisibleComma: "", InvisibleTimes: "", IOcy: "", iocy: "", Iogon: "", iogon: "", Iopf: "", iopf: "", Iota: "", iota: "", iprod: "", iquest: "", iscr: "", Iscr: "", isin: "", isindot: "", isinE: "", isins: "", isinsv: "", isinv: "", it: "", Itilde: "", itilde: "", Iukcy: "", iukcy: "", Iuml: "", iuml: "", Jcirc: "", jcirc: "", Jcy: "", jcy: "", Jfr: "", jfr: "", jmath: "", Jopf: "", jopf: "", Jscr: "", jscr: "", Jsercy: "", jsercy: "", Jukcy: "", jukcy: "", Kappa: "", kappa: "", kappav: "", Kcedil: "", kcedil: "", Kcy: "", kcy: "", Kfr: "", kfr: "", kgreen: "", KHcy: "", khcy: "", KJcy: "", kjcy: "", Kopf: "", kopf: "", Kscr: "", kscr: "", lAarr: "", Lacute: "", lacute: "", laemptyv: "", lagran: "", Lambda: "", lambda: "", lang: "", Lang: "", langd: "", langle: "", lap: "", Laplacetrf: "", laquo: "", larrb: "", larrbfs: "", larr: "", Larr: "", lArr: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", latail: "", lAtail: "", lat: "", late: "", lates: "", lbarr: "", lBarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", Lcaron: "", lcaron: "", Lcedil: "", lcedil: "", lceil: "", lcub: "{", Lcy: "", lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", lE: "", LeftAngleBracket: "", LeftArrowBar: "", leftarrow: "", LeftArrow: "", Leftarrow: "", LeftArrowRightArrow: "", leftarrowtail: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVectorBar: "", LeftDownVector: "", LeftFloor: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", LeftRightArrow: "", Leftrightarrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", LeftRightVector: "", LeftTeeArrow: "", LeftTee: "", LeftTeeVector: "", leftthreetimes: "", LeftTriangleBar: "", LeftTriangle: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVectorBar: "", LeftUpVector: "", LeftVectorBar: "", LeftVector: "", lEg: "", leg: "", leq: "", leqq: "", leqslant: "", lescc: "", les: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", lessgtr: "", LessLess: "", lesssim: "", LessSlantEqual: "", LessTilde: "", lfisht: "", lfloor: "", Lfr: "", lfr: "", lg: "", lgE: "", lHar: "", lhard: "", lharu: "", lharul: "", lhblk: "", LJcy: "", ljcy: "", llarr: "", ll: "", Ll: "", llcorner: "", Lleftarrow: "", llhard: "", lltri: "", Lmidot: "", lmidot: "", lmoustache: "", lmoust: "", lnap: "", lnapprox: "", lne: "", lnE: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", LongLeftArrow: "", Longleftarrow: "", longleftrightarrow: "", LongLeftRightArrow: "", Longleftrightarrow: "", longmapsto: "", longrightarrow: "", LongRightArrow: "", Longrightarrow: "", looparrowleft: "", looparrowright: "", lopar: "", Lopf: "", lopf: "", loplus: "", lotimes: "", lowast: "", lowbar: "_", LowerLeftArrow: "", LowerRightArrow: "", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", Lscr: "", lsh: "", Lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", Lstrok: "", lstrok: "", ltcc: "", ltcir: "", lt: "<", LT: "<", Lt: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltri: "", ltrie: "", ltrif: "", ltrPar: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", macr: "", male: "", malt: "", maltese: "", Map: "", map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", Mcy: "", mcy: "", mdash: "", mDDot: "", measuredangle: "", MediumSpace: "", Mellintrf: "", Mfr: "", mfr: "", mho: "", micro: "", midast: "*", midcir: "", mid: "", middot: "", minusb: "", minus: "", minusd: "", minusdu: "", MinusPlus: "", mlcp: "", mldr: "", mnplus: "", models: "", Mopf: "", mopf: "", mp: "", mscr: "", Mscr: "", mstpos: "", Mu: "", mu: "", multimap: "", mumap: "", nabla: "", Nacute: "", nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natural: "", naturals: "", natur: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", Ncaron: "", ncaron: "", Ncedil: "", ncedil: "", ncong: "", ncongdot: "", ncup: "", Ncy: "", ncy: "", ndash: "", nearhk: "", nearr: "", neArr: "", nearrow: "", ne: "", nedot: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", nequiv: "", nesear: "", nesim: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: `
`, nexist: "", nexists: "", Nfr: "", nfr: "", ngE: "", nge: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", nGg: "", ngsim: "", nGt: "", ngt: "", ngtr: "", nGtv: "", nharr: "", nhArr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", NJcy: "", njcy: "", nlarr: "", nlArr: "", nldr: "", nlE: "", nle: "", nleftarrow: "", nLeftarrow: "", nleftrightarrow: "", nLeftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nLl: "", nlsim: "", nLt: "", nlt: "", nltri: "", nltrie: "", nLtv: "", nmid: "", NoBreak: "", NonBreakingSpace: "", nopf: "", Nopf: "", Not: "", not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", notin: "", notindot: "", notinE: "", notinva: "", notinvb: "", notinvc: "", NotLeftTriangleBar: "", NotLeftTriangle: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", notni: "", notniva: "", notnivb: "", notnivc: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangleBar: "", NotRightTriangle: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", nparallel: "", npar: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", nprec: "", npreceq: "", npre: "", nrarrc: "", nrarr: "", nrArr: "", nrarrw: "", nrightarrow: "", nRightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", Nscr: "", nscr: "", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsubE: "", nsube: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupE: "", nsupe: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", Ntilde: "", ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", Nu: "", nu: "", num: "#", numero: "", numsp: "", nvap: "", nvdash: "", nvDash: "", nVdash: "", nVDash: "", nvge: "", nvgt: ">", nvHarr: "", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwarhk: "", nwarr: "", nwArr: "", nwarrow: "", nwnear: "", Oacute: "", oacute: "", oast: "", Ocirc: "", ocirc: "", ocir: "", Ocy: "", ocy: "", odash: "", Odblac: "", odblac: "", odiv: "", odot: "", odsold: "", OElig: "", oelig: "", ofcir: "", Ofr: "", ofr: "", ogon: "", Ograve: "", ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", Omacr: "", omacr: "", Omega: "", omega: "", Omicron: "", omicron: "", omid: "", ominus: "", Oopf: "", oopf: "", opar: "", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", operp: "", oplus: "", orarr: "", Or: "", or: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oS: "", Oscr: "", oscr: "", Oslash: "", oslash: "", osol: "", Otilde: "", otilde: "", otimesas: "", Otimes: "", otimes: "", Ouml: "", ouml: "", ovbar: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", para: "", parallel: "", par: "", parsim: "", parsl: "", part: "", PartialD: "", Pcy: "", pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", Pfr: "", pfr: "", Phi: "", phi: "", phiv: "", phmmat: "", phone: "", Pi: "", pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plusacir: "", plusb: "", pluscir: "", plus: "+", plusdo: "", plusdu: "", pluse: "", PlusMinus: "", plusmn: "", plussim: "", plustwo: "", pm: "", Poincareplane: "", pointint: "", popf: "", Popf: "", pound: "", prap: "", Pr: "", pr: "", prcue: "", precapprox: "", prec: "", preccurlyeq: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", pre: "", prE: "", precsim: "", prime: "", Prime: "", primes: "", prnap: "", prnE: "", prnsim: "", prod: "", Product: "", profalar: "", profline: "", profsurf: "", prop: "", Proportional: "", Proportion: "", propto: "", prsim: "", prurel: "", Pscr: "", pscr: "", Psi: "", psi: "", puncsp: "", Qfr: "", qfr: "", qint: "", qopf: "", Qopf: "", qprime: "", Qscr: "", qscr: "", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', QUOT: '"', rAarr: "", race: "", Racute: "", racute: "", radic: "", raemptyv: "", rang: "", Rang: "", rangd: "", range: "", rangle: "", raquo: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarr: "", Rarr: "", rArr: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", Rarrtl: "", rarrtl: "", rarrw: "", ratail: "", rAtail: "", ratio: "", rationals: "", rbarr: "", rBarr: "", RBarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", Rcaron: "", rcaron: "", Rcedil: "", rcedil: "", rceil: "", rcub: "}", Rcy: "", rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", real: "", realine: "", realpart: "", reals: "", Re: "", rect: "", reg: "", REG: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", rfisht: "", rfloor: "", rfr: "", Rfr: "", rHar: "", rhard: "", rharu: "", rharul: "", Rho: "", rho: "", rhov: "", RightAngleBracket: "", RightArrowBar: "", rightarrow: "", RightArrow: "", Rightarrow: "", RightArrowLeftArrow: "", rightarrowtail: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVectorBar: "", RightDownVector: "", RightFloor: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", RightTeeArrow: "", RightTee: "", RightTeeVector: "", rightthreetimes: "", RightTriangleBar: "", RightTriangle: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVectorBar: "", RightUpVector: "", RightVectorBar: "", RightVector: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoustache: "", rmoust: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "", Ropf: "", roplus: "", rotimes: "", RoundImplies: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", Rrightarrow: "", rsaquo: "", rscr: "", Rscr: "", rsh: "", Rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", RuleDelayed: "", ruluhar: "", rx: "", Sacute: "", sacute: "", sbquo: "", scap: "", Scaron: "", scaron: "", Sc: "", sc: "", sccue: "", sce: "", scE: "", Scedil: "", scedil: "", Scirc: "", scirc: "", scnap: "", scnE: "", scnsim: "", scpolint: "", scsim: "", Scy: "", scy: "", sdotb: "", sdot: "", sdote: "", searhk: "", searr: "", seArr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", Sfr: "", sfr: "", sfrown: "", sharp: "", SHCHcy: "", shchcy: "", SHcy: "", shcy: "", ShortDownArrow: "", ShortLeftArrow: "", shortmid: "", shortparallel: "", ShortRightArrow: "", ShortUpArrow: "", shy: "", Sigma: "", sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", SmallCircle: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", SOFTcy: "", softcy: "", solbar: "", solb: "", sol: "/", Sopf: "", sopf: "", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", Sqrt: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", square: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", squarf: "", squ: "", squf: "", srarr: "", Sscr: "", sscr: "", ssetmn: "", ssmile: "", sstarf: "", Star: "", star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", Sub: "", subdot: "", subE: "", sube: "", subedot: "", submult: "", subnE: "", subne: "", subplus: "", subrarr: "", subset: "", Subset: "", subseteq: "", subseteqq: "", SubsetEqual: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succapprox: "", succ: "", succcurlyeq: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", SuchThat: "", sum: "", Sum: "", sung: "", sup1: "", sup2: "", sup3: "", sup: "", Sup: "", supdot: "", supdsub: "", supE: "", supe: "", supedot: "", Superset: "", SupersetEqual: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supne: "", supplus: "", supset: "", Supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swarhk: "", swarr: "", swArr: "", swarrow: "", swnwar: "", szlig: "", Tab: "	", target: "", Tau: "", tau: "", tbrk: "", Tcaron: "", tcaron: "", Tcedil: "", tcedil: "", Tcy: "", tcy: "", tdot: "", telrec: "", Tfr: "", tfr: "", there4: "", therefore: "", Therefore: "", Theta: "", theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", ThickSpace: "", ThinSpace: "", thinsp: "", thkap: "", thksim: "", THORN: "", thorn: "", tilde: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", timesbar: "", timesb: "", times: "", timesd: "", tint: "", toea: "", topbot: "", topcir: "", top: "", Topf: "", topf: "", topfork: "", tosa: "", tprime: "", trade: "", TRADE: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", TripleDot: "", triplus: "", trisb: "", tritime: "", trpezium: "", Tscr: "", tscr: "", TScy: "", tscy: "", TSHcy: "", tshcy: "", Tstrok: "", tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", Uacute: "", uacute: "", uarr: "", Uarr: "", uArr: "", Uarrocir: "", Ubrcy: "", ubrcy: "", Ubreve: "", ubreve: "", Ucirc: "", ucirc: "", Ucy: "", ucy: "", udarr: "", Udblac: "", udblac: "", udhar: "", ufisht: "", Ufr: "", ufr: "", Ugrave: "", ugrave: "", uHar: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", Umacr: "", umacr: "", uml: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", Uogon: "", uogon: "", Uopf: "", uopf: "", UpArrowBar: "", uparrow: "", UpArrow: "", Uparrow: "", UpArrowDownArrow: "", updownarrow: "", UpDownArrow: "", Updownarrow: "", UpEquilibrium: "", upharpoonleft: "", upharpoonright: "", uplus: "", UpperLeftArrow: "", UpperRightArrow: "", upsi: "", Upsi: "", upsih: "", Upsilon: "", upsilon: "", UpTeeArrow: "", UpTee: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", Uring: "", uring: "", urtri: "", Uscr: "", uscr: "", utdot: "", Utilde: "", utilde: "", utri: "", utrif: "", uuarr: "", Uuml: "", uuml: "", uwangle: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", vArr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vBar: "", Vbar: "", vBarv: "", Vcy: "", vcy: "", vdash: "", vDash: "", Vdash: "", VDash: "", Vdashl: "", veebar: "", vee: "", Vee: "", veeeq: "", vellip: "", verbar: "|", Verbar: "", vert: "|", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", Vfr: "", vfr: "", vltri: "", vnsub: "", vnsup: "", Vopf: "", vopf: "", vprop: "", vrtri: "", Vscr: "", vscr: "", vsubnE: "", vsubne: "", vsupnE: "", vsupne: "", Vvdash: "", vzigzag: "", Wcirc: "", wcirc: "", wedbar: "", wedge: "", Wedge: "", wedgeq: "", weierp: "", Wfr: "", wfr: "", Wopf: "", wopf: "", wp: "", wr: "", wreath: "", Wscr: "", wscr: "", xcap: "", xcirc: "", xcup: "", xdtri: "", Xfr: "", xfr: "", xharr: "", xhArr: "", Xi: "", xi: "", xlarr: "", xlArr: "", xmap: "", xnis: "", xodot: "", Xopf: "", xopf: "", xoplus: "", xotime: "", xrarr: "", xrArr: "", Xscr: "", xscr: "", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", Yacute: "", yacute: "", YAcy: "", yacy: "", Ycirc: "", ycirc: "", Ycy: "", ycy: "", yen: "", Yfr: "", yfr: "", YIcy: "", yicy: "", Yopf: "", yopf: "", Yscr: "", yscr: "", YUcy: "", yucy: "", yuml: "", Yuml: "", Zacute: "", zacute: "", Zcaron: "", zcaron: "", Zcy: "", zcy: "", Zdot: "", zdot: "", zeetrf: "", ZeroWidthSpace: "", Zeta: "", zeta: "", zfr: "", Zfr: "", ZHcy: "", zhcy: "", zigrarr: "", zopf: "", Zopf: "", Zscr: "", zscr: "", zwj: "", zwnj: "" };
  }
});
var require_legacy = __commonJS$3({
  "../node_modules/entities/lib/maps/legacy.json"(exports, module2) {
    module2.exports = { Aacute: "", aacute: "", Acirc: "", acirc: "", acute: "", AElig: "", aelig: "", Agrave: "", agrave: "", amp: "&", AMP: "&", Aring: "", aring: "", Atilde: "", atilde: "", Auml: "", auml: "", brvbar: "", Ccedil: "", ccedil: "", cedil: "", cent: "", copy: "", COPY: "", curren: "", deg: "", divide: "", Eacute: "", eacute: "", Ecirc: "", ecirc: "", Egrave: "", egrave: "", ETH: "", eth: "", Euml: "", euml: "", frac12: "", frac14: "", frac34: "", gt: ">", GT: ">", Iacute: "", iacute: "", Icirc: "", icirc: "", iexcl: "", Igrave: "", igrave: "", iquest: "", Iuml: "", iuml: "", laquo: "", lt: "<", LT: "<", macr: "", micro: "", middot: "", nbsp: "", not: "", Ntilde: "", ntilde: "", Oacute: "", oacute: "", Ocirc: "", ocirc: "", Ograve: "", ograve: "", ordf: "", ordm: "", Oslash: "", oslash: "", Otilde: "", otilde: "", Ouml: "", ouml: "", para: "", plusmn: "", pound: "", quot: '"', QUOT: '"', raquo: "", reg: "", REG: "", sect: "", shy: "", sup1: "", sup2: "", sup3: "", szlig: "", THORN: "", thorn: "", times: "", Uacute: "", uacute: "", Ucirc: "", ucirc: "", Ugrave: "", ugrave: "", uml: "", Uuml: "", uuml: "", Yacute: "", yacute: "", yen: "", yuml: "" };
  }
});
var require_xml = __commonJS$3({
  "../node_modules/entities/lib/maps/xml.json"(exports, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});
var require_decode = __commonJS$3({
  "../node_modules/entities/lib/maps/decode.json"(exports, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});
var require_decode_codepoint = __commonJS$3({
  "../node_modules/entities/lib/decode_codepoint.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
      }
    );
    function decodeCodePoint(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});
var require_decode2 = __commonJS$3({
  "../node_modules/entities/lib/decode.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str2) {
        return String(str2).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a2, b2) {
      return a2 < b2 ? 1 : -1;
    };
    exports.decodeHTML = function() {
      for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys2 = Object.keys(entities_json_1.default).sort(sorter), i2 = 0, j2 = 0; i2 < keys2.length; i2++)
        legacy[j2] === keys2[i2] ? (keys2[i2] += ";?", j2++) : keys2[i2] += ";";
      var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
      function replacer3(str2) {
        return str2.substr(-1) !== ";" && (str2 += ";"), replace(str2);
      }
      return function(str2) {
        return String(str2).replace(re, replacer3);
      };
    }();
    function getReplacer(map2) {
      return function(str2) {
        if (str2.charAt(1) === "#") {
          var secondChar = str2.charAt(2);
          return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str2.substr(3), 16)) : decode_codepoint_1.default(parseInt(str2.substr(2), 10));
        }
        return map2[str2.slice(1, -1)] || str2;
      };
    }
  }
});
var require_encode = __commonJS$3({
  "../node_modules/entities/lib/encode.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        return inverse[obj[name]] = "&" + name + ";", inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      for (var single = [], multiple = [], _i = 0, _a3 = Object.keys(inverse); _i < _a3.length; _i++) {
        var k2 = _a3[_i];
        k2.length === 1 ? single.push("\\" + k2) : multiple.push(k2);
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        for (var end = start; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
          end += 1;
        var count2 = 1 + end - start;
        count2 < 3 || single.splice(start, count2, single[start] + "-" + single[end]);
      }
      return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function(str2) {
          return str2.codePointAt(0);
        }
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(c2) {
          return (c2.charCodeAt(0) - 55296) * 1024 + c2.charCodeAt(1) - 56320 + 65536;
        }
      )
    );
    function singleCharReplacer(c2) {
      return "&#x" + (c2.length > 1 ? getCodePoint(c2) : c2.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape4(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape4;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c2) {
          return obj[c2] || singleCharReplacer(c2);
        });
      };
    }
  }
});
var require_lib2 = __commonJS$3({
  "../node_modules/entities/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2(), encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode2;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});
var require_ansi_to_html = __commonJS$3({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module2) {
    function _classCallCheck3(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties3(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass3(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties3(Constructor.prototype, protoProps), Constructor;
    }
    function _createForOfIteratorHelper(o2, allowArrayLike) {
      var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
      if (!it) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike) {
          it && (o2 = it);
          var i2 = 0, F = function() {
          };
          return { s: F, n: function() {
            return i2 >= o2.length ? { done: true } : { done: false, value: o2[i2++] };
          }, e: function(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function() {
        it = it.call(o2);
      }, n: function() {
        var step2 = it.next();
        return normalCompletion = step2.done, step2;
      }, e: function(_e2) {
        didErr = true, err = _e2;
      }, f: function() {
        try {
          !normalCompletion && it.return != null && it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray2(o2, minLen) {
      if (o2) {
        if (typeof o2 == "string") return _arrayLikeToArray2(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set") return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray2(o2, minLen);
      }
    }
    function _arrayLikeToArray2(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var entities = require_lib2(), defaults = {
      fg: "#FFF",
      bg: "#000",
      newline: false,
      escapeXML: false,
      stream: false,
      colors: getDefaultColors()
    };
    function getDefaultColors() {
      var colors3 = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return range(0, 5).forEach(function(red) {
        range(0, 5).forEach(function(green) {
          range(0, 5).forEach(function(blue) {
            return setStyleColor(red, green, blue, colors3);
          });
        });
      }), range(0, 23).forEach(function(gray) {
        var c2 = gray + 232, l2 = toHexString(gray * 10 + 8);
        colors3[c2] = "#" + l2 + l2 + l2;
      }), colors3;
    }
    function setStyleColor(red, green, blue, colors3) {
      var c2 = 16 + red * 36 + green * 6 + blue, r2 = red > 0 ? red * 40 + 55 : 0, g2 = green > 0 ? green * 40 + 55 : 0, b2 = blue > 0 ? blue * 40 + 55 : 0;
      colors3[c2] = toColorHexString([r2, g2, b2]);
    }
    function toHexString(num) {
      for (var str2 = num.toString(16); str2.length < 2; )
        str2 = "0" + str2;
      return str2;
    }
    function toColorHexString(ref) {
      var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var r2 = _step.value;
          results.push(toHexString(r2));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return "#" + results.join("");
    }
    function generateOutput(stack2, token, data, options) {
      var result;
      return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack2, data, options) : token === "xterm256Foreground" ? result = pushForegroundColor(stack2, options.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack2, options.colors[data]) : token === "rgb" && (result = handleRgb(stack2, data)), result;
    }
    function handleRgb(stack2, data) {
      data = data.substring(2).slice(0, -1);
      var operation = +data.substr(0, 2), color = data.substring(5).split(";"), rgb = color.map(function(value) {
        return ("0" + Number(value).toString(16)).substr(-2);
      }).join("");
      return pushStyle(stack2, (operation === 38 ? "color:#" : "background-color:#") + rgb);
    }
    function handleDisplay(stack2, code, options) {
      code = parseInt(code, 10);
      var codeMap = {
        "-1": function() {
          return "<br/>";
        },
        0: function() {
          return stack2.length && resetStyles(stack2);
        },
        1: function() {
          return pushTag(stack2, "b");
        },
        3: function() {
          return pushTag(stack2, "i");
        },
        4: function() {
          return pushTag(stack2, "u");
        },
        8: function() {
          return pushStyle(stack2, "display:none");
        },
        9: function() {
          return pushTag(stack2, "strike");
        },
        22: function() {
          return pushStyle(stack2, "font-weight:normal;text-decoration:none;font-style:normal");
        },
        23: function() {
          return closeTag(stack2, "i");
        },
        24: function() {
          return closeTag(stack2, "u");
        },
        39: function() {
          return pushForegroundColor(stack2, options.fg);
        },
        49: function() {
          return pushBackgroundColor(stack2, options.bg);
        },
        53: function() {
          return pushStyle(stack2, "text-decoration:overline");
        }
      }, result;
      return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack2, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack2, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack2, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack2, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack2, options.colors[8 + (code - 100)])), result;
    }
    function resetStyles(stack2) {
      var stackClone = stack2.slice(0);
      return stack2.length = 0, stackClone.reverse().map(function(tag) {
        return "</" + tag + ">";
      }).join("");
    }
    function range(low, high) {
      for (var results = [], j2 = low; j2 <= high; j2++)
        results.push(j2);
      return results;
    }
    function notCategory(category) {
      return function(e2) {
        return (category === null || e2.category !== category) && category !== "all";
      };
    }
    function categoryForCode(code) {
      code = parseInt(code, 10);
      var result = null;
      return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
    }
    function pushText(text, options) {
      return options.escapeXML ? entities.encodeXML(text) : text;
    }
    function pushTag(stack2, tag, style) {
      return style || (style = ""), stack2.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
    }
    function pushStyle(stack2, style) {
      return pushTag(stack2, "span", style);
    }
    function pushForegroundColor(stack2, color) {
      return pushTag(stack2, "span", "color:" + color);
    }
    function pushBackgroundColor(stack2, color) {
      return pushTag(stack2, "span", "background-color:" + color);
    }
    function closeTag(stack2, style) {
      var last;
      if (stack2.slice(-1)[0] === style && (last = stack2.pop()), last)
        return "</" + style + ">";
    }
    function tokenize(text, options, callback) {
      var ansiMatch = false, ansiHandler = 3;
      function remove() {
        return "";
      }
      function removeXterm256Foreground(m3, g1) {
        return callback("xterm256Foreground", g1), "";
      }
      function removeXterm256Background(m3, g1) {
        return callback("xterm256Background", g1), "";
      }
      function newline(m3) {
        return options.newline ? callback("display", -1) : callback("text", m3), "";
      }
      function ansiMess(m3, g1) {
        ansiMatch = true, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
        var _iterator2 = _createForOfIteratorHelper(g1), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var g2 = _step2.value;
            callback("display", g2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return "";
      }
      function realText(m3) {
        return callback("text", m3), "";
      }
      function rgb(m3) {
        return callback("rgb", m3), "";
      }
      var tokens = [{
        pattern: /^\x08+/,
        sub: remove
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: remove
      }, {
        pattern: /^\x1b\[\(B/,
        sub: remove
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: rgb
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: removeXterm256Foreground
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: removeXterm256Background
      }, {
        pattern: /^\n/,
        sub: newline
      }, {
        pattern: /^\r+\n/,
        sub: newline
      }, {
        pattern: /^\r/,
        sub: newline
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: ansiMess
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: remove
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: remove
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: remove
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: realText
      }];
      function process2(handler2, i3) {
        i3 > ansiHandler && ansiMatch || (ansiMatch = false, text = text.replace(handler2.pattern, handler2.sub));
      }
      var results1 = [], _text = text, length = _text.length;
      outer: for (; length > 0; ) {
        for (var i2 = 0, o2 = 0, len = tokens.length; o2 < len; i2 = ++o2) {
          var handler = tokens[i2];
          if (process2(handler, i2), text.length !== length) {
            length = text.length;
            continue outer;
          }
        }
        if (text.length === length)
          break;
        results1.push(0), length = text.length;
      }
      return results1;
    }
    function updateStickyStack(stickyStack, token, data) {
      return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
        token,
        data,
        category: categoryForCode(data)
      })), stickyStack;
    }
    var Filter = function() {
      function Filter2(options) {
        _classCallCheck3(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
      }
      return _createClass3(Filter2, [{
        key: "toHtml",
        value: function(input2) {
          var _this = this;
          input2 = typeof input2 == "string" ? [input2] : input2;
          var stack2 = this.stack, options = this.options, buf = [];
          return this.stickyStack.forEach(function(element) {
            var output = generateOutput(stack2, element.token, element.data, options);
            output && buf.push(output);
          }), tokenize(input2.join(""), options, function(token, data) {
            var output = generateOutput(stack2, token, data, options);
            output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
          }), stack2.length && buf.push(resetStyles(stack2)), buf.join("");
        }
      }]), Filter2;
    }();
    module2.exports = Filter;
  }
});
var require_dist$2 = __commonJS$3({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module2) {
    (function(global22, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global22 = typeof globalThis < "u" ? globalThis : global22 || self, factory(global22.jtpp = {}));
    })(exports, function(exports2) {
      function tokenToString(token) {
        return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
      }
      class NoParsletFoundError extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class EarlyEndOfParseError extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class UnexpectedTypeError extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
        }
      }
      function makePunctuationRule(type5) {
        return (text) => text.startsWith(type5) ? { type: type5, text: type5 } : null;
      }
      function getQuoted(text) {
        let position = 0, char, mark = text[0], escaped = false;
        if (mark !== "'" && mark !== '"')
          return null;
        for (; position < text.length; ) {
          if (position++, char = text[position], !escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark)
          throw new Error("Unterminated String");
        return text.slice(0, position);
      }
      let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char))
          return null;
        let position = 1;
        do {
          if (char = text[position], !identifierContinueRegex.test(char))
            break;
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a3, _b;
        return (_b = (_a3 = numberRegex.exec(text)) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : null;
      }
      let identifierRule = (text) => {
        let value = getIdentifier(text);
        return value == null ? null : {
          type: "Identifier",
          text: value
        };
      };
      function makeKeyWordRule(type5) {
        return (text) => {
          if (!text.startsWith(type5))
            return null;
          let prepends = text[type5.length];
          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
            type: type5,
            text: type5
          };
        };
      }
      let stringValueRule = (text) => {
        let value = getQuoted(text);
        return value == null ? null : {
          type: "StringValue",
          text: value
        };
      }, eofRule = (text) => text.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, numberRule = (text) => {
        let value = getNumber(text);
        return value === null ? null : {
          type: "Number",
          text: value
        };
      }, rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ], breakingWhitespaceRegex = /^\s*\n\s*/;
      class Lexer {
        static create(text) {
          let current = this.read(text);
          text = current.text;
          let next = this.read(text);
          return text = next.text, new Lexer(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
        }
        static read(text, startOfLine = false) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
          for (let rule of rules) {
            let partial = rule(text);
            if (partial !== null) {
              let token = Object.assign(Object.assign({}, partial), { startOfLine });
              return text = text.slice(token.text.length), { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          let next = Lexer.read(this.text);
          return new Lexer(next.text, this.current, this.next, next.token);
        }
      }
      function assertRootResult(result) {
        if (result === void 0)
          throw new Error("Unexpected undefined");
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertPlainKeyValueOrRootResult(result) {
        return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
      }
      function assertPlainKeyValueOrNameResult(result) {
        return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
      }
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertNumberOrVariadicNameResult(result) {
        var _a3;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a3 = result.element) === null || _a3 === void 0 ? void 0 : _a3.type) === "JsdocTypeName")
            return result;
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
          return result;
        throw new UnexpectedTypeError(result);
      }
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      class Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          let result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new EarlyEndOfParseError(this.lexer.current);
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          let result = this.tryParslets(null, precedence);
          if (result === null)
            throw new NoParsletFoundError(this.lexer.current);
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          for (; result !== null; )
            left = result, result = this.tryParslets(left, precedence);
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (let parslet of this.grammar) {
            let result = parslet(this, precedence, left);
            if (result !== null)
              return result;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), true) : false;
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      }
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      let nullableParslet = (parser, precedence, left) => {
        let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
        return left == null && type5 === "?" && !isQuestionMarkUnknownType(next) || left != null && type5 === "?" ? (parser.consume("?"), left == null ? {
          type: "JsdocTypeNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        }) : null;
      };
      function composeParslet(options) {
        let parslet = (parser, curPrecedence, left) => {
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options && options.accept(type5, next))
              return options.parsePrefix(parser);
          } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type5, next))
            return options.parseInfix(parser, left);
          return null;
        };
        return Object.defineProperty(parslet, "name", {
          value: options.name
        }), parslet;
      }
      let optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: (type5) => type5 === "=",
        precedence: Precedence.OPTIONAL,
        parsePrefix: (parser) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: parser.parseType(Precedence.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      }), numberParslet = composeParslet({
        name: "numberParslet",
        accept: (type5) => type5 === "Number",
        parsePrefix: (parser) => {
          let value = parseFloat(parser.lexer.current.text);
          return parser.consume("Number"), {
            type: "JsdocTypeNumber",
            value
          };
        }
      }), parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: (type5) => type5 === "(",
        parsePrefix: (parser) => {
          if (parser.consume("("), parser.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          let result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")"))
            throw new Error("Unterminated parenthesis");
          return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [result]
          } : {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }
      }), specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: (type5, next) => type5 === "?" && isQuestionMarkUnknownType(next) || type5 === "null" || type5 === "undefined" || type5 === "*",
        parsePrefix: (parser) => {
          if (parser.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (parser.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (parser.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (parser.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }
      }), notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: (type5) => type5 === "!",
        precedence: Precedence.NULLABLE,
        parsePrefix: (parser) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: (type5) => type5 === ",",
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: (parser, left) => {
            let elements2 = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do
              try {
                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements2.push(assertPlainKeyValueOrRootResult(next));
              } catch (e2) {
                if (e2 instanceof NoParsletFoundError)
                  break;
                throw e2;
              }
            while (parser.consume(","));
            if (elements2.length > 0 && elements2.slice(0, -1).some((e2) => e2.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements: elements2
            };
          }
        });
      }
      let genericParslet = composeParslet({
        name: "genericParslet",
        accept: (type5, next) => type5 === "<" || type5 === "." && next === "<",
        precedence: Precedence.GENERIC,
        parseInfix: (parser, left) => {
          let dot = parser.consume(".");
          parser.consume("<");
          let objects = [], infer = false;
          if (parser.consume("infer")) {
            infer = true;
            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            objects.push(left2);
          } else
            do
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            while (parser.consume(","));
          if (!parser.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }
      }), unionParslet = composeParslet({
        name: "unionParslet",
        accept: (type5) => type5 === "|",
        precedence: Precedence.UNION,
        parseInfix: (parser, left) => {
          parser.consume("|");
          let elements2 = [];
          do
            elements2.push(parser.parseType(Precedence.UNION));
          while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements2]
          };
        }
      }), baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return function(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH)
            return null;
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (!(type5 === "." && next !== "<" || type5 === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type5 === "~" || type5 === "#")))
            return null;
          let pathType, brackets = false;
          parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = true) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event")
                right = parsed;
              else
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            let token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        };
      }
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: (type5) => type5 === "Identifier" || type5 === "this" || type5 === "new" || allowedAdditionalTokens.includes(type5),
          parsePrefix: (parser) => {
            let { type: type5, text } = parser.lexer.current;
            return parser.consume(type5), {
              type: "JsdocTypeName",
              value: text
            };
          }
        });
      }
      let stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: (type5) => type5 === "StringValue",
        parsePrefix: (parser) => {
          let text = parser.lexer.current.text;
          return parser.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: (type5) => allowedTypes.includes(type5),
          parsePrefix: (parser) => {
            let type5 = parser.lexer.current.type;
            if (parser.consume(type5), !parser.consume(":"))
              return {
                type: "JsdocTypeName",
                value: type5
              };
            let result, token = parser.lexer.current;
            if (parser.consume("StringValue"))
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type5,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let value = "", allowed = ["Identifier", "@", "/"];
              for (; allowed.some((type6) => parser.consume(type6)); )
                value += token.text, token = parser.lexer.current;
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type5,
                meta: {
                  quote: void 0
                }
              };
            }
            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
          }
        });
      }
      let basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar: null
        })
      ], pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList")
          parameters2 = value.elements;
        else if (value.type === "JsdocTypeParenthesis")
          parameters2 = [value.element];
        else
          throw new UnexpectedTypeError(value);
        return parameters2.map((p2) => assertPlainKeyValueOrRootResult(p2));
      }
      function getUnnamedParameters(value) {
        let parameters2 = getParameters(value);
        if (parameters2.some((p2) => p2.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return parameters2;
      }
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: (type5, next) => type5 === "function" || allowNewAsFunctionKeyword && type5 === "new" && next === "(",
          parsePrefix: (parser) => {
            let newKeyword = parser.consume("new");
            parser.consume("function");
            let hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: false,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            }, value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0)
              result.parameters = getUnnamedParameters(value);
            else {
              if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow)
                return result = value, result.constructor = true, result;
              result.parameters = getParameters(value);
              for (let p2 of result.parameters)
                if (p2.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p2.key))
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p2.type}`);
            }
            if (parser.consume(":"))
              result.returnType = parser.parseType(Precedence.PREFIX);
            else if (!allowNoReturnType)
              throw new Error("function is missing return type");
            return result;
          }
        });
      }
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: (type5) => type5 === "...",
          precedence: Precedence.PREFIX,
          parsePrefix: (parser) => {
            parser.consume("...");
            let brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              let element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e2) {
              if (e2 instanceof NoParsletFoundError) {
                if (brackets)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: false
                  }
                };
              } else
                throw e2;
            }
          },
          parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
            type: "JsdocTypeVariadic",
            element: assertRootResult(left),
            meta: {
              position: "suffix",
              squareBrackets: false
            }
          }) : void 0
        });
      }
      let symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: (type5) => type5 === "(",
        precedence: Precedence.SYMBOL,
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          parser.consume("(");
          let result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            let next = parser.parseIntermediateType(Precedence.SYMBOL);
            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return result;
        }
      }), arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: (type5, next) => type5 === "[" && next === "]",
        parseInfix: (parser, left) => (parser.consume("["), parser.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            assertRootResult(left)
          ],
          meta: {
            brackets: "square",
            dot: false
          }
        })
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: (type5) => type5 === "{",
          parsePrefix: (parser) => {
            parser.consume("{");
            let result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              for (; ; ) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                let optional = false;
                if (field.type === "JsdocTypeNullable" && (optional = true, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: false,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                  result.elements.push(field);
                else
                  throw new UnexpectedTypeError(field);
                if (parser.lexer.current.startOfLine)
                  separator = "linebreak", parser.consume(",") || parser.consume(";");
                else if (parser.consume(","))
                  separator = "comma";
                else if (parser.consume(";"))
                  separator = "semicolon";
                else
                  break;
                if (parser.lexer.current.type === "}")
                  break;
              }
              if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return result;
          }
        });
      }
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            var _a3;
            let optional = false, readonlyProperty = false;
            allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = true, left = left.element);
            let parentParser = (_a3 = parser.baseParser) !== null && _a3 !== void 0 ? _a3 : parser;
            if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let quote2;
              left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }
        });
      }
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            let optional = false, variadic = false;
            if (allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = true, left = left.element), left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left);
            parser.consume(":");
            let right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }
        });
      }
      let jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: true,
          allowPostfix: true
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        })
      ], jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: false,
              allowKeyTypes: true,
              allowOptional: false,
              allowReadonly: false
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: true
        }),
        createKeyValueParslet({
          allowOptional: true,
          allowVariadic: true
        })
      ], typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: (type5) => type5 === "typeof",
        parsePrefix: (parser) => (parser.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
        })
      }), objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: false,
          allowKeyTypes: false,
          allowOptional: false,
          allowReadonly: false
        })
      ], closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: false,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: false,
          allowVariadic: false
        }),
        symbolParslet
      ], assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: (type5) => type5 === "asserts",
        parsePrefix: (parser) => {
          parser.consume("asserts");
          let left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          return parser.consume("is") ? {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: left
          };
        }
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: (type5) => type5 === "[",
          parsePrefix: (parser) => {
            parser.consume("[");
            let result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]"))
              return result;
            let typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
              throw new Error("Unterminated '['");
            if (result.elements.some((e2) => e2.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return result;
          }
        });
      }
      let keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: (type5) => type5 === "keyof",
        parsePrefix: (parser) => (parser.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
        })
      }), importParslet = composeParslet({
        name: "importParslet",
        accept: (type5) => type5 === "import",
        parsePrefix: (parser) => {
          if (parser.consume("import"), !parser.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          let path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!parser.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }
      }), readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: parser.parseIntermediateType(Precedence.KEY_VALUE)
        })
      }), arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: (type5) => type5 === "=>",
        parseInfix: (parser, left) => (parser.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
          arrow: true,
          constructor: false,
          parenthesis: true,
          returnType: parser.parseType(Precedence.OBJECT)
        })
      }), genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: (type5) => type5 === "<",
        parsePrefix: (parser) => {
          let typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(name);
            let constraint;
            parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
            let typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
              break;
          } while (parser.consume(","));
          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          return functionBase.typeParameters = typeParameters, functionBase;
        }
      }), intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: (type5) => type5 === "&",
        precedence: Precedence.INTERSECTION,
        parseInfix: (parser, left) => {
          parser.consume("&");
          let elements2 = [];
          do
            elements2.push(parser.parseType(Precedence.INTERSECTION));
          while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements2]
          };
        }
      }), predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "is",
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          return parser.consume("is"), {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }
      }), objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: (type5) => type5 === "[",
        parsePrefix: (parser) => {
          if (parser.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          parser.consume("[");
          let key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!parser.consume("]"))
            throw new Error("Unterminated square brackets");
          return result;
        }
      }), readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
        })
      }), conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "extends",
        parseInfix: (parser, left) => {
          parser.consume("extends");
          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
          return parser.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }
      }), objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: true,
          allowKeyTypes: false,
          allowOptional: true,
          allowReadonly: true
        }),
        objectSquaredPropertyParslet
      ], typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNoReturnType: false,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
          allowQuestionMark: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: true,
          allowJsdocNamePaths: false,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: true,
          allowOptional: true
        })
      ];
      function parse6(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (let mode of modes)
          try {
            return parse6(expression, mode);
          } catch (e2) {
            error = e2;
          }
        throw error;
      }
      function transform(rules2, parseResult) {
        let rule = rules2[parseResult.type];
        if (rule === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      function extractSpecialParams(source) {
        let result = {
          params: []
        };
        for (let param of source.parameters)
          param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
        return result;
      }
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,
          JsdocTypeFunction: (result, transform2) => {
            var _a3;
            if (result.arrow) {
              if (result.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a3 = result.typeParameters.map(transform2).join(", ")) !== null && _a3 !== void 0 ? _a3 : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              return result.constructor && (stringified = "new " + stringified), stringified;
            } else {
              let stringified = result.constructor ? "new" : "function";
              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
            }
          },
          JsdocTypeName: (result) => result.value,
          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(", ")}]`,
          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."),
          JsdocTypeNamePath: (result, transform2) => {
            let left = transform2(result.left), right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          },
          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),
          JsdocTypeAny: () => "*",
          JsdocTypeGeneric: (result, transform2) => {
            if (result.meta.brackets === "square") {
              let element = result.elements[0], transformed = transform2(element);
              return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
            } else
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === true ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
          },
          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,
          JsdocTypeObjectField: (result, transform2) => {
            let text = "";
            return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,
          JsdocTypeKeyValue: (result, transform2) => {
            let text = result.key;
            return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"),
          JsdocTypeNull: () => "null",
          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"),
          JsdocTypeNumber: (result) => result.value.toString(),
          JsdocTypeObject: (result, transform2) => {
            var _a3, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a3 = result.meta.propertyIndent) !== null && _a3 !== void 0 ? _a3 : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
          },
          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="),
          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,
          JsdocTypeUndefined: () => "undefined",
          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(" | "),
          JsdocTypeUnknown: () => "?",
          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(" & "),
          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),
          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,
          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,
          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,
          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,
          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,
          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`
        };
      }
      let storedStringifyRules = stringifyRules2();
      function stringify5(result) {
        return transform(storedStringifyRules, result);
      }
      let reservedWords2 = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        let result = {
          type: "NameExpression",
          name: value
        };
        return reservedWords2.includes(value) && (result.reservedWord = true), result;
      }
      let catharsisTransformRules = {
        JsdocTypeOptional: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.optional = true, transformed;
        },
        JsdocTypeNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = true, transformed;
        },
        JsdocTypeNotNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = false, transformed;
        },
        JsdocTypeVariadic: (result, transform2) => {
          if (result.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          let transformed = transform2(result.element);
          return transformed.repeatable = true, transformed;
        },
        JsdocTypeAny: () => ({
          type: "AllLiteral"
        }),
        JsdocTypeNull: () => ({
          type: "NullLiteral"
        }),
        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),
        JsdocTypeUndefined: () => ({
          type: "UndefinedLiteral"
        }),
        JsdocTypeUnknown: () => ({
          type: "UnknownLiteral"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let params = extractSpecialParams(result), transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o2) => transform2(o2)),
          expression: transform2(result.left)
        }),
        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)),
        JsdocTypeName: (result) => result.value !== "function" ? makeName(result.value) : {
          type: "FunctionType",
          params: []
        },
        JsdocTypeNumber: (result) => makeName(result.value.toString()),
        JsdocTypeObject: (result, transform2) => {
          let transformed = {
            type: "RecordType",
            fields: []
          };
          for (let field of result.elements)
            field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
              type: "FieldType",
              key: transform2(field),
              value: void 0
            }) : transformed.fields.push(transform2(field));
          return transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        },
        JsdocTypeJsdocObjectField: (result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }),
        JsdocTypeUnion: (result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e2) => transform2(e2))
        }),
        JsdocTypeKeyValue: (result, transform2) => ({
          type: "FieldType",
          key: makeName(result.key),
          value: result.right === void 0 ? void 0 : transform2(result.right)
        }),
        JsdocTypeNamePath: (result, transform2) => {
          let leftResult = transform2(result.left), rightValue;
          result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
          let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        },
        JsdocTypeSymbol: (result) => {
          let value = "", element = result.element, trailingDots = false;
          return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value = "..." : trailingDots = true, element = element.element), element?.type === "JsdocTypeName" ? value += element.value : element?.type === "JsdocTypeNumber" && (value += element.value.toString()), trailingDots && (value += "..."), makeName(`${result.value}(${value})`);
        },
        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      function getMemberType(type5) {
        switch (type5) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      function nestResults(type5, results) {
        return results.length === 2 ? {
          type: type5,
          left: results[0],
          right: results[1]
        } : {
          type: type5,
          left: results[0],
          right: nestResults(type5, results.slice(1))
        };
      }
      let jtpRules = {
        JsdocTypeOptional: (result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }),
        JsdocTypeNullable: (result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }),
        JsdocTypeNotNullable: (result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }),
        JsdocTypeVariadic: (result, transform2) => {
          let transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
        },
        JsdocTypeName: (result) => ({
          type: "NAME",
          name: result.value
        }),
        JsdocTypeTypeof: (result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }),
        JsdocTypeTuple: (result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }),
        JsdocTypeKeyof: (result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }),
        JsdocTypeImport: (result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }),
        JsdocTypeUndefined: () => ({
          type: "NAME",
          name: "undefined"
        }),
        JsdocTypeAny: () => ({
          type: "ANY"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let specialParams = extractSpecialParams(result), transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else
                return transform2(param);
            }),
            new: null,
            returns: null
          };
          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => {
          let transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
            type: "NAME",
            name: "function"
          }), transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: false
          };
        },
        JsdocTypeJsdocObjectField: () => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        },
        JsdocTypeKeyValue: (result, transform2) => {
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: false
          };
        },
        JsdocTypeObject: (result, transform2) => {
          let entries = [];
          for (let field of result.elements)
            (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
          return {
            type: "RECORD",
            entries
          };
        },
        JsdocTypeSpecialNamePath: (result) => {
          if (result.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        },
        JsdocTypeNamePath: (result, transform2) => {
          let hasEventPrefix = false, name, quoteStyle;
          result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = true, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
          let transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            let tModule = transformed.owner;
            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
          } else
            return transformed;
        },
        JsdocTypeUnion: (result, transform2) => nestResults("UNION", result.elements.map(transform2)),
        JsdocTypeParenthesis: (result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }),
        JsdocTypeNull: () => ({
          type: "NAME",
          name: "null"
        }),
        JsdocTypeUnknown: () => ({
          type: "UNKNOWN"
        }),
        JsdocTypeStringValue: (result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }),
        JsdocTypeIntersection: (result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)),
        JsdocTypeNumber: (result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: (result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeGeneric: (result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }),
          JsdocTypeNullable: (result) => result,
          JsdocTypeUnion: (result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeUnknown: (result) => result,
          JsdocTypeUndefined: (result) => result,
          JsdocTypeTypeof: (result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }),
          JsdocTypeSymbol: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeOptional: (result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeObject: (result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }),
          JsdocTypeNumber: (result) => result,
          JsdocTypeNull: (result) => result,
          JsdocTypeNotNullable: (result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeSpecialNamePath: (result) => result,
          JsdocTypeObjectField: (result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }),
          JsdocTypeJsdocObjectField: (result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeKeyValue: (result, transform2) => ({
            type: "JsdocTypeKeyValue",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            variadic: result.variadic
          }),
          JsdocTypeImport: (result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }),
          JsdocTypeAny: (result) => result,
          JsdocTypeStringValue: (result) => result,
          JsdocTypeNamePath: (result) => result,
          JsdocTypeVariadic: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeTuple: (result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeName: (result) => result,
          JsdocTypeFunction: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
          },
          JsdocTypeKeyof: (result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }),
          JsdocTypeParenthesis: (result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }),
          JsdocTypeProperty: (result) => result,
          JsdocTypePredicate: (result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeIndexSignature: (result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeMappedType: (result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeAsserts: (result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeReadonlyArray: (result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }),
          JsdocTypeAssertsPlain: (result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }),
          JsdocTypeConditional: (result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }),
          JsdocTypeTypeParameter: (result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          })
        };
      }
      let visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter?.(node, parentNode, property);
        let keysToVisit = visitorKeys[node.type];
        for (let key of keysToVisit) {
          let value = node[key];
          if (value !== void 0)
            if (Array.isArray(value))
              for (let element of value)
                _traverse(element, node, key, onEnter, onLeave);
            else
              _traverse(value, node, key, onEnter, onLeave);
        }
        onLeave?.(node, parentNode, property);
      }
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse6, exports2.stringify = stringify5, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
    });
  }
});
var require_browser_dtector_umd_min = __commonJS$3({
  "../node_modules/browser-dtector/browser-dtector.umd.min.js"(exports, module2) {
    (function(e2, o2) {
      typeof exports == "object" && typeof module2 < "u" ? module2.exports = o2() : typeof define == "function" && define.amd ? define(o2) : (e2 = typeof globalThis < "u" ? globalThis : e2 || self).BrowserDetector = o2();
    })(exports, function() {
      function e2(e3, o3) {
        for (var r3 = 0; r3 < o3.length; r3++) {
          var n3 = o3[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, (i3 = n3.key, t3 = void 0, typeof (t3 = function(e4, o4) {
            if (typeof e4 != "object" || e4 === null) return e4;
            var r4 = e4[Symbol.toPrimitive];
            if (r4 !== void 0) {
              var n4 = r4.call(e4, o4);
              if (typeof n4 != "object") return n4;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (o4 === "string" ? String : Number)(e4);
          }(i3, "string")) == "symbol" ? t3 : String(t3)), n3);
        }
        var i3, t3;
      }
      var o2 = { chrome: "Google Chrome", brave: "Brave", crios: "Google Chrome", edge: "Microsoft Edge", edg: "Microsoft Edge", edgios: "Microsoft Edge", fennec: "Mozilla Firefox", jsdom: "JsDOM", mozilla: "Mozilla Firefox", fxios: "Mozilla Firefox", msie: "Microsoft Internet Explorer", opera: "Opera", opios: "Opera", opr: "Opera", opt: "Opera", rv: "Microsoft Internet Explorer", safari: "Safari", samsungbrowser: "Samsung Browser", electron: "Electron" }, r2 = { android: "Android", androidTablet: "Android Tablet", cros: "Chrome OS", fennec: "Android Tablet", ipad: "IPad", iphone: "IPhone", jsdom: "JsDOM", linux: "Linux", mac: "Macintosh", tablet: "Android Tablet", win: "Windows", "windows phone": "Windows Phone", xbox: "Microsoft Xbox" }, n2 = function(e3) {
        var o3 = new RegExp("^-?\\d+(?:.\\d{0,".concat(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, "})?")), r3 = Number(e3).toString().match(o3);
        return r3 ? r3[0] : null;
      }, i2 = function() {
        return typeof window < "u" ? window.navigator : null;
      }, t22 = function() {
        function t3(e3) {
          var o3;
          (function(e4, o4) {
            if (!(e4 instanceof o4)) throw new TypeError("Cannot call a class as a function");
          })(this, t3), this.userAgent = e3 || ((o3 = i2()) === null || o3 === void 0 ? void 0 : o3.userAgent) || null;
        }
        var a2, l2, s3;
        return a2 = t3, l2 = [{ key: "parseUserAgent", value: function(e3) {
          var t4, a3, l3, s4 = {}, c2 = e3 || this.userAgent || "", d = c2.toLowerCase().replace(/\s\s+/g, " "), u3 = /(edge)\/([\w.]+)/.exec(d) || /(edg)[/]([\w.]+)/.exec(d) || /(opr)[/]([\w.]+)/.exec(d) || /(opt)[/]([\w.]+)/.exec(d) || /(fxios)[/]([\w.]+)/.exec(d) || /(edgios)[/]([\w.]+)/.exec(d) || /(jsdom)[/]([\w.]+)/.exec(d) || /(samsungbrowser)[/]([\w.]+)/.exec(d) || /(electron)[/]([\w.]+)/.exec(d) || /(chrome)[/]([\w.]+)/.exec(d) || /(crios)[/]([\w.]+)/.exec(d) || /(opios)[/]([\w.]+)/.exec(d) || /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(d) || /(webkit)[/]([\w.]+)/.exec(d) || /(opera)(?:.*version|)[/]([\w.]+)/.exec(d) || /(msie) ([\w.]+)/.exec(d) || /(fennec)[/]([\w.]+)/.exec(d) || d.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(d) || d.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(d) || [], f4 = /(ipad)/.exec(d) || /(ipod)/.exec(d) || /(iphone)/.exec(d) || /(jsdom)/.exec(d) || /(windows phone)/.exec(d) || /(xbox)/.exec(d) || /(win)/.exec(d) || /(tablet)/.exec(d) || /(android)/.test(d) && /(mobile)/.test(d) === false && ["androidTablet"] || /(android)/.exec(d) || /(mac)/.exec(d) || /(linux)/.exec(d) || /(cros)/.exec(d) || [], p2 = u3[5] || u3[3] || u3[1] || null, w2 = f4[0] || null, x2 = u3[4] || u3[2] || null, b2 = i2();
          p2 === "chrome" && typeof (b2 == null || (t4 = b2.brave) === null || t4 === void 0 ? void 0 : t4.isBrave) == "function" && (p2 = "brave"), p2 && (s4[p2] = true), w2 && (s4[w2] = true);
          var v2 = !!(s4.tablet || s4.android || s4.androidTablet), m3 = !!(s4.ipad || s4.tablet || s4.androidTablet), g2 = !!(s4.android || s4.androidTablet || s4.tablet || s4.ipad || s4.ipod || s4.iphone || s4["windows phone"]), h3 = !!(s4.cros || s4.mac || s4.linux || s4.win), y2 = !!(s4.brave || s4.chrome || s4.crios || s4.opr || s4.safari || s4.edg || s4.electron), A = !!(s4.msie || s4.rv);
          return { name: (a3 = o2[p2]) !== null && a3 !== void 0 ? a3 : null, platform: (l3 = r2[w2]) !== null && l3 !== void 0 ? l3 : null, userAgent: c2, version: x2, shortVersion: x2 ? n2(parseFloat(x2), 2) : null, isAndroid: v2, isTablet: m3, isMobile: g2, isDesktop: h3, isWebkit: y2, isIE: A };
        } }, { key: "getBrowserInfo", value: function() {
          var e3 = this.parseUserAgent();
          return { name: e3.name, platform: e3.platform, userAgent: e3.userAgent, version: e3.version, shortVersion: e3.shortVersion };
        } }], s3 = [{ key: "VERSION", get: function() {
          return "3.4.0";
        } }], l2 && e2(a2.prototype, l2), s3 && e2(a2, s3), Object.defineProperty(a2, "prototype", { writable: false }), t3;
      }();
      return t22;
    });
  }
});
var core_events_exports = {};
__export$4(core_events_exports, {
  ARGTYPES_INFO_REQUEST: () => ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE: () => ARGTYPES_INFO_RESPONSE,
  CHANNEL_CREATED: () => CHANNEL_CREATED,
  CHANNEL_WS_DISCONNECT: () => CHANNEL_WS_DISCONNECT,
  CONFIG_ERROR: () => CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST: () => CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE: () => CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET: () => CURRENT_STORY_WAS_SET,
  DOCS_PREPARED: () => DOCS_PREPARED,
  DOCS_RENDERED: () => DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST: () => FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE: () => FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_REMOUNT: () => FORCE_REMOUNT,
  FORCE_RE_RENDER: () => FORCE_RE_RENDER,
  GLOBALS_UPDATED: () => GLOBALS_UPDATED,
  MANAGER_INERT_ATTRIBUTE_CHANGED: () => MANAGER_INERT_ATTRIBUTE_CHANGED,
  NAVIGATE_URL: () => NAVIGATE_URL,
  OPEN_IN_EDITOR_REQUEST: () => OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE: () => OPEN_IN_EDITOR_RESPONSE,
  PLAY_FUNCTION_THREW_EXCEPTION: () => PLAY_FUNCTION_THREW_EXCEPTION,
  PRELOAD_ENTRIES: () => PRELOAD_ENTRIES,
  PREVIEW_BUILDER_PROGRESS: () => PREVIEW_BUILDER_PROGRESS,
  PREVIEW_INITIALIZED: () => PREVIEW_INITIALIZED,
  PREVIEW_KEYDOWN: () => PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION: () => REGISTER_SUBSCRIPTION,
  REQUEST_WHATS_NEW_DATA: () => REQUEST_WHATS_NEW_DATA,
  RESET_STORY_ARGS: () => RESET_STORY_ARGS,
  RESULT_WHATS_NEW_DATA: () => RESULT_WHATS_NEW_DATA,
  SAVE_STORY_REQUEST: () => SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE: () => SAVE_STORY_RESPONSE,
  SELECT_STORY: () => SELECT_STORY$1,
  SET_CONFIG: () => SET_CONFIG,
  SET_CURRENT_STORY: () => SET_CURRENT_STORY,
  SET_FILTER: () => SET_FILTER,
  SET_GLOBALS: () => SET_GLOBALS,
  SET_INDEX: () => SET_INDEX,
  SET_STORIES: () => SET_STORIES,
  SET_WHATS_NEW_CACHE: () => SET_WHATS_NEW_CACHE,
  SHARED_STATE_CHANGED: () => SHARED_STATE_CHANGED,
  SHARED_STATE_SET: () => SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL: () => STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL: () => STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED: () => STORY_ARGS_UPDATED,
  STORY_CHANGED: () => STORY_CHANGED$1,
  STORY_ERRORED: () => STORY_ERRORED,
  STORY_FINISHED: () => STORY_FINISHED,
  STORY_HOT_UPDATED: () => STORY_HOT_UPDATED,
  STORY_INDEX_INVALIDATED: () => STORY_INDEX_INVALIDATED,
  STORY_MISSING: () => STORY_MISSING,
  STORY_PREPARED: () => STORY_PREPARED,
  STORY_RENDERED: () => STORY_RENDERED,
  STORY_RENDER_PHASE_CHANGED: () => STORY_RENDER_PHASE_CHANGED,
  STORY_SPECIFIED: () => STORY_SPECIFIED,
  STORY_THREW_EXCEPTION: () => STORY_THREW_EXCEPTION,
  STORY_UNCHANGED: () => STORY_UNCHANGED,
  TELEMETRY_ERROR: () => TELEMETRY_ERROR,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => TOGGLE_WHATS_NEW_NOTIFICATIONS,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => UNHANDLED_ERRORS_WHILE_PLAYING,
  UPDATE_GLOBALS: () => UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS: () => UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS: () => UPDATE_STORY_ARGS,
  default: () => core_events_default
});
var events = /* @__PURE__ */ ((events2) => (events2.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", events2.CHANNEL_CREATED = "channelCreated", events2.CONFIG_ERROR = "configError", events2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", events2.STORY_SPECIFIED = "storySpecified", events2.SET_CONFIG = "setConfig", events2.SET_STORIES = "setStories", events2.SET_INDEX = "setIndex", events2.SET_CURRENT_STORY = "setCurrentStory", events2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", events2.FORCE_RE_RENDER = "forceReRender", events2.FORCE_REMOUNT = "forceRemount", events2.PRELOAD_ENTRIES = "preloadStories", events2.STORY_PREPARED = "storyPrepared", events2.DOCS_PREPARED = "docsPrepared", events2.STORY_CHANGED = "storyChanged", events2.STORY_UNCHANGED = "storyUnchanged", events2.STORY_RENDERED = "storyRendered", events2.STORY_FINISHED = "storyFinished", events2.STORY_MISSING = "storyMissing", events2.STORY_ERRORED = "storyErrored", events2.STORY_THREW_EXCEPTION = "storyThrewException", events2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", events2.STORY_HOT_UPDATED = "storyHotUpdated", events2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", events2.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", events2.UPDATE_STORY_ARGS = "updateStoryArgs", events2.STORY_ARGS_UPDATED = "storyArgsUpdated", events2.RESET_STORY_ARGS = "resetStoryArgs", events2.SET_FILTER = "setFilter", events2.SET_GLOBALS = "setGlobals", events2.UPDATE_GLOBALS = "updateGlobals", events2.GLOBALS_UPDATED = "globalsUpdated", events2.REGISTER_SUBSCRIPTION = "registerSubscription", events2.PREVIEW_INITIALIZED = "previewInitialized", events2.PREVIEW_KEYDOWN = "previewKeydown", events2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", events2.SELECT_STORY = "selectStory", events2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", events2.STORIES_EXPAND_ALL = "storiesExpandAll", events2.DOCS_RENDERED = "docsRendered", events2.SHARED_STATE_CHANGED = "sharedStateChanged", events2.SHARED_STATE_SET = "sharedStateSet", events2.NAVIGATE_URL = "navigateUrl", events2.UPDATE_QUERY_PARAMS = "updateQueryParams", events2.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", events2.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", events2.SET_WHATS_NEW_CACHE = "setWhatsNewCache", events2.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", events2.TELEMETRY_ERROR = "telemetryError", events2.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", events2.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", events2.SAVE_STORY_REQUEST = "saveStoryRequest", events2.SAVE_STORY_RESPONSE = "saveStoryResponse", events2.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", events2.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", events2.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", events2.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", events2.OPEN_IN_EDITOR_REQUEST = "openInEditorRequest", events2.OPEN_IN_EDITOR_RESPONSE = "openInEditorResponse", events2.MANAGER_INERT_ATTRIBUTE_CHANGED = "managerInertAttributeChanged", events2))(events || {}), core_events_default = events, {
  CHANNEL_WS_DISCONNECT,
  CHANNEL_CREATED,
  CONFIG_ERROR,
  CREATE_NEW_STORYFILE_REQUEST,
  CREATE_NEW_STORYFILE_RESPONSE,
  CURRENT_STORY_WAS_SET,
  DOCS_PREPARED,
  DOCS_RENDERED,
  FILE_COMPONENT_SEARCH_REQUEST,
  FILE_COMPONENT_SEARCH_RESPONSE,
  FORCE_RE_RENDER,
  FORCE_REMOUNT,
  GLOBALS_UPDATED,
  NAVIGATE_URL,
  PLAY_FUNCTION_THREW_EXCEPTION,
  UNHANDLED_ERRORS_WHILE_PLAYING,
  PRELOAD_ENTRIES,
  PREVIEW_INITIALIZED,
  PREVIEW_BUILDER_PROGRESS,
  PREVIEW_KEYDOWN,
  REGISTER_SUBSCRIPTION,
  RESET_STORY_ARGS,
  SELECT_STORY: SELECT_STORY$1,
  SET_CONFIG,
  SET_CURRENT_STORY,
  SET_FILTER,
  SET_GLOBALS,
  SET_INDEX,
  SET_STORIES,
  SHARED_STATE_CHANGED,
  SHARED_STATE_SET,
  STORIES_COLLAPSE_ALL,
  STORIES_EXPAND_ALL,
  STORY_ARGS_UPDATED,
  STORY_CHANGED: STORY_CHANGED$1,
  STORY_ERRORED,
  STORY_INDEX_INVALIDATED,
  STORY_MISSING,
  STORY_PREPARED,
  STORY_RENDER_PHASE_CHANGED,
  STORY_RENDERED,
  STORY_FINISHED,
  STORY_SPECIFIED,
  STORY_THREW_EXCEPTION,
  STORY_UNCHANGED,
  STORY_HOT_UPDATED,
  UPDATE_GLOBALS,
  UPDATE_QUERY_PARAMS,
  UPDATE_STORY_ARGS,
  REQUEST_WHATS_NEW_DATA,
  RESULT_WHATS_NEW_DATA,
  SET_WHATS_NEW_CACHE,
  TOGGLE_WHATS_NEW_NOTIFICATIONS,
  TELEMETRY_ERROR,
  SAVE_STORY_REQUEST,
  SAVE_STORY_RESPONSE,
  ARGTYPES_INFO_REQUEST,
  ARGTYPES_INFO_RESPONSE,
  OPEN_IN_EDITOR_REQUEST,
  OPEN_IN_EDITOR_RESPONSE,
  MANAGER_INERT_ATTRIBUTE_CHANGED
} = events;
var dist_exports = {};
__export$4(dist_exports, {
  global: () => scope
});
var scope = (() => {
  let win;
  return typeof window < "u" ? win = window : typeof globalThis < "u" ? win = globalThis : typeof global < "u" ? win = global : typeof self < "u" ? win = self : win = {}, win;
})();
var globalsNameReferenceMap = {
  "@storybook/global": "__STORYBOOK_MODULE_GLOBAL__",
  "storybook/test": "__STORYBOOK_MODULE_TEST__",
  "storybook/actions": "__STORYBOOK_MODULE_ACTIONS__",
  "storybook/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__",
  "storybook/internal/channels": "__STORYBOOK_MODULE_CHANNELS__",
  "storybook/internal/client-logger": "__STORYBOOK_MODULE_CLIENT_LOGGER__",
  "storybook/internal/core-events": "__STORYBOOK_MODULE_CORE_EVENTS__",
  "storybook/internal/preview-errors": "__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__",
  "storybook/internal/types": "__STORYBOOK_MODULE_TYPES__",
  // @deprecated TODO: Remove in 9.1 or some point in the future, I guess
  "storybook/internal/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__"
}, globalPackages = Object.keys(globalsNameReferenceMap);
var channels_exports = {};
__export$4(channels_exports, {
  Channel: () => Channel,
  HEARTBEAT_INTERVAL: () => HEARTBEAT_INTERVAL,
  HEARTBEAT_MAX_LATENCY: () => HEARTBEAT_MAX_LATENCY,
  PostMessageTransport: () => PostMessageTransport,
  WebsocketTransport: () => WebsocketTransport,
  createBrowserChannel: () => createBrowserChannel$1,
  default: () => channels_default
});
function dedent$1(templ) {
  for (var values = [], _i = 1; _i < arguments.length; _i++)
    values[_i - 1] = arguments[_i];
  var strings = Array.from(typeof templ == "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str2) {
    var matches5 = str2.match(/\n([\t ]+|(?!\s).)/g);
    return matches5 ? arr.concat(matches5.map(function(match) {
      var _a3, _b;
      return (_b = (_a3 = match.match(/[\t ]/g)) === null || _a3 === void 0 ? void 0 : _a3.length) !== null && _b !== void 0 ? _b : 0;
    })) : arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str2) {
      return str2.replace(pattern_1, `
`);
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  return values.forEach(function(value, i2) {
    var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value;
    typeof value == "string" && value.includes(`
`) && (indentedValue = String(value).split(`
`).map(function(str2, i3) {
      return i3 === 0 ? str2 : "" + endentation + str2;
    }).join(`
`)), string += indentedValue + strings[i2 + 1];
  }), string;
}
var instances = /* @__PURE__ */ new Map();
var CHANNEL_EVENT_PREFIX = "UNIVERSAL_STORE:", ProgressState = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, _UniversalStore = class _UniversalStore2 {
  constructor(options, environmentOverrides) {
    this.debugging = false;
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    this.getState = () => (this.debug("getState", { state: this.state }), this.state);
    this.subscribe = (eventTypeOrListener, maybeListener) => {
      let subscribesToAllEvents = typeof eventTypeOrListener == "function", eventType = subscribesToAllEvents ? "*" : eventTypeOrListener, listener = subscribesToAllEvents ? eventTypeOrListener : maybeListener;
      if (this.debug("subscribe", { eventType, listener }), !listener)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(eventType) || this.listeners.set(eventType, /* @__PURE__ */ new Set()), this.listeners.get(eventType).add(listener), () => {
        this.debug("unsubscribe", { eventType, listener }), this.listeners.has(eventType) && (this.listeners.get(eventType).delete(listener), this.listeners.get(eventType)?.size === 0 && this.listeners.delete(eventType));
      };
    };
    this.send = (event) => {
      if (this.debug("send", { event }), this.status !== _UniversalStore2.Status.READY)
        throw new TypeError(
          dedent$1`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(event, { actor: this.actor }), this.emitToChannel(event, { actor: this.actor });
    };
    if (this.debugging = options.debug ?? false, !_UniversalStore2.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (_UniversalStore2.isInternalConstructing = false, this.id = options.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = options.leader ? _UniversalStore2.ActorType.LEADER : _UniversalStore2.ActorType.FOLLOWER, this.state = options.initialState, this.channelEventName = `${CHANNEL_EVENT_PREFIX}${this.id}`, this.debug("constructor", {
      options,
      environmentOverrides,
      channelEventName: this.channelEventName
    }), this.actor.type === _UniversalStore2.ActorType.LEADER)
      this.syncing = {
        state: ProgressState.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let syncingResolve, syncingReject, syncingPromise = new Promise((resolve, reject) => {
        syncingResolve = () => {
          this.syncing.state === ProgressState.PENDING && (this.syncing.state = ProgressState.RESOLVED, resolve());
        }, syncingReject = (reason) => {
          this.syncing.state === ProgressState.PENDING && (this.syncing.state = ProgressState.REJECTED, reject(reason));
        };
      });
      this.syncing = {
        state: ProgressState.PENDING,
        promise: syncingPromise,
        resolve: syncingResolve,
        reject: syncingReject
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(this), this.debug = this.debug.bind(this), this.channel = environmentOverrides?.channel ?? _UniversalStore2.preparation.channel, this.environment = environmentOverrides?.environment ?? _UniversalStore2.preparation.environment, this.channel && this.environment ? (_UniversalStore2.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis({ channel: this.channel, environment: this.environment })) : _UniversalStore2.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let resolveRef, rejectRef, promise = new Promise(
      (resolve, reject) => {
        resolveRef = (args) => {
          resolve(args);
        }, rejectRef = (...args) => {
          reject(args);
        };
      }
    );
    _UniversalStore2.preparation = {
      resolve: resolveRef,
      reject: rejectRef,
      promise
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? _UniversalStore2.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return _UniversalStore2.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case ProgressState.PENDING:
      case void 0:
        return _UniversalStore2.Status.SYNCING;
      case ProgressState.REJECTED:
        return _UniversalStore2.Status.ERROR;
      case ProgressState.RESOLVED:
      default:
        return _UniversalStore2.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([_UniversalStore2.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(options) {
    if (!options || typeof options?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    options.debug && console.debug(
      dedent$1`[UniversalStore]
        create`,
      { options }
    );
    let existing = instances.get(options.id);
    if (existing)
      return console.warn(dedent$1`UniversalStore with id "${options.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), existing;
    _UniversalStore2.isInternalConstructing = true;
    let store = new _UniversalStore2(options);
    return instances.set(options.id, store), store;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(channel2, environment) {
    _UniversalStore2.preparation.channel = channel2, _UniversalStore2.preparation.environment = environment, _UniversalStore2.preparation.resolve({ channel: channel2, environment });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(updater) {
    let previousState = this.state, newState = typeof updater == "function" ? updater(previousState) : updater;
    if (this.debug("setState", { newState, previousState, updater }), this.status !== _UniversalStore2.Status.READY)
      throw new TypeError(
        dedent$1`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = newState;
    let event = {
      type: _UniversalStore2.InternalEventType.SET_STATE,
      payload: {
        state: newState,
        previousState
      }
    };
    this.emitToChannel(event, { actor: this.actor }), this.emitToListeners(event, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(listener) {
    return this.debug("onStateChange", { listener }), this.subscribe(
      _UniversalStore2.InternalEventType.SET_STATE,
      ({ payload }, eventInfo) => {
        listener(payload.state, payload.previousState, eventInfo);
      }
    );
  }
  emitToChannel(event, eventInfo) {
    this.debug("emitToChannel", { event, eventInfo, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event,
      eventInfo
    });
  }
  prepareThis({
    channel: channel2,
    environment
  }) {
    this.channel = channel2, this.environment = environment, this.debug("prepared", { channel: !!channel2, environment }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === _UniversalStore2.ActorType.LEADER ? this.emitToChannel(
      { type: _UniversalStore2.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: _UniversalStore2.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: _UniversalStore2.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(event, eventInfo) {
    let eventTypeListeners = this.listeners.get(event.type), everythingListeners = this.listeners.get("*");
    this.debug("emitToListeners", {
      event,
      eventInfo,
      eventTypeListeners,
      everythingListeners
    }), [...eventTypeListeners ?? [], ...everythingListeners ?? []].forEach(
      (listener) => listener(event, eventInfo)
    );
  }
  handleChannelEvents(channelEvent) {
    let { event, eventInfo } = channelEvent;
    if ([eventInfo.actor.id, eventInfo.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent });
      return;
    } else if (this.syncing?.state === ProgressState.PENDING && event.type !== _UniversalStore2.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent }), this.actor.type === _UniversalStore2.ActorType.LEADER) {
      let shouldForwardEvent = true;
      switch (event.type) {
        case _UniversalStore2.InternalEventType.EXISTING_STATE_REQUEST:
          shouldForwardEvent = false;
          let responseEvent = {
            type: _UniversalStore2.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent
          }), this.emitToChannel(responseEvent, { actor: this.actor }), this.emitToListeners(responseEvent, { actor: this.actor });
          break;
        case _UniversalStore2.InternalEventType.LEADER_CREATED:
          shouldForwardEvent = false, this.syncing.state = ProgressState.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event
          }), console.error(
            dedent$1`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(eventInfo.actor, null, 2)}`
          );
          break;
      }
      shouldForwardEvent && (this.debug("handleChannelEvents: forwarding event", { channelEvent }), this.emitToChannel(event, { actor: eventInfo.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === _UniversalStore2.ActorType.FOLLOWER)
      switch (event.type) {
        case _UniversalStore2.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event
          }), this.syncing?.state !== ProgressState.PENDING)
            break;
          this.syncing.resolve?.();
          let setStateEvent = {
            type: _UniversalStore2.InternalEventType.SET_STATE,
            payload: {
              state: event.payload,
              previousState: this.state
            }
          };
          this.state = event.payload, this.emitToListeners(setStateEvent, eventInfo);
          break;
      }
    switch (event.type) {
      case _UniversalStore2.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event }), this.state = event.payload.state;
        break;
    }
    this.emitToListeners(event, { actor: eventInfo.actor });
  }
  debug(message, data) {
    this.debugging && console.debug(
      dedent$1`[UniversalStore::${this.id}::${this.environment ?? _UniversalStore2.Environment.UNKNOWN}]
        ${message}`,
      JSON.stringify(
        {
          data,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    _UniversalStore2.preparation.reject(new Error("reset")), _UniversalStore2.setupPreparationPromise(), _UniversalStore2.isInternalConstructing = false;
  }
};
_UniversalStore.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
}, /**
* Defines the possible environments the store can run in
*
* @readonly
*/
_UniversalStore.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
}, /**
* Internal event types used for store synchronization
*
* @readonly
*/
_UniversalStore.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
}, _UniversalStore.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
}, // This is used to check if constructor was called from the static factory create()
_UniversalStore.isInternalConstructing = false, _UniversalStore.setupPreparationPromise();
var UniversalStore = _UniversalStore;
var isMulti = (args) => args.transports !== void 0, generateRandomId = () => Math.random().toString(16).slice(2), Channel = class {
  constructor(input2 = {}) {
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = input2.async || false, isMulti(input2) ? (this.transports = input2.transports || [], this.transports.forEach((t22) => {
      t22.setHandler((event) => this.handleEvent(event));
    })) : this.transports = input2.transport ? [input2.transport] : [], this.transports.forEach((t22) => {
      t22.setHandler((event) => this.handleEvent(event));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(eventName, listener) {
    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);
  }
  emit(eventName, ...args) {
    let event = { type: eventName, args, from: this.sender }, options = {};
    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);
    let handler = () => {
      this.transports.forEach((t22) => {
        t22.send(event, options);
      }), this.handleEvent(event);
    };
    this.isAsync ? setImmediate(handler) : handler();
  }
  last(eventName) {
    return this.data[eventName];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(eventName) {
    let listeners3 = this.listeners(eventName);
    return listeners3 ? listeners3.length : 0;
  }
  listeners(eventName) {
    return this.events[eventName] || void 0;
  }
  once(eventName, listener) {
    let onceListener = this.onceListener(eventName, listener);
    this.addListener(eventName, onceListener);
  }
  removeAllListeners(eventName) {
    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};
  }
  removeListener(eventName, listener) {
    let listeners3 = this.listeners(eventName);
    listeners3 && (this.events[eventName] = listeners3.filter((l2) => l2 !== listener));
  }
  on(eventName, listener) {
    this.addListener(eventName, listener);
  }
  off(eventName, listener) {
    this.removeListener(eventName, listener);
  }
  handleEvent(event) {
    let listeners3 = this.listeners(event.type);
    listeners3 && listeners3.length && listeners3.forEach((fn3) => {
      fn3.apply(event, event.args);
    }), this.data[event.type] = event.args;
  }
  onceListener(eventName, listener) {
    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));
    return onceListener;
  }
};
var client_logger_exports = {};
__export$4(client_logger_exports, {
  deprecate: () => deprecate,
  logger: () => logger$1,
  once: () => once,
  pretty: () => pretty
});
var { LOGLEVEL } = scope, levels = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, currentLogLevelString = LOGLEVEL, currentLogLevelNumber = levels[currentLogLevelString] || levels.info, logger$1 = {
  trace: (message, ...rest) => {
    currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);
  },
  debug: (message, ...rest) => {
    currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);
  },
  info: (message, ...rest) => {
    currentLogLevelNumber <= levels.info && console.info(message, ...rest);
  },
  warn: (message, ...rest) => {
    currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);
  },
  error: (message, ...rest) => {
    currentLogLevelNumber <= levels.error && console.error(message, ...rest);
  },
  log: (message, ...rest) => {
    currentLogLevelNumber < levels.silent && console.log(message, ...rest);
  }
}, logged = /* @__PURE__ */ new Set(), once = (type5) => (message, ...rest) => {
  if (!logged.has(message))
    return logged.add(message), logger$1[type5](message, ...rest);
};
once.clear = () => logged.clear();
once.trace = once("trace");
once.debug = once("debug");
once.info = once("info");
once.warn = once("warn");
once.error = once("error");
once.log = once("log");
var deprecate = once("warn"), pretty = (type5) => (...args) => {
  let argArray = [];
  if (args.length) {
    let startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, endTagRe = /<\/span>/gi, reResultArray;
    for (argArray.push(args[0].replace(startTagRe, "%c").replace(endTagRe, "%c")); reResultArray = startTagRe.exec(args[0]); )
      argArray.push(reResultArray[2]), argArray.push("");
    for (let j2 = 1; j2 < args.length; j2++)
      argArray.push(args[j2]);
  }
  logger$1[type5].apply(logger$1, argArray);
};
pretty.trace = pretty("trace");
pretty.debug = pretty("debug");
pretty.info = pretty("info");
pretty.warn = pretty("warn");
pretty.error = pretty("error");
var __create2 = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc2 = Object.getOwnPropertyDescriptor, __getOwnPropNames2 = Object.getOwnPropertyNames, __getProtoOf2 = Object.getPrototypeOf, __hasOwnProp2 = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames2(from))
      !__hasOwnProp2.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  return to;
}, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
)), eventProperties = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], customEventSpecificProperties = ["detail"];
function extractEventHiddenProperties(event) {
  let rebuildEvent = eventProperties.filter((value) => event[value] !== void 0).reduce((acc, value) => (acc[value] = event[value], acc), {});
  if (event instanceof CustomEvent)
    for (let value of customEventSpecificProperties.filter(
      (value2) => event[value2] !== void 0
    ))
      rebuildEvent[value] = event[value];
  return rebuildEvent;
}
var require_es_object_atoms = __commonJS2({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module2) {
    module2.exports = Object;
  }
}), require_es_errors = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module2) {
    module2.exports = Error;
  }
}), require_eval = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module2) {
    module2.exports = EvalError;
  }
}), require_range = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module2) {
    module2.exports = RangeError;
  }
}), require_ref = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module2) {
    module2.exports = ReferenceError;
  }
}), require_syntax = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module2) {
    module2.exports = SyntaxError;
  }
}), require_type = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module2) {
    module2.exports = TypeError;
  }
}), require_uri = __commonJS2({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module2) {
    module2.exports = URIError;
  }
}), require_abs = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module2) {
    module2.exports = Math.abs;
  }
}), require_floor = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module2) {
    module2.exports = Math.floor;
  }
}), require_max = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module2) {
    module2.exports = Math.max;
  }
}), require_min = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module2) {
    module2.exports = Math.min;
  }
}), require_pow = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module2) {
    module2.exports = Math.pow;
  }
}), require_round = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module2) {
    module2.exports = Math.round;
  }
}), require_isNaN = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module2) {
    module2.exports = Number.isNaN || function(a2) {
      return a2 !== a2;
    };
  }
}), require_sign = __commonJS2({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module2) {
    var $isNaN = require_isNaN();
    module2.exports = function(number) {
      return $isNaN(number) || number === 0 ? number : number < 0 ? -1 : 1;
    };
  }
}), require_gOPD = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module2) {
    module2.exports = Object.getOwnPropertyDescriptor;
  }
}), require_gopd = __commonJS2({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module2) {
    var $gOPD = require_gOPD();
    if ($gOPD)
      try {
        $gOPD([], "length");
      } catch {
        $gOPD = null;
      }
    module2.exports = $gOPD;
  }
}), require_es_define_property = __commonJS2({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module2) {
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty)
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch {
        $defineProperty = false;
      }
    module2.exports = $defineProperty;
  }
}), require_shams = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module2) {
    module2.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var obj = {}, sym = Symbol("test"), symObj = Object(sym);
      if (typeof sym == "string" || Object.prototype.toString.call(sym) !== "[object Symbol]" || Object.prototype.toString.call(symObj) !== "[object Symbol]")
        return false;
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj)
        return false;
      if (typeof Object.keys == "function" && Object.keys(obj).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(obj).length !== 0)
        return false;
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym || !Object.prototype.propertyIsEnumerable.call(obj, sym))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true)
          return false;
      }
      return true;
    };
  }
}), require_has_symbols = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module2) {
    var origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = require_shams();
    module2.exports = function() {
      return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : hasSymbolSham();
    };
  }
}), require_Reflect_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module2) {
    module2.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), require_Object_getPrototypeOf = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module2) {
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
}), require_implementation = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module2) {
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr3 = Object.prototype.toString, max2 = Math.max, funcType = "[object Function]", concatty = function(a2, b2) {
      for (var arr = [], i2 = 0; i2 < a2.length; i2 += 1)
        arr[i2] = a2[i2];
      for (var j2 = 0; j2 < b2.length; j2 += 1)
        arr[j2 + a2.length] = b2[j2];
      return arr;
    }, slicy = function(arrLike, offset2) {
      for (var arr = [], i2 = offset2, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1)
        arr[j2] = arrLike[i2];
      return arr;
    }, joiny = function(arr, joiner) {
      for (var str2 = "", i2 = 0; i2 < arr.length; i2 += 1)
        str2 += arr[i2], i2 + 1 < arr.length && (str2 += joiner);
      return str2;
    };
    module2.exports = function(that) {
      var target = this;
      if (typeof target != "function" || toStr3.apply(target) !== funcType)
        throw new TypeError(ERROR_MESSAGE + target);
      for (var args = slicy(arguments, 1), bound, binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          return Object(result) === result ? result : this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, boundLength = max2(0, target.length - args.length), boundArgs = [], i2 = 0; i2 < boundLength; i2++)
        boundArgs[i2] = "$" + i2;
      if (bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder), target.prototype) {
        var Empty = function() {
        };
        Empty.prototype = target.prototype, bound.prototype = new Empty(), Empty.prototype = null;
      }
      return bound;
    };
  }
}), require_function_bind = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module2) {
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
}), require_functionCall = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module2) {
    module2.exports = Function.prototype.call;
  }
}), require_functionApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module2) {
    module2.exports = Function.prototype.apply;
  }
}), require_reflectApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module2) {
    module2.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), require_actualApply = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module2) {
    var bind = require_function_bind(), $apply = require_functionApply(), $call = require_functionCall(), $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
}), require_call_bind_apply_helpers = __commonJS2({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module2) {
    var bind = require_function_bind(), $TypeError = require_type(), $call = require_functionCall(), $actualApply = require_actualApply();
    module2.exports = function(args) {
      if (args.length < 1 || typeof args[0] != "function")
        throw new $TypeError("a function is required");
      return $actualApply(bind, $call, args);
    };
  }
}), require_get = __commonJS2({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module2) {
    var callBind = require_call_bind_apply_helpers(), gOPD = require_gopd(), hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e2) {
      if (!e2 || typeof e2 != "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS")
        throw e2;
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), $Object = Object, $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get == "function" ? callBind([desc.get]) : typeof $getPrototypeOf == "function" ? (
      /** @type {import('./get')} */
      function(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
}), require_get_proto = __commonJS2({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module2) {
    var reflectGetProto = require_Reflect_getPrototypeOf(), originalGetProto = require_Object_getPrototypeOf(), getDunderProto = require_get();
    module2.exports = reflectGetProto ? function(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function(O) {
      if (!O || typeof O != "object" && typeof O != "function")
        throw new TypeError("getProto: not an object");
      return originalGetProto(O);
    } : getDunderProto ? function(O) {
      return getDunderProto(O);
    } : null;
  }
}), require_hasown = __commonJS2({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module2) {
    var call2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind = require_function_bind();
    module2.exports = bind.call(call2, $hasOwn);
  }
}), require_get_intrinsic = __commonJS2({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module2) {
    var undefined2, $Object = require_es_object_atoms(), $Error = require_es_errors(), $EvalError = require_eval(), $RangeError = require_range(), $ReferenceError = require_ref(), $SyntaxError = require_syntax(), $TypeError = require_type(), $URIError = require_uri(), abs = require_abs(), floor2 = require_floor(), max2 = require_max(), min2 = require_min(), pow = require_pow(), round2 = require_round(), sign = require_sign(), $Function = Function, getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch {
      }
    }, $gOPD = require_gopd(), $defineProperty = require_es_define_property(), throwTypeError = function() {
      throw new $TypeError();
    }, ThrowTypeError = $gOPD ? function() {
      try {
        return arguments.callee, throwTypeError;
      } catch {
        try {
          return $gOPD(arguments, "callee").get;
        } catch {
          return throwTypeError;
        }
      }
    }() : throwTypeError, hasSymbols = require_has_symbols()(), getProto = require_get_proto(), $ObjectGPO = require_Object_getPrototypeOf(), $ReflectGPO = require_Reflect_getPrototypeOf(), $apply = require_functionApply(), $call = require_functionCall(), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto ? undefined2 : getProto(Uint8Array), INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics > "u" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt > "u" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array > "u" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array > "u" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON == "object" ? JSON : undefined2,
      "%Map%": typeof Map > "u" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy > "u" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect > "u" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array > "u" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap > "u" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor2,
      "%Math.max%": max2,
      "%Math.min%": min2,
      "%Math.pow%": pow,
      "%Math.round%": round2,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto)
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2)), INTRINSICS["%Error.prototype%"] = errorProto;
      }
    var errorProto, doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%")
        value = getEvalledConstructor("async function () {}");
      else if (name === "%GeneratorFunction%")
        value = getEvalledConstructor("function* () {}");
      else if (name === "%AsyncGeneratorFunction%")
        value = getEvalledConstructor("async function* () {}");
      else if (name === "%AsyncGenerator%") {
        var fn3 = doEval2("%AsyncGeneratorFunction%");
        fn3 && (value = fn3.prototype);
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        gen && getProto && (value = getProto(gen.prototype));
      }
      return INTRINSICS[name] = value, value;
    }, LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, bind = require_function_bind(), hasOwn = require_hasown(), $concat = bind.call($call, Array.prototype.concat), $spliceApply = bind.call($apply, Array.prototype.splice), $replace = bind.call($call, String.prototype.replace), $strSlice = bind.call($call, String.prototype.slice), $exec = bind.call($call, RegExp.prototype.exec), rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar2 = /\\(\\)?/g, stringToPath2 = function(string) {
      var first = $strSlice(string, 0, 1), last = $strSlice(string, -1);
      if (first === "%" && last !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      if (last === "%" && first !== "%")
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      var result = [];
      return $replace(string, rePropName2, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      }), result;
    }, getBaseIntrinsic = function(name, allowMissing) {
      var intrinsicName = name, alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName) && (alias = LEGACY_ALIASES[intrinsicName], intrinsicName = "%" + alias[0] + "%"), hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval && (value = doEval(intrinsicName)), typeof value > "u" && !allowMissing)
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function(name, allowMissing) {
      if (typeof name != "string" || name.length === 0)
        throw new $TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof allowMissing != "boolean")
        throw new $TypeError('"allowMissing" argument must be a boolean');
      if ($exec(/^%?[^%]*%?$/, name) === null)
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var parts = stringToPath2(name), intrinsicBaseName = parts.length > 0 ? parts[0] : "", intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing), intrinsicRealName = intrinsic.name, value = intrinsic.value, skipFurtherCaching = false, alias = intrinsic.alias;
      alias && (intrinsicBaseName = alias[0], $spliceApply(parts, $concat([0, 1], alias)));
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2], first = $strSlice(part, 0, 1), last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last)
          throw new $SyntaxError("property names with quotes must have matching quotes");
        if ((part === "constructor" || !isOwn) && (skipFurtherCaching = true), intrinsicBaseName += "." + part, intrinsicRealName = "%" + intrinsicBaseName + "%", hasOwn(INTRINSICS, intrinsicRealName))
          value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing)
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            return;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc, isOwn && "get" in desc && !("originalValue" in desc.get) ? value = desc.get : value = value[part];
          } else
            isOwn = hasOwn(value, part), value = value[part];
          isOwn && !skipFurtherCaching && (INTRINSICS[intrinsicRealName] = value);
        }
      }
      return value;
    };
  }
}), require_call_bound = __commonJS2({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports, module2) {
    var GetIntrinsic = require_get_intrinsic(), callBindBasic = require_call_bind_apply_helpers(), $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      return typeof intrinsic == "function" && $indexOf(name, ".prototype.") > -1 ? callBindBasic(
        /** @type {const} */
        [intrinsic]
      ) : intrinsic;
    };
  }
}), require_shams2 = __commonJS2({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module2) {
    var hasSymbols = require_shams();
    module2.exports = function() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
}), require_is_regex = __commonJS2({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(exports, module2) {
    var callBound = require_call_bound(), hasToStringTag = require_shams2()(), hasOwn = require_hasown(), gOPD = require_gopd(), fn3;
    hasToStringTag ? ($exec = callBound("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
      throw isRegexMarker;
    }, badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    }, typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn3 = function(value) {
      if (!value || typeof value != "object")
        return false;
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      ), hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty)
        return false;
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e2) {
        return e2 === isRegexMarker;
      }
    }) : ($toString = callBound("Object.prototype.toString"), regexClass = "[object RegExp]", fn3 = function(value) {
      return !value || typeof value != "object" && typeof value != "function" ? false : $toString(value) === regexClass;
    });
    var $exec, isRegexMarker, throwRegexMarker, badStringifier, $toString, regexClass;
    module2.exports = fn3;
  }
}), require_is_function = __commonJS2({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(exports, module2) {
    module2.exports = isFunction32;
    var toString22 = Object.prototype.toString;
    function isFunction32(fn3) {
      if (!fn3)
        return false;
      var string = toString22.call(fn3);
      return string === "[object Function]" || typeof fn3 == "function" && string !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (fn3 === window.setTimeout || fn3 === window.alert || fn3 === window.confirm || fn3 === window.prompt);
    }
  }
}), require_safe_regex_test = __commonJS2({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(exports, module2) {
    var callBound = require_call_bound(), isRegex = require_is_regex(), $exec = callBound("RegExp.prototype.exec"), $TypeError = require_type();
    module2.exports = function(regex) {
      if (!isRegex(regex))
        throw new $TypeError("`regex` must be a RegExp");
      return function(s3) {
        return $exec(regex, s3) !== null;
      };
    };
  }
}), require_is_symbol = __commonJS2({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(exports, module2) {
    var callBound = require_call_bound(), $toString = callBound("Object.prototype.toString"), hasSymbols = require_has_symbols()(), safeRegexTest = require_safe_regex_test();
    hasSymbols ? ($symToStr = callBound("Symbol.prototype.toString"), isSymString = safeRegexTest(/^Symbol\(.*\)$/), isSymbolObject = function(value) {
      return typeof value.valueOf() != "symbol" ? false : isSymString($symToStr(value));
    }, module2.exports = function(value) {
      if (typeof value == "symbol")
        return true;
      if (!value || typeof value != "object" || $toString(value) !== "[object Symbol]")
        return false;
      try {
        return isSymbolObject(value);
      } catch {
        return false;
      }
    }) : module2.exports = function(value) {
      return false;
    };
    var $symToStr, isSymString, isSymbolObject;
  }
}), import_is_regex = __toESM2(require_is_regex()), import_is_function = __toESM2(require_is_function()), import_is_symbol = __toESM2(require_is_symbol());
function isObject$1(val) {
  return val != null && typeof val == "object" && Array.isArray(val) === false;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeGlobal_default = freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal_default || freeSelf || Function("return this")(), root_default = root, Symbol2 = root_default.Symbol, Symbol_default = Symbol2, objectProto = Object.prototype, hasOwnProperty$1 = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$1.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch {
  }
  var result = nativeObjectToString.call(value);
  return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
}
var getRawTag_default = getRawTag, objectProto2 = Object.prototype, nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike, symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag$1;
}
var isSymbol_default = isSymbol;
function arrayMap(array, iteratee) {
  for (var index2 = -1, length = array == null ? 0 : array.length, result = Array(length); ++index2 < length; )
    result[index2] = iteratee(array[index2], index2, array);
  return result;
}
var arrayMap_default = arrayMap, isArray = Array.isArray, isArray_default = isArray, symbolProto = Symbol_default ? Symbol_default.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string")
    return value;
  if (isArray_default(value))
    return arrayMap_default(value, baseToString) + "";
  if (isSymbol_default(value))
    return symbolToString ? symbolToString.call(value) : "";
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
var baseToString_default = baseToString;
function isObject2(value) {
  var type5 = typeof value;
  return value != null && (type5 == "object" || type5 == "function");
}
var isObject_default = isObject2, asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject_default(value))
    return false;
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction$1, coreJsData = root_default["__core-js_shared__"], coreJsData_default = coreJsData, maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked, funcProto = Function.prototype, funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch {
    }
    try {
      return func + "";
    } catch {
    }
  }
  return "";
}
var toSource_default = toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto2 = Function.prototype, objectProto3 = Object.prototype, funcToString2 = funcProto2.toString, hasOwnProperty2 = objectProto3.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value))
    return false;
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;
function getValue(object, key) {
  return object?.[key];
}
var getValue_default = getValue;
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value))
    return false;
  var type5 = typeof value;
  return type5 == "number" || type5 == "symbol" || type5 == "boolean" || value == null || isSymbol_default(value) ? true : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey, nativeCreate = getNative_default(Object, "create"), nativeCreate_default = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {}, this.size = 0;
}
var hashClear_default = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  return this.size -= result ? 1 : 0, result;
}
var hashDelete_default = hashDelete, HASH_UNDEFINED = "__lodash_hash_undefined__", objectProto4 = Object.prototype, hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet, objectProto5 = Object.prototype, hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas, HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value, this;
}
var hashSet_default = hashSet;
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype.delete = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
var listCacheClear_default = listCacheClear;
function assocIndexOf(array, key) {
  for (var length = array.length; length--; )
    if (eq_default(array[length][0], key))
      return length;
  return -1;
}
var assocIndexOf_default = assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0)
    return false;
  var lastIndex = data.length - 1;
  return index2 == lastIndex ? data.pop() : splice.call(data, index2, 1), --this.size, true;
}
var listCacheDelete_default = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? (++this.size, data.push([key, value])) : data[index2][1] = value, this;
}
var listCacheSet_default = listCacheSet;
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype.delete = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache, Map2 = getNative_default(root_default, "Map"), Map_default = Map2;
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash_default(),
    map: new (Map_default || ListCache_default)(),
    string: new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;
function isKeyable(value) {
  var type5 = typeof value;
  return type5 == "string" || type5 == "number" || type5 == "symbol" || type5 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;
function mapCacheDelete(key) {
  var result = getMapData_default(this, key).delete(key);
  return this.size -= result ? 1 : 0, result;
}
var mapCacheDelete_default = mapCacheDelete;
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  return data.set(key, value), this.size += data.size == size2 ? 0 : 1, this;
}
var mapCacheSet_default = mapCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  for (this.clear(); ++index2 < length; ) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype.delete = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache, FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key))
      return cache.get(key);
    var result = func.apply(this, args);
    return memoized.cache = cache.set(key, result) || cache, result;
  };
  return memoized.cache = new (memoize.Cache || MapCache_default)(), memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize, MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
  }), cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  return string.charCodeAt(0) === 46 && result.push(""), string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  }), result;
}), stringToPath_default = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;
function castPath(value, object) {
  return isArray_default(value) ? value : isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value))
    return value;
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
var toKey_default = toKey;
function baseGet(object, path) {
  path = castPath_default(path, object);
  for (var index2 = 0, length = path.length; object != null && index2 < length; )
    object = object[toKey_default(path[index2++])];
  return index2 && index2 == length ? object : void 0;
}
var baseGet_default = baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get, isObject3 = isObject$1, dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, isJSON = (input2) => input2.match(/^[\[\{\"\}].*[\]\}\"]$/);
function convertUnconventionalData(data) {
  if (!isObject3(data))
    return data;
  let result = data, wasMutated = false;
  return typeof Event < "u" && data instanceof Event && (result = extractEventHiddenProperties(result), wasMutated = true), result = Object.keys(result).reduce((acc, key) => {
    try {
      result[key] && result[key].toJSON, acc[key] = result[key];
    } catch {
      wasMutated = true;
    }
    return acc;
  }, {}), wasMutated ? result : data;
}
var replacer = function(options) {
  let objects, map2, stack2, keys2;
  return function(key, value) {
    try {
      if (key === "")
        return keys2 = [], objects = /* @__PURE__ */ new Map([[value, "[]"]]), map2 = /* @__PURE__ */ new Map(), stack2 = [], value;
      let origin = map2.get(this) || this;
      for (; stack2.length && origin !== stack2[0]; )
        stack2.shift(), keys2.pop();
      if (typeof value == "boolean")
        return value;
      if (value === void 0)
        return options.allowUndefined ? "_undefined_" : void 0;
      if (value === null)
        return null;
      if (typeof value == "number")
        return value === Number.NEGATIVE_INFINITY ? "_-Infinity_" : value === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(value) ? "_NaN_" : value;
      if (typeof value == "bigint")
        return `_bigint_${value.toString()}`;
      if (typeof value == "string")
        return dateFormat.test(value) ? options.allowDate ? `_date_${value}` : void 0 : value;
      if ((0, import_is_regex.default)(value))
        return options.allowRegExp ? `_regexp_${value.flags}|${value.source}` : void 0;
      if ((0, import_is_function.default)(value))
        return;
      if ((0, import_is_symbol.default)(value)) {
        if (!options.allowSymbol)
          return;
        let globalRegistryKey = Symbol.keyFor(value);
        return globalRegistryKey !== void 0 ? `_gsymbol_${globalRegistryKey}` : `_symbol_${value.toString().slice(7, -1)}`;
      }
      if (stack2.length >= options.maxDepth)
        return Array.isArray(value) ? `[Array(${value.length})]` : "[Object]";
      if (value === this)
        return `_duplicate_${JSON.stringify(keys2)}`;
      if (value instanceof Error && options.allowError)
        return {
          __isConvertedError__: true,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...value.cause ? { cause: value.cause } : {},
            ...value,
            name: value.name,
            message: value.message,
            stack: value.stack,
            "_constructor-name_": value.constructor.name
          }
        };
      if (value?.constructor?.name && value.constructor.name !== "Object" && !Array.isArray(value)) {
        let found2 = objects.get(value);
        if (!found2) {
          let plainObject = {
            __isClassInstance__: true,
            __className__: value.constructor.name,
            ...Object.getOwnPropertyNames(value).reduce(
              (acc, prop) => {
                try {
                  acc[prop] = value[prop];
                } catch {
                }
                return acc;
              },
              {}
            )
          };
          return keys2.push(key), stack2.unshift(plainObject), objects.set(value, JSON.stringify(keys2)), value !== plainObject && map2.set(value, plainObject), plainObject;
        }
        return `_duplicate_${found2}`;
      }
      let found = objects.get(value);
      if (!found) {
        let converted = Array.isArray(value) ? value : convertUnconventionalData(value);
        return keys2.push(key), stack2.unshift(converted), objects.set(value, JSON.stringify(keys2)), value !== converted && map2.set(value, converted), converted;
      }
      return `_duplicate_${found}`;
    } catch {
      return;
    }
  };
}, reviver = function(options) {
  let refs = [], root2;
  return function(key, value) {
    if (key === "" && (root2 = value, refs.forEach(({ target, container, replacement }) => {
      let replacementArr = isJSON(replacement) ? JSON.parse(replacement) : replacement.split(".");
      replacementArr.length === 0 ? container[target] = root2 : container[target] = get_default(root2, replacementArr);
    })), key === "_constructor-name_")
      return value;
    if (isObject3(value) && value.__isConvertedError__) {
      let { message, ...properties } = value.errorProperties, error = new Error(message);
      return Object.assign(error, properties), error;
    }
    if (typeof value == "string" && value.startsWith("_regexp_") && options.allowRegExp) {
      let [, flags, source] = value.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(source, flags);
    }
    return typeof value == "string" && value.startsWith("_date_") && options.allowDate ? new Date(value.replace("_date_", "")) : typeof value == "string" && value.startsWith("_duplicate_") ? (refs.push({ target: key, container: this, replacement: value.replace(/^_duplicate_/, "") }), null) : typeof value == "string" && value.startsWith("_symbol_") && options.allowSymbol ? Symbol(value.replace("_symbol_", "")) : typeof value == "string" && value.startsWith("_gsymbol_") && options.allowSymbol ? Symbol.for(value.replace("_gsymbol_", "")) : typeof value == "string" && value === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof value == "string" && value === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof value == "string" && value === "_NaN_" ? Number.NaN : typeof value == "string" && value.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(value.replace("_bigint_", "")) : value;
  };
}, defaultOptions = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: true,
  allowDate: true,
  allowError: true,
  allowUndefined: true,
  allowSymbol: true
}, stringify = (data, options = {}) => {
  let mergedOptions = { ...defaultOptions, ...options };
  return JSON.stringify(convertUnconventionalData(data), replacer(mergedOptions), options.space);
}, mutator = () => {
  let mutated = /* @__PURE__ */ new Map();
  return function mutateUndefined(value) {
    isObject3(value) && Object.entries(value).forEach(([k2, v2]) => {
      v2 === "_undefined_" ? value[k2] = void 0 : mutated.get(v2) || (mutated.set(v2, true), mutateUndefined(v2));
    }), Array.isArray(value) && value.forEach((v2, index2) => {
      v2 === "_undefined_" ? (mutated.set(v2, true), value[index2] = void 0) : mutated.get(v2) || (mutated.set(v2, true), mutateUndefined(v2));
    });
  };
}, parse$2 = (data, options = {}) => {
  let mergedOptions = { ...defaultOptions, ...options }, result = JSON.parse(data, reviver(mergedOptions));
  return mutator()(result), result;
};
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (!condition) {
    throw new Error(prefix);
  }
}
var getEventSourceUrl = (event) => {
  let frames = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [frame, ...remainder] = frames.filter((element) => {
    try {
      return element.contentWindow?.location.origin === event.source.location.origin && element.contentWindow?.location.pathname === event.source.location.pathname;
    } catch {
    }
    try {
      return element.contentWindow === event.source;
    } catch {
    }
    let src2 = element.getAttribute("src"), origin;
    try {
      if (!src2)
        return false;
      ({ origin } = new URL(src2, document.location.toString()));
    } catch {
      return false;
    }
    return origin === event.origin;
  }), src = frame?.getAttribute("src");
  if (src && remainder.length === 0) {
    let { protocol, host, pathname } = new URL(src, document.location.toString());
    return `${protocol}//${host}${pathname}`;
  }
  return remainder.length > 0 && logger$1.error("found multiple candidates for event source"), null;
};
var { document: document2, location } = scope, KEY = "storybook-channel", defaultEventOptions = { maxDepth: 25 }, PostMessageTransport = class {
  constructor(config4) {
    this.config = config4;
    this.connected = false;
    if (this.buffer = [], typeof scope?.addEventListener == "function" && scope.addEventListener("message", this.handleEvent.bind(this), false), config4.page !== "manager" && config4.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${config4.page}"`);
  }
  setHandler(handler) {
    this.handler = (...args) => {
      handler.apply(this, args), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = true);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(event, options) {
    let {
      target,
      // telejson options
      allowRegExp,
      allowSymbol,
      allowDate,
      allowError,
      allowUndefined,
      maxDepth,
      space
    } = options || {}, eventOptions = Object.fromEntries(
      Object.entries({
        allowRegExp,
        allowSymbol,
        allowDate,
        allowError,
        allowUndefined,
        maxDepth,
        space
      }).filter(([k2, v2]) => typeof v2 < "u")
    ), stringifyOptions = {
      ...defaultEventOptions,
      ...scope.CHANNEL_OPTIONS || {},
      ...eventOptions
    }, frames = this.getFrames(target), query = new URLSearchParams(location?.search || ""), data = stringify(
      {
        key: KEY,
        event,
        refId: query.get("refId")
      },
      stringifyOptions
    );
    return frames.length ? (this.buffer.length && this.flush(), frames.forEach((f4) => {
      try {
        f4.postMessage(data, "*");
      } catch {
        logger$1.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((resolve, reject) => {
      this.buffer.push({ event, resolve, reject });
    });
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((item) => {
      this.send(item.event).then(item.resolve).catch(item.reject);
    });
  }
  getFrames(target) {
    if (this.config.page === "manager") {
      let list = Array.from(
        document2.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((e2) => {
        try {
          return e2.contentWindow && e2.dataset.isStorybook !== void 0 && e2.id === target ? [e2.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return list?.length ? list : this.getCurrentFrames();
    }
    return scope && scope.parent && scope.parent !== scope.self ? [scope.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      document2.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []) : scope && scope.parent ? [scope.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      document2.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((e2) => e2.contentWindow ? [e2.contentWindow] : []) : scope && scope.parent ? [scope.parent] : [];
  }
  handleEvent(rawEvent) {
    try {
      let { data } = rawEvent, { key, event, refId } = typeof data == "string" && isJSON(data) ? parse$2(data, scope.CHANNEL_OPTIONS || {}) : data;
      if (key === KEY) {
        let pageString = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', eventString = Object.values(core_events_exports).includes(event.type) ? `<span style="color: #FF4785">${event.type}</span>` : `<span style="color: #FFAE00">${event.type}</span>`;
        if (refId && (event.refId = refId), event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent), !event.source) {
          pretty.error(
            `${pageString} received ${eventString} but was unable to determine the source of the event`
          );
          return;
        }
        let message = `${pageString} received ${eventString} (${data.length})`;
        pretty.debug(
          location.origin !== event.source ? message : `${message} <span style="color: gray">(on ${location.origin} from ${event.source})</span>`,
          ...event.args
        ), invariant(this.handler, "ChannelHandler should be set"), this.handler(event);
      }
    } catch (error) {
      logger$1.error(error);
    }
  }
};
var { WebSocket } = scope, HEARTBEAT_INTERVAL = 15e3, HEARTBEAT_MAX_LATENCY = 5e3, WebsocketTransport = class {
  constructor({ url, onError, page }) {
    this.buffer = [];
    this.isReady = false;
    this.isClosed = false;
    this.pingTimeout = 0;
    this.socket = new WebSocket(url), this.socket.onopen = () => {
      this.isReady = true, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data }) => {
      let event = typeof data == "string" && isJSON(data) ? parse$2(data) : data;
      invariant(this.handler), this.handler(event), event.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (e2) => {
      onError && onError(e2);
    }, this.socket.onclose = (ev) => {
      invariant(this.handler), this.handler({
        type: CHANNEL_WS_DISCONNECT,
        args: [{ reason: ev.reason, code: ev.code }],
        from: page || "preview"
      }), this.isClosed = true, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, HEARTBEAT_INTERVAL + HEARTBEAT_MAX_LATENCY);
  }
  setHandler(handler) {
    this.handler = handler;
  }
  send(event) {
    this.isClosed || (this.isReady ? this.sendNow(event) : this.sendLater(event));
  }
  sendLater(event) {
    this.buffer.push(event);
  }
  sendNow(event) {
    let data = stringify(event, {
      maxDepth: 15,
      ...scope.CHANNEL_OPTIONS
    });
    this.socket.send(data);
  }
  flush() {
    let { buffer } = this;
    this.buffer = [], buffer.forEach((event) => this.send(event));
  }
};
var { CONFIG_TYPE } = scope, channels_default = Channel;
function createBrowserChannel$1({ page, extraTransports = [] }) {
  let transports = [new PostMessageTransport({ page }), ...extraTransports];
  if (CONFIG_TYPE === "DEVELOPMENT") {
    let protocol = window.location.protocol === "http:" ? "ws" : "wss", { hostname, port } = window.location, channelUrl = `${protocol}://${hostname}:${port}/storybook-server-channel`;
    transports.push(new WebsocketTransport({ url: channelUrl, onError: () => {
    }, page }));
  }
  let channel2 = new Channel({ transports });
  return UniversalStore.__prepare(
    channel2,
    page === "manager" ? UniversalStore.Environment.MANAGER : UniversalStore.Environment.PREVIEW
  ), channel2;
}
var preview_errors_exports = {};
__export$4(preview_errors_exports, {
  CalledExtractOnStoreError: () => CalledExtractOnStoreError,
  CalledPreviewMethodBeforeInitializationError: () => CalledPreviewMethodBeforeInitializationError,
  Category: () => Category,
  ElementA11yParameterError: () => ElementA11yParameterError,
  EmptyIndexError: () => EmptyIndexError,
  ImplicitActionsDuringRendering: () => ImplicitActionsDuringRendering,
  MdxFileWithNoCsfReferencesError: () => MdxFileWithNoCsfReferencesError,
  MissingRenderToCanvasError: () => MissingRenderToCanvasError,
  MissingStoryAfterHmrError: () => MissingStoryAfterHmrError,
  MissingStoryFromCsfFileError: () => MissingStoryFromCsfFileError,
  MountMustBeDestructuredError: () => MountMustBeDestructuredError,
  NextJsSharpError: () => NextJsSharpError,
  NextjsRouterMocksNotAvailable: () => NextjsRouterMocksNotAvailable,
  NoRenderFunctionError: () => NoRenderFunctionError,
  NoStoryMatchError: () => NoStoryMatchError,
  NoStoryMountedError: () => NoStoryMountedError,
  StatusTypeIdMismatchError: () => StatusTypeIdMismatchError,
  StoryIndexFetchError: () => StoryIndexFetchError,
  StoryStoreAccessedBeforeInitializationError: () => StoryStoreAccessedBeforeInitializationError,
  UnknownArgTypesError: () => UnknownArgTypesError$1,
  UnsupportedViewportDimensionError: () => UnsupportedViewportDimensionError
});
function parseErrorCode({
  code,
  category
}) {
  let paddedCode = String(code).padStart(4, "0");
  return `SB_${category}_${paddedCode}`;
}
function appendErrorRef(url) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
    return url;
  try {
    let urlObj = new URL(url);
    return urlObj.searchParams.set("ref", "error"), urlObj.toString();
  } catch {
    return url;
  }
}
var StorybookError = class _StorybookError extends Error {
  constructor(props) {
    super(_StorybookError.getFullMessage(props));
    this.data = {};
    this.fromStorybook = true;
    this.isHandledError = false;
    this.subErrors = [];
    this.category = props.category, this.documentation = props.documentation ?? false, this.code = props.code, this.isHandledError = props.isHandledError ?? false, this.name = props.name, this.subErrors = props.subErrors ?? [];
  }
  get fullErrorCode() {
    return parseErrorCode({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let errorName = this._name || this.constructor.name;
    return `${this.fullErrorCode} (${errorName})`;
  }
  set name(name) {
    this._name = name;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation,
    code,
    category,
    message
  }) {
    let page;
    return documentation === true ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
  }
};
var Category = /* @__PURE__ */ ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {}), MissingStoryAfterHmrError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryAfterHmrError",
      category: "PREVIEW_API",
      code: 1,
      message: dedent$1`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = data;
  }
}, ImplicitActionsDuringRendering = class extends StorybookError {
  constructor(data) {
    super({
      name: "ImplicitActionsDuringRendering",
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: dedent$1`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
    });
    this.data = data;
  }
}, CalledExtractOnStoreError = class extends StorybookError {
  constructor() {
    super({
      name: "CalledExtractOnStoreError",
      category: "PREVIEW_API",
      code: 3,
      message: dedent$1`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
}, MissingRenderToCanvasError = class extends StorybookError {
  constructor() {
    super({
      name: "MissingRenderToCanvasError",
      category: "PREVIEW_API",
      code: 4,
      message: dedent$1`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
}, CalledPreviewMethodBeforeInitializationError = class extends StorybookError {
  constructor(data) {
    super({
      name: "CalledPreviewMethodBeforeInitializationError",
      category: "PREVIEW_API",
      code: 5,
      message: dedent$1`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = data;
  }
}, StoryIndexFetchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StoryIndexFetchError",
      category: "PREVIEW_API",
      code: 6,
      message: dedent$1`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = data;
  }
}, MdxFileWithNoCsfReferencesError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MdxFileWithNoCsfReferencesError",
      category: "PREVIEW_API",
      code: 7,
      message: dedent$1`
        Tried to render docs entry ${data.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = data;
  }
}, EmptyIndexError = class extends StorybookError {
  constructor() {
    super({
      name: "EmptyIndexError",
      category: "PREVIEW_API",
      code: 8,
      message: dedent$1`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
}, NoStoryMatchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "NoStoryMatchError",
      category: "PREVIEW_API",
      code: 9,
      message: dedent$1`
        Couldn't find story matching '${data.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = data;
  }
}, MissingStoryFromCsfFileError = class extends StorybookError {
  constructor(data) {
    super({
      name: "MissingStoryFromCsfFileError",
      category: "PREVIEW_API",
      code: 10,
      message: dedent$1`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = data;
  }
}, StoryStoreAccessedBeforeInitializationError = class extends StorybookError {
  constructor() {
    super({
      name: "StoryStoreAccessedBeforeInitializationError",
      category: "PREVIEW_API",
      code: 11,
      message: dedent$1`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
}, MountMustBeDestructuredError = class extends StorybookError {
  // name: 'MountMustBeDestructuredError';
  constructor(data) {
    super({
      name: "MountMustBeDestructuredError",
      category: "PREVIEW_API",
      code: 12,
      message: dedent$1`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
    });
    this.data = data;
  }
}, NoRenderFunctionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "NoRenderFunctionError",
      category: "PREVIEW_API",
      code: 14,
      message: dedent$1`
        No render function available for storyId '${data.id}'
      `
    });
    this.data = data;
  }
}, NoStoryMountedError = class extends StorybookError {
  constructor() {
    super({
      name: "NoStoryMountedError",
      category: "PREVIEW_API",
      code: 15,
      message: dedent$1`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
}, StatusTypeIdMismatchError = class extends StorybookError {
  constructor(data) {
    super({
      name: "StatusTypeIdMismatchError",
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
        data.status,
        null,
        2
      )}`
    });
    this.data = data;
  }
}, NextJsSharpError = class extends StorybookError {
  constructor() {
    super({
      name: "NextJsSharpError",
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: dedent$1`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
}, NextjsRouterMocksNotAvailable = class extends StorybookError {
  constructor(data) {
    super({
      name: "NextjsRouterMocksNotAvailable",
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: dedent$1`
        Tried to access router mocks from "${data.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = data;
  }
}, UnknownArgTypesError$1 = class UnknownArgTypesError extends StorybookError {
  constructor(data) {
    super({
      name: "UnknownArgTypesError",
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: dedent$1`
        There was a failure when generating detailed ArgTypes in ${data.language} for:
        ${JSON.stringify(data.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = data;
  }
}, UnsupportedViewportDimensionError = class extends StorybookError {
  constructor(data) {
    super({
      name: "UnsupportedViewportDimensionError",
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: dedent$1`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = data;
  }
}, ElementA11yParameterError = class extends StorybookError {
  constructor() {
    super({
      name: "ElementA11yParameterError",
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
var types_exports = {};
__export$4(types_exports, {
  Addon_TypesEnum: () => Addon_TypesEnum,
  CoreWebpackCompiler: () => CoreWebpackCompiler,
  Feature: () => Feature,
  SupportedBuilder: () => SupportedBuilder,
  SupportedFramework: () => SupportedFramework,
  SupportedLanguage: () => SupportedLanguage,
  SupportedRenderer: () => SupportedRenderer
});
var Addon_TypesEnum = /* @__PURE__ */ ((Addon_TypesEnum2) => (Addon_TypesEnum2.TAB = "tab", Addon_TypesEnum2.PANEL = "panel", Addon_TypesEnum2.TOOL = "tool", Addon_TypesEnum2.TOOLEXTRA = "toolextra", Addon_TypesEnum2.PREVIEW = "preview", Addon_TypesEnum2.experimental_PAGE = "page", Addon_TypesEnum2.experimental_TEST_PROVIDER = "test-provider", Addon_TypesEnum2))(Addon_TypesEnum || {});
var SupportedFramework = /* @__PURE__ */ ((SupportedFramework2) => (SupportedFramework2.ANGULAR = "angular", SupportedFramework2.EMBER = "ember", SupportedFramework2.HTML_VITE = "html-vite", SupportedFramework2.NEXTJS = "nextjs", SupportedFramework2.NEXTJS_VITE = "nextjs-vite", SupportedFramework2.PREACT_VITE = "preact-vite", SupportedFramework2.REACT_NATIVE_WEB_VITE = "react-native-web-vite", SupportedFramework2.REACT_VITE = "react-vite", SupportedFramework2.REACT_WEBPACK5 = "react-webpack5", SupportedFramework2.SERVER_WEBPACK5 = "server-webpack5", SupportedFramework2.SVELTE_VITE = "svelte-vite", SupportedFramework2.SVELTEKIT = "sveltekit", SupportedFramework2.VUE3_VITE = "vue3-vite", SupportedFramework2.WEB_COMPONENTS_VITE = "web-components-vite", SupportedFramework2.HTML_RSBUILD = "html-rsbuild", SupportedFramework2.NUXT = "nuxt", SupportedFramework2.QWIK = "qwik", SupportedFramework2.REACT_RSBUILD = "react-rsbuild", SupportedFramework2.SOLID = "solid", SupportedFramework2.VUE3_RSBUILD = "vue3-rsbuild", SupportedFramework2.WEB_COMPONENTS_RSBUILD = "web-components-rsbuild", SupportedFramework2))(SupportedFramework || {});
var SupportedRenderer = /* @__PURE__ */ ((SupportedRenderer2) => (SupportedRenderer2.REACT = "react", SupportedRenderer2.REACT_NATIVE = "react-native", SupportedRenderer2.VUE3 = "vue3", SupportedRenderer2.ANGULAR = "angular", SupportedRenderer2.EMBER = "ember", SupportedRenderer2.PREACT = "preact", SupportedRenderer2.SVELTE = "svelte", SupportedRenderer2.QWIK = "qwik", SupportedRenderer2.HTML = "html", SupportedRenderer2.WEB_COMPONENTS = "web-components", SupportedRenderer2.SERVER = "server", SupportedRenderer2.SOLID = "solid", SupportedRenderer2.NUXT = "nuxt", SupportedRenderer2))(SupportedRenderer || {});
var CoreWebpackCompiler = /* @__PURE__ */ ((CoreWebpackCompiler2) => (CoreWebpackCompiler2.Babel = "babel", CoreWebpackCompiler2.SWC = "swc", CoreWebpackCompiler2))(CoreWebpackCompiler || {});
var SupportedBuilder = /* @__PURE__ */ ((SupportedBuilder2) => (SupportedBuilder2.WEBPACK5 = "webpack5", SupportedBuilder2.VITE = "vite", SupportedBuilder2.RSBUILD = "rsbuild", SupportedBuilder2))(SupportedBuilder || {});
var Feature = /* @__PURE__ */ ((Feature2) => (Feature2.DOCS = "docs", Feature2.TEST = "test", Feature2.ONBOARDING = "onboarding", Feature2.A11Y = "a11y", Feature2))(Feature || {});
var SupportedLanguage = /* @__PURE__ */ ((SupportedLanguage2) => (SupportedLanguage2.JAVASCRIPT = "javascript", SupportedLanguage2.TYPESCRIPT = "typescript", SupportedLanguage2))(SupportedLanguage || {});
var actions_exports = {};
__export$4(actions_exports, {
  ADDON_ID: () => ADDON_ID$1,
  CLEAR_ID: () => CLEAR_ID,
  CYCLIC_KEY: () => CYCLIC_KEY,
  EVENT_ID: () => EVENT_ID,
  PANEL_ID: () => PANEL_ID,
  PARAM_KEY: () => PARAM_KEY$1,
  action: () => action,
  actions: () => actions,
  config: () => config3,
  configureActions: () => configureActions
});
var PARAM_KEY$1 = "actions", ADDON_ID$1 = "storybook/actions", PANEL_ID = `${ADDON_ID$1}/panel`, EVENT_ID = `${ADDON_ID$1}/action-event`, CLEAR_ID = `${ADDON_ID$1}/action-clear`, CYCLIC_KEY = "$___storybook.isCyclic";
var preview_api_exports = {};
__export$4(preview_api_exports, {
  DocsContext: () => DocsContext,
  HooksContext: () => HooksContext,
  Preview: () => Preview,
  PreviewWeb: () => PreviewWeb$1,
  PreviewWithSelection: () => PreviewWithSelection,
  ReporterAPI: () => ReporterAPI,
  StoryStore: () => StoryStore,
  UrlStore: () => UrlStore,
  WebView: () => WebView,
  addons: () => addons$2,
  applyHooks: () => applyHooks,
  combineArgs: () => combineArgs,
  combineParameters: () => combineParameters$1,
  composeConfigs: () => composeConfigs$1,
  composeStepRunners: () => composeStepRunners,
  composeStories: () => composeStories,
  composeStory: () => composeStory,
  createPlaywrightTest: () => createPlaywrightTest,
  decorateStory: () => decorateStory,
  defaultDecorateStory: () => defaultDecorateStory$1,
  emitTransformCode: () => emitTransformCode$1,
  filterArgTypes: () => filterArgTypes,
  getCsfFactoryAnnotations: () => getCsfFactoryAnnotations,
  inferControls: () => inferControls,
  makeDecorator: () => makeDecorator$1,
  mockChannel: () => mockChannel,
  normalizeArrays: () => normalizeArrays,
  normalizeProjectAnnotations: () => normalizeProjectAnnotations,
  normalizeStory: () => normalizeStory,
  pauseAnimations: () => pauseAnimations,
  prepareMeta: () => prepareMeta,
  prepareStory: () => prepareStory,
  sanitizeStoryContextUpdate: () => sanitizeStoryContextUpdate,
  setDefaultProjectAnnotations: () => setDefaultProjectAnnotations,
  setProjectAnnotations: () => setProjectAnnotations,
  simulateDOMContentLoaded: () => simulateDOMContentLoaded,
  simulatePageLoad: () => simulatePageLoad,
  sortStoriesV7: () => sortStoriesV7,
  useArgs: () => useArgs,
  useCallback: () => useCallback,
  useChannel: () => useChannel,
  useEffect: () => useEffect$1,
  useGlobals: () => useGlobals$1,
  useMemo: () => useMemo,
  useParameter: () => useParameter,
  useReducer: () => useReducer,
  useRef: () => useRef$1,
  useState: () => useState,
  useStoryContext: () => useStoryContext,
  userOrAutoTitle: () => userOrAutoTitle,
  userOrAutoTitleFromSpecifier: () => userOrAutoTitleFromSpecifier,
  waitForAnimations: () => waitForAnimations
});
function mockChannel() {
  let transport = {
    setHandler: () => {
    },
    send: () => {
    }
  };
  return new Channel({ transport });
}
var AddonStore = class {
  constructor() {
    this.getChannel = () => {
      if (!this.channel) {
        let channel2 = mockChannel();
        return this.setChannel(channel2), channel2;
      }
      return this.channel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.setChannel = (channel2) => {
      this.channel = channel2, this.resolve();
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
}, KEY2 = "__STORYBOOK_ADDONS_PREVIEW";
function getAddonsStore() {
  return scope[KEY2] || (scope[KEY2] = new AddonStore()), scope[KEY2];
}
var addons$2 = getAddonsStore();
var HooksContext = class {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = (storyId) => {
      storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      effect.destroy && effect.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let hook = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
    }), this.currentEffects.forEach((effect) => {
      this.prevEffects.includes(effect) || (effect.destroy = effect.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), addons$2.getChannel().on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    addons$2.getChannel().removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn3) {
  let hookified = (...args) => {
    let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn3.name, hooks.prevMountedDecorators.has(fn3) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn3) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn3, hooks.currentHooks), hooks.prevMountedDecorators.add(fn3)), hooks.nextHookIndex = 0;
    let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
    scope.STORYBOOK_HOOKS_CONTEXT = hooks;
    let result = fn3(...args);
    if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
  };
  return hookified.originalFn = fn3, hookified;
}
var numberOfRenders = 0, RENDER_LIMIT = 25, applyHooks = (applyDecorators3) => (storyFn, decorators4) => {
  let decorated = applyDecorators3(
    hookify(storyFn),
    decorators4.map((decorator) => hookify(decorator))
  );
  return (context) => {
    let { hooks } = context;
    hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]), hooks.currentContext = context, hooks.hasUpdates = false;
    let result = decorated(context);
    for (numberOfRenders = 1; hooks.hasUpdates; )
      if (hooks.hasUpdates = false, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return hooks.addRenderListeners(), result;
  };
}, areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i2) => dep === nextDeps[i2]), invalidHooksError = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
function getHooksContextOrNull() {
  return scope.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  let hooks = getHooksContextOrNull();
  if (hooks == null)
    throw invalidHooksError();
  return hooks;
}
function useHook(name, callback, deps) {
  let hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    deps != null && !Array.isArray(deps) && logger$1.warn(
      `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
    );
    let hook = { name, deps };
    return hooks.currentHooks.push(hook), callback(hook), hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    let hook = hooks.getNextHook();
    if (hook == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return hook.name !== name && logger$1.warn(
      `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), deps != null && hook.deps == null && logger$1.warn(
      `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger$1.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  let { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useCallback(callback, deps) {
  return useMemoLike("useCallback", () => callback, deps);
}
function useRefLike(name, initialValue2) {
  return useMemoLike(name, () => ({ current: initialValue2 }), []);
}
function useRef$1(initialValue2) {
  return useRefLike("useRef", initialValue2);
}
function triggerUpdate() {
  let hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE")
    hooks.hasUpdates = true;
  else
    try {
      addons$2.getChannel().emit(FORCE_RE_RENDER);
    } catch {
      logger$1.warn("State updates of Storybook preview hooks work only in browser");
    }
}
function useStateLike(name, initialState) {
  let stateRef = useRefLike(
    name,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof initialState == "function" ? initialState() : initialState
  ), setState2 = (update) => {
    stateRef.current = typeof update == "function" ? update(stateRef.current) : update, triggerUpdate();
  };
  return [stateRef.current, setState2];
}
function useState(initialState) {
  return useStateLike("useState", initialState);
}
function useReducer(reducer, initialArg, init2) {
  let initialState = init2 != null ? () => init2(initialArg) : initialArg, [state3, setState2] = useStateLike("useReducer", initialState);
  return [state3, (action2) => setState2((prevState) => reducer(prevState, action2))];
}
function useEffect$1(create, deps) {
  let hooks = getHooksContextOrThrow(), effect = useMemoLike("useEffect", () => ({ create }), deps);
  hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);
}
function useChannel(eventMap3, deps = []) {
  let channel2 = addons$2.getChannel();
  return useEffect$1(() => (Object.entries(eventMap3).forEach(([type5, listener]) => channel2.on(type5, listener)), () => {
    Object.entries(eventMap3).forEach(
      ([type5, listener]) => channel2.removeListener(type5, listener)
    );
  }), [...Object.keys(eventMap3), ...deps]), useCallback(channel2.emit.bind(channel2), [channel2]);
}
function useStoryContext() {
  let { currentContext } = getHooksContextOrThrow();
  if (currentContext == null)
    throw invalidHooksError();
  return currentContext;
}
function useParameter(parameterKey, defaultValue) {
  let { parameters: parameters2 } = useStoryContext();
  if (parameterKey)
    return parameters2[parameterKey] ?? defaultValue;
}
function useArgs() {
  let channel2 = addons$2.getChannel(), { id: storyId, args } = useStoryContext(), updateArgs = useCallback(
    (updatedArgs) => channel2.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
    [channel2, storyId]
  ), resetArgs = useCallback(
    (argNames) => channel2.emit(RESET_STORY_ARGS, { storyId, argNames }),
    [channel2, storyId]
  );
  return [args, updateArgs, resetArgs];
}
function useGlobals$1() {
  let channel2 = addons$2.getChannel(), { globals } = useStoryContext(), updateGlobals = useCallback(
    (newGlobals) => channel2.emit(UPDATE_GLOBALS, { globals: newGlobals }),
    [channel2]
  );
  return [globals, updateGlobals];
}
var makeDecorator$1 = ({
  name,
  parameterName,
  wrapper,
  skipIfNoParametersOrOptions = false
}) => {
  let decorator = (options) => (storyFn, context) => {
    let parameters2 = context.parameters && context.parameters[parameterName];
    return parameters2 && parameters2.disable || skipIfNoParametersOrOptions && !options && !parameters2 ? storyFn(context) : wrapper(storyFn, context, {
      options,
      parameters: parameters2
    });
  };
  return (...args) => typeof args[0] == "function" ? decorator()(...args) : (...innerArgs) => {
    if (innerArgs.length > 1)
      return args.length > 1 ? decorator(args)(...innerArgs) : decorator(...args)(...innerArgs);
    throw new Error(
      `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
    );
  };
};
function toStartCaseStr(str2) {
  return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $2, $3) => `${$1} ${$2}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $2) => `${$1} ${$2}`).replace(/([a-z])([0-9])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/([0-9])([a-z])/gi, (str22, $1, $2) => `${$1} ${$2}`).replace(/(\s|^)(\w)/g, (str22, $1, $2) => `${$1}${$2.toUpperCase()}`).replace(/ +/g, " ").trim();
}
var import_tiny_isequal = __toESM$3(require_tiny_isequal(), 1), count$1 = (vals) => vals.map((v2) => typeof v2 < "u").filter(Boolean).length, testValue = (cond, value) => {
  let { exists, eq: eq4, neq, truthy } = cond;
  if (count$1([exists, eq4, neq, truthy]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq4, neq })}`);
  if (typeof eq4 < "u")
    return (0, import_tiny_isequal.isEqual)(value, eq4);
  if (typeof neq < "u")
    return !(0, import_tiny_isequal.isEqual)(value, neq);
  if (typeof exists < "u") {
    let valueExists = typeof value < "u";
    return exists ? valueExists : !valueExists;
  }
  return (typeof truthy > "u" ? true : truthy) ? !!value : !value;
}, includeConditionalArg = (argType, args, globals) => {
  if (!argType.if)
    return true;
  let { arg, global: global22 } = argType.if;
  if (count$1([arg, global22]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global22 })}`);
  let value = arg ? args[arg] : globals[global22];
  return testValue(argType.if, value);
};
function mountDestructured(playFunction) {
  return playFunction != null && getUsedProps(playFunction).includes("mount");
}
function getUsedProps(fn3) {
  let match = fn3.toString().match(/[^(]*\(([^)]*)/);
  if (!match)
    return [];
  let args = splitByComma(match[1]);
  if (!args.length)
    return [];
  let first = args[0];
  return first.startsWith("{") && first.endsWith("}") ? splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => prop.replace(/:.*|=.*/g, "")) : [];
}
function splitByComma(s3) {
  let result = [], stack2 = [], start = 0;
  for (let i2 = 0; i2 < s3.length; i2++)
    if (s3[i2] === "{" || s3[i2] === "[")
      stack2.push(s3[i2] === "{" ? "}" : "]");
    else if (s3[i2] === stack2[stack2.length - 1])
      stack2.pop();
    else if (!stack2.length && s3[i2] === ",") {
      let token = s3.substring(start, i2).trim();
      token && result.push(token), start = i2 + 1;
    }
  let lastToken = s3.substring(start).trim();
  return lastToken && result.push(lastToken), result;
}
var addArgs_exports = {};
__export$4(addArgs_exports, {
  argsEnhancers: () => argsEnhancers
});
var isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs), inferActionsFromArgTypesRegex = (context) => {
  let {
    initialArgs,
    argTypes,
    id,
    parameters: { actions: actions2 }
  } = context;
  if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes)
    return {};
  let argTypesRegex = new RegExp(actions2.argTypesRegex);
  return Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: true, id })), acc), {});
}, addActionsFromArgTypes = (context) => {
  let {
    initialArgs,
    argTypes,
    parameters: { actions: actions2 }
  } = context;
  return actions2?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
};
var argsEnhancers = [
  addActionsFromArgTypes,
  inferActionsFromArgTypesRegex
];
var loaders_exports = {};
__export$4(loaders_exports, {
  loaders: () => loaders
});
var test_exports = {};
__export$4(test_exports, {
  buildQueries: () => buildQueries2,
  clearAllMocks: () => clearAllMocks,
  configure: () => configure2,
  createEvent: () => createEvent3,
  expect: () => expect3,
  findAllByAltText: () => findAllByAltText2,
  findAllByDisplayValue: () => findAllByDisplayValue2,
  findAllByLabelText: () => findAllByLabelText2,
  findAllByPlaceholderText: () => findAllByPlaceholderText2,
  findAllByRole: () => findAllByRole2,
  findAllByTestId: () => findAllByTestId2,
  findAllByText: () => findAllByText2,
  findAllByTitle: () => findAllByTitle2,
  findByAltText: () => findByAltText2,
  findByDisplayValue: () => findByDisplayValue2,
  findByLabelText: () => findByLabelText2,
  findByPlaceholderText: () => findByPlaceholderText2,
  findByRole: () => findByRole2,
  findByTestId: () => findByTestId2,
  findByText: () => findByText2,
  findByTitle: () => findByTitle2,
  fireEvent: () => fireEvent2,
  fn: () => fn2,
  getAllByAltText: () => getAllByAltText2,
  getAllByDisplayValue: () => getAllByDisplayValue2,
  getAllByLabelText: () => getAllByLabelText2,
  getAllByPlaceholderText: () => getAllByPlaceholderText2,
  getAllByRole: () => getAllByRole2,
  getAllByTestId: () => getAllByTestId2,
  getAllByText: () => getAllByText2,
  getAllByTitle: () => getAllByTitle2,
  getByAltText: () => getByAltText2,
  getByDisplayValue: () => getByDisplayValue2,
  getByLabelText: () => getByLabelText2,
  getByPlaceholderText: () => getByPlaceholderText2,
  getByRole: () => getByRole2,
  getByTestId: () => getByTestId2,
  getByText: () => getByText2,
  getByTitle: () => getByTitle2,
  getConfig: () => getConfig3,
  getDefaultNormalizer: () => getDefaultNormalizer2,
  getElementError: () => getElementError2,
  getNodeText: () => getNodeText2,
  getQueriesForElement: () => getQueriesForElement2,
  getRoles: () => getRoles2,
  getSuggestedQuery: () => getSuggestedQuery2,
  isInaccessible: () => isInaccessible2,
  isMockFunction: () => isMockFunction,
  logDOM: () => logDOM2,
  logRoles: () => logRoles2,
  mocked: () => mocked,
  mocks: () => mocks,
  onMockCall: () => onMockCall,
  prettyDOM: () => prettyDOM2,
  prettyFormat: () => prettyFormat2,
  queries: () => queries2,
  queryAllByAltText: () => queryAllByAltText2,
  queryAllByAttribute: () => queryAllByAttribute2,
  queryAllByDisplayValue: () => queryAllByDisplayValue2,
  queryAllByLabelText: () => queryAllByLabelText2,
  queryAllByPlaceholderText: () => queryAllByPlaceholderText2,
  queryAllByRole: () => queryAllByRole2,
  queryAllByTestId: () => queryAllByTestId2,
  queryAllByText: () => queryAllByText2,
  queryAllByTitle: () => queryAllByTitle2,
  queryByAltText: () => queryByAltText2,
  queryByAttribute: () => queryByAttribute2,
  queryByDisplayValue: () => queryByDisplayValue2,
  queryByLabelText: () => queryByLabelText2,
  queryByPlaceholderText: () => queryByPlaceholderText2,
  queryByRole: () => queryByRole2,
  queryByTestId: () => queryByTestId2,
  queryByText: () => queryByText2,
  queryByTitle: () => queryByTitle2,
  queryHelpers: () => queryHelpers2,
  resetAllMocks: () => resetAllMocks,
  restoreAllMocks: () => restoreAllMocks,
  sb: () => sb,
  screen: () => screen2,
  spyOn: () => spyOn2,
  uninstrumentedUserEvent: () => uninstrumentedUserEvent,
  userEvent: () => userEvent2,
  waitFor: () => waitFor2,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved2,
  within: () => within
});
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, h = Object.entries(f);
function a(n2) {
  return String(n2);
}
a.open = "";
a.close = "";
h.reduce(
  (n2, [e2]) => (n2[e2] = a, n2),
  { isColorSupported: false }
);
function C(n2 = false) {
  let e2 = typeof process < "u" ? process : void 0, i2 = e2?.env || {}, g2 = e2?.argv || [];
  return !("NO_COLOR" in i2 || g2.includes("--no-color")) && ("FORCE_COLOR" in i2 || g2.includes("--color") || e2?.platform === "win32" || n2 && i2.TERM !== "dumb" || "CI" in i2) || typeof window < "u" && !!window.chrome;
}
function p(n2 = false) {
  let e2 = C(n2), i2 = (r2, t22, c2, o2) => {
    let l2 = "", s3 = 0;
    do
      l2 += r2.substring(s3, o2) + c2, s3 = o2 + t22.length, o2 = r2.indexOf(t22, s3);
    while (~o2);
    return l2 + r2.substring(s3);
  }, g2 = (r2, t22, c2 = r2) => {
    let o2 = (l2) => {
      let s3 = String(l2), b2 = s3.indexOf(t22, r2.length);
      return ~b2 ? r2 + i2(s3, t22, c2, b2) + t22 : r2 + s3 + t22;
    };
    return o2.open = r2, o2.close = t22, o2;
  }, u3 = {
    isColorSupported: e2
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t22] of h)
    u3[r2] = e2 ? g2(
      d(t22[0]),
      d(t22[1]),
      t22[2]
    ) : a;
  return u3;
}
var s = p();
function _mergeNamespaces$1(n2, m3) {
  return m3.forEach(function(e2) {
    e2 && typeof e2 != "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d.get ? d : {
          enumerable: true,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  }), Object.freeze(n2);
}
function getKeysOfEnumerableProperties(object, compareKeys) {
  let rawKeys = Object.keys(object), keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols)
    for (let symbol of Object.getOwnPropertySymbols(object))
      Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
  return keys2;
}
function printIteratorEntries(iterator, config4, indentation, depth, refs, printer2, separator = ": ") {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config4.maxWidth) {
        result += "";
        break;
      }
      let name = printer2(current.value[0], config4, indentationNext, depth, refs), value = printer2(current.value[1], config4, indentationNext, depth, refs);
      result += name + separator + value, current = iterator.next(), current.done ? config4.min || (result += ",") : result += `,${config4.spacingInner}`;
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(iterator, config4, indentation, depth, refs, printer2) {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config4.maxWidth) {
        result += "";
        break;
      }
      result += printer2(current.value, config4, indentationNext, depth, refs), current = iterator.next(), current.done ? config4.min || (result += ",") : result += `,${config4.spacingInner}`;
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config4, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  let isDataView = (l2) => l2 instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < length; i2++) {
      if (result += indentationNext, i2 === config4.maxWidth) {
        result += "";
        break;
      }
      (isDataView(list) || i2 in list) && (result += printer2(isDataView(list) ? list.getInt8(i2) : list[i2], config4, indentationNext, depth, refs)), i2 < length - 1 ? result += `,${config4.spacingInner}` : config4.min || (result += ",");
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config4, indentation, depth, refs, printer2) {
  let result = "", keys2 = getKeysOfEnumerableProperties(val, config4.compareKeys);
  if (keys2.length > 0) {
    result += config4.spacingOuter;
    let indentationNext = indentation + config4.indent;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      let key = keys2[i2], name = printer2(key, config4, indentationNext, depth, refs), value = printer2(val[key], config4, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`, i2 < keys2.length - 1 ? result += `,${config4.spacingInner}` : config4.min || (result += ",");
    }
    result += config4.spacingOuter + indentation;
  }
  return result;
}
var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = (val, config4, indentation, depth, refs, printer2) => {
  let stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
    return ++depth > config4.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config4, indentation, depth, refs, printer2)}]`;
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
    return ++depth > config4.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config4, indentation, depth, refs, printer2)}}`;
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
    return stringedValue + SPACE$2 + printer2(val.sample, config4, indentation, depth, refs);
  if (typeof val.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  return val.toAsymmetricMatcher();
}, test$5 = (val) => val && val.$$typeof === asymmetricMatcher, plugin$5 = {
  serialize: serialize$5,
  test: test$5
}, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = (collection, config4, indentation, depth, refs, printer2) => {
  let name = collection.constructor.name;
  return ++depth > config4.maxDepth ? `[${name}]` : (config4.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config4, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config4, indentation, depth, refs, printer2)}]`);
}, plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str2) {
  return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys2, props, config4, indentation, depth, refs, printer2) {
  let indentationNext = indentation + config4.indent, colors3 = config4.colors;
  return keys2.map((key) => {
    let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
    return typeof value != "string" && (printed.includes(`
`) && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = `{${printed}}`), `${config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
  }).join("");
}
function printChildren(children, config4, indentation, depth, refs, printer2) {
  return children.map((child) => config4.spacingOuter + indentation + (typeof child == "string" ? printText(child, config4) : printer2(child, config4, indentation, depth, refs))).join("");
}
function printText(text, config4) {
  let contentColor = config4.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config4) {
  let commentColor = config4.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type5, printedProps, printedChildren, config4, indentation) {
  let tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config4.spacingOuter}${indentation}${tagColor.open}</${type5}` : `${printedProps && !config4.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type5, config4) {
  let tagColor = config4.colors.tag;
  return `${tagColor.open}<${type5}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute == "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
function testNode(val) {
  let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = (val) => {
  var _val$constructor;
  return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = (node, config4, indentation, depth, refs, printer2) => {
  if (nodeIsText(node))
    return printText(node.data, config4);
  if (nodeIsComment(node))
    return printComment(node.data, config4);
  let type5 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  return ++depth > config4.maxDepth ? printElementAsLeaf(type5, config4) : printElement(type5, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr2) => attr2.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
}, plugin$3 = {
  serialize: serialize$3,
  test: test$3
}, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = (name) => `Immutable.${name}`, printAsLeaf = (name) => `[${name}]`, SPACE = " ", LAZY = "";
function printImmutableEntries(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}{${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2)}}`;
}
function getRecordEntries(val) {
  let i2 = 0;
  return { next() {
    if (i2 < val._keys.length) {
      let key = val._keys[i2++];
      return {
        done: false,
        value: [key, val.get(key)]
      };
    }
    return {
      done: true,
      value: void 0
    };
  } };
}
function printImmutableRecord(val, config4, indentation, depth, refs, printer2) {
  let name = getImmutableName(val._name || "Record");
  return ++depth > config4.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config4, indentation, depth, refs, printer2)}}`;
}
function printImmutableSeq(val, config4, indentation, depth, refs, printer2) {
  let name = getImmutableName("Seq");
  return ++depth > config4.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config4, indentation, depth, refs, printer2) : LAZY}]`;
}
function printImmutableValues(val, config4, indentation, depth, refs, printer2, type5) {
  return ++depth > config4.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}[${printIteratorValues(val.values(), config4, indentation, depth, refs, printer2)}]`;
}
var serialize$2 = (val, config4, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config4, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config4, indentation, depth, refs, printer2) : printImmutableRecord(val, config4, indentation, depth, refs, printer2), test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true), plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var reactIs$1 = { exports: {} }, reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if (typeof object == "object" && object !== null) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  return reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_production.ContextProvider = REACT_CONTEXT_TYPE, reactIs_production.Element = REACT_ELEMENT_TYPE, reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_production.Fragment = REACT_FRAGMENT_TYPE, reactIs_production.Lazy = REACT_LAZY_TYPE, reactIs_production.Memo = REACT_MEMO_TYPE, reactIs_production.Portal = REACT_PORTAL_TYPE, reactIs_production.Profiler = REACT_PROFILER_TYPE, reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_production.Suspense = REACT_SUSPENSE_TYPE, reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  }, reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  }, reactIs_production.isElement = function(object) {
    return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }, reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  }, reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  }, reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  }, reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  }, reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  }, reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  }, reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  }, reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  }, reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  }, reactIs_production.isValidElementType = function(type5) {
    return typeof type5 == "string" || typeof type5 == "function" || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || typeof type5 == "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_CONSUMER_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_CLIENT_REFERENCE || type5.getModuleId !== void 0);
  }, reactIs_production.typeOf = typeOf, reactIs_production;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, reactIs$1.exports = requireReactIs_production()), reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1(), index$1$1 = getDefaultExportFromCjs$1(reactIsExports$1), ReactIs19 = _mergeNamespaces$1({
  __proto__: null,
  default: index$1$1
}, [reactIsExports$1]), reactIs = { exports: {} }, reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f4 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h3 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m3 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t22 = Symbol.for("react.offscreen"), u3;
  u3 = Symbol.for("react.module.reference");
  function v2(a2) {
    if (typeof a2 == "object" && a2 !== null) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d:
            case f4:
            case e2:
            case m3:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h3:
                case l2:
                case q:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  return reactIs_production_min.ContextConsumer = h3, reactIs_production_min.ContextProvider = g2, reactIs_production_min.Element = b2, reactIs_production_min.ForwardRef = l2, reactIs_production_min.Fragment = d, reactIs_production_min.Lazy = q, reactIs_production_min.Memo = p2, reactIs_production_min.Portal = c2, reactIs_production_min.Profiler = f4, reactIs_production_min.StrictMode = e2, reactIs_production_min.Suspense = m3, reactIs_production_min.SuspenseList = n2, reactIs_production_min.isAsyncMode = function() {
    return false;
  }, reactIs_production_min.isConcurrentMode = function() {
    return false;
  }, reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h3;
  }, reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  }, reactIs_production_min.isElement = function(a2) {
    return typeof a2 == "object" && a2 !== null && a2.$$typeof === b2;
  }, reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  }, reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d;
  }, reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q;
  }, reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  }, reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  }, reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f4;
  }, reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e2;
  }, reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m3;
  }, reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  }, reactIs_production_min.isValidElementType = function(a2) {
    return typeof a2 == "string" || typeof a2 == "function" || a2 === d || a2 === f4 || a2 === e2 || a2 === m3 || a2 === n2 || a2 === t22 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === l2 || a2.$$typeof === u3 || a2.getModuleId !== void 0);
  }, reactIs_production_min.typeOf = v2, reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_production_min()), reactIs.exports;
}
var reactIsExports = requireReactIs(), index$2 = getDefaultExportFromCjs$1(reactIsExports), ReactIs18 = _mergeNamespaces$1({
  __proto__: null,
  default: index$2
}, [reactIsExports]), reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], ReactIs = Object.fromEntries(reactIsMethods.map((m3) => [m3, (v2) => ReactIs18[m3](v2) || ReactIs19[m3](v2)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg))
    for (let item of arg)
      getChildren(item, children);
  else arg != null && arg !== false && arg !== "" && children.push(arg);
  return children;
}
function getType(element) {
  let type5 = element.type;
  if (typeof type5 == "string")
    return type5;
  if (typeof type5 == "function")
    return type5.displayName || type5.name || "Unknown";
  if (ReactIs.isFragment(element))
    return "React.Fragment";
  if (ReactIs.isSuspense(element))
    return "React.Suspense";
  if (typeof type5 == "object" && type5 !== null) {
    if (ReactIs.isContextProvider(element))
      return "Context.Provider";
    if (ReactIs.isContextConsumer(element))
      return "Context.Consumer";
    if (ReactIs.isForwardRef(element)) {
      if (type5.displayName)
        return type5.displayName;
      let functionName = type5.render.displayName || type5.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (ReactIs.isMemo(element)) {
      let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  let { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
var serialize$1 = (element, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(getType(element), config4) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config4, indentation + config4.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation), test$1 = (val) => val != null && ReactIs.isElement(val), plugin$1 = {
  serialize: serialize$1,
  test: test$1
}, testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  let { props } = object;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
var serialize = (object, config4, indentation, depth, refs, printer2) => ++depth > config4.maxDepth ? printElementAsLeaf(object.type, config4) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config4, indentation + config4.indent, depth, refs, printer2) : "", object.children ? printChildren(object.children, config4, indentation + config4.indent, depth, refs, printer2) : "", config4, indentation), test = (val) => val && val.$$typeof === testSymbol, plugin = {
  serialize,
  test
}, toString2 = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor == "function" && val.constructor.name || "Object";
}
function isWindow(val) {
  return typeof window < "u" && val === window;
}
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, PrettyFormatPluginError = class extends Error {
  constructor(message, stack2) {
    super(message), this.stack = stack2, this.name = this.constructor.name;
  }
};
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return `${val}n`;
}
function printFunction(val, printFunctionName) {
  return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false)
    return `${val}`;
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  let typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "bigint")
    return printBigInt(val);
  if (typeOf === "string")
    return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
  if (typeOf === "function")
    return printFunction(val, printFunctionName);
  if (typeOf === "symbol")
    return printSymbol(val);
  let toStringed = toString2.call(val);
  return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
}
function printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val))
    return "[Circular]";
  refs = [...refs], refs.push(val);
  let hitMaxDepth = ++depth > config4.maxDepth, min2 = config4.min;
  if (config4.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
    return printer(val.toJSON(), config4, indentation, depth, refs, true);
  let toStringed = toString2.call(val);
  return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min2 ? "" : "Arguments "}[${printListItems(val, config4, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min2 || !config4.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config4, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config4, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config4, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min2 || !config4.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config4, indentation, depth, refs, printer)}}`;
}
var ErrorPlugin = {
  test: (val) => val && val instanceof Error,
  serialize(val, config4, indentation, depth, refs, printer2) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs, val];
    let hitMaxDepth = ++depth > config4.maxDepth, { message, cause, ...rest } = val, entries = {
      message,
      ...typeof cause < "u" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    }, name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config4, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin2) {
  return plugin2.serialize != null;
}
function printPlugin(plugin2, val, config4, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config4, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config4, indentation, depth, refs), (str2) => {
      let indentationNext = indentation + config4.indent;
      return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config4.spacingOuter,
      min: config4.min,
      spacing: config4.spacingInner
    }, config4.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  return printed;
}
function findPlugin(plugins3, val) {
  for (let plugin2 of plugins3)
    try {
      if (plugin2.test(val))
        return plugin2;
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  return null;
}
function printer(val, config4, indentation, depth, refs, hasCalledToJSON) {
  let plugin2 = findPlugin(config4.plugins, val);
  if (plugin2 !== null)
    return printPlugin(plugin2, val, config4, indentation, depth, refs);
  let basicResult = printBasicValue(val, config4.printFunctionName, config4.escapeRegex, config4.escapeString);
  return basicResult !== null ? basicResult : printComplexValue(val, config4, indentation, depth, refs, hasCalledToJSON);
}
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS$1 = {
  callToJSON: true,
  compareKeys: void 0,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (let key of Object.keys(options))
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS$1, key))
      throw new Error(`pretty-format: Unknown option "${key}".`);
  if (options.min && options.indent !== void 0 && options.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
    let value = DEFAULT_THEME[key], color = value && s[value];
    if (color && typeof color.close == "string" && typeof color.open == "string")
      colors3[key] = color;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    return colors3;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors3, key) => (colors3[key] = {
    close: "",
    open: ""
  }, colors3), /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName(options) {
  return options?.printFunctionName ?? DEFAULT_OPTIONS$1.printFunctionName;
}
function getEscapeRegex(options) {
  return options?.escapeRegex ?? DEFAULT_OPTIONS$1.escapeRegex;
}
function getEscapeString(options) {
  return options?.escapeString ?? DEFAULT_OPTIONS$1.escapeString;
}
function getConfig(options) {
  return {
    callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS$1.callToJSON,
    colors: options?.highlight ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof options?.compareKeys == "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS$1.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS$1.indent),
    maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS$1.maxDepth,
    maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS$1.maxWidth,
    min: options?.min ?? DEFAULT_OPTIONS$1.min,
    plugins: options?.plugins ?? DEFAULT_OPTIONS$1.plugins,
    printBasicPrototype: options?.printBasicPrototype ?? true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: options?.min ? " " : `
`,
    spacingOuter: options?.min ? "" : `
`
  };
}
function createIndent(indent2) {
  return Array.from({ length: indent2 + 1 }).join(" ");
}
function format(val, options) {
  if (options && (validateOptions(options), options.plugins)) {
    let plugin2 = findPlugin(options.plugins, val);
    if (plugin2 !== null)
      return printPlugin(plugin2, val, getConfig(options), "", 0, []);
  }
  let basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  return basicResult !== null ? basicResult : printComplexValue(val, getConfig(options), "", 0, []);
}
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator = "";
function colorise(value, styleType) {
  let color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors: colors3 = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate3 = 1 / 0,
  stylize = String
} = {}, inspect5) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors3,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate3),
    seen,
    inspect: inspect5,
    stylize
  };
  return options.colors && (options.stylize = colorise), options;
}
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate(string, length, tail = truncator) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size2 = list.length;
  if (size2 === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i2 = 0; i2 < size2; i2 += 1) {
    let last = i2 + 1 === list.length, secondToLast = i2 + 2 === list.length;
    truncated = `${truncator}(${list.length - i2})`;
    let value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}
function inspectArray(array, options) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
var getArrayName = (array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name;
function inspectTypedArray(array, options) {
  let name = getArrayName(array);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    let string = `${options.stylize(truncate(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    if (options.truncate -= string.length, array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
function inspectDate(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
function inspectFunction(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}
function inspectMapEntry([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
function mapToEntries(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
function inspectMap(map2, options) {
  return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`);
}
var isNaN2 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber(number, options) {
  return isNaN2(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate(String(number), options.truncate), "number");
}
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  return nums !== truncator && (nums += "n"), options.stylize(nums, "bigint");
}
function inspectRegExp(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
function arrayFromSet(set2) {
  let values = [];
  return set2.forEach((value) => {
    values.push(value);
  }), values;
}
function inspectSet(set2, options) {
  return set2.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set2), options)} }`);
}
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex = 16;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-4)}`;
}
function inspectString(string, options) {
  return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
}
function inspectSymbol(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}
var getPromiseValue = () => "Promise{}", promise_default = getPromiseValue;
function inspectObject(object, options) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object))
    return "[Circular]";
  options.seen.push(object);
  let propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
  let name = "";
  return toStringTag && toStringTag in value && (name = value[toStringTag]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject(value, options)}`;
}
function inspectArguments(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList(args, options)} ]`);
}
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
function inspectAttribute([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, `
`);
}
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
function inspectHTML(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ")), options.truncate -= propertyContents.length;
  let truncate3 = options.truncate, children = inspectNodeCollection(element.children, options);
  return children && children.length > truncate3 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = Symbol.for("nodejs.util.inspect.custom"), constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
  undefined: (value, options) => options.stylize("undefined", "undefined"),
  null: (value, options) => options.stylize("null", "null"),
  boolean: (value, options) => options.stylize(String(value), "boolean"),
  Boolean: (value, options) => options.stylize(String(value), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value, options) => options.stylize("WeakSet{}", "special"),
  WeakMap: (value, options) => options.stylize("WeakMap{}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject2,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
}, inspectCustom = (value, options, type5, inspectFn) => chaiInspect in value && typeof value[chaiInspect] == "function" ? value[chaiInspect](options) : nodeInspect in value && typeof value[nodeInspect] == "function" ? value[nodeInspect](options.depth, options, inspectFn) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap.has(value.constructor) ? constructorMap.get(value.constructor)(value, options) : stringTagMap[type5] ? stringTagMap[type5](value, options) : "", toString3 = Object.prototype.toString;
function inspect(value, opts = {}) {
  let options = normaliseOptions(opts, inspect), { customInspect } = options, type5 = value === null ? "null" : typeof value;
  if (type5 === "object" && (type5 = toString3.call(value).slice(8, -1)), type5 in baseTypesMap)
    return baseTypesMap[type5](value, options);
  if (customInspect && value) {
    let output = inspectCustom(value, options, type5, inspect);
    if (output)
      return typeof output == "string" ? output : inspect(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : false;
  return proto === Object.prototype || proto === null ? inspectObject(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass(value, options) : inspectObject(value, options) : value === Object(value) ? inspectObject(value, options) : options.stylize(String(value), type5);
}
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify2(object, maxDepth = 10, { maxLength, ...options } = {}) {
  let MAX_LENGTH = maxLength ?? 1e4, result;
  try {
    result = format(object, {
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object, {
      callToJSON: false,
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args) {
  if (typeof args[0] != "string") {
    let objects = [];
    for (let i3 = 0; i3 < args.length; i3++)
      objects.push(inspect2(args[i3], {
        depth: 0,
        colors: false
      }));
    return objects.join(" ");
  }
  let len = args.length, i2 = 1, template = args[0], str2 = String(template).replace(formatRegExp, (x2) => {
    if (x2 === "%%")
      return "%";
    if (i2 >= len)
      return x2;
    switch (x2) {
      case "%s": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : typeof value == "number" && value === 0 && 1 / value < 0 ? "-0" : typeof value == "object" && value !== null ? typeof value.toString == "function" && value.toString !== Object.prototype.toString ? value.toString() : inspect2(value, {
          depth: 0,
          colors: false
        }) : String(value);
      }
      case "%d": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number(value).toString();
      }
      case "%i": {
        let value = args[i2++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number.parseInt(String(value)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args[i2++])).toString();
      case "%o":
        return inspect2(args[i2++], {
          showHidden: true,
          showProxy: true
        });
      case "%O":
        return inspect2(args[i2++]);
      case "%c":
        return i2++, "";
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (err) {
          let m3 = err.message;
          if (m3.includes("circular structure") || m3.includes("cyclic structures") || m3.includes("cyclic object"))
            return "[Circular]";
          throw err;
        }
      default:
        return x2;
    }
  });
  for (let x2 = args[i2]; i2 < len; x2 = args[++i2])
    x2 === null || typeof x2 != "object" ? str2 += ` ${x2}` : str2 += ` ${inspect2(x2)}`;
  return str2;
}
function inspect2(obj, options = {}) {
  return options.truncate === 0 && (options.truncate = Number.POSITIVE_INFINITY), inspect(obj, options);
}
function getDefaultExportFromCjs2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
function assertTypes(value, name, types) {
  let receivedType = typeof value;
  if (!types.includes(receivedType))
    throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function isObject4(item) {
  return item != null && typeof item == "object" && !Array.isArray(item);
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  let ownProps = /* @__PURE__ */ new Set();
  return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
}
var defaultCloneOptions = { forceWritable: false };
function deepClone(val, options = defaultCloneOptions) {
  return clone$1(val, /* @__PURE__ */ new WeakMap(), options);
}
function clone$1(val, seen, options = defaultCloneOptions) {
  let k2, out;
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    for (out = Array.from({ length: k2 = val.length }), seen.set(val, out); k2--; )
      out[k2] = clone$1(val[k2], seen, options);
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
    let props = getOwnProperties(val);
    for (let k3 of props) {
      let descriptor = Object.getOwnPropertyDescriptor(val, k3);
      if (!descriptor)
        continue;
      let cloned = clone$1(val[k3], seen, options);
      options.forceWritable ? Object.defineProperty(out, k3, {
        enumerable: descriptor.enumerable,
        configurable: true,
        writable: true,
        value: cloned
      }) : "get" in descriptor ? Object.defineProperty(out, k3, {
        ...descriptor,
        get() {
          return cloned;
        }
      }) : Object.defineProperty(out, k3, {
        ...descriptor,
        value: cloned
      });
    }
    return out;
  }
  return val;
}
function noop$2() {
}
var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, Diff = class {
  0;
  1;
  constructor(op, text) {
    this[0] = op, this[1] = text;
  }
};
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
  for (; pointermin < pointermid; )
    text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
  for (; pointermin < pointermid; )
    text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonOverlap_(text1, text2) {
  let text1_length = text1.length, text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
  let text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0, length = 1;
  for (; ; ) {
    let pattern = text1.substring(text_length - length), found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length += found, (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
  }
}
function diff_cleanupSemantic(diffs) {
  let changes = false, equalities = [], equalitiesLength = 0, lastEquality = null, pointer4 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
  for (; pointer4 < diffs.length; )
    diffs[pointer4][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer4, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer4][1]) : (diffs[pointer4][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer4][1].length : length_deletions2 += diffs[pointer4][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer4 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = true)), pointer4++;
  for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer4 = 1; pointer4 < diffs.length; ) {
    if (diffs[pointer4 - 1][0] === DIFF_DELETE && diffs[pointer4][0] === DIFF_INSERT) {
      let deletion = diffs[pointer4 - 1][1], insertion = diffs[pointer4][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
      overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer4 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer4 + 1][1] = insertion.substring(overlap_length1), pointer4++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer4, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer4 - 1][0] = DIFF_INSERT, diffs[pointer4 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer4 + 1][0] = DIFF_DELETE, diffs[pointer4 + 1][1] = deletion.substring(overlap_length2), pointer4++), pointer4++;
    }
    pointer4++;
  }
}
var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer4 = 1;
  for (; pointer4 < diffs.length - 1; ) {
    if (diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer4 - 1][1], edit = diffs[pointer4][1], equality2 = diffs[pointer4 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        let commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer4 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer4 - 1][1] = bestEquality1 : (diffs.splice(pointer4 - 1, 1), pointer4--), diffs[pointer4][1] = bestEdit, bestEquality2 ? diffs[pointer4 + 1][1] = bestEquality2 : (diffs.splice(pointer4 + 1, 1), pointer4--));
    }
    pointer4++;
  }
}
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer4 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
  for (; pointer4 < diffs.length; )
    switch (diffs[pointer4][0]) {
      case DIFF_INSERT:
        count_insert++, text_insert += diffs[pointer4][1], pointer4++;
        break;
      case DIFF_DELETE:
        count_delete++, text_delete += diffs[pointer4][1], pointer4++;
        break;
      case DIFF_EQUAL:
        count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer4 - count_delete - count_insert > 0 && diffs[pointer4 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer4 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer4++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer4][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer4][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer4 -= count_delete + count_insert, diffs.splice(pointer4, count_delete + count_insert), text_delete.length && (diffs.splice(pointer4, 0, new Diff(DIFF_DELETE, text_delete)), pointer4++), text_insert.length && (diffs.splice(pointer4, 0, new Diff(DIFF_INSERT, text_insert)), pointer4++), pointer4++) : pointer4 !== 0 && diffs[pointer4 - 1][0] === DIFF_EQUAL ? (diffs[pointer4 - 1][1] += diffs[pointer4][1], diffs.splice(pointer4, 1)) : pointer4++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
        break;
    }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let changes = false;
  for (pointer4 = 1; pointer4 < diffs.length - 1; )
    diffs[pointer4 - 1][0] === DIFF_EQUAL && diffs[pointer4 + 1][0] === DIFF_EQUAL && (diffs[pointer4][1].substring(diffs[pointer4][1].length - diffs[pointer4 - 1][1].length) === diffs[pointer4 - 1][1] ? (diffs[pointer4][1] = diffs[pointer4 - 1][1] + diffs[pointer4][1].substring(0, diffs[pointer4][1].length - diffs[pointer4 - 1][1].length), diffs[pointer4 + 1][1] = diffs[pointer4 - 1][1] + diffs[pointer4 + 1][1], diffs.splice(pointer4 - 1, 1), changes = true) : diffs[pointer4][1].substring(0, diffs[pointer4 + 1][1].length) === diffs[pointer4 + 1][1] && (diffs[pointer4 - 1][1] += diffs[pointer4 + 1][1], diffs[pointer4][1] = diffs[pointer4][1].substring(diffs[pointer4 + 1][1].length) + diffs[pointer4 + 1][1], diffs.splice(pointer4 + 1, 1), changes = true)), pointer4++;
  changes && diff_cleanupMerge(diffs);
}
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two)
    return 6;
  let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
}
var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
    value: true
  }), build.default = diffSequence;
  let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
      aIndex += 1, bIndex += 1, nCommon += 1;
    return nCommon;
  }, countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
      aIndex -= 1, bIndex -= 1, nCommon += 1;
    return nCommon;
  }, extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0, kF = -d, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    let nF = d < iMaxF ? d : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d && aIndexPrev1 < aIndexesF[iF])
        aFirst = aIndexesF[iF];
      else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
        return iF - 1;
      aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0, kR = d, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    let nR = d < iMaxR ? d : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d && aIndexesR[iR] < aIndexPrev1)
        aFirst = aIndexesR[iR];
      else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
        return iR - 1;
      aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  }, extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d - 1), kMaxOverlapF = -baDeltaLength + (d - 1), aIndexPrev1 = NOT_YET_SET, nF = d < iMaxF ? d : iMaxF;
    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      let insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      ), aLast = aFirst + nCommonF;
      if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        let iR = (d - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1, d - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
          let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
          return division.nChangeFollowing = d - 1, d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), true;
        }
      }
    }
    return false;
  }, extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d, kMaxOverlapR = baDeltaLength + d, aIndexPrev1 = NOT_YET_SET, nR = d < iMaxR ? d : iMaxR;
    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      let insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      ), aLast = aFirst - nCommonR;
      if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        let iF = (d + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          let bLast = bFirst - nCommonR;
          if (division.nChangePreceding = d, d === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d - 1, d === 1)
            division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
          else {
            let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
            let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
            d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
          }
          return true;
        }
      }
    }
    return false;
  }, divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
    if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
      let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
      for (let d = 1; d <= dMax; d += 1)
        if (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d < dMin)
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    } else {
      let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d = 1;
      for (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d += 1; d <= dMax; d += 1)
        if (iMaxR = extendPathsR(
          d - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        ), d < dMin)
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  }, findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      if (transposed = !transposed, transposed && callbacks.length === 1) {
        let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: (nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          },
          isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
        };
      }
      let tStart = aStart, tEnd = aEnd;
      aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
    }
    let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    let {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
      nChangePreceding,
      aStart,
      aEndPreceding,
      bStart,
      bEndPreceding,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
      nChangeFollowing,
      aStartFollowing,
      aEnd,
      bStartFollowing,
      bEnd,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    );
  }, validateLength = (name, arg) => {
    if (typeof arg != "number")
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    if (!Number.isSafeInteger(arg))
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    if (arg < 0)
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
  }, validateCallback = (name, arg) => {
    let type5 = typeof arg;
    if (type5 !== "function")
      throw new TypeError(`${pkg}: ${name} typeof ${type5} is not a function`);
  };
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
    let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
      let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
      aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
        0,
        aStart,
        aEnd,
        bStart,
        bEnd,
        false,
        [
          {
            foundSubsequence,
            isCommon
          }
        ],
        [NOT_YET_SET],
        [NOT_YET_SET],
        {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        }
      ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
    }
  }
  return build;
}
var buildExports = requireBuild(), diffSequences = getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
  let iLength = diffs.length, nContextLines = options.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = false, nExcessesBetweenChanges = 0, i2 = 0;
  for (; i2 !== iLength; ) {
    let iStart = i2;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_EQUAL; )
      i2 += 1;
    if (iStart !== i2)
      if (iStart === 0)
        i2 > nContextLines && (jLength -= i2 - nContextLines, hasExcessAtStartOrEnd = true);
      else if (i2 === iLength) {
        let n2 = i2 - iStart;
        n2 > nContextLines && (jLength -= n2 - nContextLines, hasExcessAtStartOrEnd = true);
      } else {
        let n2 = i2 - iStart;
        n2 > nContextLines2 && (jLength -= n2 - nContextLines2, nExcessesBetweenChanges += 1);
      }
    for (; i2 !== iLength && diffs[i2][0] !== DIFF_EQUAL; )
      i2 += 1;
  }
  let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
  let jLast = jLength - 1, lines = [], jPatchMark = 0;
  hasPatch && lines.push("");
  let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
    let j2 = lines.length;
    lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1, bEnd += 1;
  }, pushDeleteLine = (line) => {
    let j2 = lines.length;
    lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1;
  }, pushInsertLine = (line) => {
    let j2 = lines.length;
    lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options)), bEnd += 1;
  };
  for (i2 = 0; i2 !== iLength; ) {
    let iStart = i2;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_EQUAL; )
      i2 += 1;
    if (iStart !== i2)
      if (iStart === 0) {
        i2 > nContextLines && (iStart = i2 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
        for (let iCommon = iStart; iCommon !== i2; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else if (i2 === iLength) {
        let iEnd = i2 - iStart > nContextLines ? iStart + nContextLines : i2;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else {
        let nCommon = i2 - iStart;
        if (nCommon > nContextLines2) {
          let iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options), jPatchMark = lines.length, lines.push("");
          let nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
          for (let iCommon = i2 - nContextLines; iCommon !== i2; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else
          for (let iCommon = iStart; iCommon !== i2; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
      }
    for (; i2 !== iLength && diffs[i2][0] === DIFF_DELETE; )
      pushDeleteLine(diffs[i2][1]), i2 += 1;
    for (; i2 !== iLength && diffs[i2][0] === DIFF_INSERT; )
      pushInsertLine(diffs[i2][1]), i2 += 1;
  }
  return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options)), lines.join(`
`);
}
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i2, diffs2) => {
    let line = diff2[1], isFirstOrLast = i2 === 0 || i2 === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join(`
`);
}
var noColor = (string) => string, DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: s.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: s.red,
    bIndicator: "+",
    changeColor: s.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: s.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: s.yellow,
    printBasicPrototype: false,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  let a2 = 0, b2 = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a2 += 1;
        break;
      case DIFF_INSERT:
        b2 += 1;
        break;
    }
  }), {
    a: a2,
    b: b2
  };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines)
    return "";
  let aRest = "", bRest = "";
  if (includeChangeCounts) {
    let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  let a2 = `${aIndicator} ${aAnnotation}${aRest}`, b2 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a2)}
${bColor(b2)}

`;
}
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
  let normalizedOptions = normalizeDiffOptions(options), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options), aIndex = 0, bIndex = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
    }
  }), printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
  let truncate3 = options?.truncateThreshold ?? false, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = truncate3 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate3 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
  for (diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bCommon; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
  }); aIndex !== aLength; aIndex += 1)
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  for (; bIndex !== bLength; bIndex += 1)
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  return [diffs, truncated];
}
function getType3(value) {
  if (value === void 0)
    return "undefined";
  if (value === null)
    return "null";
  if (Array.isArray(value))
    return "array";
  if (typeof value == "boolean")
    return "boolean";
  if (typeof value == "function")
    return "function";
  if (typeof value == "number")
    return "number";
  if (typeof value == "string")
    return "string";
  if (typeof value == "bigint")
    return "bigint";
  if (typeof value == "object") {
    if (value != null) {
      if (value.constructor === RegExp)
        return "regexp";
      if (value.constructor === Map)
        return "map";
      if (value.constructor === Set)
        return "set";
      if (value.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof value == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string) {
  return string.includes(`\r
`) ? `\r
` : `
`;
}
function diffStrings(a2, b2, options) {
  let truncate3 = options?.truncateThreshold ?? false, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = a2.length, bLength = b2.length;
  if (truncate3) {
    let aMultipleLines = a2.includes(`
`), bMultipleLines = b2.includes(`
`), aNewLineSymbol = getNewLineSymbol(a2), bNewLineSymbol = getNewLineSymbol(b2), _a3 = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a2, _b = bMultipleLines ? `${b2.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b2;
    aLength = _a3.length, bLength = _b.length;
  }
  let truncated = aLength !== a2.length || bLength !== b2.length, isCommon = (aIndex2, bIndex2) => a2[aIndex2] === b2[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
  return diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b2.slice(bCommon, bIndex)));
  }), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex))), [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
var ChangeBuffer = class {
  op;
  line;
  lines;
  changeColor;
  constructor(op, changeColor) {
    this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    let string = diff2[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        i2 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
      });
    } else
      this.pushDiff(diff2);
  }
  // Output from buffer.
  moveLinesTo(lines) {
    this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
  }
}, CommonBuffer = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(deleteBuffer, insertBuffer) {
    this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    let isDiffEmpty = diff2[1].length === 0;
    (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    let op = diff2[0], string = diff2[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 === 0) {
          let subdiff = new Diff(op, substring);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
        } else i2 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
      });
    } else
      this.pushDiffChangeLines(diff2);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
function getAlignedDiffs(diffs, changeColor) {
  let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  }), commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    let iLast = diffs.length - 1;
    return diffs.some((diff2, i2) => diff2[0] === DIFF_EQUAL && (i2 !== iLast || diff2[1] !== `
`));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
function diffStringsUnified(a2, b2, options) {
  if (a2 !== b2 && a2.length !== 0 && b2.length !== 0) {
    let isMultiline = a2.includes(`
`) || b2.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}
` : a2, isMultiline ? `${b2}
` : b2, true, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      let optionsNormalized = normalizeDiffOptions(options), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a2.split(`
`), b2.split(`
`), options);
}
function diffStringsRaw(a2, b2, cleanup, options) {
  let [diffs, truncated] = diffStrings(a2, b2, options);
  return diff_cleanupSemantic(diffs), [diffs, truncated];
}
function getCommonMessage(message, options) {
  let { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
], FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
}, FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a2, b2, options) {
  if (Object.is(a2, b2))
    return "";
  let aType = getType3(a2), expectedType = aType, omitDifference = false;
  if (aType === "object" && typeof a2.asymmetricMatch == "function") {
    if (a2.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a2.getExpectedType != "function")
      return;
    expectedType = a2.getExpectedType(), omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b2)) {
    let truncate3 = function(s3) {
      return s3.length <= MAX_LENGTH ? s3 : `${s3.slice(0, MAX_LENGTH)}...`;
    }, { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options), aDisplay = format(a2, formatOptions), bDisplay = format(b2, formatOptions), MAX_LENGTH = 1e5;
    aDisplay = truncate3(aDisplay), bDisplay = truncate3(bDisplay);
    let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (!omitDifference)
    switch (aType) {
      case "string":
        return diffLinesUnified(a2.split(`
`), b2.split(`
`), options);
      case "boolean":
      case "number":
        return comparePrimitive(a2, b2, options);
      case "map":
        return compareObjects(sortMap(a2), sortMap(b2), options);
      case "set":
        return compareObjects(sortSet(a2), sortSet(b2), options);
      default:
        return compareObjects(a2, b2, options);
    }
}
function comparePrimitive(a2, b2, options) {
  let aFormat = format(a2, FORMAT_OPTIONS), bFormat = format(b2, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options);
}
function sortMap(map2) {
  return new Map(Array.from(map2.entries()).sort());
}
function sortSet(set2) {
  return new Set(Array.from(set2.values()).sort());
}
function compareObjects(a2, b2, options) {
  let difference, hasThrown = false;
  try {
    let formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
  } catch {
    hasThrown = true;
  }
  let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`);
  }
  return difference;
}
function getFormatOptions(formatOptions, options) {
  let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
function getObjectsDifference(a2, b2, formatOptions, options) {
  let formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  }, aCompare = format(a2, formatOptionsZeroIndent), bCompare = format(b2, formatOptionsZeroIndent);
  if (aCompare === bCompare)
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  {
    let aDisplay = format(a2, formatOptions), bDisplay = format(b2, formatOptions);
    return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
}
function isReplaceable(obj1, obj2) {
  let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
  let { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes(`
`) || received.includes(`
`))
      return diffStringsUnified(expected, received, options);
    let [diffs] = diffStringsRaw(expected, received), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  let clonedExpected = deepClone(expected, { forceWritable: true }), clonedReceived = deepClone(received, { forceWritable: true }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  return diff(replacedExpected, replacedActual, options);
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
    replacedActual: actual,
    replacedExpected: expected
  }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
    replacedActual: actual,
    replacedExpected: expected
  } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
    let expectedValue = expected[key], actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue))
      expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
    else if (isAsymmetricMatcher(actualValue))
      actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
    else if (isReplaceable(actualValue, expectedValue)) {
      let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
    }
  }), {
    replacedActual: actual,
    replacedExpected: expected
  }) : {
    replacedActual: actual,
    replacedExpected: expected
  };
}
function getLabelPrinter(...strings) {
  let maxLength = strings.reduce((max2, string) => string.length > max2 ? string.length : max2, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
var SPACE_SYMBOL = "";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object) {
  return s.red(replaceTrailingSpaces(stringify2(object)));
}
function printExpected(value) {
  return s.green(replaceTrailingSpaces(stringify2(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v2) {
  return v2 && (v2[IS_COLLECTION_SYMBOL] || v2[IS_RECORD_SYMBOL]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val == "string")
    return val;
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
    let jsonValue = val.toJSON();
    return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
  }
  if (typeof val == "function")
    return `Function<${val.name || "anonymous"}>`;
  if (typeof val == "symbol")
    return val.toString();
  if (typeof val != "object")
    return val;
  if (typeof Buffer < "u" && val instanceof Buffer)
    return `<Buffer(${val.length}) ...>`;
  if (typeof Uint8Array < "u" && val instanceof Uint8Array)
    return `<Uint8Array(${val.length}) ...>`;
  if (isImmutable(val))
    return serializeValue(val.toJSON(), seen);
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && val instanceof Element)
    return val.tagName;
  if (typeof val.asymmetricMatch == "function")
    return `${val.toString()} ${format2(val.sample)}`;
  if (typeof val.toJSON == "function")
    return serializeValue(val.toJSON(), seen);
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    let clone3 = new Array(val.length);
    return seen.set(val, clone3), val.forEach((e2, i2) => {
      try {
        clone3[i2] = serializeValue(e2, seen);
      } catch (err) {
        clone3[i2] = getUnserializableMessage(err);
      }
    }), clone3;
  } else {
    let clone3 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone3);
    let obj = val;
    for (; obj && obj !== OBJECT_PROTO; )
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (!(key in clone3))
          try {
            clone3[key] = serializeValue(val[key], seen);
          } catch (err) {
            delete clone3[key], clone3[key] = getUnserializableMessage(err);
          }
      }), obj = Object.getPrototypeOf(obj);
    return clone3;
  }
}
function safe(fn3) {
  try {
    return fn3();
  } catch {
  }
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err != "object")
    return { message: String(_err) };
  let err = _err;
  (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
    ...diffOptions,
    ...err.diffOptions
  })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
  try {
    typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
  } catch {
  }
  try {
    !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e2) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e2?.message}
Inner error message: ${err?.message}`));
  }
}
var EVENTS = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
};
var addons2 = globalThis.__STORYBOOK_ADDONS_PREVIEW;
var alreadyCompletedException = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), isObject5 = (o2) => Object.prototype.toString.call(o2) === "[object Object]", isModule = (o2) => Object.prototype.toString.call(o2) === "[object Module]", isInstrumentable = (o2) => {
  if (!isObject5(o2) && !isModule(o2))
    return false;
  if (o2.constructor === void 0)
    return true;
  let proto = o2.constructor.prototype;
  return !!isObject5(proto);
}, construct = (obj) => {
  try {
    return new obj.constructor();
  } catch {
    return {};
  }
}, getInitialState = () => ({
  renderPhase: "preparing",
  isDebugging: false,
  isPlaying: false,
  isLocked: false,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), getRetainedState = (state3, isDebugging = false) => {
  let calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call2) => call2.retain);
  if (!calls.length)
    return;
  let callRefsByResult = new Map(
    Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
  );
  return { cursor: calls.length, calls, callRefsByResult };
}, Instrumenter = class {
  constructor() {
    this.detached = false;
    this.initialized = false;
    this.state = {};
    this.loadParentWindowState = () => {
      try {
        this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = true;
      }
    };
    this.updateParentWindowState = () => {
      try {
        scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = true;
      }
    };
    this.loadParentWindowState();
    let resetState = ({
      storyId,
      renderPhase,
      isPlaying = true,
      isDebugging = false
    }) => {
      let state3 = this.getState(storyId);
      this.setState(storyId, {
        ...getInitialState(),
        ...getRetainedState(state3, isDebugging),
        renderPhase: renderPhase || state3.renderPhase,
        shadowCalls: isDebugging ? state3.shadowCalls : [],
        chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: isDebugging ? state3.playUntil : void 0,
        isPlaying,
        isDebugging
      }), this.sync(storyId);
    }, start = (channel2) => ({ storyId, playUntil }) => {
      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({
        calls: [],
        shadowCalls: calls.map((call2) => ({
          ...call2,
          status: "waiting"
          /* WAITING */
        })),
        isDebugging: true
      }));
      let log = this.getLog(storyId);
      this.setState(storyId, ({ shadowCalls }) => {
        if (playUntil || !log.length)
          return { playUntil };
        let firstRowIndex = shadowCalls.findIndex((call2) => call2.id === log[0].callId);
        return {
          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call2) => call2.interceptable && !call2.ancestors?.length).slice(-1)[0]?.id
        };
      }), channel2.emit(FORCE_REMOUNT, { storyId, isDebugging: true });
    }, back = (channel2) => ({ storyId }) => {
      let log = this.getLog(storyId).filter((call2) => !call2.ancestors?.length), last = log.reduceRight((res, item, index2) => res >= 0 || item.status === "waiting" ? res : index2, -1);
      start(channel2)({ storyId, playUntil: log[last - 1]?.callId });
    }, goto = (channel2) => ({ storyId, callId }) => {
      let { calls, shadowCalls, resolvers } = this.getState(storyId), call2 = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);
      if (!call2 && shadowCall && Object.values(resolvers).length > 0) {
        let nextId2 = this.getLog(storyId).find(
          (c2) => c2.status === "waiting"
          /* WAITING */
        )?.callId;
        shadowCall.id !== nextId2 && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
      } else
        start(channel2)({ storyId, playUntil: callId });
    }, next = (channel2) => ({ storyId }) => {
      let { resolvers } = this.getState(storyId);
      if (Object.values(resolvers).length > 0)
        Object.values(resolvers).forEach((resolve) => resolve());
      else {
        let nextId2 = this.getLog(storyId).find(
          (c2) => c2.status === "waiting"
          /* WAITING */
        )?.callId;
        nextId2 ? start(channel2)({ storyId, playUntil: nextId2 }) : end({ storyId });
      }
    }, end = ({ storyId }) => {
      this.setState(storyId, { playUntil: void 0, isDebugging: false }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
    }, renderPhaseChanged = ({
      storyId,
      newPhase
    }) => {
      let { isDebugging } = this.getState(storyId);
      if (newPhase === "preparing" && isDebugging)
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      if (newPhase === "playing")
        return resetState({ storyId, renderPhase: newPhase, isDebugging });
      newPhase === "played" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: false,
        isPlaying: false,
        isDebugging: false
      }) : newPhase === "errored" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: false,
        isPlaying: false
      }) : newPhase === "aborted" ? this.setState(storyId, {
        renderPhase: newPhase,
        isLocked: true,
        isPlaying: false
      }) : this.setState(storyId, {
        renderPhase: newPhase
      }), this.sync(storyId);
    };
    addons2 && addons2.ready().then(() => {
      this.channel = addons2.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {
        this.initialized ? this.cleanup() : this.initialized = true;
      }), this.channel.on(EVENTS.START, start(this.channel)), this.channel.on(EVENTS.BACK, back(this.channel)), this.channel.on(EVENTS.GOTO, goto(this.channel)), this.channel.on(EVENTS.NEXT, next(this.channel)), this.channel.on(EVENTS.END, end);
    });
  }
  getState(storyId) {
    return this.state[storyId] || getInitialState();
  }
  setState(storyId, update) {
    if (storyId) {
      let state3 = this.getState(storyId), patch = typeof update == "function" ? update(state3) : update;
      this.state = { ...this.state, [storyId]: { ...state3, ...patch } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (acc, [storyId, state3]) => {
        let retainedState = getRetainedState(state3);
        return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
      },
      {}
    );
    let payload = { controlStates: {
      detached: this.detached,
      start: false,
      back: false,
      goto: false,
      next: false,
      end: false
    }, logItems: [] };
    this.channel?.emit(EVENTS.SYNC, payload), this.updateParentWindowState();
  }
  getLog(storyId) {
    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
    calls.forEach((call2, index2) => {
      merged[index2] = call2;
    });
    let seen = /* @__PURE__ */ new Set();
    return merged.reduceRight((acc, call2) => (call2.args.forEach((arg) => {
      arg?.__callId__ && seen.add(arg.__callId__);
    }), call2.path.forEach((node) => {
      node.__callId__ && seen.add(node.__callId__);
    }), (call2.interceptable || call2.exception) && !seen.has(call2.id) && (acc.unshift({ callId: call2.id, status: call2.status, ancestors: call2.ancestors }), seen.add(call2.id)), acc), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(obj, options, depth = 0) {
    if (!isInstrumentable(obj))
      return obj;
    let { mutate = false, path = [] } = options, keys2 = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
    return depth += 1, keys2.reduce(
      (acc, key) => {
        let descriptor = getPropertyDescriptor(obj, key);
        if (typeof descriptor?.get == "function") {
          if (descriptor.configurable) {
            let getter = () => descriptor?.get?.bind(obj)?.();
            Object.defineProperty(acc, key, {
              get: () => this.instrument(getter(), { ...options, path: path.concat(key) }, depth)
            });
          }
          return acc;
        }
        let value = obj[key];
        return typeof value != "function" ? (acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth), acc) : "__originalFn__" in value && typeof value.__originalFn__ == "function" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, obj, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], "name", { value: key, writable: false }), Object.keys(value).length > 0 && Object.assign(
          acc[key],
          this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)
        ), acc);
      },
      mutate ? obj : construct(obj)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(method, fn3, object, args, options) {
    let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);
    this.setState(storyId, { cursor: cursor + 1 });
    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = false, retain = false } = options, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call2 = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn3, object, call2, options);
    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call2.id }] });
  }
  intercept(fn3, object, call2, options) {
    let { chainedCallIds, isDebugging, playUntil } = this.getState(call2.storyId), isChainedUpon = chainedCallIds.has(call2.id);
    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call2.id && this.setState(call2.storyId, { playUntil: void 0 }), this.invoke(fn3, object, call2, options)) : new Promise((resolve) => {
      this.setState(call2.storyId, ({ resolvers }) => ({
        isLocked: false,
        resolvers: { ...resolvers, [call2.id]: resolve }
      }));
    }).then(() => (this.setState(call2.storyId, (state3) => {
      let { [call2.id]: _, ...resolvers } = state3.resolvers;
      return { isLocked: true, resolvers };
    }), this.invoke(fn3, object, call2, options)));
  }
  invoke(fn3, object, call2, options) {
    let { callRefsByResult, renderPhase } = this.getState(call2.storyId), maximumDepth = 25, serializeValues = (value, depth, seen) => {
      if (seen.includes(value))
        return "[Circular]";
      if (seen = [...seen, value], depth > maximumDepth)
        return "...";
      if (callRefsByResult.has(value))
        return callRefsByResult.get(value);
      if (value instanceof Array)
        return value.map((it) => serializeValues(it, ++depth, seen));
      if (value instanceof Date)
        return { __date__: { value: value.toISOString() } };
      if (value instanceof Error) {
        let { name, message, stack: stack2 } = value;
        return { __error__: { name, message, stack: stack2 } };
      }
      if (value instanceof RegExp) {
        let { flags, source } = value;
        return { __regexp__: { flags, source } };
      }
      if (value instanceof scope.window?.HTMLElement) {
        let { prefix: prefix2, localName, id, classList, innerText } = value, classNames = Array.from(classList);
        return { __element__: { prefix: prefix2, localName, id, classNames, innerText } };
      }
      return typeof value == "function" ? {
        __function__: { name: "getMockName" in value ? value.getMockName() : value.name }
      } : typeof value == "symbol" ? { __symbol__: { description: value.description } } : typeof value == "object" && value?.constructor?.name && value?.constructor?.name !== "Object" ? { __class__: { name: value.constructor.name } } : Object.prototype.toString.call(value) === "[object Object]" ? Object.fromEntries(
        Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
      ) : value;
    }, info = {
      ...call2,
      args: call2.args.map((arg) => serializeValues(arg, 0, []))
    };
    call2.path.forEach((ref) => {
      ref?.__callId__ && this.setState(call2.storyId, ({ chainedCallIds }) => ({
        chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
      }));
    });
    let handleException = (e2) => {
      if (e2 instanceof Error) {
        let { name, message, stack: stack2, callId = call2.id } = e2, {
          showDiff = void 0,
          diff: diff2 = void 0,
          actual = void 0,
          expected = void 0
        } = e2.name === "AssertionError" ? processError(e2) : e2, exception = { name, message, stack: stack2, callId, showDiff, diff: diff2, actual, expected };
        if (this.update({ ...info, status: "error", exception }), this.setState(call2.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [e2, { __callId__: call2.id, retain: call2.retain }]
          ])
        })), call2.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(e2, "callId") || Object.defineProperty(e2, "callId", { value: call2.id }), e2;
      }
      throw e2;
    };
    try {
      if (renderPhase === "played" && !call2.retain)
        throw alreadyCompletedException;
      let finalArgs = (options.getArgs ? options.getArgs(call2, this.getState(call2.storyId)) : call2.args).map((arg) => typeof arg != "function" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {
        let { cursor, ancestors } = this.getState(call2.storyId);
        this.setState(call2.storyId, { cursor: 0, ancestors: [...ancestors, call2.id] });
        let restore = () => this.setState(call2.storyId, { cursor, ancestors }), willRestore = false;
        try {
          let res = arg(...args);
          return res instanceof Promise ? (willRestore = true, res.finally(restore)) : res;
        } finally {
          willRestore || restore();
        }
      }), result = fn3.apply(object, finalArgs);
      return result && ["object", "function", "symbol"].includes(typeof result) && this.setState(call2.storyId, (state3) => ({
        callRefsByResult: new Map([
          ...Array.from(state3.callRefsByResult.entries()),
          [result, { __callId__: call2.id, retain: call2.retain }]
        ])
      })), this.update({
        ...info,
        status: result instanceof Promise ? "active" : "done"
        /* DONE */
      }), result instanceof Promise ? result.then((value) => (this.update({
        ...info,
        status: "done"
        /* DONE */
      }), value), handleException) : result;
    } catch (e2) {
      return handleException(e2);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(call2) {
    this.channel?.emit(EVENTS.CALL, call2), this.setState(call2.storyId, ({ calls }) => {
      let callsById = calls.concat(call2).reduce((a2, c2) => Object.assign(a2, { [c2.id]: c2 }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(callsById).sort(
          (a2, b2) => a2.id.localeCompare(b2.id, void 0, { numeric: true })
        )
      };
    }), this.sync(call2.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(storyId) {
    let synchronize = () => {
      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find(
        (item) => item.status === "waiting"
        /* WAITING */
      )?.callId, hasActive = logItems.some(
        (item) => item.status === "active"
        /* ACTIVE */
      );
      if (this.detached || isLocked || hasActive || logItems.length === 0) {
        let payload2 = { controlStates: {
          detached: this.detached,
          start: false,
          back: false,
          goto: false,
          next: false,
          end: false
        }, logItems };
        this.channel?.emit(EVENTS.SYNC, payload2);
        return;
      }
      let hasPrevious = logItems.some(
        (item) => item.status === "done" || item.status === "error"
        /* ERROR */
      ), payload = { controlStates: {
        detached: this.detached,
        start: hasPrevious,
        back: hasPrevious,
        goto: true,
        next: isPlaying,
        end: isPlaying
      }, logItems, pausedAt };
      this.channel?.emit(EVENTS.SYNC, payload);
    };
    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
  }
};
function instrument(obj, options = {}) {
  try {
    let forceInstrument = false, skipInstrument = false;
    return scope.window?.location?.search?.includes("instrument=true") ? forceInstrument = true : scope.window?.location?.search?.includes("instrument=false") && (skipInstrument = true), scope.window?.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));
  } catch (e2) {
    return once.warn(e2), obj;
  }
}
function getPropertyDescriptor(obj, propName) {
  let target = obj;
  for (; target != null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(target, propName);
    if (descriptor)
      return descriptor;
    target = Object.getPrototypeOf(target);
  }
}
function isClass(obj) {
  if (typeof obj != "function")
    return false;
  let descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
  return descriptor ? !descriptor.writable : false;
}
var __defProp3 = Object.defineProperty, __name = (target, value) => __defProp3(target, "name", { value, configurable: true }), __export2 = (target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: true });
}, utils_exports = {};
__export2(utils_exports, {
  addChainableMethod: () => addChainableMethod,
  addLengthGuard: () => addLengthGuard,
  addMethod: () => addMethod,
  addProperty: () => addProperty,
  checkError: () => check_error_exports,
  compareByInspect: () => compareByInspect,
  eql: () => deep_eql_default,
  expectTypes: () => expectTypes,
  flag: () => flag,
  getActual: () => getActual,
  getMessage: () => getMessage2,
  getName: () => getName,
  getOperator: () => getOperator,
  getOwnEnumerableProperties: () => getOwnEnumerableProperties,
  getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
  getPathInfo: () => getPathInfo,
  hasProperty: () => hasProperty,
  inspect: () => inspect22,
  isNaN: () => isNaN22,
  isNumeric: () => isNumeric,
  isProxyEnabled: () => isProxyEnabled,
  isRegExp: () => isRegExp2,
  objDisplay: () => objDisplay,
  overwriteChainableMethod: () => overwriteChainableMethod,
  overwriteMethod: () => overwriteMethod,
  overwriteProperty: () => overwriteProperty,
  proxify: () => proxify,
  test: () => test2,
  transferFlags: () => transferFlags,
  type: () => type
});
var check_error_exports = {};
__export2(check_error_exports, {
  compatibleConstructor: () => compatibleConstructor,
  compatibleInstance: () => compatibleInstance,
  compatibleMessage: () => compatibleMessage,
  getConstructorName: () => getConstructorName2,
  getMessage: () => getMessage
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  return isErrorInstance(errorLike) ? thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor : (typeof errorLike == "object" || typeof errorLike == "function") && errorLike.prototype ? thrown.constructor === errorLike || thrown instanceof errorLike : false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  let comparisonString = typeof thrown == "string" ? thrown : thrown.message;
  return isRegExp(errMatcher) ? errMatcher.test(comparisonString) : typeof errMatcher == "string" ? comparisonString.indexOf(errMatcher) !== -1 : false;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName2(errorLike) {
  let constructorName = errorLike;
  return isErrorInstance(errorLike) ? constructorName = errorLike.constructor.name : typeof errorLike == "function" && (constructorName = errorLike.name, constructorName === "" && (constructorName = new errorLike().name || constructorName)), constructorName;
}
__name(getConstructorName2, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  return errorLike && errorLike.message ? msg = errorLike.message : typeof errorLike == "string" && (msg = errorLike), msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value) {
  let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    flags[key] = value;
  else
    return flags[key];
}
__name(flag, "flag");
function test2(obj, args) {
  let negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test2, "test");
function type(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag2 = obj[Symbol.toStringTag];
  return typeof stringTag2 == "string" ? stringTag2 : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error, _a, AssertionError = (_a = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message), this.message = message, canElideFrames && Error.captureStackTrace(this, ssf || _a);
    for (let key in props)
      key in this || (this[key] = props[key]);
  }
  toJSON(stack2) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: false,
      stack: stack2 !== false ? this.stack : void 0
    };
  }
}, __name(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  let flagMsg = flag(obj, "message"), ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "", obj = flag(obj, "object"), types = types.map(function(t22) {
    return t22.toLowerCase();
  }), types.sort();
  let str2 = types.map(function(t22, index2) {
    let art = ~["a", "e", "i", "o", "u"].indexOf(t22.charAt(0)) ? "an" : "a";
    return (types.length > 1 && index2 === types.length - 1 ? "or " : "") + art + " " + t22;
  }).join(", "), objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  }))
    throw new AssertionError(
      flagMsg + "object tested must be " + str2 + ", but " + objType + " given",
      void 0,
      ssfi
    );
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors2 = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles2 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator2 = "";
function colorise2(value, styleType) {
  let color = ansiColors2[styles2[styleType]] || ansiColors2[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
__name(colorise2, "colorise");
function normaliseOptions2({
  showHidden = false,
  depth = 2,
  colors: colors3 = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate22 = 1 / 0,
  stylize = String
} = {}, inspect32) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors3,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate22),
    seen,
    inspect: inspect32,
    stylize
  };
  return options.colors && (options.stylize = colorise2), options;
}
__name(normaliseOptions2, "normaliseOptions");
function isHighSurrogate2(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate2, "isHighSurrogate");
function truncate2(string, length, tail = truncator2) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate2(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
__name(truncate2, "truncate");
function inspectList2(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size2 = list.length;
  if (size2 === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i2 = 0; i2 < size2; i2 += 1) {
    let last = i2 + 1 === list.length, secondToLast = i2 + 2 === list.length;
    truncated = `${truncator2}(${list.length - i2})`;
    let value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator2}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList2, "inspectList");
function quoteComplexKey2(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey2, "quoteComplexKey");
function inspectProperty2([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey2(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}
__name(inspectProperty2, "inspectProperty");
function inspectArray2(array, options) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList2(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray2, "inspectArray");
var getArrayName2 = __name((array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name, "getArrayName");
function inspectTypedArray2(array, options) {
  let name = getArrayName2(array);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    let string = `${options.stylize(truncate2(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    if (options.truncate -= string.length, array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator2}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty2)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray2, "inspectTypedArray");
function inspectDate2(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate2(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate2, "inspectDate");
function inspectFunction2(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate2(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}
__name(inspectFunction2, "inspectFunction");
function inspectMapEntry2([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
__name(inspectMapEntry2, "inspectMapEntry");
function mapToEntries2(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
__name(mapToEntries2, "mapToEntries");
function inspectMap2(map2, options) {
  return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList2(mapToEntries2(map2), options, inspectMapEntry2)} }`);
}
__name(inspectMap2, "inspectMap");
var isNaN3 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber2(number, options) {
  return isNaN3(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate2(String(number), options.truncate), "number");
}
__name(inspectNumber2, "inspectNumber");
function inspectBigInt2(number, options) {
  let nums = truncate2(number.toString(), options.truncate - 1);
  return nums !== truncator2 && (nums += "n"), options.stylize(nums, "bigint");
}
__name(inspectBigInt2, "inspectBigInt");
function inspectRegExp2(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate2(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp2, "inspectRegExp");
function arrayFromSet2(set2) {
  let values = [];
  return set2.forEach((value) => {
    values.push(value);
  }), values;
}
__name(arrayFromSet2, "arrayFromSet");
function inspectSet2(set2, options) {
  return set2.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList2(arrayFromSet2(set2), options)} }`);
}
__name(inspectSet2, "inspectSet");
var stringEscapeChars2 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters2 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex2 = 16;
function escape2$1(char) {
  return escapeCharacters2[char] || `\\u${`0000${char.charCodeAt(0).toString(hex2)}`.slice(-4)}`;
}
__name(escape2$1, "escape");
function inspectString2(string, options) {
  return stringEscapeChars2.test(string) && (string = string.replace(stringEscapeChars2, escape2$1)), options.stylize(`'${truncate2(string, options.truncate - 2)}'`, "string");
}
__name(inspectString2, "inspectString");
function inspectSymbol2(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}
__name(inspectSymbol2, "inspectSymbol");
var getPromiseValue2 = __name(() => "Promise{}", "getPromiseValue"), promise_default2 = getPromiseValue2;
function inspectObject3(object, options) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object))
    return "[Circular]";
  options.seen.push(object);
  let propertyContents = inspectList2(properties.map((key) => [key, object[key]]), options, inspectProperty2), symbolContents = inspectList2(symbols.map((key) => [key, object[key]]), options, inspectProperty2);
  options.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject3, "inspectObject");
var toStringTag2 = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass2(value, options) {
  let name = "";
  return toStringTag2 && toStringTag2 in value && (name = value[toStringTag2]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject3(value, options)}`;
}
__name(inspectClass2, "inspectClass");
function inspectArguments2(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList2(args, options)} ]`);
}
__name(inspectArguments2, "inspectArguments");
var errorKeys2 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject22(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys2.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate2(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList2(properties.map((key) => [key, error[key]]), options, inspectProperty2);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject22, "inspectObject");
function inspectAttribute2([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
__name(inspectAttribute2, "inspectAttribute");
function inspectNodeCollection2(collection, options) {
  return inspectList2(collection, options, inspectNode2, `
`);
}
__name(inspectNodeCollection2, "inspectNodeCollection");
function inspectNode2(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML2(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode2, "inspectNode");
function inspectHTML2(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList2(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute2, " ")), options.truncate -= propertyContents.length;
  let truncate22 = options.truncate, children = inspectNodeCollection2(element.children, options);
  return children && children.length > truncate22 && (children = `${truncator2}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML2, "inspectHTML");
var symbolsSupported2 = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect2 = symbolsSupported2 ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect2 = Symbol.for("nodejs.util.inspect.custom"), constructorMap2 = /* @__PURE__ */ new WeakMap(), stringTagMap2 = {}, baseTypesMap2 = {
  undefined: __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
  null: __name((value, options) => options.stylize("null", "null"), "null"),
  boolean: __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
  Boolean: __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
  number: inspectNumber2,
  Number: inspectNumber2,
  bigint: inspectBigInt2,
  BigInt: inspectBigInt2,
  string: inspectString2,
  String: inspectString2,
  function: inspectFunction2,
  Function: inspectFunction2,
  symbol: inspectSymbol2,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol2,
  Array: inspectArray2,
  Date: inspectDate2,
  Map: inspectMap2,
  Set: inspectSet2,
  RegExp: inspectRegExp2,
  Promise: promise_default2,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: __name((value, options) => options.stylize("WeakSet{}", "special"), "WeakSet"),
  WeakMap: __name((value, options) => options.stylize("WeakMap{}", "special"), "WeakMap"),
  Arguments: inspectArguments2,
  Int8Array: inspectTypedArray2,
  Uint8Array: inspectTypedArray2,
  Uint8ClampedArray: inspectTypedArray2,
  Int16Array: inspectTypedArray2,
  Uint16Array: inspectTypedArray2,
  Int32Array: inspectTypedArray2,
  Uint32Array: inspectTypedArray2,
  Float32Array: inspectTypedArray2,
  Float64Array: inspectTypedArray2,
  Generator: __name(() => "", "Generator"),
  DataView: __name(() => "", "DataView"),
  ArrayBuffer: __name(() => "", "ArrayBuffer"),
  Error: inspectObject22,
  HTMLCollection: inspectNodeCollection2,
  NodeList: inspectNodeCollection2
}, inspectCustom2 = __name((value, options, type32) => chaiInspect2 in value && typeof value[chaiInspect2] == "function" ? value[chaiInspect2](options) : nodeInspect2 in value && typeof value[nodeInspect2] == "function" ? value[nodeInspect2](options.depth, options) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap2.has(value.constructor) ? constructorMap2.get(value.constructor)(value, options) : stringTagMap2[type32] ? stringTagMap2[type32](value, options) : "", "inspectCustom"), toString4 = Object.prototype.toString;
function inspect3(value, opts = {}) {
  let options = normaliseOptions2(opts, inspect3), { customInspect } = options, type32 = value === null ? "null" : typeof value;
  if (type32 === "object" && (type32 = toString4.call(value).slice(8, -1)), type32 in baseTypesMap2)
    return baseTypesMap2[type32](value, options);
  if (customInspect && value) {
    let output = inspectCustom2(value, options, type32);
    if (output)
      return typeof output == "string" ? output : inspect3(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : false;
  return proto === Object.prototype || proto === null ? inspectObject3(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML2(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass2(value, options) : inspectObject3(value, options) : value === Object(value) ? inspectObject3(value, options) : options.stylize(String(value), type32);
}
__name(inspect3, "inspect");
var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect22(obj, showHidden, depth, colors3) {
  let options = {
    colors: colors3,
    depth: typeof depth > "u" ? 2 : depth,
    showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : 1 / 0
  };
  return inspect3(obj, options);
}
__name(inspect22, "inspect");
function objDisplay(obj) {
  let str2 = inspect22(obj), type32 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str2.length >= config.truncateThreshold) {
    if (type32 === "[object Function]")
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    if (type32 === "[object Array]")
      return "[ Array(" + obj.length + ") ]";
    if (type32 === "[object Object]") {
      let keys2 = Object.keys(obj);
      return "{ Object (" + (keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ")) + ") }";
    } else
      return str2;
  } else
    return str2;
}
__name(objDisplay, "objDisplay");
function getMessage2(obj, args) {
  let negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
  return typeof msg == "function" && (msg = msg()), msg = msg || "", msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  }), flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object, includeAll) {
  let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  object.__flags || (object.__flags = /* @__PURE__ */ Object.create(null)), includeAll = arguments.length === 3 ? includeAll : true;
  for (let flag3 in flags)
    (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") && (object.__flags[flag3] = flags[flag3]);
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag2 = obj[Symbol.toStringTag];
  return typeof stringTag2 == "string" ? stringTag2 : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: __name(function(key) {
    return key[this._key];
  }, "get"),
  set: __name(function(key, value) {
    Object.isExtensible(key) && Object.defineProperty(key, this._key, {
      value,
      configurable: true
    });
  }, "set")
};
var MemoizeMap = typeof WeakMap == "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand))
    return null;
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result == "boolean")
      return result;
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!(!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand))) {
    var leftHandMap = memoizeMap.get(leftHandOperand);
    leftHandMap ? leftHandMap.set(rightHandOperand, result) : (leftHandMap = new MemoizeMap(), leftHandMap.set(rightHandOperand, result), memoizeMap.set(leftHandOperand, leftHandMap));
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual$1;
function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator)
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  return simpleResult !== null ? simpleResult : extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual$1, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand === rightHandOperand ? leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand : leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand ? true : isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand) ? false : null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {}, options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator, memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null)
    return memoizeResultLeft;
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null)
    return memoizeResultRight;
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true)
      return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult), comparatorResult;
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null)
      return simpleResult;
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand))
    return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false), false;
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result), result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size)
      return false;
    if (leftHandOperand.size === 0)
      return true;
  } catch {
    return false;
  }
  var leftHandItems = [], rightHandItems = [];
  return leftHandOperand.forEach(__name(function(key, value) {
    leftHandItems.push([key, value]);
  }, "gatherEntries")), rightHandOperand.forEach(__name(function(key, value) {
    rightHandItems.push([key, value]);
  }, "gatherEntries")), iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length)
    return false;
  if (length === 0)
    return true;
  for (var index2 = -1; ++index2 < length; )
    if (deepEqual$1(leftHandOperand[index2], rightHandOperand[index2], options) === false)
      return false;
  return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol < "u" && typeof target == "object" && typeof Symbol.iterator < "u" && typeof target[Symbol.iterator] == "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target))
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  for (var generatorResult = generator.next(), accumulator = [generatorResult.value]; generatorResult.done === false; )
    generatorResult = generator.next(), accumulator.push(generatorResult.value);
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys2 = [];
  for (var key in target)
    keys2.push(key);
  return keys2;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  for (var keys2 = [], allKeys2 = Object.getOwnPropertySymbols(target), i2 = 0; i2 < allKeys2.length; i2 += 1) {
    var key = allKeys2[i2];
    Object.getOwnPropertyDescriptor(target, key).enumerable && keys2.push(key);
  }
  return keys2;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys2, options) {
  var length = keys2.length;
  if (length === 0)
    return true;
  for (var i2 = 0; i2 < length; i2 += 1)
    if (deepEqual$1(leftHandOperand[keys2[i2]], rightHandOperand[keys2[i2]], options) === false)
      return false;
  return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand), rightHandKeys = getEnumerableKeys(rightHandOperand), leftHandSymbols = getEnumerableSymbols(leftHandOperand), rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  if (leftHandKeys = leftHandKeys.concat(leftHandSymbols), rightHandKeys = rightHandKeys.concat(rightHandSymbols), leftHandKeys.length && leftHandKeys.length === rightHandKeys.length)
    return iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false ? false : keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  var leftHandEntries = getIteratorEntries(leftHandOperand), rightHandEntries = getIteratorEntries(rightHandOperand);
  return leftHandEntries.length && leftHandEntries.length === rightHandEntries.length ? (leftHandEntries.sort(), rightHandEntries.sort(), iterableEqual(leftHandEntries, rightHandEntries, options)) : leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0;
}
__name(objectEqual, "objectEqual");
function isPrimitive$1(value) {
  return value === null || typeof value != "object";
}
__name(isPrimitive$1, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(__name(function(entry) {
    return typeof entry == "symbol" ? entry.toString() : entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  return typeof obj > "u" || obj === null ? false : name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
  return path.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((value) => {
    if (value === "constructor" || value === "__proto__" || value === "prototype")
      return {};
    let mArr = /^\[(\d+)\]$/.exec(value), parsed = null;
    return mArr ? parsed = { i: parseFloat(mArr[1]) } : parsed = { p: value.replace(/\\([.[\]])/g, "$1") }, parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj, res = null;
  pathDepth = typeof pathDepth > "u" ? parsed.length : pathDepth;
  for (let i2 = 0; i2 < pathDepth; i2++) {
    let part = parsed[i2];
    temporaryValue && (typeof part.p > "u" ? temporaryValue = temporaryValue[part.i] : temporaryValue = temporaryValue[part.p], i2 === pathDepth - 1 && (res = temporaryValue));
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
  let parsed = parsePath(path), last = parsed[parsed.length - 1], info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  return info.exists = hasProperty(info.parent, info.name), info;
}
__name(getPathInfo, "getPathInfo");
var _a2, Assertion = (_a2 = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(obj, msg, ssfi, lockSsfi) {
    return flag(this, "ssfi", ssfi || _a2), flag(this, "lockSsfi", lockSsfi), flag(this, "object", obj), flag(this, "message", msg), flag(this, "eql", config.deepEqual || deep_eql_default), proxify(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(value) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack = value;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(value) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff = value;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(name, fn3) {
    addProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(name, fn3) {
    addMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(name, fn3, chainingBehavior) {
    addChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(name, fn3) {
    overwriteProperty(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(name, fn3) {
    overwriteMethod(this.prototype, name, fn3);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(name, fn3, chainingBehavior) {
    overwriteChainableMethod(this.prototype, name, fn3, chainingBehavior);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
    let ok = test2(this, arguments);
    if (showDiff !== false && (showDiff = true), expected === void 0 && _actual === void 0 && (showDiff = false), config.showDiff !== true && (showDiff = false), !ok) {
      msg = getMessage2(this, arguments);
      let assertionErrorObjectProperties = {
        actual: getActual(this, arguments),
        expected,
        showDiff
      }, operator = getOperator(this, arguments);
      throw operator && (assertionErrorObjectProperties.operator = operator), new AssertionError(
        msg,
        assertionErrorObjectProperties,
        // @ts-expect-error Not sure what to do about these types yet
        config.includeStack ? this.assert : flag(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return flag(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(val) {
    flag(this, "object", val);
  }
}, __name(_a2, "Assertion"), _a2);
function isProxyEnabled() {
  return config.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter, Object.defineProperty(ctx, name, {
    get: __name(function propertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", propertyGetter);
      let result = getter.call(this);
      if (result !== void 0) return result;
      let newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "propertyGetter"),
    configurable: true
  });
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn3, assertionName, isChainable) {
  return fnLengthDesc.configurable && Object.defineProperty(fn3, "length", {
    get: __name(function() {
      throw Error(
        isChainable ? "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.' : "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".'
      );
    }, "get")
  }), fn3;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object) {
  let result = Object.getOwnPropertyNames(object);
  function addProperty2(property) {
    result.indexOf(property) === -1 && result.push(property);
  }
  __name(addProperty2, "addProperty");
  let proto = Object.getPrototypeOf(object);
  for (; proto !== null; )
    Object.getOwnPropertyNames(proto).forEach(addProperty2), proto = Object.getPrototypeOf(proto);
  return result;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  return isProxyEnabled() ? new Proxy(obj, {
    get: __name(function proxyGetter(target, property) {
      if (typeof property == "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName)
          throw Error(
            "Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".'
          );
        let suggestion = null, suggestionDistance = 4;
        throw getProperties(target).forEach(function(prop) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1
          ) {
            let dist = stringDistanceCapped(property, prop, suggestionDistance);
            dist < suggestionDistance && (suggestion = prop, suggestionDistance = dist);
          }
        }), Error(
          suggestion !== null ? "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?' : "Invalid Chai property: " + property
        );
      }
      return builtins.indexOf(property) === -1 && !flag(target, "lockSsfi") && flag(target, "ssfi", proxyGetter), Reflect.get(target, property);
    }, "proxyGetter")
  }) : obj;
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap)
    return cap;
  let memo = [];
  for (let i2 = 0; i2 <= strA.length; i2++)
    memo[i2] = Array(strB.length + 1).fill(0), memo[i2][0] = i2;
  for (let j2 = 0; j2 < strB.length; j2++)
    memo[0][j2] = j2;
  for (let i2 = 1; i2 <= strA.length; i2++) {
    let ch = strA.charCodeAt(i2 - 1);
    for (let j2 = 1; j2 <= strB.length; j2++) {
      if (Math.abs(i2 - j2) >= cap) {
        memo[i2][j2] = cap;
        continue;
      }
      memo[i2][j2] = Math.min(
        memo[i2 - 1][j2] + 1,
        memo[i2][j2 - 1] + 1,
        memo[i2 - 1][j2 - 1] + (ch === strB.charCodeAt(j2 - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  let methodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", methodWrapper);
    let result = method.apply(this, arguments);
    if (result !== void 0) return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, false), ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = __name(function() {
  }, "_super");
  _get && typeof _get.get == "function" && (_super = _get.get), Object.defineProperty(ctx, name, {
    get: __name(function overwritingPropertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", overwritingPropertyGetter);
      let origLockSsfi = flag(this, "lockSsfi");
      flag(this, "lockSsfi", true);
      let result = getter(_super).call(this);
      if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
        return result;
      let newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "overwritingPropertyGetter"),
    configurable: true
  });
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  let _method = ctx[name], _super = __name(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  _method && typeof _method == "function" && (_super = _method);
  let overwritingMethodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", overwritingMethodWrapper);
    let origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    let result = method(_super).apply(this, arguments);
    if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, false), ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf == "function", testFn = __name(function() {
}, "testFn"), excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  let propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  return typeof propDesc != "object" ? true : !propDesc.configurable;
}), call = Function.prototype.call, apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  typeof chainingBehavior != "function" && (chainingBehavior = __name(function() {
  }, "chainingBehavior"));
  let chainableBehavior = {
    method,
    chainingBehavior
  };
  ctx.__methods || (ctx.__methods = {}), ctx.__methods[name] = chainableBehavior, Object.defineProperty(ctx, name, {
    get: __name(function() {
      chainableBehavior.chainingBehavior.call(this);
      let chainableMethodWrapper = __name(function() {
        flag(this, "lockSsfi") || flag(this, "ssfi", chainableMethodWrapper);
        let result = chainableBehavior.method.apply(this, arguments);
        if (result !== void 0)
          return result;
        let newAssertion = new Assertion();
        return transferFlags(this, newAssertion), newAssertion;
      }, "chainableMethodWrapper");
      if (addLengthGuard(chainableMethodWrapper, name, true), canSetPrototype) {
        let prototype = Object.create(this);
        prototype.call = call, prototype.apply = apply, Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } else
        Object.getOwnPropertyNames(ctx).forEach(function(asserterName) {
          if (excludeNames.indexOf(asserterName) !== -1)
            return;
          let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
          Object.defineProperty(chainableMethodWrapper, asserterName, pd);
        });
      return transferFlags(this, chainableMethodWrapper), proxify(chainableMethodWrapper);
    }, "chainableMethodGetter"),
    configurable: true
  });
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  let chainableBehavior = ctx.__methods[name], _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = __name(function() {
    let result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodGetter");
  let _method = chainableBehavior.method;
  chainableBehavior.method = __name(function() {
    let result = method(_method).apply(this, arguments);
    if (result !== void 0)
      return result;
    let newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a2, b2) {
  return inspect22(a2) < inspect22(b2) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN22 = Number.isNaN;
function isObjectType(obj) {
  let objectType = type(obj);
  return ["Array", "Object", "Function"].indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
  let operator = flag(obj, "operator"), negate = flag(obj, "negate"), expected = args[3], msg = negate ? args[2] : args[1];
  if (operator)
    return operator;
  if (typeof msg == "function" && (msg = msg()), msg = msg || "", !msg || /\shave\s/.test(msg))
    return;
  let isObject7 = isObjectType(expected);
  return /\snot\s/.test(msg) ? isObject7 ? "notDeepStrictEqual" : "notStrictEqual" : isObject7 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn3) {
  return fn3.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
  return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", true), flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", true), flag2(this, "any", false);
});
var functionTypes = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type32, msg) {
  msg && flag2(this, "message", msg), type32 = type32.toLowerCase();
  let obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type32.charAt(0)) ? "an " : "a ", detectedType = type(obj).toLowerCase();
  functionTypes.function.includes(type32) ? this.assert(
    functionTypes[type32].includes(detectedType),
    "expected #{this} to be " + article + type32,
    "expected #{this} not to be " + article + type32
  ) : this.assert(
    type32 === detectedType,
    "expected #{this} to be " + article + type32,
    "expected #{this} not to be " + article + type32
  );
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a2, b2) {
  return isNaN22(a2) && isNaN22(b2) || a2 === b2;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep)
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      isDeep ? obj.forEach(function(item) {
        included = included || isEql(item, val);
      }) : included = obj.has(val);
      break;
    case "array":
      isDeep ? included = obj.some(function(item) {
        return isEql(item, val);
      }) : included = obj.indexOf(val) !== -1;
      break;
    default: {
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
          void 0,
          ssfi
        );
      let props = Object.keys(val), firstErr = null, numErrs = 0;
      if (props.forEach(function(prop) {
        let propAssertion = new Assertion(obj);
        if (transferFlags(this, propAssertion, true), flag2(propAssertion, "lockSsfi", true), !negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError))
            throw err;
          firstErr === null && (firstErr = err), numErrs++;
        }
      }, this), negate && props.length > 1 && numErrs === props.length)
        throw firstErr;
      return;
    }
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect22(val),
    "expected #{this} to not " + descriptor + "include " + inspect22(val)
  );
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    flag2(this, "object") === true,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("numeric", function() {
  let object = flag2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(type(object)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("callable", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), message = flag2(this, "message"), msg = message ? `${message}: ` : "", negate = flag2(this, "negate"), assertionMessage = negate ? `${msg}expected ${inspect22(val)} not to be a callable function` : `${msg}expected ${inspect22(val)} to be a callable function`, isCallable3 = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(type(val));
  if (isCallable3 && negate || !isCallable3 && !negate)
    throw new AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
  this.assert(
    flag2(this, "object") === false,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!flag2(this, "negate")
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    flag2(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    flag2(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN22(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  let val = flag2(this, "object");
  this.assert(
    val != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  switch (flagMsg = flagMsg ? flagMsg + ": " : "", type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function": {
      let msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    }
    default:
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect22(val),
          void 0,
          ssfi
        );
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    itemsCount === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  let obj = flag2(this, "object"), type32 = type(obj);
  this.assert(
    type32 === "Arguments",
    "expected #{this} to be arguments but got " + type32,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    let prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true), this.eql(val), flag2(this, "lockSsfi", prevLockSsfi);
  } else
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      true
    );
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  msg && flag2(this, "message", msg);
  let eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    true
  );
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    throw new AssertionError(
      msgPrefix + "the argument to above must be a date",
      void 0,
      ssfi
    );
  if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    throw new AssertionError(
      msgPrefix + "the argument to above must be a number",
      void 0,
      ssfi
    );
  if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(
      msgPrefix + "expected " + printObj + " to be a number or a date",
      void 0,
      ssfi
    );
  }
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount > n2,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj > n2,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n2
    );
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to least must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to least must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = false;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= n2,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj >= n2,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n2
    );
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to below must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to below must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = false;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount < n2,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj < n2,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n2
    );
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to most must be a date";
  else if (!isNumeric(n2) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to most must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = false;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount <= n2,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else
    this.assert(
      obj <= n2,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n2
    );
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && (startType !== "date" || finishType !== "date"))
    errorMessage = msgPrefix + "the arguments to within must be dates";
  else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    let printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = false;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    let descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
});
function assertInstanceOf(constructor, msg) {
  msg && flag2(this, "message", msg);
  let target = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), isInstanceOf;
  try {
    isInstanceOf = target instanceof constructor;
  } catch (err) {
    throw err instanceof TypeError ? (flagMsg = flagMsg ? flagMsg + ": " : "", new AssertionError(
      flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
      void 0,
      ssfi
    )) : err;
  }
  let name = getName(constructor);
  name == null && (name = "an unnamed constructor"), this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  msg && flag2(this, "message", msg);
  let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  if (flagMsg = flagMsg ? flagMsg + ": " : "", isNested) {
    if (nameType !== "string")
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
  } else if (nameType !== "string" && nameType !== "number" && nameType !== "symbol")
    throw new AssertionError(
      flagMsg + "the argument to property must be a string, number, or symbol",
      void 0,
      ssfi
    );
  if (isNested && isOwn)
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  if (obj == null)
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2, descriptor = "";
  isDeep && (descriptor += "deep "), isOwn && (descriptor += "own "), isNested && (descriptor += "nested "), descriptor += "property ";
  let hasProperty2;
  isOwn ? hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name) : isNested ? hasProperty2 = pathInfo.exists : hasProperty2 = hasProperty(obj, name), (!negate || arguments.length === 1) && this.assert(
    hasProperty2,
    "expected #{this} to have " + descriptor + inspect22(name),
    "expected #{this} to not have " + descriptor + inspect22(name)
  ), arguments.length > 1 && this.assert(
    hasProperty2 && isEql(val, value),
    "expected #{this} to have " + descriptor + inspect22(name) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + descriptor + inspect22(name) + " of #{act}",
    val,
    value
  ), flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
  flag2(this, "own", true), assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  typeof descriptor == "string" && (msg = descriptor, descriptor = null), msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name), eql = flag2(this, "eql");
  actualDescriptor && descriptor ? this.assert(
    eql(descriptor, actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to match " + inspect22(descriptor) + ", got " + inspect22(actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to not match " + inspect22(descriptor),
    descriptor,
    actualDescriptor,
    true
  ) : this.assert(
    actualDescriptor,
    "expected #{this} to have an own property descriptor for " + inspect22(name),
    "expected #{this} to not have an own property descriptor for " + inspect22(name)
  ), flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size", itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n2,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n2,
    itemsCount
  );
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    re.exec(obj),
    "expected #{this} to match " + re,
    "expected #{this} not to match " + re
  );
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str2, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string"), this.assert(
    ~obj.indexOf(str2),
    "expected #{this} to contain " + inspect22(str2),
    "expected #{this} to not contain " + inspect22(str2)
  );
});
function assertKeys(keys2) {
  let obj = flag2(this, "object"), objType = type(obj), keysType = type(keys2), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str2, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set")
    deepStr = isDeep ? "deeply " : "", actual = [], obj.forEach(function(val, key) {
      actual.push(key);
    }), keysType !== "Array" && (keys2 = Array.prototype.slice.call(arguments));
  else {
    switch (actual = getOwnEnumerableProperties(obj), keysType) {
      case "Array":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        keys2 = Object.keys(keys2);
        break;
      default:
        keys2 = Array.prototype.slice.call(arguments);
    }
    keys2 = keys2.map(function(val) {
      return typeof val == "symbol" ? val : String(val);
    });
  }
  if (!keys2.length)
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  let len = keys2.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys2, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all && (all = true), any && (ok = expected.some(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  })), all && (ok = expected.every(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  }), flag2(this, "contains") || (ok = ok && keys2.length == actual.length)), len > 1) {
    keys2 = keys2.map(function(key) {
      return inspect22(key);
    });
    let last = keys2.pop();
    all && (str2 = keys2.join(", ") + ", and " + last), any && (str2 = keys2.join(", ") + ", or " + last);
  } else
    str2 = inspect22(keys2[0]);
  str2 = (len > 1 ? "keys " : "key ") + str2, str2 = (flag2(this, "contains") ? "contain " : "have ") + str2, this.assert(
    ok,
    "expected #{this} to " + deepStr + str2,
    "expected #{this} to not " + deepStr + str2,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    true
  );
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function"), (isRegExp2(errorLike) || typeof errorLike == "string") && (errMsgMatcher = errorLike, errorLike = null);
  let caughtErr, errorWasThrown = false;
  try {
    obj();
  } catch (err) {
    errorWasThrown = true, caughtErr = err;
  }
  let everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0, everyArgIsDefined = !!(errorLike && errMsgMatcher), errorLikeFail = false, errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    let errorLikeString = "an error";
    errorLike instanceof Error ? errorLikeString = "#{exp}" : errorLike && (errorLikeString = check_error_exports.getConstructorName(errorLike));
    let actual = caughtErr;
    if (caughtErr instanceof Error)
      actual = caughtErr.toString();
    else if (typeof caughtErr == "string")
      actual = caughtErr;
    else if (caughtErr && (typeof caughtErr == "object" || typeof caughtErr == "function"))
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch {
      }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr && (errorLike instanceof Error && check_error_exports.compatibleInstance(
    caughtErr,
    errorLike
  ) === negate && (everyArgIsDefined && negate ? errorLikeFail = true : this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
    errorLike.toString(),
    caughtErr.toString()
  )), check_error_exports.compatibleConstructor(
    caughtErr,
    errorLike
  ) === negate && (everyArgIsDefined && negate ? errorLikeFail = true : this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
    errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
    caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
  ))), caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    let placeholder = "including";
    isRegExp2(errMsgMatcher) && (placeholder = "matching"), check_error_exports.compatibleMessage(
      caughtErr,
      errMsgMatcher
    ) === negate && (everyArgIsDefined && negate ? errMsgMatcherFail = true : this.assert(
      negate,
      "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + placeholder + " #{exp}",
      errMsgMatcher,
      check_error_exports.getMessage(caughtErr)
    ));
  }
  errorLikeFail && errMsgMatcherFail && this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
    errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
    caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
  ), flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = typeof obj == "function" && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    typeof context == "function",
    "expected #{this} to respond to " + inspect22(method),
    "expected #{this} to not respond to " + inspect22(method)
  );
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), result = matcher(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay(matcher),
    "expected #{this} to not satisfy" + objDisplay(matcher),
    !flag2(this, "negate"),
    result
  );
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.numeric;
  let message = "A `delta` value is required for `closeTo`";
  if (delta == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  if (new Assertion(delta, flagMsg, ssfi, true).is.numeric, message = "A `expected` value is required for `closeTo`", expected == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  new Assertion(expected, flagMsg, ssfi, true).is.numeric;
  let abs = __name((x2) => x2 < 0n ? -x2 : x2, "abs"), strip = __name((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
  this.assert(
    strip(abs(obj - expected)) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains2, ordered) {
  let superset = Array.from(_superset), subset = Array.from(_subset);
  if (!contains2) {
    if (subset.length !== superset.length) return false;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      let matchIdx = superset.indexOf(elem);
      return matchIdx === -1 ? false : (contains2 || superset.splice(matchIdx, 1), true);
    }
    return superset.some(function(elem2, matchIdx) {
      return cmp(elem, elem2) ? (contains2 || superset.splice(matchIdx, 1), true) : false;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable, new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  let contains2 = flag2(this, "contains"), ordered = flag2(this, "ordered"), subject, failMsg, failNegateMsg;
  contains2 ? (subject = ordered ? "an ordered superset" : "a superset", failMsg = "expected #{this} to be " + subject + " of #{exp}", failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}") : (subject = ordered ? "ordered members" : "members", failMsg = "expected #{this} to have the same " + subject + " as #{exp}", failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}");
  let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains2, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    true
  );
});
Assertion.addProperty("iterable", function(msg) {
  msg && flag2(this, "message", msg);
  let obj = flag2(this, "object");
  this.assert(
    obj != null && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  msg && flag2(this, "message", msg);
  let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains2 = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array"), contains2 ? this.assert(
    list.some(function(possibility) {
      return expected.indexOf(possibility) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    list,
    expected
  ) : isDeep ? this.assert(
    list.some(function(possibility) {
      return eql(expected, possibility);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    list,
    expected
  ) : this.assert(
    list.indexOf(expected) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    list,
    expected
  );
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "change"), flag2(this, "realDelta", final !== initial), this.assert(
    initial !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, true).is.a("number"), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "increase"), flag2(this, "realDelta", final - initial), this.assert(
    final - initial > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  let fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  let initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, true).is.a("number"), fn3();
  let final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "decrease"), flag2(this, "realDelta", initial - final), this.assert(
    final - initial < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  msg && flag2(this, "message", msg);
  let msgObj = flag2(this, "deltaMsgObj"), initial = flag2(this, "initialDeltaValue"), final = flag2(this, "finalDeltaValue"), behavior2 = flag2(this, "deltaBehavior"), realDelta = flag2(this, "realDelta"), expression;
  behavior2 === "change" ? expression = Math.abs(final - initial) === Math.abs(delta) : expression = realDelta === Math.abs(delta), this.assert(
    expression,
    "expected " + msgObj + " to " + behavior2 + " by " + delta,
    "expected " + msgObj + " to not " + behavior2 + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  let obj = flag2(this, "object"), isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  let obj = flag2(this, "object"), isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  let obj = flag2(this, "object"), isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(_msg) {
  let obj = flag2(this, "object");
  this.assert(
    typeof obj == "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function compareSubset(expected, actual) {
  return expected === actual ? true : typeof actual != typeof expected ? false : typeof expected != "object" || expected === null ? expected === actual : actual ? Array.isArray(expected) ? Array.isArray(actual) ? expected.every(function(exp) {
    return actual.some(function(act) {
      return compareSubset(exp, act);
    });
  }) : false : expected instanceof Date ? actual instanceof Date ? expected.getTime() === actual.getTime() : false : Object.keys(expected).every(function(key) {
    let expectedValue = expected[key], actualValue = actual[key];
    return typeof expectedValue == "object" && expectedValue !== null && actualValue !== null ? compareSubset(expectedValue, actualValue) : typeof expectedValue == "function" ? expectedValue(actualValue) : actualValue === expectedValue;
  }) : false;
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
  let actual = flag(this, "object"), showDiff = config.showDiff;
  this.assert(
    compareSubset(expected, actual),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    expected,
    actual,
    showDiff
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "expect.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    expect.fail
  );
};
var should_exports = {};
__export2(should_exports, {
  Should: () => Should,
  should: () => should
});
function loadShould() {
  function shouldGetter() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new Assertion(this.valueOf(), null, shouldGetter) : new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value) {
    Object.defineProperty(this, "should", {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  __name(shouldSetter, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: true
  });
  let should2 = {};
  return should2.fail = function(actual, expected, message, operator) {
    throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "should.fail()", new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      should2.fail
    );
  }, should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  }, should2.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.Throw(errt, errs);
  }, should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  }, should2.not = {}, should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  }, should2.not.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.not.Throw(errt, errs);
  }, should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  }, should2.throw = should2.Throw, should2.not.throw = should2.not.Throw, should2;
}
__name(loadShould, "loadShould");
var should = loadShould, Should = loadShould;
function assert(express, errmsg) {
  new Assertion(null, null, assert, true).assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "assert.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    assert.fail
  );
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, true).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.equal, true);
  test22.assert(
    exp == flag(test22, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    true
  );
};
assert.notEqual = function(act, exp, msg) {
  let test22 = new Assertion(act, msg, assert.notEqual, true);
  test22.assert(
    exp != flag(test22, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    true
  );
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, true).is.true;
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, true).is.false;
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, true).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
};
assert.isNotNaN = function(value, message) {
  new Assertion(value, message, assert.isNotNaN, true).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, true).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, true).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
};
assert.isCallable = function(value, message) {
  new Assertion(value, message, assert.isCallable, true).is.callable;
};
assert.isNotCallable = function(value, message) {
  new Assertion(value, message, assert.isNotCallable, true).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, true).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, true).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, true).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
};
assert.isNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNumeric, true).is.numeric;
};
assert.isNotNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumeric, true).is.not.numeric;
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, true).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
};
assert.typeOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.typeOf, true).to.be.a(type32);
};
assert.notTypeOf = function(value, type32, message) {
  new Assertion(value, message, assert.notTypeOf, true).to.not.be.a(type32);
};
assert.instanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type32);
};
assert.notInstanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(
    type32
  );
};
assert.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.include, true).include(inc);
};
assert.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
};
assert.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
};
assert.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
};
assert.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
};
assert.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(
    inc
  );
};
assert.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(
    inc
  );
};
assert.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(
    exp,
    msg,
    assert.notDeepNestedInclude,
    true
  ).not.deep.nested.include(inc);
};
assert.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
};
assert.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
};
assert.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
};
assert.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(
    inc
  );
};
assert.match = function(exp, re, msg) {
  new Assertion(exp, msg, assert.match, true).to.match(re);
};
assert.notMatch = function(exp, re, msg) {
  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, true).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(
    prop,
    val
  );
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(
    prop,
    val
  );
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepPropertyVal,
    true
  ).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(
    prop
  );
};
assert.ownPropertyVal = function(obj, prop, value, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(
    prop,
    value
  );
};
assert.notOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notOwnPropertyVal,
    true
  ).to.not.have.own.property(prop, value);
};
assert.deepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepOwnPropertyVal,
    true
  ).to.have.deep.own.property(prop, value);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepOwnPropertyVal,
    true
  ).to.not.have.deep.own.property(prop, value);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(
    prop
  );
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedProperty,
    true
  ).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.nestedPropertyVal,
    true
  ).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notNestedPropertyVal,
    true
  ).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.deepNestedPropertyVal,
    true
  ).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert.notDeepNestedPropertyVal,
    true
  ).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys2);
};
assert.hasAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys2);
};
assert.containsAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(
    keys2
  );
};
assert.doesNotHaveAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(
    keys2
  );
};
assert.doesNotHaveAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(
    keys2
  );
};
assert.hasAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(
    keys2
  );
};
assert.hasAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(
    keys2
  );
};
assert.containsAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.containsAllDeepKeys,
    true
  ).to.contain.all.deep.keys(keys2);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAnyDeepKeys,
    true
  ).to.not.have.any.deep.keys(keys2);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert.doesNotHaveAllDeepKeys,
    true
  ).to.not.have.all.deep.keys(keys2);
};
assert.throws = function(fn3, errorLike, errMsgMatcher, msg) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null);
  let assertErr = new Assertion(fn3, msg, assert.throws, true).to.throw(
    errorLike,
    errMsgMatcher
  );
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn3, errorLike, errMsgMatcher, message) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null), new Assertion(fn3, message, assert.doesNotThrow, true).to.not.throw(
    errorLike,
    errMsgMatcher
  );
};
assert.operator = function(val, operator, val2, msg) {
  let ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      throw msg = msg && msg + ": ", new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert.operator
      );
  }
  let test22 = new Assertion(ok, msg, assert.operator, true);
  test22.assert(
    flag(test22, "object") === true,
    "expected " + inspect22(val) + " to be " + operator + " " + inspect22(val2),
    "expected " + inspect22(val) + " to not be " + operator + " " + inspect22(val2)
  );
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, true).to.be.approximately(
    exp,
    delta
  );
};
assert.sameMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
};
assert.notSameMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameMembers,
    true
  ).to.not.have.same.members(set2);
};
assert.sameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepMembers,
    true
  ).to.have.same.deep.members(set2);
};
assert.notSameDeepMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepMembers,
    true
  ).to.not.have.same.deep.members(set2);
};
assert.sameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameOrderedMembers,
    true
  ).to.have.same.ordered.members(set2);
};
assert.notSameOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameOrderedMembers,
    true
  ).to.not.have.same.ordered.members(set2);
};
assert.sameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.sameDeepOrderedMembers,
    true
  ).to.have.same.deep.ordered.members(set2);
};
assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(
    set1,
    msg,
    assert.notSameDeepOrderedMembers,
    true
  ).to.not.have.same.deep.ordered.members(set2);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, true).to.include.members(
    subset
  );
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeMembers,
    true
  ).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepMembers,
    true
  ).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepMembers,
    true
  ).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeOrderedMembers,
    true
  ).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeOrderedMembers,
    true
  ).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.includeDeepOrderedMembers,
    true
  ).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert.notIncludeDeepOrderedMembers,
    true
  ).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == null || !obj[Symbol.iterator])
    throw msg = msg ? `${msg} expected ${inspect22(obj)} to be an iterable` : `expected ${inspect22(obj)} to be an iterable`, new AssertionError(msg, void 0, assert.isIterable);
};
assert.changes = function(fn3, obj, prop, msg) {
  arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.changes, true).to.change(obj, prop);
};
assert.changesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotChange, true).to.not.change(
    obj,
    prop
  );
};
assert.changesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.increases, true).to.increase(obj, prop);
};
assert.increasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotIncrease, true).to.not.increase(
    obj,
    prop
  );
};
assert.increasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.decreases, true).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotDecrease, true).to.not.decrease(
    obj,
    prop
  );
};
assert.doesNotDecreaseBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  return new Assertion(fn3, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    let tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val)
    throw val;
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
};
assert.containsSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.containSubset(exp);
};
assert.doesNotContainSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (let [name, as] of aliases)
  assert[as] = assert[name];
var used = [];
function use(fn3) {
  let exports = {
    use,
    AssertionError,
    util: utils_exports,
    config,
    expect,
    assert,
    Assertion,
    ...should_exports
  };
  return ~used.indexOf(fn3) || (fn3(exports, utils_exports), used.push(fn3)), exports;
}
__name(use, "use");
var matchers_exports = {};
__export$4(matchers_exports, {
  toAppearAfter: () => toAppearAfter,
  toAppearBefore: () => toAppearBefore,
  toBeChecked: () => toBeChecked,
  toBeDisabled: () => toBeDisabled,
  toBeEmpty: () => toBeEmpty,
  toBeEmptyDOMElement: () => toBeEmptyDOMElement,
  toBeEnabled: () => toBeEnabled,
  toBeInTheDOM: () => toBeInTheDOM,
  toBeInTheDocument: () => toBeInTheDocument,
  toBeInvalid: () => toBeInvalid,
  toBePartiallyChecked: () => toBePartiallyChecked,
  toBePartiallyPressed: () => toBePartiallyPressed,
  toBePressed: () => toBePressed,
  toBeRequired: () => toBeRequired,
  toBeValid: () => toBeValid,
  toBeVisible: () => toBeVisible,
  toContainElement: () => toContainElement,
  toContainHTML: () => toContainHTML,
  toHaveAccessibleDescription: () => toHaveAccessibleDescription,
  toHaveAccessibleErrorMessage: () => toHaveAccessibleErrorMessage,
  toHaveAccessibleName: () => toHaveAccessibleName,
  toHaveAttribute: () => toHaveAttribute,
  toHaveClass: () => toHaveClass,
  toHaveDescription: () => toHaveDescription,
  toHaveDisplayValue: () => toHaveDisplayValue,
  toHaveErrorMessage: () => toHaveErrorMessage,
  toHaveFocus: () => toHaveFocus,
  toHaveFormValues: () => toHaveFormValues,
  toHaveRole: () => toHaveRole,
  toHaveSelection: () => toHaveSelection,
  toHaveStyle: () => toHaveStyle,
  toHaveTextContent: () => toHaveTextContent,
  toHaveValue: () => toHaveValue
});
var import_redent = __toESM$3(require_redent(), 1);
var t$1 = class t extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(t22, e2, i2, s3, n2) {
    super(`${t22}:${i2}:${s3}: ${e2}`), this.reason = e2, this.filename = t22, this.line = i2, this.column = s3, this.source = n2;
  }
}, e = class {
  start;
  end;
  source;
  constructor(t22, e2, i2) {
    this.start = t22, this.end = e2, this.source = i2;
  }
}, i;
(function(t22) {
  t22.stylesheet = "stylesheet", t22.rule = "rule", t22.declaration = "declaration", t22.comment = "comment", t22.container = "container", t22.charset = "charset", t22.document = "document", t22.customMedia = "custom-media", t22.fontFace = "font-face", t22.host = "host", t22.import = "import", t22.keyframes = "keyframes", t22.keyframe = "keyframe", t22.layer = "layer", t22.media = "media", t22.namespace = "namespace", t22.page = "page", t22.startingStyle = "starting-style", t22.supports = "supports";
})(i || (i = {}));
var s2 = (t22, e2, i2) => {
  let s3 = i2, n2 = 1e4;
  do {
    let i3 = e2.map((e3) => t22.indexOf(e3, s3));
    i3.push(t22.indexOf("\\", s3));
    let r2 = i3.filter((t3) => t3 !== -1);
    if (r2.length === 0) return -1;
    let o2 = Math.min(...r2);
    if (t22[o2] !== "\\") return o2;
    s3 = o2 + 2, n2--;
  } while (n2 > 0);
  throw new Error("Too many escaping");
}, n = (t22, e2, i2) => {
  let r2 = i2, o2 = 1e4;
  do {
    let i3 = e2.map((e3) => t22.indexOf(e3, r2));
    i3.push(t22.indexOf("(", r2)), i3.push(t22.indexOf('"', r2)), i3.push(t22.indexOf("'", r2)), i3.push(t22.indexOf("\\", r2));
    let c2 = i3.filter((t3) => t3 !== -1);
    if (c2.length === 0) return -1;
    let a2 = Math.min(...c2);
    switch (t22[a2]) {
      case "\\":
        r2 = a2 + 2;
        break;
      case "(":
        {
          let e3 = n(t22, [")"], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      case '"':
        {
          let e3 = s2(t22, ['"'], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      case "'":
        {
          let e3 = s2(t22, ["'"], a2 + 1);
          if (e3 === -1) return -1;
          r2 = e3 + 1;
        }
        break;
      default:
        return a2;
    }
    o2--;
  } while (o2 > 0);
  throw new Error("Too many escaping");
}, r = /\/\*[^]*?(?:\*\/|$)/g;
function o(t22) {
  return t22 ? t22.trim() : "";
}
function c(t22, e2) {
  let i2 = t22 && typeof t22.type == "string", s3 = i2 ? t22 : e2;
  for (let e3 in t22) {
    let i3 = t22[e3];
    Array.isArray(i3) ? i3.forEach((t3) => {
      c(t3, s3);
    }) : i3 && typeof i3 == "object" && c(i3, s3);
  }
  return i2 && Object.defineProperty(t22, "parent", { configurable: true, writable: true, enumerable: false, value: e2 || null }), t22;
}
var m2 = (s3, a2) => {
  a2 = a2 || {};
  let m3 = 1, h3 = 1;
  function u3() {
    let t22 = { line: m3, column: h3 };
    return (i2) => (i2.position = new e(t22, { line: m3, column: h3 }, a2?.source || ""), $(), i2);
  }
  let p2 = [];
  function l2(e2) {
    let i2 = new t$1(a2?.source || "", e2, m3, h3, s3);
    if (!a2?.silent) throw i2;
    p2.push(i2);
  }
  function f4() {
    let t22 = /^{\s*/.exec(s3);
    return !!t22 && (g2(t22), true);
  }
  function d() {
    let t22 = /^}/.exec(s3);
    return !!t22 && (g2(t22), true);
  }
  function y2() {
    let t22, e2 = [];
    for ($(), x2(e2); s3.length && s3.charAt(0) !== "}" && (t22 = A() || S2(), t22); ) e2.push(t22), x2(e2);
    return e2;
  }
  function g2(t22) {
    let e2 = t22[0];
    return function(t3) {
      let e3 = t3.match(/\n/g);
      e3 && (m3 += e3.length);
      let i2 = t3.lastIndexOf(`
`);
      h3 = ~i2 ? t3.length - i2 : h3 + t3.length;
    }(e2), s3 = s3.slice(e2.length), t22;
  }
  function $() {
    let t22 = /^\s*/.exec(s3);
    t22 && g2(t22);
  }
  function x2(t22) {
    t22 = t22 || [];
    let e2 = V();
    for (; e2; ) t22.push(e2), e2 = V();
    return t22;
  }
  function V() {
    let t22 = u3();
    if (s3.charAt(0) !== "/" || s3.charAt(1) !== "*") return;
    let e2 = /^\/\*[^]*?\*\//.exec(s3);
    return e2 ? (g2(e2), t22({ type: i.comment, comment: e2[0].slice(2, -2) })) : l2("End of comment missing");
  }
  function k2() {
    let t22 = /^([^{]+)/.exec(s3);
    if (t22)
      return g2(t22), ((t3, e2) => {
        let i2 = [], s4 = 0;
        for (; s4 < t3.length; ) {
          let r2 = n(t3, e2, s4);
          if (r2 === -1) return i2.push(t3.substring(s4)), i2;
          i2.push(t3.substring(s4, r2)), s4 = r2 + 1;
        }
        return i2;
      })(o(t22[0]).replace(r, ""), [","]).map((t3) => o(t3));
  }
  function v2() {
    let t22 = u3(), e2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(s3);
    if (!e2) return;
    g2(e2);
    let c2 = o(e2[0]), a3 = /^:\s*/.exec(s3);
    if (!a3) return l2("property missing ':'");
    g2(a3);
    let m4 = "", h4 = n(s3, [";", "}"]);
    h4 !== -1 && (m4 = s3.substring(0, h4), g2([m4]), m4 = o(m4).replace(r, ""));
    let p3 = t22({ type: i.declaration, property: c2.replace(r, ""), value: m4 }), f5 = /^[;\s]*/.exec(s3);
    return f5 && g2(f5), p3;
  }
  function w2() {
    let t22 = [];
    if (!f4()) return l2("missing '{'");
    x2(t22);
    let e2 = v2();
    for (; e2; ) t22.push(e2), x2(t22), e2 = v2();
    return d() ? t22 : l2("missing '}'");
  }
  function b2() {
    let t22 = [], e2 = u3(), n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    for (; n2; ) {
      let e3 = g2(n2);
      t22.push(e3[1]);
      let i2 = /^,\s*/.exec(s3);
      i2 && g2(i2), n2 = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(s3);
    }
    if (t22.length) return e2({ type: i.keyframe, values: t22, declarations: w2() || [] });
  }
  let j2 = M2("import"), O = M2("charset"), E2 = M2("namespace");
  function M2(t22) {
    let e2 = new RegExp("^@" + t22 + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      let i2 = u3(), n2 = e2.exec(s3);
      if (!n2) return;
      let r2 = g2(n2), o2 = { type: t22 };
      return o2[t22] = r2[1].trim(), i2(o2);
    };
  }
  function A() {
    if (s3[0] === "@") return function() {
      let t22 = u3(), e2 = /^@([-\w]+)?keyframes\s*/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2)[1], r2 = /^([-\w]+)\s*/.exec(s3);
      if (!r2) return l2("@keyframes missing name");
      let o2 = g2(r2)[1];
      if (!f4()) return l2("@keyframes missing '{'");
      let c2 = x2(), a3 = b2();
      for (; a3; ) c2.push(a3), c2 = c2.concat(x2()), a3 = b2();
      return d() ? t22({ type: i.keyframes, name: o2, vendor: n2, keyframes: c2 }) : l2("@keyframes missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@media *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@media missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t22({ type: i.media, media: n2, rules: r2 }) : l2("@media missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2);
      return t22({ type: i.customMedia, name: o(n2[1]), media: o(n2[2]) });
    }() || function() {
      let t22 = u3(), e2 = /^@supports *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@supports missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t22({ type: i.supports, supports: n2, rules: r2 }) : l2("@supports missing '}'");
    }() || j2() || O() || E2() || function() {
      let t22 = u3(), e2 = /^@([-\w]+)?document *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = g2(e2), r2 = o(n2[1]), c2 = o(n2[2]);
      if (!f4()) return l2("@document missing '{'");
      let a3 = x2().concat(y2());
      return d() ? t22({ type: i.document, document: c2, vendor: r2, rules: a3 }) : l2("@document missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@page */.exec(s3);
      if (!e2) return;
      g2(e2);
      let n2 = k2() || [];
      if (!f4()) return l2("@page missing '{'");
      let r2 = x2(), o2 = v2();
      for (; o2; ) r2.push(o2), r2 = r2.concat(x2()), o2 = v2();
      return d() ? t22({ type: i.page, selectors: n2, declarations: r2 }) : l2("@page missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@host\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@host missing '{'");
      let n2 = x2().concat(y2());
      return d() ? t22({ type: i.host, rules: n2 }) : l2("@host missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@font-face\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@font-face missing '{'");
      let n2 = x2(), r2 = v2();
      for (; r2; ) n2.push(r2), n2 = n2.concat(x2()), r2 = v2();
      return d() ? t22({ type: i.fontFace, declarations: n2 }) : l2("@font-face missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@container *([^{]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) return l2("@container missing '{'");
      let r2 = x2().concat(y2());
      return d() ? t22({ type: i.container, container: n2, rules: r2 }) : l2("@container missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@starting-style\s*/.exec(s3);
      if (!e2) return;
      if (g2(e2), !f4()) return l2("@starting-style missing '{'");
      let n2 = x2().concat(y2());
      return d() ? t22({ type: i.startingStyle, rules: n2 }) : l2("@starting-style missing '}'");
    }() || function() {
      let t22 = u3(), e2 = /^@layer *([^{;@]+)/.exec(s3);
      if (!e2) return;
      let n2 = o(g2(e2)[1]);
      if (!f4()) {
        let e3 = /^[;\s]*/.exec(s3);
        return e3 && g2(e3), t22({ type: i.layer, layer: n2 });
      }
      let r2 = x2().concat(y2());
      return d() ? t22({ type: i.layer, layer: n2, rules: r2 }) : l2("@layer missing '}'");
    }();
  }
  function S2() {
    let t22 = u3(), e2 = k2();
    return e2 ? (x2(), t22({ type: i.rule, selectors: e2, declarations: w2() || [] })) : l2("selector missing");
  }
  return c(function() {
    let t22 = y2();
    return { type: i.stylesheet, stylesheet: { source: a2?.source, rules: t22, parsingErrors: p2 } };
  }());
};
var toStr = Object.prototype.toString;
function isCallable(fn3) {
  return typeof fn3 == "function" || toStr.call(fn3) === "[object Function]";
}
function toInteger(value) {
  var number = Number(value);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(value) {
  var len = toInteger(value);
  return Math.min(Math.max(len, 0), maxSafeInteger);
}
function arrayFrom(arrayLike, mapFn) {
  var C2 = Array, items = Object(arrayLike);
  if (arrayLike == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  for (var len = toLength(items.length), A = isCallable(C2) ? Object(new C2(len)) : new Array(len), k2 = 0, kValue; k2 < len; )
    kValue = items[k2], A[k2] = kValue, k2 += 1;
  return A.length = len, A;
}
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
}
function _defineProperty$1(obj, key, value) {
  return key = _toPropertyKey$1(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }) : obj[key] = value, obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _toPrimitive$1(input2, hint) {
  if (_typeof$1(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint);
    if (_typeof$1(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, SetLike3), _defineProperty$1(this, "items", void 0), this.items = items;
  }
  return _createClass(SetLike3, [{
    key: "add",
    value: function(value) {
      return this.has(value) === false && this.items.push(value), this;
    }
  }, {
    key: "clear",
    value: function() {
      this.items = [];
    }
  }, {
    key: "delete",
    value: function(value) {
      var previousLength = this.items.length;
      return this.items = this.items.filter(function(item) {
        return item !== value;
      }), previousLength !== this.items.length;
    }
  }, {
    key: "forEach",
    value: function(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }
  }, {
    key: "has",
    value: function(value) {
      return this.items.indexOf(value) !== -1;
    }
  }, {
    key: "size",
    get: function() {
      return this.items.length;
    }
  }]), SetLike3;
}(), SetLike_default = typeof Set > "u" ? Set : SetLike;
function getLocalName(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
var localNameToRoleMappings = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, prohibitedAttributes = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole(element, implicitRole) {
  return hasGlobalAriaAttributes(element, implicitRole);
}
function getRole(element) {
  var explicitRole = getExplicitRole(element);
  if (explicitRole === null || presentationRoles.indexOf(explicitRole) !== -1) {
    var implicitRole = getImplicitRole(element);
    if (presentationRoles.indexOf(explicitRole || "") === -1 || ignorePresentationalRole(element, implicitRole || ""))
      return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole(element) {
  var mappedByTag = localNameToRoleMappings[getLocalName(element)];
  if (mappedByTag !== void 0)
    return mappedByTag;
  switch (getLocalName(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0)
      return explicitRole;
  }
  return null;
}
var presentationRoles = ["presentation", "none"];
function isElement$1(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement(node) {
  return isElement$1(node) && getLocalName(node) === "caption";
}
function isHTMLInputElement(node) {
  return isElement$1(node) && getLocalName(node) === "input";
}
function isHTMLOptGroupElement(node) {
  return isElement$1(node) && getLocalName(node) === "optgroup";
}
function isHTMLSelectElement(node) {
  return isElement$1(node) && getLocalName(node) === "select";
}
function isHTMLTableElement(node) {
  return isElement$1(node) && getLocalName(node) === "table";
}
function isHTMLTextAreaElement(node) {
  return isElement$1(node) && getLocalName(node) === "textarea";
}
function safeWindow(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null)
    throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement(node) {
  return isElement$1(node) && getLocalName(node) === "fieldset";
}
function isHTMLLegendElement(node) {
  return isElement$1(node) && getLocalName(node) === "legend";
}
function isHTMLSlotElement(node) {
  return isElement$1(node) && getLocalName(node) === "slot";
}
function isSVGElement(node) {
  return isElement$1(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement(node) {
  return isElement$1(node) && getLocalName(node) === "svg";
}
function isSVGTitleElement(node) {
  return isSVGElement(node) && getLocalName(node) === "title";
}
function queryIdRefs(node, attributeName) {
  if (isElement$1(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
function hasAnyConcreteRoles(node, roles3) {
  return isElement$1(node) ? roles3.indexOf(getRole(node)) !== -1 : false;
}
function asFlatString(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
function isHidden$1(node, getComputedStyleImplementation) {
  if (!isElement$1(node))
    return false;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true")
    return true;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl(node) {
  return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
}
function hasAbstractRole(node, role) {
  if (!isElement$1(node))
    return false;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree(element, selectors) {
  var elements2 = arrayFrom(element.querySelectorAll(selectors));
  return queryIdRefs(element, "aria-owns").forEach(function(root2) {
    elements2.push.apply(elements2, arrayFrom(root2.querySelectorAll(selectors)));
  }), elements2;
}
function querySelectedOptions(listbox) {
  return isHTMLSelectElement(listbox) ? listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]") : querySelectorAllSubtree(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational(node) {
  return hasAnyConcreteRoles(node, presentationRoles);
}
function isNativeHostLanguageTextAlternativeElement(node) {
  return isHTMLTableCaptionElement(node);
}
function allowsNameFromContent(node) {
  return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement(node) {
  return false;
}
function getValueOfTextbox(element) {
  return isHTMLInputElement(element) || isHTMLTextAreaElement(element) ? element.value : element.textContent || "";
}
function getTextualContent(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement(element) {
  var localName = getLocalName(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement(element) {
  if (isLabelableElement(element))
    return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement$1(childNode)) {
      var descendantLabelableElement = findLabelableElement(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel(label) {
  if (label.control !== void 0)
    return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement(label);
}
function getLabels(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null)
    return labelsProperty;
  if (labelsProperty !== void 0)
    return arrayFrom(labelsProperty);
  if (!isLabelableElement(element))
    return null;
  var document7 = element.ownerDocument;
  return arrayFrom(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel(label) === element;
  });
}
function getSlotContents(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom(slot.childNodes) : assignedNodes;
}
function computeTextAlternative(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default(), window2 = safeWindow(root2), _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement$1(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before"), beforeContent = getTextualContent(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      }), display2 = isElement$1(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    }), isElement$1(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after"), afterContent = getTextualContent(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement$1(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement$1(node))
      return null;
    if (isHTMLFieldSetElement(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom(node.childNodes), i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement(child))
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (isHTMLTableElement(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement(_child))
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (isSVGSVGElement(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement(_child2))
          return _child2.textContent;
      }
      return null;
    } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null)
        return nameFromAlt;
    } else if (isHTMLOptGroupElement(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null)
        return nameFromLabel;
    }
    if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null)
        return nameFromValue;
      if (node.type === "submit")
        return "Submit";
      if (node.type === "reset")
        return "Reset";
    }
    var labels = getLabels(node);
    if (labels !== null && labels.length !== 0)
      return consultedNodes.add(node), arrayFrom(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    if (isHTMLInputElement(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null)
        return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: false
      });
      if (nameFromSubTree !== "")
        return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current))
      return "";
    if (!hidden && isHidden$1(current, getComputedStyle2) && !context.isReferenced)
      return consultedNodes.add(current), "";
    var labelAttributeNode = isElement$1(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0)
      return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    var skipToStep2E = context.recursion && isControl(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement$1(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name")
        return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null)
          return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles(current, ["menu"]))
      return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions(current);
        return selectedOptions.length === 0 ? isHTMLInputElement(current) ? current.value : "" : arrayFrom(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (hasAbstractRole(current, "range"))
        return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles(current, ["textbox"]))
        return consultedNodes.add(current), getValueOfTextbox(current);
    }
    if (allowsNameFromContent(current) || isElement$1(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement()) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel
      });
      if (accumulatedText2F !== "")
        return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE)
      return consultedNodes.add(current), current.textContent || "";
    if (context.recursion)
      return consultedNodes.add(current), computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel
      });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString(computeTextAlternative3(root2, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: false
  }));
}
function _typeof2(o2) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof2(o2);
}
function ownKeys$1(e2, r2) {
  var t22 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t22.push.apply(t22, o2);
  }
  return t22;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t22 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t22), true).forEach(function(r3) {
      _defineProperty2(e2, r3, t22[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t22)) : ownKeys$1(Object(t22)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t22, r3));
    });
  }
  return e2;
}
function _defineProperty2(obj, key, value) {
  return key = _toPropertyKey2(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }) : obj[key] = value, obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
function _toPrimitive2(input2, hint) {
  if (_typeof2(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint);
    if (_typeof2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative(element, _objectSpread(_objectSpread({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var ariaDescription = root2.getAttribute("aria-description");
    description = ariaDescription === null ? "" : ariaDescription;
  }
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
function prohibitsNaming(node) {
  return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming(root2) ? "" : computeTextAlternative(root2, options);
}
var import_aria_query = __toESM$3(require_lib(), 1), import_picocolors = __toESM$3(require_picocolors_browser(), 1), import_css = __toESM$3(require_css_escape(), 1), GenericTypeError = class extends Error {
  constructor(expectedString, received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn);
    let withType = "";
    try {
      withType = context.utils.printWithType(
        "Received",
        received,
        context.utils.printReceived
      );
    } catch {
    }
    this.message = [
      context.utils.matcherHint(
        `${context.isNot ? ".not" : ""}.${matcherFn.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${context.utils.RECEIVED_COLOR(
        "received"
      )} value must ${expectedString}.`,
      withType
    ].join(`
`);
  }
}, HtmlElementTypeError = class extends GenericTypeError {
  constructor(...args) {
    super("be an HTMLElement or an SVGElement", ...args);
  }
}, NodeTypeError = class extends GenericTypeError {
  constructor(...args) {
    super("be a Node", ...args);
  }
};
function checkHasWindow(htmlElement, ErrorClass, ...args) {
  if (!htmlElement || !htmlElement.ownerDocument || !htmlElement.ownerDocument.defaultView)
    throw new ErrorClass(htmlElement, ...args);
}
function checkNode(node, ...args) {
  checkHasWindow(node, NodeTypeError, ...args);
  let window2 = node.ownerDocument.defaultView;
  if (!(node instanceof window2.Node))
    throw new NodeTypeError(node, ...args);
}
function checkHtmlElement(htmlElement, ...args) {
  checkHasWindow(htmlElement, HtmlElementTypeError, ...args);
  let window2 = htmlElement.ownerDocument.defaultView;
  if (!(htmlElement instanceof window2.HTMLElement) && !(htmlElement instanceof window2.SVGElement))
    throw new HtmlElementTypeError(htmlElement, ...args);
}
var InvalidCSSError = class extends Error {
  constructor(received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn), this.message = [
      received.message,
      "",
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      context.utils.RECEIVED_COLOR(`${received.css}`)
    ].join(`
`);
  }
};
function parseCSS(css2, ...args) {
  let ast = m2(`selector { ${css2} }`, { silent: true }).stylesheet;
  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    let { reason, line } = ast.parsingErrors[0];
    throw new InvalidCSSError(
      {
        css: css2,
        message: `Syntax error parsing expected css: ${reason} on line: ${line}`
      },
      ...args
    );
  }
  return ast.rules[0].declarations.filter((d) => d.type === "declaration").reduce(
    (obj, { property, value }) => Object.assign(obj, { [property]: value }),
    {}
  );
}
function display(context, value) {
  return typeof value == "string" ? value : context.utils.stringify(value);
}
function getMessage3(context, matcher, expectedLabel, expectedValue, receivedLabel, receivedValue) {
  return [
    `${matcher}
`,
    // eslint-disable-next-line new-cap
    `${expectedLabel}:
${context.utils.EXPECTED_COLOR(
      (0, import_redent.default)(display(context, expectedValue), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${receivedLabel}:
${context.utils.RECEIVED_COLOR(
      (0, import_redent.default)(display(context, receivedValue), 2)
    )}`
  ].join(`
`);
}
function matches$1(textToMatch, matcher) {
  return matcher instanceof RegExp ? matcher.test(textToMatch) : textToMatch.includes(String(matcher));
}
function deprecate2(name, replacementText) {
  console.warn(
    `Warning: ${name} has been deprecated and will be removed in future updates.`,
    replacementText
  );
}
function normalize(text) {
  return text.replace(/\s+/g, " ").trim();
}
function getTag$1(element) {
  return element.tagName && element.tagName.toLowerCase();
}
function getSelectValue({ multiple, options }) {
  let selectedOptions = [...options].filter((option) => option.selected);
  if (multiple)
    return [...selectedOptions].map((opt) => opt.value);
  if (selectedOptions.length !== 0)
    return selectedOptions[0].value;
}
function getInputValue(inputElement) {
  switch (inputElement.type) {
    case "number":
      return inputElement.value === "" ? null : Number(inputElement.value);
    case "checkbox":
      return inputElement.checked;
    default:
      return inputElement.value;
  }
}
var rolesSupportingValues = ["meter", "progressbar", "slider", "spinbutton"];
function getAccessibleValue(element) {
  if (rolesSupportingValues.includes(element.getAttribute("role")))
    return Number(element.getAttribute("aria-valuenow"));
}
function getSingleElementValue(element) {
  if (element)
    switch (element.tagName.toLowerCase()) {
      case "input":
        return getInputValue(element);
      case "select":
        return getSelectValue(element);
      default:
        return element.value ?? getAccessibleValue(element);
    }
}
function toSentence(array, { wordConnector = ", ", lastWordConnector = " and " } = {}) {
  return [array.slice(0, -1).join(wordConnector), array[array.length - 1]].join(
    array.length > 1 ? lastWordConnector : ""
  );
}
function compareAsSet(val1, val2) {
  return Array.isArray(val1) && Array.isArray(val2) ? [...new Set(val1)].every((v2) => new Set(val2).has(v2)) : val1 === val2;
}
function toBeInTheDOM(element, container) {
  return deprecate2(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), element && checkHtmlElement(element, toBeInTheDOM, this), container && checkHtmlElement(container, toBeInTheDOM, this), {
    pass: container ? container.contains(element) : !!element,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        element && element.cloneNode(false)
      )}`
    ].join(`
`)
  };
}
function toBeInTheDocument(element) {
  (element !== null || !this.isNot) && checkHtmlElement(element, toBeInTheDocument, this);
  let pass = element === null ? false : element.ownerDocument === element.getRootNode({ composed: true }), errorFound = () => `expected document not to contain element, found ${this.utils.stringify(
    element.cloneNode(true)
  )} instead`, errorNotFound = () => "element could not be found in the document";
  return {
    pass,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? errorFound() : errorNotFound())
    ].join(`
`)
  };
}
function toBeEmpty(element) {
  return deprecate2(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), checkHtmlElement(element, toBeEmpty, this), {
    pass: element.innerHTML === "",
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(element.innerHTML)}`
    ].join(`
`)
  };
}
function toBeEmptyDOMElement(element) {
  return checkHtmlElement(element, toBeEmptyDOMElement, this), {
    pass: isEmptyElement(element),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(element.innerHTML)}`
    ].join(`
`)
  };
}
function isEmptyElement(element) {
  return [...element.childNodes].filter((node) => node.nodeType !== 8).length === 0;
}
function toContainElement(container, element) {
  return checkHtmlElement(container, toContainElement, this), element !== null && checkHtmlElement(element, toContainElement, this), {
    pass: container.contains(element),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        container.cloneNode(false)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(element && element.cloneNode(false))}
        `)
    ].join(`
`)
  };
}
function getNormalizedHtml(container, htmlText) {
  let div = container.ownerDocument.createElement("div");
  return div.innerHTML = htmlText, div.innerHTML;
}
function toContainHTML(container, htmlText) {
  if (checkHtmlElement(container, toContainHTML, this), typeof htmlText != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${htmlText}`);
  return {
    pass: container.outerHTML.includes(getNormalizedHtml(container, htmlText)),
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(htmlText)}`,
      "Received:",
      `  ${this.utils.printReceived(container.cloneNode(true))}`
    ].join(`
`)
  };
}
function toHaveTextContent(node, checkWith, options = { normalizeWhitespace: true }) {
  checkNode(node, toHaveTextContent, this);
  let textContent = options.normalizeWhitespace ? normalize(node.textContent) : node.textContent.replace(/\u00a0/g, " "), checkingWithEmptyString = textContent !== "" && checkWith === "";
  return {
    pass: !checkingWithEmptyString && matches$1(textContent, checkWith),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        checkingWithEmptyString ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${to} have text content`,
        checkWith,
        "Received",
        textContent
      );
    }
  };
}
function toHaveAccessibleDescription(htmlElement, expectedAccessibleDescription) {
  checkHtmlElement(htmlElement, toHaveAccessibleDescription, this);
  let actualAccessibleDescription = computeAccessibleDescription(htmlElement), missingExpectedValue = arguments.length === 1, pass = false;
  return missingExpectedValue ? pass = actualAccessibleDescription !== "" : pass = expectedAccessibleDescription instanceof RegExp ? expectedAccessibleDescription.test(actualAccessibleDescription) : this.equals(
    actualAccessibleDescription,
    expectedAccessibleDescription
  ), {
    pass,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleDescription.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible description`,
        expectedAccessibleDescription,
        "Received",
        actualAccessibleDescription
      );
    }
  };
}
var ariaInvalidName = "aria-invalid", validStates = ["false"];
function toHaveAccessibleErrorMessage(htmlElement, expectedAccessibleErrorMessage) {
  checkHtmlElement(htmlElement, toHaveAccessibleErrorMessage, this);
  let to = this.isNot ? "not to" : "to", method = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", errormessageId = htmlElement.getAttribute("aria-errormessage");
  if (!!errormessageId && /\s+/.test(errormessageId))
    return {
      pass: false,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(method, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${errormessageId}"`
      )
    };
  let ariaInvalidVal = htmlElement.getAttribute(ariaInvalidName);
  if (!htmlElement.hasAttribute(ariaInvalidName) || validStates.includes(ariaInvalidVal))
    return {
      pass: false,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(method, "element"),
        "Expected element to be marked as invalid with attribute",
        `${ariaInvalidName}="${String(true)}"`,
        "Received",
        htmlElement.hasAttribute("aria-invalid") ? `${ariaInvalidName}="${htmlElement.getAttribute(ariaInvalidName)}` : null
      )
    };
  let error = normalize(
    htmlElement.ownerDocument.getElementById(errormessageId)?.textContent ?? ""
  );
  return {
    pass: expectedAccessibleErrorMessage === void 0 ? !!error : expectedAccessibleErrorMessage instanceof RegExp ? expectedAccessibleErrorMessage.test(error) : this.equals(error, expectedAccessibleErrorMessage),
    message: () => getMessage3(
      this,
      this.utils.matcherHint(method, "element"),
      `Expected element ${to} have accessible error message`,
      expectedAccessibleErrorMessage ?? "",
      "Received",
      error
    )
  };
}
var elementRoleList = buildElementRoleList(import_aria_query.elementRoles);
function toHaveRole(htmlElement, expectedRole) {
  checkHtmlElement(htmlElement, toHaveRole, this);
  let actualRoles = getExplicitOrImplicitRoles(htmlElement);
  return {
    pass: actualRoles.some((el) => el === expectedRole),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveRole.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have role`,
        expectedRole,
        "Received",
        actualRoles.join(", ")
      );
    }
  };
}
function getExplicitOrImplicitRoles(htmlElement) {
  return htmlElement.hasAttribute("role") ? htmlElement.getAttribute("role").split(" ").filter(Boolean) : getImplicitAriaRoles(htmlElement);
}
function getImplicitAriaRoles(currentNode) {
  for (let { match, roles: roles3 } of elementRoleList)
    if (match(currentNode))
      return [...roles3];
  return [];
}
function buildElementRoleList(elementRolesMap) {
  function makeElementSelector({ name, attributes }) {
    return `${name}${attributes.map(({ name: attributeName, value, constraints = [] }) => constraints.indexOf("undefined") !== -1 ? `:not([${attributeName}])` : value ? `[${attributeName}="${value}"]` : `[${attributeName}]`).join("")}`;
  }
  function getSelectorSpecificity({ attributes = [] }) {
    return attributes.length;
  }
  function bySelectorSpecificity({ specificity: leftSpecificity }, { specificity: rightSpecificity }) {
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let { attributes = [] } = element, typeTextIndex = attributes.findIndex(
      (attribute) => attribute.value && attribute.name === "type" && attribute.value === "text"
    );
    typeTextIndex >= 0 && (attributes = [
      ...attributes.slice(0, typeTextIndex),
      ...attributes.slice(typeTextIndex + 1)
    ]);
    let selector = makeElementSelector({ ...element, attributes });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? false : node.matches(selector);
  }
  let result = [];
  for (let [element, roles3] of elementRolesMap.entries())
    result = [
      ...result,
      {
        match: match(element),
        roles: Array.from(roles3),
        specificity: getSelectorSpecificity(element)
      }
    ];
  return result.sort(bySelectorSpecificity);
}
function toHaveAccessibleName(htmlElement, expectedAccessibleName) {
  checkHtmlElement(htmlElement, toHaveAccessibleName, this);
  let actualAccessibleName = computeAccessibleName(htmlElement), missingExpectedValue = arguments.length === 1, pass = false;
  return missingExpectedValue ? pass = actualAccessibleName !== "" : pass = expectedAccessibleName instanceof RegExp ? expectedAccessibleName.test(actualAccessibleName) : this.equals(actualAccessibleName, expectedAccessibleName), {
    pass,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${toHaveAccessibleName.name}`,
          "element",
          ""
        ),
        `Expected element ${to} have accessible name`,
        expectedAccessibleName,
        "Received",
        actualAccessibleName
      );
    }
  };
}
function printAttribute(stringify5, name, value) {
  return value === void 0 ? name : `${name}=${stringify5(value)}`;
}
function getAttributeComment(stringify5, name, value) {
  return value === void 0 ? `element.hasAttribute(${stringify5(name)})` : `element.getAttribute(${stringify5(name)}) === ${stringify5(value)}`;
}
function toHaveAttribute(htmlElement, name, expectedValue) {
  checkHtmlElement(htmlElement, toHaveAttribute, this);
  let isExpectedValuePresent = expectedValue !== void 0, hasAttribute = htmlElement.hasAttribute(name), receivedValue = htmlElement.getAttribute(name);
  return {
    pass: isExpectedValuePresent ? hasAttribute && this.equals(receivedValue, expectedValue) : hasAttribute,
    message: () => {
      let to = this.isNot ? "not to" : "to", receivedAttribute = hasAttribute ? printAttribute(this.utils.stringify, name, receivedValue) : null, matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(name),
        {
          secondArgument: isExpectedValuePresent ? this.utils.printExpected(expectedValue) : void 0,
          comment: getAttributeComment(
            this.utils.stringify,
            name,
            expectedValue
          )
        }
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have attribute`,
        printAttribute(this.utils.stringify, name, expectedValue),
        "Received",
        receivedAttribute
      );
    }
  };
}
function getExpectedClassNamesAndOptions(params) {
  let lastParam = params.pop(), expectedClassNames, options;
  return typeof lastParam == "object" && !(lastParam instanceof RegExp) ? (expectedClassNames = params, options = lastParam) : (expectedClassNames = params.concat(lastParam), options = { exact: false }), { expectedClassNames, options };
}
function splitClassNames(str2) {
  return str2 ? str2.split(/\s+/).filter((s3) => s3.length > 0) : [];
}
function isSubset$1(subset, superset) {
  return subset.every(
    (strOrRegexp) => typeof strOrRegexp == "string" ? superset.includes(strOrRegexp) : superset.some((className) => strOrRegexp.test(className))
  );
}
function toHaveClass(htmlElement, ...params) {
  checkHtmlElement(htmlElement, toHaveClass, this);
  let { expectedClassNames, options } = getExpectedClassNamesAndOptions(params), received = splitClassNames(htmlElement.getAttribute("class")), expected = expectedClassNames.reduce(
    (acc, className) => acc.concat(
      typeof className == "string" || !className ? splitClassNames(className) : className
    ),
    []
  ), hasRegExp = expected.some((className) => className instanceof RegExp);
  if (options.exact && hasRegExp)
    throw new Error("Exact option does not support RegExp expected class names");
  return options.exact ? {
    pass: isSubset$1(expected, received) && expected.length === received.length,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(expected.join(" "))
        ),
        `Expected the element ${to} have EXACTLY defined classes`,
        expected.join(" "),
        "Received",
        received.join(" ")
      );
    }
  } : expected.length > 0 ? {
    pass: isSubset$1(expected, received),
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(expected.join(" "))
        ),
        `Expected the element ${to} have class`,
        expected.join(" "),
        "Received",
        received.join(" ")
      );
    }
  } : {
    pass: this.isNot ? received.length > 0 : false,
    message: () => this.isNot ? getMessage3(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      received.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`)
  };
}
function getStyleDeclaration(document7, css2) {
  let styles3 = {}, copy3 = document7.createElement("div");
  return Object.keys(css2).forEach((property) => {
    copy3.style[property] = css2[property], styles3[property] = copy3.style[property];
  }), styles3;
}
function isSubset(styles3, computedStyle) {
  return !!Object.keys(styles3).length && Object.entries(styles3).every(([prop, value]) => {
    let isCustomProperty = prop.startsWith("--"), spellingVariants = [prop];
    return isCustomProperty || spellingVariants.push(prop.toLowerCase()), spellingVariants.some(
      (name) => computedStyle[name] === value || computedStyle.getPropertyValue(name) === value
    );
  });
}
function printoutStyles(styles3) {
  return Object.keys(styles3).sort().map((prop) => `${prop}: ${styles3[prop]};`).join(`
`);
}
function expectedDiff(diffFn, expected, computedStyles) {
  let received = Array.from(computedStyles).filter((prop) => expected[prop] !== void 0).reduce(
    (obj, prop) => Object.assign(obj, { [prop]: computedStyles.getPropertyValue(prop) }),
    {}
  );
  return diffFn(printoutStyles(expected), printoutStyles(received)).replace(`${import_picocolors.default.red("+ Received")}
`, "");
}
function toHaveStyle(htmlElement, css2) {
  checkHtmlElement(htmlElement, toHaveStyle, this);
  let parsedCSS = typeof css2 == "object" ? css2 : parseCSS(css2, toHaveStyle, this), { getComputedStyle: getComputedStyle2 } = htmlElement.ownerDocument.defaultView, expected = getStyleDeclaration(htmlElement.ownerDocument, parsedCSS), received = getComputedStyle2(htmlElement);
  return {
    pass: isSubset(expected, received),
    message: () => {
      let matcher = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(matcher, "element", ""),
        expectedDiff(this.utils.diff, expected, received)
      ].join(`

`);
    }
  };
}
function toHaveFocus(element) {
  return checkHtmlElement(element, toHaveFocus, this), {
    pass: element.ownerDocument.activeElement === element,
    message: () => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(element)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(element)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          element.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`)
  };
}
function getMultiElementValue(elements2) {
  let types = [...new Set(elements2.map((element) => element.type))];
  if (types.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (types[0]) {
    case "radio": {
      let theChosenOne = elements2.find((radio) => radio.checked);
      return theChosenOne ? theChosenOne.value : void 0;
    }
    case "checkbox":
      return elements2.filter((checkbox) => checkbox.checked).map((checkbox) => checkbox.value);
    default:
      return elements2.map((element) => element.value);
  }
}
function getFormValue(container, name) {
  let elements2 = [...container.querySelectorAll(`[name="${(0, import_css.default)(name)}"]`)];
  if (elements2.length !== 0)
    switch (elements2.length) {
      case 1:
        return getSingleElementValue(elements2[0]);
      default:
        return getMultiElementValue(elements2);
    }
}
function getPureName(name) {
  return /\[\]$/.test(name) ? name.slice(0, -2) : name;
}
function getAllFormValues(container) {
  return Array.from(container.elements).map((element) => element.name).reduce(
    (obj, name) => ({
      ...obj,
      [getPureName(name)]: getFormValue(container, name)
    }),
    {}
  );
}
function toHaveFormValues(formElement, expectedValues) {
  if (checkHtmlElement(formElement, toHaveFormValues, this), !formElement.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  let formValues = getAllFormValues(formElement);
  return {
    pass: Object.entries(expectedValues).every(
      ([name, expectedValue]) => compareAsSet(formValues[name], expectedValue)
    ),
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = `${this.isNot ? ".not" : ""}.toHaveFormValues`, commonKeyValues = Object.keys(formValues).filter((key) => expectedValues.hasOwnProperty(key)).reduce((obj, key) => ({ ...obj, [key]: formValues[key] }), {});
      return [
        this.utils.matcherHint(matcher, "element", ""),
        `Expected the element ${to} have form values`,
        this.utils.diff(expectedValues, commonKeyValues)
      ].join(`

`);
    }
  };
}
function isStyleVisible(element) {
  let { getComputedStyle: getComputedStyle2 } = element.ownerDocument.defaultView, { display: display2, visibility, opacity } = getComputedStyle2(element);
  return display2 !== "none" && visibility !== "hidden" && visibility !== "collapse" && opacity !== "0" && opacity !== 0;
}
function isAttributeVisible(element, previousElement) {
  let detailsVisibility;
  return previousElement ? detailsVisibility = element.nodeName === "DETAILS" && previousElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true : detailsVisibility = element.nodeName === "DETAILS" ? element.hasAttribute("open") : true, !element.hasAttribute("hidden") && detailsVisibility;
}
function isElementVisible(element, previousElement) {
  return isStyleVisible(element) && isAttributeVisible(element, previousElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
function toBeVisible(element) {
  checkHtmlElement(element, toBeVisible, this);
  let isInDocument = element.ownerDocument === element.getRootNode({ composed: true }), isVisible2 = isInDocument && isElementVisible(element);
  return {
    pass: isVisible2,
    message: () => {
      let is = isVisible2 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${is} visible${isInDocument ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS$2 = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function isFirstLegendChildOfFieldset(element, parent) {
  return getTag$1(element) === "legend" && getTag$1(parent) === "fieldset" && element.isSameNode(
    Array.from(parent.children).find((child) => getTag$1(child) === "legend")
  );
}
function isElementDisabledByParent(element, parent) {
  return isElementDisabled(parent) && !isFirstLegendChildOfFieldset(element, parent);
}
function isCustomElement(tag) {
  return tag.includes("-");
}
function canElementBeDisabled(element) {
  let tag = getTag$1(element);
  return FORM_TAGS$2.includes(tag) || isCustomElement(tag);
}
function isElementDisabled(element) {
  return canElementBeDisabled(element) && element.hasAttribute("disabled");
}
function isAncestorDisabled(element) {
  let parent = element.parentElement;
  return !!parent && (isElementDisabledByParent(element, parent) || isAncestorDisabled(parent));
}
function isElementOrAncestorDisabled(element) {
  return canElementBeDisabled(element) && (isElementDisabled(element) || isAncestorDisabled(element));
}
function toBeDisabled(element) {
  checkHtmlElement(element, toBeDisabled, this);
  let isDisabled3 = isElementOrAncestorDisabled(element);
  return {
    pass: isDisabled3,
    message: () => {
      let is = isDisabled3 ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} disabled:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
function toBeEnabled(element) {
  checkHtmlElement(element, toBeEnabled, this);
  let isEnabled = !isElementOrAncestorDisabled(element);
  return {
    pass: isEnabled,
    message: () => {
      let is = isEnabled ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${is} enabled:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS$1 = ["select", "textarea"], ARIA_FORM_TAGS = ["input", "select", "textarea"], UNSUPPORTED_INPUT_TYPES = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], SUPPORTED_ARIA_ROLES = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function isRequiredOnFormTagsExceptInput(element) {
  return FORM_TAGS$1.includes(getTag$1(element)) && element.hasAttribute("required");
}
function isRequiredOnSupportedInput(element) {
  return getTag$1(element) === "input" && element.hasAttribute("required") && (element.hasAttribute("type") && !UNSUPPORTED_INPUT_TYPES.includes(element.getAttribute("type")) || !element.hasAttribute("type"));
}
function isElementRequiredByARIA(element) {
  return element.hasAttribute("aria-required") && element.getAttribute("aria-required") === "true" && (ARIA_FORM_TAGS.includes(getTag$1(element)) || element.hasAttribute("role") && SUPPORTED_ARIA_ROLES.includes(element.getAttribute("role")));
}
function toBeRequired(element) {
  checkHtmlElement(element, toBeRequired, this);
  let isRequired = isRequiredOnFormTagsExceptInput(element) || isRequiredOnSupportedInput(element) || isElementRequiredByARIA(element);
  return {
    pass: isRequired,
    message: () => {
      let is = isRequired ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${is} required:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
var FORM_TAGS = ["form", "input", "select", "textarea"];
function isElementHavingAriaInvalid(element) {
  return element.hasAttribute("aria-invalid") && element.getAttribute("aria-invalid") !== "false";
}
function isSupportsValidityMethod(element) {
  return FORM_TAGS.includes(getTag$1(element));
}
function isElementInvalid(element) {
  let isHaveAriaInvalid = isElementHavingAriaInvalid(element);
  return isSupportsValidityMethod(element) ? isHaveAriaInvalid || !element.checkValidity() : isHaveAriaInvalid;
}
function toBeInvalid(element) {
  checkHtmlElement(element, toBeInvalid, this);
  let isInvalid = isElementInvalid(element);
  return {
    pass: isInvalid,
    message: () => {
      let is = isInvalid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently invalid:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
function toBeValid(element) {
  checkHtmlElement(element, toBeValid, this);
  let isValid = !isElementInvalid(element);
  return {
    pass: isValid,
    message: () => {
      let is = isValid ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${is} currently valid:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
function toHaveValue(htmlElement, expectedValue) {
  if (checkHtmlElement(htmlElement, toHaveValue, this), htmlElement.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(htmlElement.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  let receivedValue = getSingleElementValue(htmlElement), expectsValue = expectedValue !== void 0, expectedTypedValue = expectedValue, receivedTypedValue = receivedValue;
  return expectedValue == receivedValue && expectedValue !== receivedValue && (expectedTypedValue = `${expectedValue} (${typeof expectedValue})`, receivedTypedValue = `${receivedValue} (${typeof receivedValue})`), {
    pass: expectsValue ? compareAsSet(receivedValue, expectedValue) : !!receivedValue,
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        expectedValue
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have value`,
        expectsValue ? expectedTypedValue : "(any)",
        "Received",
        receivedTypedValue
      );
    }
  };
}
function toHaveDisplayValue(htmlElement, expectedValue) {
  checkHtmlElement(htmlElement, toHaveDisplayValue, this);
  let tagName = htmlElement.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(tagName))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (tagName === "input" && ["radio", "checkbox"].includes(htmlElement.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${htmlElement.type}"], try with another matcher instead.`
    );
  let values = getValues(tagName, htmlElement), expectedValues = getExpectedValues(expectedValue), numberOfMatchesWithValues = expectedValues.filter(
    (expected) => values.some(
      (value) => expected instanceof RegExp ? expected.test(value) : this.equals(value, String(expected))
    )
  ).length, matchedWithAllValues = numberOfMatchesWithValues === values.length, matchedWithAllExpectedValues = numberOfMatchesWithValues === expectedValues.length;
  return {
    pass: matchedWithAllValues && matchedWithAllExpectedValues,
    message: () => getMessage3(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      expectedValue,
      "Received",
      values
    )
  };
}
function getValues(tagName, htmlElement) {
  return tagName === "select" ? Array.from(htmlElement).filter((option) => option.selected).map((option) => option.textContent) : [htmlElement.value];
}
function getExpectedValues(expectedValue) {
  return expectedValue instanceof Array ? expectedValue : [expectedValue];
}
function toBeChecked(element) {
  checkHtmlElement(element, toBeChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(element.type), isValidAriaElement = () => roleSupportsChecked(element.getAttribute("role")) && ["true", "false"].includes(element.getAttribute("aria-checked"));
  if (!isValidInput() && !isValidAriaElement())
    return {
      pass: false,
      message: () => `only inputs with type="checkbox" or type="radio" or elements with ${supportedRolesSentence()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`
    };
  let isChecked = () => isValidInput() ? element.checked : element.getAttribute("aria-checked") === "true";
  return {
    pass: isChecked(),
    message: () => {
      let is = isChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} checked:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
function supportedRolesSentence() {
  return toSentence(
    supportedRoles().map((role) => `role="${role}"`),
    { lastWordConnector: " or " }
  );
}
function supportedRoles() {
  return import_aria_query.roles.keys().filter(roleSupportsChecked);
}
function roleSupportsChecked(role) {
  return import_aria_query.roles.get(role)?.props["aria-checked"] !== void 0;
}
function toBePartiallyChecked(element) {
  checkHtmlElement(element, toBePartiallyChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && element.type === "checkbox", isValidAriaElement = () => element.getAttribute("role") === "checkbox";
  if (!isValidInput() && !isValidAriaElement())
    return {
      pass: false,
      message: () => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead'
    };
  let isPartiallyChecked = () => {
    let isAriaMixed = element.getAttribute("aria-checked") === "mixed";
    return isValidInput() && element.indeterminate || isAriaMixed;
  };
  return {
    pass: isPartiallyChecked(),
    message: () => {
      let is = isPartiallyChecked() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${is} partially checked:`,
        `  ${this.utils.printReceived(element.cloneNode(false))}`
      ].join(`
`);
    }
  };
}
function toHaveDescription(htmlElement, checkWith) {
  deprecate2(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), checkHtmlElement(htmlElement, toHaveDescription, this);
  let expectsDescription = checkWith !== void 0, descriptionIDs = (htmlElement.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean), description = "";
  if (descriptionIDs.length > 0) {
    let document7 = htmlElement.ownerDocument, descriptionEls = descriptionIDs.map((descriptionID) => document7.getElementById(descriptionID)).filter(Boolean);
    description = normalize(descriptionEls.map((el) => el.textContent).join(" "));
  }
  return {
    pass: expectsDescription ? checkWith instanceof RegExp ? checkWith.test(description) : this.equals(description, checkWith) : !!description,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${to} have description`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(description)
      );
    }
  };
}
function toHaveErrorMessage(htmlElement, checkWith) {
  if (deprecate2("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), checkHtmlElement(htmlElement, toHaveErrorMessage, this), !htmlElement.hasAttribute("aria-invalid") || htmlElement.getAttribute("aria-invalid") === "false") {
    let not = this.isNot ? ".not" : "";
    return {
      pass: false,
      message: () => getMessage3(
        this,
        this.utils.matcherHint(`${not}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        htmlElement.hasAttribute("aria-invalid") ? `aria-invalid="${htmlElement.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      )
    };
  }
  let expectsErrorMessage = checkWith !== void 0, errormessageIDs = (htmlElement.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean), errormessage = "";
  if (errormessageIDs.length > 0) {
    let document7 = htmlElement.ownerDocument, errormessageEls = errormessageIDs.map((errormessageID) => document7.getElementById(errormessageID)).filter(Boolean);
    errormessage = normalize(
      errormessageEls.map((el) => el.textContent).join(" ")
    );
  }
  return {
    pass: expectsErrorMessage ? checkWith instanceof RegExp ? checkWith.test(errormessage) : this.equals(errormessage, checkWith) : !!errormessage,
    message: () => {
      let to = this.isNot ? "not to" : "to";
      return getMessage3(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${to} have error message`,
        this.utils.printExpected(checkWith),
        "Received",
        this.utils.printReceived(errormessage)
      );
    }
  };
}
function getSelection(element) {
  let selection = element.ownerDocument.getSelection();
  if (["input", "textarea"].includes(element.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(element.type) ? "" : element.value.toString().substring(element.selectionStart, element.selectionEnd);
  if (selection.anchorNode === null || selection.focusNode === null)
    return "";
  let originalRange = selection.getRangeAt(0), temporaryRange = element.ownerDocument.createRange();
  if (selection.containsNode(element, false))
    temporaryRange.selectNodeContents(element), selection.removeAllRanges(), selection.addRange(temporaryRange);
  else if (!(element.contains(selection.anchorNode) && element.contains(selection.focusNode))) {
    let selectionStartsWithinElement = element === originalRange.startContainer || element.contains(originalRange.startContainer), selectionEndsWithinElement = element === originalRange.endContainer || element.contains(originalRange.endContainer);
    selection.removeAllRanges(), (selectionStartsWithinElement || selectionEndsWithinElement) && (temporaryRange.selectNodeContents(element), selectionStartsWithinElement && temporaryRange.setStart(
      originalRange.startContainer,
      originalRange.startOffset
    ), selectionEndsWithinElement && temporaryRange.setEnd(
      originalRange.endContainer,
      originalRange.endOffset
    ), selection.addRange(temporaryRange));
  }
  let result = selection.toString();
  return selection.removeAllRanges(), selection.addRange(originalRange), result;
}
function toHaveSelection(htmlElement, expectedSelection) {
  checkHtmlElement(htmlElement, toHaveSelection, this);
  let expectsSelection = expectedSelection !== void 0;
  if (expectsSelection && typeof expectedSelection != "string")
    throw new Error("expected selection must be a string or undefined");
  let receivedSelection = getSelection(htmlElement);
  return {
    pass: expectsSelection ? compareAsSet(receivedSelection, expectedSelection) : !!receivedSelection,
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        expectedSelection
      );
      return getMessage3(
        this,
        matcher,
        `Expected the element ${to} have selection`,
        expectsSelection ? expectedSelection : "(any)",
        "Received",
        receivedSelection
      );
    }
  };
}
function toBePressed(element) {
  checkHtmlElement(element, toBePressed, this);
  let roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim()), isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button"), pressedAttribute = element.getAttribute("aria-pressed");
  return !isButton || !(pressedAttribute === "true" || pressedAttribute === "false") ? {
    pass: false,
    message: () => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()'
  } : {
    pass: isButton && pressedAttribute === "true",
    message: () => {
      let matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        "Expected element to have",
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        "Received",
        `aria-pressed="${pressedAttribute}"`
      );
    }
  };
}
function toBePartiallyPressed(element) {
  checkHtmlElement(element, toBePartiallyPressed, this);
  let roles3 = (element.getAttribute("role") || "").split(" ").map((role) => role.trim()), isButton = element.tagName.toLowerCase() === "button" || element.tagName.toLowerCase() === "input" && element.type === "button" || roles3.includes("button"), pressedAttribute = element.getAttribute("aria-pressed");
  return !isButton || !(pressedAttribute === "true" || pressedAttribute === "false" || pressedAttribute === "mixed") ? {
    pass: false,
    message: () => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()'
  } : {
    pass: isButton && pressedAttribute === "mixed",
    message: () => {
      let to = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return getMessage3(
        this,
        matcher,
        `Expected element ${to} have`,
        'aria-pressed="mixed"',
        "Received",
        `aria-pressed="${pressedAttribute}"`
      );
    }
  };
}
var DOCUMENT_POSITION_DISCONNECTED = 1, DOCUMENT_POSITION_PRECEDING = 2, DOCUMENT_POSITION_FOLLOWING = 4, DOCUMENT_POSITION_CONTAINS = 8, DOCUMENT_POSITION_CONTAINED_BY = 16, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32, DOCUMENT_POSITIONS_STRINGS = {
  [DOCUMENT_POSITION_DISCONNECTED]: "Node.DOCUMENT_POSITION_DISCONNECTED",
  [DOCUMENT_POSITION_PRECEDING]: "Node.DOCUMENT_POSITION_PRECEDING",
  [DOCUMENT_POSITION_FOLLOWING]: "Node.DOCUMENT_POSITION_FOLLOWING",
  [DOCUMENT_POSITION_CONTAINS]: "Node.DOCUMENT_POSITION_CONTAINS",
  [DOCUMENT_POSITION_CONTAINED_BY]: "Node.DOCUMENT_POSITION_CONTAINED_BY",
  [DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC]: "Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"
};
function makeDocumentPositionErrorString(documentPosition) {
  return documentPosition in DOCUMENT_POSITIONS_STRINGS ? `${DOCUMENT_POSITIONS_STRINGS[documentPosition]} (${documentPosition})` : `Unknown document position (${documentPosition})`;
}
function checkToAppear(methodName, targetDocumentPosition) {
  return function(element, secondElement) {
    checkHtmlElement(element, toAppearBefore, this), checkHtmlElement(secondElement, toAppearBefore, this);
    let documentPosition = element.compareDocumentPosition(secondElement);
    return {
      pass: documentPosition === targetDocumentPosition,
      message: () => [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${methodName}`,
          "element",
          "secondElement"
        ),
        "",
        `Received: ${makeDocumentPositionErrorString(documentPosition)}`
      ].join(`
`)
    };
  };
}
function toAppearBefore(element, secondElement) {
  return checkToAppear("toAppearBefore", DOCUMENT_POSITION_FOLLOWING).apply(
    this,
    [element, secondElement]
  );
}
function toAppearAfter(element, secondElement) {
  return checkToAppear("toAppearAfter", DOCUMENT_POSITION_PRECEDING).apply(
    this,
    [element, secondElement]
  );
}
__toESM$3(require_redent(), 1);
__toESM$3(require_lib(), 1);
__toESM$3(require_picocolors_browser(), 1);
__toESM$3(require_css_escape(), 1);
var jsTokens_1, hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  return RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu, LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y, MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, SingleLineComment = /\/\/.*/y, JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y, JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y, JSXText = /[^<>{}]+/y, TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/, Newline = RegExp(LineTerminatorSequence.source), jsTokens_1 = function* (input2, { jsx = false } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack2;
    for ({ length } = input2, lastIndex = 0, lastSignificantToken = "", stack2 = [
      { tag: "JS" }
    ], braces = [], parenNesting = 0, postfixIncDec = false; lastIndex < length; ) {
      switch (mode = stack2[stack2.length - 1], mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input2[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)) && (RegularExpressionLiteral.lastIndex = lastIndex, match = RegularExpressionLiteral.exec(input2))) {
            lastIndex = RegularExpressionLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = true, yield {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
            continue;
          }
          if (Punctuator.lastIndex = lastIndex, match = Punctuator.exec(input2)) {
            switch (punctuator = match[0], nextLastIndex = Punctuator.lastIndex, nextLastSignificantToken = punctuator, punctuator) {
              case "(":
                lastSignificantToken === "?NonExpressionParenKeyword" && stack2.push({
                  tag: "JSNonExpressionParen",
                  nesting: parenNesting
                }), parenNesting++, postfixIncDec = false;
                break;
              case ")":
                parenNesting--, postfixIncDec = true, mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting && (stack2.pop(), nextLastSignificantToken = "?NonExpressionParenEnd", postfixIncDec = false);
                break;
              case "{":
                Punctuator.lastIndex = 0, isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)), braces.push(isExpression), postfixIncDec = false;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex, match = Template.exec(input2), lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", postfixIncDec = false, yield {
                        type: "TemplateMiddle",
                        value: match[0]
                      }) : (stack2.pop(), postfixIncDec = true, yield {
                        type: "TemplateTail",
                        value: match[0],
                        closed: match[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack2.pop(), lastIndex += 1, lastSignificantToken = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop(), nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = true;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack2.push({ tag: "JSXTag" }), lastIndex += 1, lastSignificantToken = "<", yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = false;
                break;
              default:
                postfixIncDec = false;
            }
            lastIndex = nextLastIndex, lastSignificantToken = nextLastSignificantToken, yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          if (Identifier.lastIndex = lastIndex, match = Identifier.exec(input2)) {
            switch (lastIndex = Identifier.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                lastSignificantToken !== "." && lastSignificantToken !== "?." && (nextLastSignificantToken = "?NonExpressionParenKeyword");
            }
            lastSignificantToken = nextLastSignificantToken, postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]), yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          if (StringLiteral.lastIndex = lastIndex, match = StringLiteral.exec(input2)) {
            lastIndex = StringLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = true, yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          if (NumericLiteral.lastIndex = lastIndex, match = NumericLiteral.exec(input2)) {
            lastIndex = NumericLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = true, yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          if (Template.lastIndex = lastIndex, match = Template.exec(input2)) {
            lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", stack2.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            }), postfixIncDec = false, yield {
              type: "TemplateHead",
              value: match[0]
            }) : (postfixIncDec = true, yield {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (JSXPunctuator.lastIndex = lastIndex, match = JSXPunctuator.exec(input2)) {
            switch (lastIndex = JSXPunctuator.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "<":
                stack2.push({ tag: "JSXTag" });
                break;
              case ">":
                stack2.pop(), lastSignificantToken === "/" || mode.tag === "JSXTagEnd" ? (nextLastSignificantToken = "?JSX", postfixIncDec = true) : stack2.push({ tag: "JSXChildren" });
                break;
              case "{":
                stack2.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                }), nextLastSignificantToken = "?InterpolationInJSX", postfixIncDec = false;
                break;
              case "/":
                lastSignificantToken === "<" && (stack2.pop(), stack2[stack2.length - 1].tag === "JSXChildren" && stack2.pop(), stack2.push({ tag: "JSXTagEnd" }));
            }
            lastSignificantToken = nextLastSignificantToken, yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          if (JSXIdentifier.lastIndex = lastIndex, match = JSXIdentifier.exec(input2)) {
            lastIndex = JSXIdentifier.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          if (JSXString.lastIndex = lastIndex, match = JSXString.exec(input2)) {
            lastIndex = JSXString.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (JSXText.lastIndex = lastIndex, match = JSXText.exec(input2)) {
            lastIndex = JSXText.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input2[lastIndex]) {
            case "<":
              stack2.push({ tag: "JSXTag" }), lastIndex++, lastSignificantToken = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack2.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              }), lastIndex++, lastSignificantToken = "?InterpolationInJSX", postfixIncDec = false, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (WhiteSpace.lastIndex = lastIndex, match = WhiteSpace.exec(input2)) {
        lastIndex = WhiteSpace.lastIndex, yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      if (LineTerminatorSequence.lastIndex = lastIndex, match = LineTerminatorSequence.exec(input2)) {
        lastIndex = LineTerminatorSequence.lastIndex, postfixIncDec = false, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      if (MultiLineComment.lastIndex = lastIndex, match = MultiLineComment.exec(input2)) {
        lastIndex = MultiLineComment.lastIndex, Newline.test(match[0]) && (postfixIncDec = false, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      if (SingleLineComment.lastIndex = lastIndex, match = SingleLineComment.exec(input2)) {
        lastIndex = SingleLineComment.lastIndex, postfixIncDec = false, yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input2.codePointAt(lastIndex)), lastIndex += firstCodePoint.length, lastSignificantToken = firstCodePoint, postfixIncDec = false, yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
  }, jsTokens_1;
}
var jsTokensExports = requireJsTokens();
getDefaultExportFromCjs2(jsTokensExports);
var reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(reservedWords.keyword);
new Set(reservedWords.strict);
function S(e2, t22) {
  if (!e2)
    throw new Error(t22);
}
function f2(e2, t22) {
  return typeof t22 === e2;
}
function w(e2) {
  return e2 instanceof Promise;
}
function u$1(e2, t22, r2) {
  Object.defineProperty(e2, t22, r2);
}
function l(e2, t22, r2) {
  u$1(e2, t22, { value: r2, configurable: true, writable: true });
}
var y = Symbol.for("tinyspy:spy"), x = /* @__PURE__ */ new Set(), h2 = (e2) => {
  e2.called = false, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, k = (e2) => (u$1(e2, y, {
  value: { reset: () => h2(e2[y]) }
}), e2[y]), T = (e2) => e2[y] || k(e2);
function R(e2) {
  S(
    f2("function", e2) || f2("undefined", e2),
    "cannot spy on a non-function value"
  );
  let t22 = function(...s3) {
    let n2 = T(t22);
    n2.called = true, n2.callCount++, n2.calls.push(s3);
    let d = n2.next.shift();
    if (d) {
      n2.results.push(d);
      let [a2, i2] = d;
      if (a2 === "ok")
        return i2;
      throw i2;
    }
    let o2, c2 = "ok", p2 = n2.results.length;
    if (n2.impl)
      try {
        new.target ? o2 = Reflect.construct(n2.impl, s3, new.target) : o2 = n2.impl.apply(this, s3), c2 = "ok";
      } catch (a2) {
        throw o2 = a2, c2 = "error", n2.results.push([c2, a2]), a2;
      }
    let g2 = [c2, o2];
    return w(o2) && o2.then(
      (a2) => n2.resolves[p2] = ["ok", a2],
      (a2) => n2.resolves[p2] = ["error", a2]
    ), n2.results.push(g2), o2;
  };
  l(t22, "_isMockFunction", true), l(t22, "length", e2 ? e2.length : 0), l(t22, "name", e2 && e2.name || "spy");
  let r2 = T(t22);
  return r2.reset(), r2.impl = e2, t22;
}
function v(e2) {
  return !!e2 && e2._isMockFunction === true;
}
var b = (e2, t22) => {
  let r2 = Object.getOwnPropertyDescriptor(e2, t22);
  if (r2)
    return [e2, r2];
  let s3 = Object.getPrototypeOf(e2);
  for (; s3 !== null; ) {
    let n2 = Object.getOwnPropertyDescriptor(s3, t22);
    if (n2)
      return [s3, n2];
    s3 = Object.getPrototypeOf(s3);
  }
}, P = (e2, t22) => {
  t22 != null && typeof t22 == "function" && t22.prototype != null && Object.setPrototypeOf(e2.prototype, t22.prototype);
};
function M(e2, t22, r2) {
  S(
    !f2("undefined", e2),
    "spyOn could not find an object to spy upon"
  ), S(
    f2("object", e2) || f2("function", e2),
    "cannot spyOn on a primitive value"
  );
  let [s3, n2] = (() => {
    if (!f2("object", t22))
      return [t22, "value"];
    if ("getter" in t22 && "setter" in t22)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t22)
      return [t22.getter, "get"];
    if ("setter" in t22)
      return [t22.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [d, o2] = b(e2, s3) || [];
  S(
    o2 || s3 in e2,
    `${String(s3)} does not exist`
  );
  let c2 = false;
  n2 === "value" && o2 && !o2.value && o2.get && (n2 = "get", c2 = true, r2 = o2.get());
  let p2;
  o2 ? p2 = o2[n2] : n2 !== "value" ? p2 = () => e2[s3] : p2 = e2[s3], p2 && j(p2) && (p2 = p2[y].getOriginal());
  let g2 = (I) => {
    let { value: F, ...O } = o2 || {
      configurable: true,
      writable: true
    };
    n2 !== "value" && delete O.writable, O[n2] = I, u$1(e2, s3, O);
  }, a2 = () => {
    d !== e2 ? Reflect.deleteProperty(e2, s3) : o2 && !p2 ? u$1(e2, s3, o2) : g2(p2);
  };
  r2 || (r2 = p2);
  let i2 = E(R(r2), r2);
  n2 === "value" && P(i2, p2);
  let m3 = i2[y];
  return l(m3, "restore", a2), l(m3, "getOriginal", () => c2 ? p2() : p2), l(m3, "willCall", (I) => (m3.impl = I, i2)), g2(
    c2 ? () => (P(i2, r2), i2) : i2
  ), x.add(i2), i2;
}
var K = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function D(e2) {
  let t22 = /* @__PURE__ */ new Set(), r2 = {};
  for (; e2 && e2 !== Object.prototype && e2 !== Function.prototype; ) {
    let s3 = [
      ...Object.getOwnPropertyNames(e2),
      ...Object.getOwnPropertySymbols(e2)
    ];
    for (let n2 of s3)
      r2[n2] || K.has(n2) || (t22.add(n2), r2[n2] = Object.getOwnPropertyDescriptor(e2, n2));
    e2 = Object.getPrototypeOf(e2);
  }
  return {
    properties: t22,
    descriptors: r2
  };
}
function E(e2, t22) {
  if (!t22 || // the original is already a spy, so it has all the properties
  y in t22)
    return e2;
  let { properties: r2, descriptors: s3 } = D(t22);
  for (let n2 of r2) {
    let d = s3[n2];
    b(e2, n2) || u$1(e2, n2, d);
  }
  return e2;
}
function j(e2) {
  return v(e2) && "getOriginal" in e2[y];
}
var mocks = /* @__PURE__ */ new Set();
function isMockFunction(fn3) {
  return typeof fn3 == "function" && "_isMockFunction" in fn3 && fn3._isMockFunction;
}
function spyOn(obj, method, accessType) {
  let objMethod = accessType ? { [{
    get: "getter",
    set: "setter"
  }[accessType]]: method } : method, state3, descriptor = getDescriptor(obj, method), fn3 = descriptor && descriptor[accessType || "value"];
  isMockFunction(fn3) && (state3 = fn3.mock._state());
  try {
    let stub = M(obj, objMethod), spy = enhanceSpy(stub);
    return state3 && spy.mock._state(state3), spy;
  } catch (error) {
    throw error instanceof TypeError && Symbol.toStringTag && obj[Symbol.toStringTag] === "Module" && (error.message.includes("Cannot redefine property") || error.message.includes("Cannot replace module namespace") || error.message.includes("can't redefine non-configurable property")) ? new TypeError(`Cannot spy on export "${String(objMethod)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: error }) : error;
  }
}
var callOrder = 0;
function enhanceSpy(spy) {
  let stub = spy, implementation, onceImplementations = [], implementationChangedTemporarily = false, instances2 = [], contexts = [], invocations = [], state3 = T(spy), mockContext = {
    get calls() {
      return state3.calls;
    },
    get contexts() {
      return contexts;
    },
    get instances() {
      return instances2;
    },
    get invocationCallOrder() {
      return invocations;
    },
    get results() {
      return state3.results.map(([callType, value]) => ({
        type: callType === "error" ? "throw" : "return",
        value
      }));
    },
    get settledResults() {
      return state3.resolves.map(([callType, value]) => ({
        type: callType === "error" ? "rejected" : "fulfilled",
        value
      }));
    },
    get lastCall() {
      return state3.calls[state3.calls.length - 1];
    },
    _state(state4) {
      return state4 && (implementation = state4.implementation, onceImplementations = state4.onceImplementations, implementationChangedTemporarily = state4.implementationChangedTemporarily), {
        implementation,
        onceImplementations,
        implementationChangedTemporarily
      };
    }
  };
  function mockCall(...args) {
    return instances2.push(this), contexts.push(this), invocations.push(++callOrder), (implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state3.getOriginal() || (() => {
    })).apply(this, args);
  }
  let name = stub.name;
  stub.getMockName = () => name || "vi.fn()", stub.mockName = (n2) => (name = n2, stub), stub.mockClear = () => (state3.reset(), instances2 = [], contexts = [], invocations = [], stub), stub.mockReset = () => (stub.mockClear(), implementation = void 0, onceImplementations = [], stub), stub.mockRestore = () => (stub.mockReset(), state3.restore(), stub), Symbol.dispose && (stub[Symbol.dispose] = () => stub.mockRestore()), stub.getMockImplementation = () => implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation, stub.mockImplementation = (fn3) => (implementation = fn3, state3.willCall(mockCall), stub), stub.mockImplementationOnce = (fn3) => (onceImplementations.push(fn3), stub);
  function withImplementation(fn3, cb) {
    let originalImplementation = implementation;
    implementation = fn3, state3.willCall(mockCall), implementationChangedTemporarily = true;
    let reset = () => {
      implementation = originalImplementation, implementationChangedTemporarily = false;
    }, result = cb();
    return typeof result == "object" && result && typeof result.then == "function" ? result.then(() => (reset(), stub)) : (reset(), stub);
  }
  return stub.withImplementation = withImplementation, stub.mockReturnThis = () => stub.mockImplementation(function() {
    return this;
  }), stub.mockReturnValue = (val) => stub.mockImplementation(() => val), stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val), stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val)), stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val)), stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val)), stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val)), Object.defineProperty(stub, "mock", { get: () => mockContext }), state3.willCall(mockCall), mocks.add(stub), stub;
}
function fn(implementation) {
  let enhancedSpy = enhanceSpy(M({ spy: implementation || function() {
  } }, "spy"));
  return implementation && enhancedSpy.mockImplementation(implementation), enhancedSpy;
}
function getDescriptor(obj, method) {
  let objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor)
    return objDescriptor;
  let currentProto = Object.getPrototypeOf(obj);
  for (; currentProto !== null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor)
      return descriptor;
    currentProto = Object.getPrototypeOf(currentProto);
  }
}
var MATCHERS_OBJECT = Symbol.for("matchers-object"), JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object-storybook"), GLOBAL_EXPECT = Symbol.for("expect-global"), ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object"), customMatchers = {
  toSatisfy(actual, expected, message) {
    let { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils, pass = expected(actual);
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  },
  toBeOneOf(actual, expected) {
    let { equals: equals2, customTesters } = this, { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils;
    if (!Array.isArray(expected))
      throw new TypeError(`You must provide an array to ${matcherHint2(".toBeOneOf")}, not '${typeof expected}'.`);
    let pass = expected.length === 0 || expected.some((item) => equals2(item, actual, customTesters));
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  }
}, EXPECTED_COLOR = s.green, RECEIVED_COLOR = s.red, INVERTED_COLOR = s.inverse, BOLD_WEIGHT = s.bold, DIM_COLOR = s.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
  let { comment = "", isDirectExpectCall = false, isNot = false, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options, hint = "", dimString = "expect";
  return !isDirectExpectCall && received !== "" && (hint += DIM_COLOR(`${dimString}(`) + receivedColor(received), dimString = ")"), promise !== "" && (hint += DIM_COLOR(`${dimString}.`) + promise, dimString = ""), isNot && (hint += `${DIM_COLOR(`${dimString}.`)}not`, dimString = ""), matcherName.includes(".") ? dimString += matcherName : (hint += DIM_COLOR(`${dimString}.`) + matcherName, dimString = ""), expected === "" ? dimString += "()" : (hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected), secondArgument && (hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument)), dimString = ")"), comment !== "" && (dimString += ` // ${comment}`), dimString !== "" && (hint += DIM_COLOR(dimString)), hint;
}
var SPACE_SYMBOL2 = "";
function replaceTrailingSpaces2(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL2.repeat(spaces.length));
}
function printReceived2(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces2(stringify2(object)));
}
function printExpected2(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces2(stringify2(value)));
}
function getMatcherUtils() {
  return {
    EXPECTED_COLOR,
    RECEIVED_COLOR,
    INVERTED_COLOR,
    BOLD_WEIGHT,
    DIM_COLOR,
    diff,
    matcherHint,
    printReceived: printReceived2,
    printExpected: printExpected2,
    printDiffOrStringify,
    printWithType
  };
}
function printWithType(name, value, print) {
  let type5 = getType2(value), hasType = type5 !== "null" && type5 !== "undefined" ? `${name} has type:  ${type5}
` : "", hasValue = `${name} has value: ${print(value)}`;
  return hasType + hasValue;
}
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function equals(a2, b2, customTesters, strictCheck) {
  return customTesters = customTesters || [], eq2(a2, b2, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
function isAsymmetric(obj) {
  return !!obj && typeof obj == "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a2, b2) {
  let asymmetricA = isAsymmetric(a2), asymmetricB = isAsymmetric(b2);
  if (!(asymmetricA && asymmetricB)) {
    if (asymmetricA)
      return a2.asymmetricMatch(b2);
    if (asymmetricB)
      return b2.asymmetricMatch(a2);
  }
}
function eq2(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = true, asymmetricResult = asymmetricMatch(a2, b2);
  if (asymmetricResult !== void 0)
    return asymmetricResult;
  let testerContext = { equals };
  for (let i2 = 0; i2 < customTesters.length; i2++) {
    let customTesterResult = customTesters[i2].call(testerContext, a2, b2, customTesters);
    if (customTesterResult !== void 0)
      return customTesterResult;
  }
  if (typeof URL == "function" && a2 instanceof URL && b2 instanceof URL)
    return a2.href === b2.href;
  if (Object.is(a2, b2))
    return true;
  if (a2 === null || b2 === null)
    return a2 === b2;
  let className = Object.prototype.toString.call(a2);
  if (className !== Object.prototype.toString.call(b2))
    return false;
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof a2 != typeof b2 ? false : typeof a2 != "object" && typeof b2 != "object" ? Object.is(a2, b2) : Object.is(a2.valueOf(), b2.valueOf());
    case "[object Date]": {
      let numA = +a2, numB = +b2;
      return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
    }
    case "[object RegExp]":
      return a2.source === b2.source && a2.flags === b2.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return a2.equals(b2);
    case "[object Temporal.Duration]":
      return a2.toString() === b2.toString();
  }
  if (typeof a2 != "object" || typeof b2 != "object")
    return false;
  if (isDomNode(a2) && isDomNode(b2))
    return a2.isEqualNode(b2);
  let length = aStack.length;
  for (; length--; ) {
    if (aStack[length] === a2)
      return bStack[length] === b2;
    if (bStack[length] === b2)
      return false;
  }
  if (aStack.push(a2), bStack.push(b2), className === "[object Array]" && a2.length !== b2.length)
    return false;
  if (a2 instanceof Error && b2 instanceof Error)
    try {
      return isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2);
    } finally {
      aStack.pop(), bStack.pop();
    }
  let aKeys = keys(a2, hasKey2), key, size2 = aKeys.length;
  if (keys(b2, hasKey2).length !== size2)
    return false;
  for (; size2--; )
    if (key = aKeys[size2], result = hasKey2(b2, key) && eq2(a2[key], b2[key], aStack, bStack, customTesters, hasKey2), !result)
      return false;
  return aStack.pop(), bStack.pop(), result;
}
function isErrorEqual(a2, b2, aStack, bStack, customTesters, hasKey2) {
  let result = Object.getPrototypeOf(a2) === Object.getPrototypeOf(b2) && a2.name === b2.name && a2.message === b2.message;
  return typeof b2.cause < "u" && result && (result = eq2(a2.cause, b2.cause, aStack, bStack, customTesters, hasKey2)), a2 instanceof AggregateError && b2 instanceof AggregateError && result && (result = eq2(a2.errors, b2.errors, aStack, bStack, customTesters, hasKey2)), result && (result = eq2({ ...a2 }, { ...b2 }, aStack, bStack, customTesters, hasKey2)), result;
}
function keys(obj, hasKey2) {
  let keys2 = [];
  for (let key in obj)
    hasKey2(obj, key) && keys2.push(key);
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== void 0;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
  return obj !== null && typeof obj == "object" && "nodeType" in obj && typeof obj.nodeType == "number" && "nodeName" in obj && typeof obj.nodeName == "string" && "isEqualNode" in obj && typeof obj.isEqualNode == "function";
}
var IS_KEYED_SENTINEL2 = "@@__IMMUTABLE_KEYED__@@", IS_SET_SENTINEL2 = "@@__IMMUTABLE_SET__@@", IS_LIST_SENTINEL2 = "@@__IMMUTABLE_LIST__@@", IS_ORDERED_SENTINEL2 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SYMBOL2 = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL2] && !maybeKeyed[IS_ORDERED_SENTINEL2]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL2] && !maybeSet[IS_ORDERED_SENTINEL2]);
}
function isObjectLiteral(source) {
  return source != null && typeof source == "object" && !Array.isArray(source);
}
function isImmutableList(source) {
  return !!(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL2]);
}
function isImmutableOrderedKeyed(source) {
  return !!(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableOrderedSet(source) {
  return !!(source && isObjectLiteral(source) && source[IS_SET_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableRecord(source) {
  return !!(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL2]);
}
var IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
  return !!(object != null && object[IteratorSymbol]);
}
function iterableEquality(a2, b2, customTesters = [], aStack = [], bStack = []) {
  if (typeof a2 != "object" || typeof b2 != "object" || Array.isArray(a2) || Array.isArray(b2) || !hasIterator(a2) || !hasIterator(b2))
    return;
  if (a2.constructor !== b2.constructor)
    return false;
  let length = aStack.length;
  for (; length--; )
    if (aStack[length] === a2)
      return bStack[length] === b2;
  aStack.push(a2), bStack.push(b2);
  let filteredCustomTesters = [...customTesters.filter((t22) => t22 !== iterableEquality), iterableEqualityWithStack];
  function iterableEqualityWithStack(a3, b3) {
    return iterableEquality(a3, b3, [...customTesters], [...aStack], [...bStack]);
  }
  if (a2.size !== void 0) {
    if (a2.size !== b2.size)
      return false;
    if (isA("Set", a2) || isImmutableUnorderedSet(a2)) {
      let allFound = true;
      for (let aValue of a2)
        if (!b2.has(aValue)) {
          let has = false;
          for (let bValue of b2)
            equals(aValue, bValue, filteredCustomTesters) === true && (has = true);
          if (has === false) {
            allFound = false;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    } else if (isA("Map", a2) || isImmutableUnorderedKeyed(a2)) {
      let allFound = true;
      for (let aEntry of a2)
        if (!b2.has(aEntry[0]) || !equals(aEntry[1], b2.get(aEntry[0]), filteredCustomTesters)) {
          let has = false;
          for (let bEntry of b2) {
            let matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters), matchedValue = false;
            matchedKey === true && (matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters)), matchedValue === true && (has = true);
          }
          if (has === false) {
            allFound = false;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    }
  }
  let bIterator = b2[IteratorSymbol]();
  for (let aValue of a2) {
    let nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters))
      return false;
  }
  if (!bIterator.next().done)
    return false;
  if (!isImmutableList(a2) && !isImmutableOrderedKeyed(a2) && !isImmutableOrderedSet(a2) && !isImmutableRecord(a2)) {
    let aEntries = Object.entries(a2), bEntries = Object.entries(b2);
    if (!equals(aEntries, bEntries, filteredCustomTesters))
      return false;
  }
  return aStack.pop(), bStack.pop(), true;
}
function hasPropertyInObject(object, key) {
  return !object || typeof object != "object" || object === Object.prototype ? false : Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
}
function isObjectWithKeys(a2) {
  return isObject4(a2) && !(a2 instanceof Error) && !Array.isArray(a2) && !(a2 instanceof Date);
}
function subsetEquality(object, subset, customTesters = []) {
  let filteredCustomTesters = customTesters.filter((t22) => t22 !== subsetEquality), subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (isObjectWithKeys(subset2))
      return Object.keys(subset2).every((key) => {
        if (subset2[key] != null && typeof subset2[key] == "object") {
          if (seenReferences.has(subset2[key]))
            return equals(object2[key], subset2[key], filteredCustomTesters);
          seenReferences.set(subset2[key], true);
        }
        let result = object2 != null && hasPropertyInObject(object2, key) && equals(object2[key], subset2[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
        return seenReferences.delete(subset2[key]), result;
      });
  };
  return subsetEqualityWithContext()(object, subset);
}
function typeEquality(a2, b2) {
  if (!(a2 == null || b2 == null || a2.constructor === b2.constructor))
    return false;
}
function arrayBufferEquality(a2, b2) {
  let dataViewA = a2, dataViewB = b2;
  if (!(a2 instanceof DataView && b2 instanceof DataView)) {
    if (!(a2 instanceof ArrayBuffer) || !(b2 instanceof ArrayBuffer))
      return;
    try {
      dataViewA = new DataView(a2), dataViewB = new DataView(b2);
    } catch {
      return;
    }
  }
  if (dataViewA.byteLength !== dataViewB.byteLength)
    return false;
  for (let i2 = 0; i2 < dataViewA.byteLength; i2++)
    if (dataViewA.getUint8(i2) !== dataViewB.getUint8(i2))
      return false;
  return true;
}
function sparseArrayEquality(a2, b2, customTesters = []) {
  if (!Array.isArray(a2) || !Array.isArray(b2))
    return;
  let aKeys = Object.keys(a2), bKeys = Object.keys(b2), filteredCustomTesters = customTesters.filter((t22) => t22 !== sparseArrayEquality);
  return equals(a2, b2, filteredCustomTesters, true) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
  let toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(deepEqualityName) ? `${toBeMessage}

If it should pass with deep equality, replace "toBe" with "${deepEqualityName}"

Expected: ${expected}
Received: serializes to the same string
` : toBeMessage;
}
function pluralize(word, count2) {
  return `${count2} ${word}${count2 === 1 ? "" : "s"}`;
}
function getObjectKeys(object) {
  return [...Object.keys(object), ...Object.getOwnPropertySymbols(object).filter((s3) => {
    var _Object$getOwnPropert;
    return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object, s3)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
  })];
}
function getObjectSubset(object, subset, customTesters) {
  let stripped = 0, getObjectSubsetWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (Array.isArray(object2)) {
      if (Array.isArray(subset2) && subset2.length === object2.length)
        return subset2.map((sub, i2) => getObjectSubsetWithContext(seenReferences)(object2[i2], sub));
    } else {
      if (object2 instanceof Date)
        return object2;
      if (isObject4(object2) && isObject4(subset2)) {
        if (equals(object2, subset2, [
          ...customTesters,
          iterableEquality,
          subsetEquality
        ]))
          return subset2;
        let trimmed = {};
        seenReferences.set(object2, trimmed), typeof object2.constructor == "function" && typeof object2.constructor.name == "string" && Object.defineProperty(trimmed, "constructor", {
          enumerable: false,
          value: object2.constructor
        });
        for (let key of getObjectKeys(object2))
          hasPropertyInObject(subset2, key) ? trimmed[key] = seenReferences.has(object2[key]) ? seenReferences.get(object2[key]) : getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]) : seenReferences.has(object2[key]) || (stripped += 1, isObject4(object2[key]) && (stripped += getObjectKeys(object2[key]).length), getObjectSubsetWithContext(seenReferences)(object2[key], subset2[key]));
        if (getObjectKeys(trimmed).length > 0)
          return trimmed;
      }
    }
    return object2;
  };
  return {
    subset: getObjectSubsetWithContext()(object, subset),
    stripped
  };
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  let globalState = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: () => globalState });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
  let matchers = /* @__PURE__ */ Object.create(null), customEqualityTesters = [];
  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
    configurable: true,
    get: () => ({
      state: globalThis[MATCHERS_OBJECT].get(globalThis[GLOBAL_EXPECT]),
      matchers,
      customEqualityTesters
    })
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ASYMMETRIC_MATCHERS_OBJECT)) {
  let asymmetricMatchers = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: () => asymmetricMatchers });
}
function getState(expect4) {
  return globalThis[MATCHERS_OBJECT].get(expect4);
}
function setState(state3, expect4) {
  let map2 = globalThis[MATCHERS_OBJECT], current = map2.get(expect4) || {}, results = Object.defineProperties(current, {
    ...Object.getOwnPropertyDescriptors(current),
    ...Object.getOwnPropertyDescriptors(state3)
  });
  map2.set(expect4, results);
}
var AsymmetricMatcher3 = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(sample, inverse = false) {
    this.sample = sample, this.inverse = inverse;
  }
  getMatcherContext(expect4) {
    return {
      ...getState(expect4 || globalThis[GLOBAL_EXPECT]),
      equals,
      isNot: this.inverse,
      customTesters: getCustomEqualityTesters(),
      utils: {
        ...getMatcherUtils(),
        diff,
        stringify: stringify2,
        iterableEquality,
        subsetEquality
      }
    };
  }
};
AsymmetricMatcher3.prototype[Symbol.for("chai/inspect")] = function(options) {
  let result = stringify2(this, options.depth, { min: true });
  return result.length <= options.truncate ? result : `${this.toString()}{}`;
};
var StringContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample))
      throw new Error("Expected is not a string");
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && other.includes(this.sample);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
}, Anything = class extends AsymmetricMatcher3 {
  asymmetricMatch(other) {
    return other != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
}, ObjectContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  getPrototype(obj) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.constructor.prototype === obj ? null : obj.constructor.prototype;
  }
  hasProperty(obj, property) {
    return obj ? Object.prototype.hasOwnProperty.call(obj, property) ? true : this.hasProperty(this.getPrototype(obj), property) : false;
  }
  asymmetricMatch(other) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let result = true, matcherContext = this.getMatcherContext();
    for (let property in this.sample)
      if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
        result = false;
        break;
      }
    return this.inverse ? !result : result;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
}, ArrayContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    let matcherContext = this.getMatcherContext(), result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
    return this.inverse ? !result : result;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
}, Any = class extends AsymmetricMatcher3 {
  constructor(sample) {
    if (typeof sample > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(sample);
  }
  fnNameFor(func) {
    if (func.name)
      return func.name;
    let matches5 = Function.prototype.toString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return matches5 ? matches5[1] : "<anonymous>";
  }
  asymmetricMatch(other) {
    return this.sample === String ? typeof other == "string" || other instanceof String : this.sample === Number ? typeof other == "number" || other instanceof Number : this.sample === Function ? typeof other == "function" || typeof other == "function" : this.sample === Boolean ? typeof other == "boolean" || other instanceof Boolean : this.sample === BigInt ? typeof other == "bigint" || other instanceof BigInt : this.sample === Symbol ? typeof other == "symbol" || other instanceof Symbol : this.sample === Object ? typeof other == "object" : other instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
}, StringMatching = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample) && !isA("RegExp", sample))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(sample), inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && this.sample.test(other);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
}, CloseTo = class extends AsymmetricMatcher3 {
  precision;
  constructor(sample, precision = 2, inverse = false) {
    if (!isA("Number", sample))
      throw new Error("Expected is not a Number");
    if (!isA("Number", precision))
      throw new Error("Precision is not a Number");
    super(sample), this.inverse = inverse, this.precision = precision;
  }
  asymmetricMatch(other) {
    if (!isA("Number", other))
      return false;
    let result = false;
    return other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? result = true : result = Math.abs(this.sample - other) < 10 ** -this.precision / 2, this.inverse ? !result : result;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${pluralize("digit", this.precision)})`
    ].join(" ");
  }
}, JestAsymmetricMatchers = (chai, utils) => {
  utils.addMethod(chai.expect, "anything", () => new Anything()), utils.addMethod(chai.expect, "any", (expected) => new Any(expected)), utils.addMethod(chai.expect, "stringContaining", (expected) => new StringContaining(expected)), utils.addMethod(chai.expect, "objectContaining", (expected) => new ObjectContaining(expected)), utils.addMethod(chai.expect, "arrayContaining", (expected) => new ArrayContaining(expected)), utils.addMethod(chai.expect, "stringMatching", (expected) => new StringMatching(expected)), utils.addMethod(chai.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision)), chai.expect.not = {
    stringContaining: (expected) => new StringContaining(expected, true),
    objectContaining: (expected) => new ObjectContaining(expected, true),
    arrayContaining: (expected) => new ArrayContaining(expected, true),
    stringMatching: (expected) => new StringMatching(expected, true),
    closeTo: (expected, precision) => new CloseTo(expected, precision, true)
  };
};
function createAssertionMessage(util, assertion, hasArgs) {
  let not = util.flag(assertion, "negate") ? "not." : "", name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`, promiseName = util.flag(assertion, "promise");
  return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect(_test, promise, assertion, error) {
  let test3 = _test;
  if (test3 && promise instanceof Promise) {
    promise = promise.finally(() => {
      if (!test3.promises)
        return;
      let index2 = test3.promises.indexOf(promise);
      index2 !== -1 && test3.promises.splice(index2, 1);
    }), test3.promises || (test3.promises = []), test3.promises.push(promise);
    let resolved = false;
    return test3.onFinished ?? (test3.onFinished = []), test3.onFinished.push(() => {
      if (!resolved) {
        var _vitest_worker__;
        let stack2 = (((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s3) => s3 || ""))(error.stack);
        console.warn([
          `Promise returned by \`${assertion}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          stack2
        ].join(""));
      }
    }), {
      then(onFulfilled, onRejected) {
        return resolved = true, promise.then(onFulfilled, onRejected);
      },
      catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally(onFinally) {
        return promise.finally(onFinally);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return promise;
}
function handleTestError(test3, err) {
  var _test$result;
  test3.result || (test3.result = { state: "fail" }), test3.result.state = "fail", (_test$result = test3.result).errors || (_test$result.errors = []), test3.result.errors.push(processError(err));
}
function wrapAssertion(utils, name, fn3) {
  return function(...args) {
    if (name !== "withTest" && utils.flag(this, "_name", name), !utils.flag(this, "soft"))
      return fn3.apply(this, args);
    let test3 = utils.flag(this, "vitest-test");
    if (!test3)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      let result = fn3.apply(this, args);
      return result && typeof result == "object" && typeof result.then == "function" ? result.then(noop$2, (err) => {
        handleTestError(test3, err);
      }) : result;
    } catch (err) {
      handleTestError(test3, err);
    }
  };
}
var JestChaiExpect = (chai, utils) => {
  let { AssertionError: AssertionError2 } = chai, customTesters = getCustomEqualityTesters();
  function def(name, fn3) {
    let addMethod2 = (n2) => {
      let softWrapper = wrapAssertion(utils, n2, fn3);
      utils.addMethod(chai.Assertion.prototype, n2, softWrapper), utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n2, softWrapper);
    };
    Array.isArray(name) ? name.forEach((n2) => addMethod2(n2)) : addMethod2(name);
  }
  [
    "throw",
    "throws",
    "Throw"
  ].forEach((m3) => {
    utils.overwriteMethod(chai.Assertion.prototype, m3, (_super) => function(...args) {
      let promise = utils.flag(this, "promise"), object = utils.flag(this, "object"), isNot = utils.flag(this, "negate");
      if (promise === "rejects")
        utils.flag(this, "object", () => {
          throw object;
        });
      else if (promise === "resolves" && typeof object != "function") {
        if (isNot)
          return;
        {
          let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: false };
          throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
        }
      }
      _super.apply(this, args);
    });
  }), def("withTest", function(test3) {
    return utils.flag(this, "vitest-test", test3), this;
  }), def("toEqual", function(expected) {
    let actual = utils.flag(this, "object"), equal = equals(actual, expected, [...customTesters, iterableEquality]);
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  }), def("toStrictEqual", function(expected) {
    let obj = utils.flag(this, "object"), equal = equals(obj, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], true);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  }), def("toBe", function(expected) {
    let actual = this._obj, pass = Object.is(actual, expected), deepEqualityName = "";
    return pass || (equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], true) ? deepEqualityName = "toStrictEqual" : equals(actual, expected, [...customTesters, iterableEquality]) && (deepEqualityName = "toEqual")), this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  }), def("toMatchObject", function(expected) {
    let actual = this._obj, pass = equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      subsetEquality
    ]), isNot = utils.flag(this, "negate"), { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
    if (pass && isNot || !pass && !isNot) {
      let msg = utils.getMessage(this, [
        pass,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        expected,
        actualSubset,
        false
      ]), message = stripped === 0 ? msg : `${msg}
(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
      throw new AssertionError2(message, {
        showDiff: true,
        expected,
        actual: actualSubset
      });
    }
  }), def("toMatch", function(expected) {
    let actual = this._obj;
    if (typeof actual != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
    return this.assert(typeof expected == "string" ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
  }), def("toContain", function(item) {
    let actual = this._obj;
    if (typeof Node < "u" && actual instanceof Node) {
      if (!(item instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList < "u" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      let expectedClassList = utils.flag(this, "negate") ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
      return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
    }
    return typeof actual == "string" && typeof item == "string" ? this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual) : (actual != null && typeof actual != "string" && utils.flag(this, "object", Array.from(actual)), this.contain(item));
  }), def("toContainEqual", function(expected) {
    let obj = utils.flag(this, "object"), index2 = Array.from(obj).findIndex((item) => equals(item, expected, customTesters));
    this.assert(index2 !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  }), def("toBeTruthy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!!obj, "expected #{this} to be truthy", "expected #{this} to not be truthy", true, obj);
  }), def("toBeFalsy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, obj);
  }), def("toBeGreaterThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, false);
  }), def("toBeGreaterThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, false);
  }), def("toBeLessThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, false);
  }), def("toBeLessThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, false);
  }), def("toBeNaN", function() {
    let obj = utils.flag(this, "object");
    this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, obj);
  }), def("toBeUndefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
  }), def("toBeNull", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
  }), def("toBeDefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(typeof obj < "u", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
  }), def("toBeTypeOf", function(expected) {
    let actual = typeof this._obj, equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  }), def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  }), def("toHaveLength", function(length) {
    return this.have.length(length);
  }), def("toHaveProperty", function(...args) {
    Array.isArray(args[0]) && (args[0] = args[0].map((key) => String(key).replace(/([.[\]])/g, "\\$1")).join("."));
    let actual = this._obj, [propertyName, expected] = args, getValue2 = () => Object.prototype.hasOwnProperty.call(actual, propertyName) ? {
      value: actual[propertyName],
      exists: true
    } : utils.getPathInfo(actual, propertyName), { value, exists } = getValue2(), pass = exists && (args.length === 1 || equals(expected, value, customTesters)), valueString = args.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
    return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
  }), def("toBeCloseTo", function(received, precision = 2) {
    let expected = this._obj, pass = false, expectedDiff2 = 0, receivedDiff = 0;
    return received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY || received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY ? pass = true : (expectedDiff2 = 10 ** -precision / 2, receivedDiff = Math.abs(expected - received), pass = receivedDiff < expectedDiff2), this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, received, expected, false);
  });
  function assertIsMock(assertion) {
    if (!isMockFunction(assertion._obj))
      throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
  }
  function getSpy(assertion) {
    return assertIsMock(assertion), assertion._obj;
  }
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, false);
  }), def("toHaveBeenCalledOnce", function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, false);
  }), def(["toHaveBeenCalled", "toBeCalled"], function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, called = callCount > 0, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      called,
      `expected "${spyName}" to be called at least once`,
      `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
      true,
      called
    ]);
    if (called && isNot && (msg = formatCalls(spy, msg)), called && isNot || !called && !isNot)
      throw new AssertionError2(msg);
  });
  function equalsArgumentArray(a2, b2) {
    return a2.length === b2.length && a2.every((aItem, i2) => equals(aItem, b2[i2], [...customTesters, iterableEquality]));
  }
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)), isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called with arguments: #{exp}`,
      `expected "${spyName}" to not be called with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def("toHaveBeenCalledExactlyOnceWith", function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)) && callCount === 1, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called once with arguments: #{exp}`,
      `expected "${spyName}" to not be called once with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), nthCall = spy.mock.calls[times - 1], callCount = spy.mock.calls.length, isCalled = times <= callCount;
    this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? "" : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
  }), def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
  });
  function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
    let beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder, afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
    return beforeInvocationCallOrder.length === 0 ? !failIfNoFirstInvocation : afterInvocationCallOrder.length === 0 ? false : beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
  }
  def(["toHaveBeenCalledBefore"], function(resultSpy, failIfNoFirstInvocation = true) {
    let expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toHaveBeenCalledAfter"], function(resultSpy, failIfNoFirstInvocation = true) {
    let expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toThrow", "toThrowError"], function(expected) {
    if (typeof expected == "string" || typeof expected > "u" || expected instanceof RegExp)
      return this.throws(expected === "" ? /^$/ : expected);
    let obj = this._obj, promise = utils.flag(this, "promise"), isNot = utils.flag(this, "negate"), thrown = null;
    if (promise === "rejects")
      thrown = obj;
    else if (promise === "resolves" && typeof obj != "function") {
      if (isNot)
        return;
      {
        let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    } else {
      let isThrow = false;
      try {
        obj();
      } catch (err) {
        isThrow = true, thrown = err;
      }
      if (!isThrow && !isNot) {
        let message = utils.flag(this, "message") || "expected function to throw an error, but it didn't", error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected == "function") {
      let name = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
    }
    if (expected instanceof Error) {
      let equal = equals(thrown, expected, [...customTesters, iterableEquality]);
      return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
    }
    if (typeof expected == "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch == "function") {
      let matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
  }), [{
    name: "toHaveResolved",
    condition: (spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type5 }) => type5 === "fulfilled"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: (spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type5 }) => type5 !== "throw"),
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function() {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} at least once`, `expected "${spyName}" to not be successfully ${action2}`, pass, !pass, false);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: (spy, times) => spy.mock.settledResults.reduce((s3, { type: type5 }) => type5 === "fulfilled" ? ++s3 : s3, 0) === times,
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: (spy, times) => spy.mock.results.reduce((s3, { type: type5 }) => type5 === "throw" ? s3 : ++s3, 0) === times,
    action: "called"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(times) {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy, times);
      this.assert(pass, `expected "${spyName}" to be successfully ${action2} ${times} times`, `expected "${spyName}" to not be successfully ${action2} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, false);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: (spy, value) => spy.mock.settledResults.some(({ type: type5, value: result }) => type5 === "fulfilled" && equals(value, result)),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: (spy, value) => spy.mock.results.some(({ type: type5, value: result }) => type5 === "return" && equals(value, result)),
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      let spy = getSpy(this), pass = condition(spy, value), isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        let spyName = spy.getMockName(), msg = utils.getMessage(this, [
          pass,
          `expected "${spyName}" to ${action2} with: #{exp} at least once`,
          `expected "${spyName}" to not ${action2} with: #{exp}`,
          value
        ]), results = action2 === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError2(formatReturns(spy, results, msg, value));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: (spy, value) => {
      let result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: (spy, value) => {
      let result = spy.mock.results[spy.mock.results.length - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(value) {
      let spy = getSpy(this), results = action2 === "return" ? spy.mock.results : spy.mock.settledResults, result = results[results.length - 1], spyName = spy.getMockName();
      this.assert(condition(spy, value), `expected last "${spyName}" call to ${action2} #{exp}`, `expected last "${spyName}" call to not ${action2} #{exp}`, value, result?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: (spy, index2, value) => {
      let result = spy.mock.settledResults[index2 - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: (spy, index2, value) => {
      let result = spy.mock.results[index2 - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action: action2 }) => {
    def(name, function(nthCall, value) {
      let spy = getSpy(this), spyName = spy.getMockName(), result = (action2 === "return" ? spy.mock.results : spy.mock.settledResults)[nthCall - 1], ordinalCall = `${ordinalOf(nthCall)} call`;
      this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action2} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action2} #{exp}`, value, result?.value);
    });
  }), def("withContext", function(context) {
    for (let key in context)
      utils.flag(this, key, context[key]);
    return this;
  }), utils.addProperty(chai.Assertion.prototype, "resolves", function() {
    let error = new Error("resolves");
    utils.flag(this, "promise", "resolves"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object");
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof obj?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = obj.then((value) => (utils.flag(this, "object", value), result.call(this, ...args)), (err) => {
          let _error = new AssertionError2(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: false });
          throw _error.cause = err, _error.stack = error.stack.replace(error.message, _error.message), _error;
        });
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  }), utils.addProperty(chai.Assertion.prototype, "rejects", function() {
    let error = new Error("rejects");
    utils.flag(this, "promise", "rejects"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object"), wrapper = typeof obj == "function" ? obj() : obj;
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof wrapper?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = wrapper.then((value) => {
          let _error = new AssertionError2(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
            showDiff: true,
            expected: new Error("rejected promise"),
            actual: value
          });
          throw _error.stack = error.stack.replace(error.message, _error.message), _error;
        }, (err) => (utils.flag(this, "object", err), result.call(this, ...args)));
        return recordAsyncExpect(test3, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  });
};
function ordinalOf(i2) {
  let j2 = i2 % 10, k2 = i2 % 100;
  return j2 === 1 && k2 !== 11 ? `${i2}st` : j2 === 2 && k2 !== 12 ? `${i2}nd` : j2 === 3 && k2 !== 13 ? `${i2}rd` : `${i2}th`;
}
function formatCalls(spy, msg, showActualCall) {
  return spy.mock.calls.length && (msg += s.gray(`

Received: 

${spy.mock.calls.map((callArg, i2) => {
    let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call:

`);
    return showActualCall ? methodCall += diff(showActualCall, callArg, { omitAnnotationLines: true }) : methodCall += stringify2(callArg).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`), msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
  return results.length && (msg += s.gray(`

Received: 

${results.map((callReturn, i2) => {
    let methodCall = s.bold(`  ${ordinalOf(i2 + 1)} ${spy.getMockName()} call return:

`);
    return showActualReturn ? methodCall += diff(showActualReturn, callReturn.value, { omitAnnotationLines: true }) : methodCall += stringify2(callReturn).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += s.gray(`

Number of calls: ${s.bold(spy.mock.calls.length)}
`), msg;
}
function getMatcherState(assertion, expect4) {
  let obj = assertion._obj, isNot = utils_exports.flag(assertion, "negate"), promise = utils_exports.flag(assertion, "promise") || "", jestUtils = {
    ...getMatcherUtils(),
    diff,
    stringify: stringify2,
    iterableEquality,
    subsetEquality
  };
  return {
    state: {
      ...getState(expect4),
      customTesters: getCustomEqualityTesters(),
      isNot,
      utils: jestUtils,
      promise,
      equals,
      suppressedErrors: [],
      soft: utils_exports.flag(assertion, "soft"),
      poll: utils_exports.flag(assertion, "poll")
    },
    isNot,
    obj
  };
}
var JestExtendError = class extends Error {
  constructor(message, actual, expected) {
    super(message), this.actual = actual, this.expected = expected;
  }
};
function JestExtendPlugin(c2, expect4, matchers) {
  return (_, utils) => {
    Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
      function expectWrapper(...args) {
        let { state: state3, isNot, obj } = getMatcherState(this, expect4), result = expectAssertion.call(state3, obj, ...args);
        if (result && typeof result == "object" && typeof result.then == "function")
          return result.then(({ pass: pass2, message: message2, actual: actual2, expected: expected2 }) => {
            if (pass2 && isNot || !pass2 && !isNot)
              throw new JestExtendError(message2(), actual2, expected2);
          });
        let { pass, message, actual, expected } = result;
        if (pass && isNot || !pass && !isNot)
          throw new JestExtendError(message(), actual, expected);
      }
      let softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper), utils.addMethod(c2.Assertion.prototype, expectAssertionName, softWrapper);
      class CustomMatcher extends AsymmetricMatcher3 {
        constructor(inverse = false, ...sample) {
          super(sample, inverse);
        }
        asymmetricMatch(other) {
          let { pass } = expectAssertion.call(this.getMatcherContext(expect4), other, ...this.sample);
          return this.inverse ? !pass : pass;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${expectAssertionName}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((item) => stringify2(item)).join(", ")}>`;
        }
      }
      let customMatcher = (...sample) => new CustomMatcher(false, ...sample);
      Object.defineProperty(expect4, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      }), Object.defineProperty(expect4.not, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: (...sample) => new CustomMatcher(true, ...sample),
        writable: true
      }), Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      });
    });
  };
}
var JestExtend = (chai, utils) => {
  utils.addMethod(chai.expect, "extend", (expect4, expects) => {
    use(JestExtendPlugin(chai, expect4, expects));
  });
};
function createExpect() {
  use(JestExtend), use(JestChaiExpect), use(JestAsymmetricMatchers);
  let expect4 = (value, message) => {
    let { assertionCalls } = getState(expect4);
    return setState({ assertionCalls: assertionCalls + 1, soft: false }, expect4), expect(value, message);
  };
  Object.assign(expect4, expect), expect4.getState = () => getState(expect4), expect4.setState = (state3) => setState(state3, expect4), expect4.extend = (expects) => expect.extend(expect4, expects), expect4.soft = (...args) => {
    let assert2 = expect4(...args);
    return expect4.setState({
      soft: true
    }), assert2;
  }, expect4.extend(customMatchers), expect4.unreachable = (message) => {
    assert.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
  };
  function assertions(expected) {
    let errorGen = () => new Error(
      `expected number of assertions to be ${expected}, but got ${expect4.getState().assertionCalls}`
    );
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(errorGen(), assertions), expect4.setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberErrorGen: errorGen
    });
  }
  function hasAssertions() {
    let error = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(error, hasAssertions), expect4.setState({
      isExpectingAssertions: true,
      isExpectingAssertionsError: error
    });
  }
  return setState(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: false,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    expect4
  ), utils_exports.addMethod(expect4, "assertions", assertions), utils_exports.addMethod(expect4, "hasAssertions", hasAssertions), expect4.extend(matchers_exports), expect4;
}
var expect2 = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
  value: expect2,
  writable: true,
  configurable: true
});
function f3(e2, t22, n2) {
  Object.defineProperty(e2, t22, n2);
}
var u2 = Symbol.for("tinyspy:spy");
var P2 = (e2) => {
  e2.called = false, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
}, K2 = (e2) => (f3(e2, u2, { value: { reset: () => P2(e2[u2]) } }), e2[u2]), T2 = (e2) => e2[u2] || K2(e2);
var listeners = /* @__PURE__ */ new Set();
function onMockCall(callback) {
  return listeners.add(callback), () => void listeners.delete(callback);
}
var spyOn2 = (...args) => {
  let mock = spyOn(...args);
  return reactiveMock(mock);
};
function fn2(implementation) {
  let mock = implementation ? fn(implementation) : fn();
  return reactiveMock(mock);
}
function reactiveMock(mock) {
  let reactive = listenWhenCalled(mock), originalMockImplementation = reactive.mockImplementation.bind(null);
  return reactive.mockImplementation = (fn3) => listenWhenCalled(originalMockImplementation(fn3)), reactive;
}
function listenWhenCalled(mock) {
  let state3 = T2(mock), impl = state3.impl;
  return state3.willCall(function(...args) {
    return listeners.forEach((listener) => listener(mock, args)), impl?.apply(this, args);
  }), mock;
}
function clearAllMocks() {
  mocks.forEach((spy) => spy.mockClear());
}
function resetAllMocks() {
  mocks.forEach((spy) => spy.mockReset());
}
function restoreAllMocks() {
  mocks.forEach((spy) => spy.mockRestore());
}
function mocked(item, _options = {}) {
  return item;
}
var dom_esm_exports = {};
__export$4(dom_esm_exports, {
  buildQueries: () => buildQueries,
  configure: () => configure$1,
  createEvent: () => createEvent,
  findAllByAltText: () => findAllByAltText,
  findAllByDisplayValue: () => findAllByDisplayValue,
  findAllByLabelText: () => findAllByLabelText,
  findAllByPlaceholderText: () => findAllByPlaceholderText,
  findAllByRole: () => findAllByRole,
  findAllByTestId: () => findAllByTestId,
  findAllByText: () => findAllByText,
  findAllByTitle: () => findAllByTitle,
  findByAltText: () => findByAltText,
  findByDisplayValue: () => findByDisplayValue,
  findByLabelText: () => findByLabelText,
  findByPlaceholderText: () => findByPlaceholderText,
  findByRole: () => findByRole,
  findByTestId: () => findByTestId,
  findByText: () => findByText,
  findByTitle: () => findByTitle,
  fireEvent: () => fireEvent,
  getAllByAltText: () => getAllByAltText,
  getAllByDisplayValue: () => getAllByDisplayValue,
  getAllByLabelText: () => getAllByLabelTextWithSuggestions,
  getAllByPlaceholderText: () => getAllByPlaceholderText,
  getAllByRole: () => getAllByRole,
  getAllByTestId: () => getAllByTestId,
  getAllByText: () => getAllByText,
  getAllByTitle: () => getAllByTitle,
  getByAltText: () => getByAltText,
  getByDisplayValue: () => getByDisplayValue,
  getByLabelText: () => getByLabelTextWithSuggestions,
  getByPlaceholderText: () => getByPlaceholderText,
  getByRole: () => getByRole,
  getByTestId: () => getByTestId,
  getByText: () => getByText,
  getByTitle: () => getByTitle,
  getConfig: () => getConfig2,
  getDefaultNormalizer: () => getDefaultNormalizer,
  getElementError: () => getElementError,
  getMultipleElementsFoundError: () => getMultipleElementsFoundError,
  getNodeText: () => getNodeText,
  getQueriesForElement: () => getQueriesForElement,
  getRoles: () => getRoles,
  getSuggestedQuery: () => getSuggestedQuery,
  isInaccessible: () => isInaccessible,
  logDOM: () => logDOM,
  logRoles: () => logRoles,
  makeFindQuery: () => makeFindQuery,
  makeGetAllQuery: () => makeGetAllQuery,
  makeSingleQuery: () => makeSingleQuery,
  prettyDOM: () => prettyDOM,
  prettyFormat: () => prettyFormat,
  queries: () => queries,
  queryAllByAltText: () => queryAllByAltTextWithSuggestions,
  queryAllByAttribute: () => queryAllByAttribute,
  queryAllByDisplayValue: () => queryAllByDisplayValueWithSuggestions,
  queryAllByLabelText: () => queryAllByLabelTextWithSuggestions,
  queryAllByPlaceholderText: () => queryAllByPlaceholderTextWithSuggestions,
  queryAllByRole: () => queryAllByRoleWithSuggestions,
  queryAllByTestId: () => queryAllByTestIdWithSuggestions,
  queryAllByText: () => queryAllByTextWithSuggestions,
  queryAllByTitle: () => queryAllByTitleWithSuggestions,
  queryByAltText: () => queryByAltText,
  queryByAttribute: () => queryByAttribute,
  queryByDisplayValue: () => queryByDisplayValue,
  queryByLabelText: () => queryByLabelText,
  queryByPlaceholderText: () => queryByPlaceholderText,
  queryByRole: () => queryByRole,
  queryByTestId: () => queryByTestId,
  queryByText: () => queryByText,
  queryByTitle: () => queryByTitle,
  queryHelpers: () => queryHelpers,
  screen: () => screen,
  waitFor: () => waitForWrapper,
  waitForElementToBeRemoved: () => waitForElementToBeRemoved,
  within: () => getQueriesForElement,
  wrapAllByQueryWithSuggestion: () => wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion: () => wrapSingleQueryWithSuggestion
});
var prettyFormat = __toESM$3(require_build());
var toStr2 = Object.prototype.toString;
function isCallable2(fn3) {
  return typeof fn3 == "function" || toStr2.call(fn3) === "[object Function]";
}
function toInteger2(value) {
  var number = Number(value);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger2 = Math.pow(2, 53) - 1;
function toLength2(value) {
  var len = toInteger2(value);
  return Math.min(Math.max(len, 0), maxSafeInteger2);
}
function arrayFrom2(arrayLike, mapFn) {
  var C2 = Array, items = Object(arrayLike);
  if (arrayLike == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  for (var len = toLength2(items.length), A = isCallable2(C2) ? Object(new C2(len)) : new Array(len), k2 = 0, kValue; k2 < len; )
    kValue = items[k2], A[k2] = kValue, k2 += 1;
  return A.length = len, A;
}
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties2(Constructor.prototype, protoProps), Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
}
function _defineProperty3(obj, key, value) {
  return key = _toPropertyKey3(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }) : obj[key] = value, obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return _typeof3(key) === "symbol" ? key : String(key);
}
function _toPrimitive3(input2, hint) {
  if (_typeof3(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint);
    if (_typeof3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike2 = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck2(this, SetLike3), _defineProperty3(this, "items", void 0), this.items = items;
  }
  return _createClass2(SetLike3, [{
    key: "add",
    value: function(value) {
      return this.has(value) === false && this.items.push(value), this;
    }
  }, {
    key: "clear",
    value: function() {
      this.items = [];
    }
  }, {
    key: "delete",
    value: function(value) {
      var previousLength = this.items.length;
      return this.items = this.items.filter(function(item) {
        return item !== value;
      }), previousLength !== this.items.length;
    }
  }, {
    key: "forEach",
    value: function(callbackfn) {
      var _this = this;
      this.items.forEach(function(item) {
        callbackfn(item, item, _this);
      });
    }
  }, {
    key: "has",
    value: function(value) {
      return this.items.indexOf(value) !== -1;
    }
  }, {
    key: "size",
    get: function() {
      return this.items.length;
    }
  }]), SetLike3;
}(), SetLike_default2 = typeof Set > "u" ? Set : SetLike2;
function getLocalName2(element) {
  var _element$localName;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      element.tagName.toLowerCase()
    )
  );
}
var localNameToRoleMappings2 = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, prohibitedAttributes2 = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function hasGlobalAriaAttributes2(element, role) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes2[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole2(element, implicitRole) {
  return hasGlobalAriaAttributes2(element, implicitRole);
}
function getRole2(element) {
  var explicitRole = getExplicitRole2(element);
  if (explicitRole === null || explicitRole === "presentation") {
    var implicitRole = getImplicitRole2(element);
    if (explicitRole !== "presentation" || ignorePresentationalRole2(element, implicitRole || ""))
      return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole2(element) {
  var mappedByTag = localNameToRoleMappings2[getLocalName2(element)];
  if (mappedByTag !== void 0)
    return mappedByTag;
  switch (getLocalName2(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole2(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole2(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0)
      return explicitRole;
  }
  return null;
}
function isElement2(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement2(node) {
  return isElement2(node) && getLocalName2(node) === "caption";
}
function isHTMLInputElement2(node) {
  return isElement2(node) && getLocalName2(node) === "input";
}
function isHTMLOptGroupElement2(node) {
  return isElement2(node) && getLocalName2(node) === "optgroup";
}
function isHTMLSelectElement2(node) {
  return isElement2(node) && getLocalName2(node) === "select";
}
function isHTMLTableElement2(node) {
  return isElement2(node) && getLocalName2(node) === "table";
}
function isHTMLTextAreaElement2(node) {
  return isElement2(node) && getLocalName2(node) === "textarea";
}
function safeWindow2(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null)
    throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement2(node) {
  return isElement2(node) && getLocalName2(node) === "fieldset";
}
function isHTMLLegendElement2(node) {
  return isElement2(node) && getLocalName2(node) === "legend";
}
function isHTMLSlotElement2(node) {
  return isElement2(node) && getLocalName2(node) === "slot";
}
function isSVGElement2(node) {
  return isElement2(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement2(node) {
  return isElement2(node) && getLocalName2(node) === "svg";
}
function isSVGTitleElement2(node) {
  return isSVGElement2(node) && getLocalName2(node) === "title";
}
function queryIdRefs2(node, attributeName) {
  if (isElement2(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(
      function(element) {
        return element !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
function hasAnyConcreteRoles2(node, roles3) {
  return isElement2(node) ? roles3.indexOf(getRole2(node)) !== -1 : false;
}
function asFlatString2(s3) {
  return s3.trim().replace(/\s\s+/g, " ");
}
function isHidden2(node, getComputedStyleImplementation) {
  if (!isElement2(node))
    return false;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true")
    return true;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl2(node) {
  return hasAnyConcreteRoles2(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole2(node, "range");
}
function hasAbstractRole2(node, role) {
  if (!isElement2(node))
    return false;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles2(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree2(element, selectors) {
  var elements2 = arrayFrom2(element.querySelectorAll(selectors));
  return queryIdRefs2(element, "aria-owns").forEach(function(root2) {
    elements2.push.apply(elements2, arrayFrom2(root2.querySelectorAll(selectors)));
  }), elements2;
}
function querySelectedOptions2(listbox) {
  return isHTMLSelectElement2(listbox) ? listbox.selectedOptions || querySelectorAllSubtree2(listbox, "[selected]") : querySelectorAllSubtree2(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational2(node) {
  return hasAnyConcreteRoles2(node, ["none", "presentation"]);
}
function isNativeHostLanguageTextAlternativeElement2(node) {
  return isHTMLTableCaptionElement2(node);
}
function allowsNameFromContent2(node) {
  return hasAnyConcreteRoles2(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement2(node) {
  return false;
}
function getValueOfTextbox2(element) {
  return isHTMLInputElement2(element) || isHTMLTextAreaElement2(element) ? element.value : element.textContent || "";
}
function getTextualContent2(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement2(element) {
  var localName = getLocalName2(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement2(element) {
  if (isLabelableElement2(element))
    return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement2(childNode)) {
      var descendantLabelableElement = findLabelableElement2(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel2(label) {
  if (label.control !== void 0)
    return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement2(label);
}
function getLabels2(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null)
    return labelsProperty;
  if (labelsProperty !== void 0)
    return arrayFrom2(labelsProperty);
  if (!isLabelableElement2(element))
    return null;
  var document7 = element.ownerDocument;
  return arrayFrom2(document7.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel2(label) === element;
  });
}
function getSlotContents2(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom2(slot.childNodes) : assignedNodes;
}
function computeTextAlternative2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default2(), window2 = safeWindow2(root2), _options$compute = options.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options.getComputedStyle, getComputedStyle2 = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle2(node, "::before"), beforeContent = getTextualContent2(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement2(node) ? getSlotContents2(node) : arrayFrom2(node.childNodes).concat(queryIdRefs2(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result = computeTextAlternative3(child, {
        isEmbeddedInLabel: context.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      }), display2 = isElement2(child) ? getComputedStyle2(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result).concat(separator);
    }), isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle2(node, "::after"), afterContent = getTextualContent2(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement2(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement2(node))
      return null;
    if (isHTMLFieldSetElement2(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom2(node.childNodes), i2 = 0; i2 < children.length; i2 += 1) {
        var child = children[i2];
        if (isHTMLLegendElement2(child))
          return computeTextAlternative3(child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (isHTMLTableElement2(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom2(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement2(_child))
          return computeTextAlternative3(_child, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (isSVGSVGElement2(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom2(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement2(_child2))
          return _child2.textContent;
      }
      return null;
    } else if (getLocalName2(node) === "img" || getLocalName2(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null)
        return nameFromAlt;
    } else if (isHTMLOptGroupElement2(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null)
        return nameFromLabel;
    }
    if (isHTMLInputElement2(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null)
        return nameFromValue;
      if (node.type === "submit")
        return "Submit";
      if (node.type === "reset")
        return "Reset";
    }
    var labels = getLabels2(node);
    if (labels !== null && labels.length !== 0)
      return consultedNodes.add(node), arrayFrom2(labels).map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(label) {
        return label.length > 0;
      }).join(" ");
    if (isHTMLInputElement2(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null)
        return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles2(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, {
        isEmbeddedInLabel: false
      });
      if (nameFromSubTree !== "")
        return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current))
      return "";
    if (!hidden && isHidden2(current, getComputedStyle2) && !context.isReferenced)
      return consultedNodes.add(current), "";
    var labelAttributeNode = isElement2(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs2(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0)
      return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
        return computeTextAlternative3(element, {
          isEmbeddedInLabel: context.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    var skipToStep2E = context.recursion && isControl2(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement2(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name")
        return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational2(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null)
          return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles2(current, ["menu"]))
      return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles2(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions2(current);
        return selectedOptions.length === 0 ? isHTMLInputElement2(current) ? current.value : "" : arrayFrom2(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, {
            isEmbeddedInLabel: context.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (hasAbstractRole2(current, "range"))
        return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles2(current, ["textbox"]))
        return consultedNodes.add(current), getValueOfTextbox2(current);
    }
    if (allowsNameFromContent2(current) || isElement2(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement2(current) || isDescendantOfNativeHostLanguageTextAlternativeElement2()) {
      var accumulatedText2F = computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel
      });
      if (accumulatedText2F !== "")
        return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE)
      return consultedNodes.add(current), current.textContent || "";
    if (context.recursion)
      return consultedNodes.add(current), computeMiscTextAlternative(current, {
        isEmbeddedInLabel: context.isEmbeddedInLabel
      });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString2(computeTextAlternative3(root2, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: compute === "description",
    recursion: false
  }));
}
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  return key = _toPropertyKey4(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }) : obj[key] = value, obj;
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return _typeof4(key) === "symbol" ? key : String(key);
}
function _toPrimitive4(input2, hint) {
  if (_typeof4(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint);
    if (_typeof4(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs2(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative2(element, _objectSpread2$1(_objectSpread2$1({}, options), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
function prohibitsNaming2(node) {
  return hasAnyConcreteRoles2(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName2(root2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming2(root2) ? "" : computeTextAlternative2(root2, options);
}
var import_aria_query3 = __toESM$3(require_lib()), import_lz_string = __toESM$3(require_lz_string());
function escapeHTML2(str2) {
  return str2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var printProps2 = (keys2, props, config4, indentation, depth, refs, printer2) => {
  let indentationNext = indentation + config4.indent, colors3 = config4.colors;
  return keys2.map((key) => {
    let value = props[key], printed = printer2(value, config4, indentationNext, depth, refs);
    return typeof value != "string" && (printed.indexOf(`
`) !== -1 && (printed = config4.spacingOuter + indentationNext + printed + config4.spacingOuter + indentation), printed = "{" + printed + "}"), config4.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close + "=" + colors3.value.open + printed + colors3.value.close;
  }).join("");
}, NodeTypeTextNode = 3, printChildren2 = (children, config4, indentation, depth, refs, printer2) => children.map((child) => {
  let printedChild = typeof child == "string" ? printText2(child, config4) : printer2(child, config4, indentation, depth, refs);
  return printedChild === "" && typeof child == "object" && child !== null && child.nodeType !== NodeTypeTextNode ? "" : config4.spacingOuter + indentation + printedChild;
}).join(""), printText2 = (text, config4) => {
  let contentColor = config4.colors.content;
  return contentColor.open + escapeHTML2(text) + contentColor.close;
}, printComment2 = (comment, config4) => {
  let commentColor = config4.colors.comment;
  return commentColor.open + "<!--" + escapeHTML2(comment) + "-->" + commentColor.close;
}, printElement2 = (type5, printedProps, printedChildren, config4, indentation) => {
  let tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config4.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config4.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config4.min ? "" : " ") + "/") + ">" + tagColor.close;
}, printElementAsLeaf2 = (type5, config4) => {
  let tagColor = config4.colors.tag;
  return tagColor.open + "<" + type5 + tagColor.close + " " + tagColor.open + " />" + tagColor.close;
}, ELEMENT_NODE$1 = 1, TEXT_NODE$1 = 3, COMMENT_NODE$1 = 8, FRAGMENT_NODE2 = 11, ELEMENT_REGEXP2 = /^((HTML|SVG)\w*)?Element$/, isCustomElement2 = (val) => {
  let {
    tagName
  } = val;
  return !!(typeof tagName == "string" && tagName.includes("-") || typeof val.hasAttribute == "function" && val.hasAttribute("is"));
}, testNode2 = (val) => {
  let constructorName = val.constructor.name, {
    nodeType
  } = val;
  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP2.test(constructorName) || isCustomElement2(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE2 && constructorName === "DocumentFragment";
};
function nodeIsText2(node) {
  return node.nodeType === TEXT_NODE$1;
}
function nodeIsComment2(node) {
  return node.nodeType === COMMENT_NODE$1;
}
function nodeIsFragment2(node) {
  return node.nodeType === FRAGMENT_NODE2;
}
function createDOMElementFilter(filterNode) {
  return {
    test: (val) => {
      var _val$constructor2;
      return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement2(val)) && testNode2(val);
    },
    serialize: (node, config4, indentation, depth, refs, printer2) => {
      if (nodeIsText2(node))
        return printText2(node.data, config4);
      if (nodeIsComment2(node))
        return printComment2(node.data, config4);
      let type5 = nodeIsFragment2(node) ? "DocumentFragment" : node.tagName.toLowerCase();
      return ++depth > config4.maxDepth ? printElementAsLeaf2(type5, config4) : printElement2(type5, printProps2(nodeIsFragment2(node) ? [] : Array.from(node.attributes).map((attr2) => attr2.name).sort(), nodeIsFragment2(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config4, indentation + config4.indent, depth, refs, printer2), printChildren2(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config4, indentation + config4.indent, depth, refs, printer2), config4, indentation);
    }
  };
}
var picocolors = null, readFileSync = null, codeFrameColumns = null;
try {
  let nodeRequire = module && module.require;
  readFileSync = nodeRequire.call(module, "fs").readFileSync, codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns, picocolors = nodeRequire.call(module, "picocolors");
} catch {
}
function getCodeFrame(frame) {
  let locationStart = frame.indexOf("(") + 1, locationEnd = frame.indexOf(")"), frameLocation = frame.slice(locationStart, locationEnd), frameLocationElements = frameLocation.split(":"), [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)], rawFileContents = "";
  try {
    rawFileContents = readFileSync(filename, "utf-8");
  } catch {
    return "";
  }
  let codeFrame = codeFrameColumns(rawFileContents, {
    start: {
      line,
      column
    }
  }, {
    highlightCode: true,
    linesBelow: 0
  });
  return picocolors.dim(frameLocation) + `
` + codeFrame + `
`;
}
function getUserCodeFrame() {
  if (!readFileSync || !codeFrameColumns)
    return "";
  let firstClientCodeFrame = new Error().stack.split(`
`).slice(1).find((frame) => !frame.includes("node_modules/"));
  return getCodeFrame(firstClientCodeFrame);
}
var TEXT_NODE2 = 3;
function jestFakeTimersAreEnabled$1() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === true || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : false;
}
function getDocument$2() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
function getWindowFromNode(node) {
  if (node.defaultView)
    return node.defaultView;
  if (node.ownerDocument && node.ownerDocument.defaultView)
    return node.ownerDocument.defaultView;
  if (node.window)
    return node.window;
  throw node.ownerDocument && node.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : node.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(node) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof node.debug == "function" && typeof node.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof node + ".");
}
function checkContainerType(container) {
  if (!container || typeof container.querySelector != "function" || typeof container.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
  function getTypeName(object) {
    return typeof object == "object" ? object === null ? "null" : object.constructor.name : typeof object;
  }
}
var shouldHighlight = () => {
  if (typeof process > "u")
    return false;
  let colors3;
  try {
    var _process$env;
    let colorsJSON = (_process$env = define_process_env_default) == null ? void 0 : _process$env.COLORS;
    colorsJSON && (colors3 = JSON.parse(colorsJSON));
  } catch {
  }
  return typeof colors3 == "boolean" ? colors3 : process.versions !== void 0 && process.versions.node !== void 0;
}, {
  DOMCollection: DOMCollection3
} = prettyFormat.plugins, ELEMENT_NODE2 = 1, COMMENT_NODE2 = 8;
function filterCommentsAndDefaultIgnoreTagsTags(value) {
  return value.nodeType !== COMMENT_NODE2 && (value.nodeType !== ELEMENT_NODE2 || !value.matches(getConfig2().defaultIgnore));
}
function prettyDOM(dom, maxLength, options) {
  if (options === void 0 && (options = {}), dom || (dom = getDocument$2().body), typeof maxLength != "number" && (maxLength = typeof process < "u" && typeof define_process_env_default < "u" && define_process_env_default.DEBUG_PRINT_LIMIT || 7e3), maxLength === 0)
    return "";
  dom.documentElement && (dom = dom.documentElement);
  let domTypeName = typeof dom;
  if (domTypeName === "object" ? domTypeName = dom.constructor.name : dom = {}, !("outerHTML" in dom))
    throw new TypeError("Expected an element or document but got " + domTypeName);
  let {
    filterNode = filterCommentsAndDefaultIgnoreTagsTags,
    ...prettyFormatOptions
  } = options, debugContent = prettyFormat.format(dom, {
    plugins: [createDOMElementFilter(filterNode), DOMCollection3],
    printFunctionName: false,
    highlight: shouldHighlight(),
    ...prettyFormatOptions
  });
  return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
}
var logDOM = function() {
  let userCodeFrame = getUserCodeFrame();
  console.log(userCodeFrame ? prettyDOM(...arguments) + `

` + userCodeFrame : prettyDOM(...arguments));
}, config2 = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: (cb) => cb(),
  unstable_advanceTimersWrapper: (cb) => cb(),
  eventWrapper: (cb) => cb(),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: false,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: false,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: false,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(message, container) {
    let prettifiedDOM = prettyDOM(container), error = new Error([message, "Ignored nodes: comments, " + config2.defaultIgnore + `
` + prettifiedDOM].filter(Boolean).join(`

`));
    return error.name = "TestingLibraryElementError", error;
  },
  _disableExpensiveErrorDiagnostics: false,
  computedStyleSupportsPseudoElements: false
};
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    return config2._disableExpensiveErrorDiagnostics = true, callback();
  } finally {
    config2._disableExpensiveErrorDiagnostics = false;
  }
}
function configure$1(newConfig) {
  typeof newConfig == "function" && (newConfig = newConfig(config2)), config2 = {
    ...config2,
    ...newConfig
  };
}
function getConfig2() {
  return config2;
}
var labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function getTextContent(node) {
  return labelledNodeNames.includes(node.nodeName.toLowerCase()) ? "" : node.nodeType === TEXT_NODE2 ? node.textContent : Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
}
function getLabelContent(element) {
  let textContent;
  return element.tagName.toLowerCase() === "label" ? textContent = getTextContent(element) : textContent = element.value || element.textContent, textContent;
}
function getRealLabels(element) {
  if (element.labels !== void 0) {
    var _labels;
    return (_labels = element.labels) != null ? _labels : [];
  }
  if (!isLabelable(element)) return [];
  let labels = element.ownerDocument.querySelectorAll("label");
  return Array.from(labels).filter((label) => label.control === element);
}
function isLabelable(element) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
}
function getLabels3(container, element, _temp) {
  let {
    selector = "*"
  } = _temp === void 0 ? {} : _temp, ariaLabelledBy = element.getAttribute("aria-labelledby"), labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
  return labelsId.length ? labelsId.map((labelId) => {
    let labellingElement = container.querySelector('[id="' + labelId + '"]');
    return labellingElement ? {
      content: getLabelContent(labellingElement),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(getRealLabels(element)).map((label) => {
    let textToMatch = getLabelContent(label), labelledFormControl = Array.from(label.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((formControlElement) => formControlElement.matches(selector))[0];
    return {
      content: textToMatch,
      formControl: labelledFormControl
    };
  });
}
function assertNotNullOrUndefined(matcher) {
  if (matcher == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?"
    );
}
function fuzzyMatches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string")
    return false;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return typeof matcher == "string" || typeof matcher == "number" ? normalizedText.toLowerCase().includes(matcher.toString().toLowerCase()) : typeof matcher == "function" ? matcher(normalizedText, node) : matchRegExp(matcher, normalizedText);
}
function matches2(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string")
    return false;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return matcher instanceof Function ? matcher(normalizedText, node) : matcher instanceof RegExp ? matchRegExp(matcher, normalizedText) : normalizedText === String(matcher);
}
function getDefaultNormalizer(_temp) {
  let {
    trim: trim2 = true,
    collapseWhitespace = true
  } = _temp === void 0 ? {} : _temp;
  return (text) => {
    let normalizedText = text;
    return normalizedText = trim2 ? normalizedText.trim() : normalizedText, normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText, normalizedText;
  };
}
function makeNormalizer(_ref) {
  let {
    trim: trim2,
    collapseWhitespace,
    normalizer
  } = _ref;
  if (!normalizer)
    return getDefaultNormalizer({
      trim: trim2,
      collapseWhitespace
    });
  if (typeof trim2 < "u" || typeof collapseWhitespace < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return normalizer;
}
function matchRegExp(matcher, text) {
  let match = matcher.test(text);
  return matcher.global && matcher.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), matcher.lastIndex = 0), match;
}
function getNodeText(node) {
  return node.matches("input[type=submit], input[type=button], input[type=reset]") ? node.value : Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE2 && !!child.textContent).map((c2) => c2.textContent).join("");
}
var elementRoleList2 = buildElementRoleList2(import_aria_query3.elementRoles);
function isSubtreeInaccessible(element) {
  return element.hidden === true || element.getAttribute("aria-hidden") === "true" || element.ownerDocument.defaultView.getComputedStyle(element).display === "none";
}
function isInaccessible(element, options) {
  options === void 0 && (options = {});
  let {
    isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible
  } = options;
  if (element.ownerDocument.defaultView.getComputedStyle(element).visibility === "hidden")
    return true;
  let currentElement = element;
  for (; currentElement; ) {
    if (isSubtreeInaccessibleImpl(currentElement))
      return true;
    currentElement = currentElement.parentElement;
  }
  return false;
}
function getImplicitAriaRoles2(currentNode) {
  for (let {
    match,
    roles: roles3
  } of elementRoleList2)
    if (match(currentNode))
      return [...roles3];
  return [];
}
function buildElementRoleList2(elementRolesMap) {
  function makeElementSelector(_ref) {
    let {
      name,
      attributes
    } = _ref;
    return "" + name + attributes.map((_ref2) => {
      let {
        name: attributeName,
        value,
        constraints = []
      } = _ref2, shouldNotExist = constraints.indexOf("undefined") !== -1, shouldBeNonEmpty = constraints.indexOf("set") !== -1;
      return typeof value < "u" ? "[" + attributeName + '="' + value + '"]' : shouldNotExist ? ":not([" + attributeName + "])" : shouldBeNonEmpty ? "[" + attributeName + "]:not([" + attributeName + '=""])' : "[" + attributeName + "]";
    }).join("");
  }
  function getSelectorSpecificity(_ref3) {
    let {
      attributes = []
    } = _ref3;
    return attributes.length;
  }
  function bySelectorSpecificity(_ref4, _ref5) {
    let {
      specificity: leftSpecificity
    } = _ref4, {
      specificity: rightSpecificity
    } = _ref5;
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let {
      attributes = []
    } = element, typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
    typeTextIndex >= 0 && (attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)]);
    let selector = makeElementSelector({
      ...element,
      attributes
    });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? false : node.matches(selector);
  }
  let result = [];
  for (let [element, roles3] of elementRolesMap.entries())
    result = [...result, {
      match: match(element),
      roles: Array.from(roles3),
      specificity: getSelectorSpecificity(element)
    }];
  return result.sort(bySelectorSpecificity);
}
function getRoles(container, _temp) {
  let {
    hidden = false
  } = _temp === void 0 ? {} : _temp;
  function flattenDOM(node) {
    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
  }
  return flattenDOM(container).filter((element) => hidden === false ? isInaccessible(element) === false : true).reduce((acc, node) => {
    let roles3 = [];
    return node.hasAttribute("role") ? roles3 = node.getAttribute("role").split(" ").slice(0, 1) : roles3 = getImplicitAriaRoles2(node), roles3.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? {
      ...rolesAcc,
      [role]: [...rolesAcc[role], node]
    } : {
      ...rolesAcc,
      [role]: [node]
    }, acc);
  }, {});
}
function prettyRoles(dom, _ref6) {
  let {
    hidden,
    includeDescription
  } = _ref6, roles3 = getRoles(dom, {
    hidden
  });
  return Object.entries(roles3).filter((_ref7) => {
    let [role] = _ref7;
    return role !== "generic";
  }).map((_ref8) => {
    let [role, elements2] = _ref8, delimiterBar = "-".repeat(50), elementsString = elements2.map((el) => {
      let nameString = 'Name "' + computeAccessibleName2(el, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      }) + `":
`, domString = prettyDOM(el.cloneNode(false));
      if (includeDescription) {
        let descriptionString = 'Description "' + computeAccessibleDescription2(el, {
          computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + nameString + descriptionString + domString;
      }
      return "" + nameString + domString;
    }).join(`

`);
    return role + `:

` + elementsString + `

` + delimiterBar;
  }).join(`
`);
}
var logRoles = function(dom, _temp2) {
  let {
    hidden = false
  } = _temp2 === void 0 ? {} : _temp2;
  return console.log(prettyRoles(dom, {
    hidden
  }));
};
function computeAriaSelected(element) {
  return element.tagName === "OPTION" ? element.selected : checkBooleanAttribute(element, "aria-selected");
}
function computeAriaBusy(element) {
  return element.getAttribute("aria-busy") === "true";
}
function computeAriaChecked(element) {
  if (!("indeterminate" in element && element.indeterminate))
    return "checked" in element ? element.checked : checkBooleanAttribute(element, "aria-checked");
}
function computeAriaPressed(element) {
  return checkBooleanAttribute(element, "aria-pressed");
}
function computeAriaCurrent(element) {
  var _ref9, _checkBooleanAttribut;
  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
}
function computeAriaExpanded(element) {
  return checkBooleanAttribute(element, "aria-expanded");
}
function checkBooleanAttribute(element, attribute) {
  let attributeValue = element.getAttribute(attribute);
  if (attributeValue === "true")
    return true;
  if (attributeValue === "false")
    return false;
}
function computeHeadingLevel(element) {
  let implicitHeadingLevels = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return element.getAttribute("aria-level") && Number(element.getAttribute("aria-level")) || implicitHeadingLevels[element.tagName];
}
function computeAriaValueNow(element) {
  let valueNow = element.getAttribute("aria-valuenow");
  return valueNow === null ? void 0 : +valueNow;
}
function computeAriaValueMax(element) {
  let valueMax = element.getAttribute("aria-valuemax");
  return valueMax === null ? void 0 : +valueMax;
}
function computeAriaValueMin(element) {
  let valueMin = element.getAttribute("aria-valuemin");
  return valueMin === null ? void 0 : +valueMin;
}
function computeAriaValueText(element) {
  let valueText = element.getAttribute("aria-valuetext");
  return valueText === null ? void 0 : valueText;
}
var normalize2 = getDefaultNormalizer();
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function getRegExpMatcher(string) {
  return new RegExp(escapeRegExp(string.toLowerCase()), "i");
}
function makeSuggestion(queryName, element, content, _ref) {
  let {
    variant,
    name
  } = _ref, warning = "", queryOptions = {}, queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
  name && (queryOptions.name = getRegExpMatcher(name)), queryName === "Role" && isInaccessible(element) && (queryOptions.hidden = true, warning = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(queryOptions).length > 0 && queryArgs.push(queryOptions);
  let queryMethod = variant + "By" + queryName;
  return {
    queryName,
    queryMethod,
    queryArgs,
    variant,
    warning,
    toString() {
      warning && console.warn(warning);
      let [text, options] = queryArgs;
      return text = typeof text == "string" ? "'" + text + "'" : text, options = options ? ", { " + Object.entries(options).map((_ref2) => {
        let [k2, v2] = _ref2;
        return k2 + ": " + v2;
      }).join(", ") + " }" : "", queryMethod + "(" + text + options + ")";
    }
  };
}
function canSuggest(currentMethod, requestedMethod, data) {
  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
}
function getSuggestedQuery(element, variant, method) {
  var _element$getAttribute, _getImplicitAriaRoles;
  if (variant === void 0 && (variant = "get"), element.matches(getConfig2().defaultIgnore))
    return;
  let role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles2(element)) == null ? void 0 : _getImplicitAriaRoles[0];
  if (role !== "generic" && canSuggest("Role", method, role))
    return makeSuggestion("Role", element, role, {
      variant,
      name: computeAccessibleName2(element, {
        computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
      })
    });
  let labelText = getLabels3(document, element).map((label) => label.content).join(" ");
  if (canSuggest("LabelText", method, labelText))
    return makeSuggestion("LabelText", element, labelText, {
      variant
    });
  let placeholderText = element.getAttribute("placeholder");
  if (canSuggest("PlaceholderText", method, placeholderText))
    return makeSuggestion("PlaceholderText", element, placeholderText, {
      variant
    });
  let textContent = normalize2(getNodeText(element));
  if (canSuggest("Text", method, textContent))
    return makeSuggestion("Text", element, textContent, {
      variant
    });
  if (canSuggest("DisplayValue", method, element.value))
    return makeSuggestion("DisplayValue", element, normalize2(element.value), {
      variant
    });
  let alt = element.getAttribute("alt");
  if (canSuggest("AltText", method, alt))
    return makeSuggestion("AltText", element, alt, {
      variant
    });
  let title = element.getAttribute("title");
  if (canSuggest("Title", method, title))
    return makeSuggestion("Title", element, title, {
      variant
    });
  let testId = element.getAttribute(getConfig2().testIdAttribute);
  if (canSuggest("TestId", method, testId))
    return makeSuggestion("TestId", element, testId, {
      variant
    });
}
function copyStackTrace(target, source) {
  target.stack = source.stack.replace(source.message, target.message);
}
function waitFor(callback, _ref) {
  let {
    container = getDocument$2(),
    timeout = getConfig2().asyncUtilTimeout,
    showOriginalStackTrace = getConfig2().showOriginalStackTrace,
    stackTraceError,
    interval = 50,
    onTimeout = (error) => (Object.defineProperty(error, "message", {
      value: getConfig2().getElementError(error.message, container).message
    }), error),
    mutationObserverOptions = {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true
    }
  } = _ref;
  if (typeof callback != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (resolve, reject) => {
    let lastError, intervalId, observer, finished = false, promiseStatus = "idle", overallTimeoutTimer = setTimeout(handleTimeout, timeout), usingJestFakeTimers = jestFakeTimersAreEnabled$1();
    if (usingJestFakeTimers) {
      let {
        unstable_advanceTimersWrapper: advanceTimersWrapper
      } = getConfig2();
      for (checkCallback(); !finished; ) {
        if (!jestFakeTimersAreEnabled$1()) {
          let error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
          return;
        }
        if (await advanceTimersWrapper(async () => {
          jest.advanceTimersByTime(interval);
        }), finished)
          break;
        checkCallback();
      }
    } else {
      try {
        checkContainerType(container);
      } catch (e2) {
        reject(e2);
        return;
      }
      intervalId = setInterval(checkRealTimersCallback, interval);
      let {
        MutationObserver: MutationObserver2
      } = getWindowFromNode(container);
      observer = new MutationObserver2(checkRealTimersCallback), observer.observe(container, mutationObserverOptions), checkCallback();
    }
    function onDone(error, result) {
      finished = true, clearTimeout(overallTimeoutTimer), usingJestFakeTimers || (clearInterval(intervalId), observer.disconnect()), error ? reject(error) : resolve(result);
    }
    function checkRealTimersCallback() {
      if (jestFakeTimersAreEnabled$1()) {
        let error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
      } else
        return checkCallback();
    }
    function checkCallback() {
      if (promiseStatus !== "pending")
        try {
          let result = runWithExpensiveErrorDiagnosticsDisabled(callback);
          typeof result?.then == "function" ? (promiseStatus = "pending", result.then((resolvedValue) => {
            promiseStatus = "resolved", onDone(null, resolvedValue);
          }, (rejectedValue) => {
            promiseStatus = "rejected", lastError = rejectedValue;
          })) : onDone(null, result);
        } catch (error) {
          lastError = error;
        }
    }
    function handleTimeout() {
      let error;
      lastError ? (error = lastError, !showOriginalStackTrace && error.name === "TestingLibraryElementError" && copyStackTrace(error, stackTraceError)) : (error = new Error("Timed out in waitFor."), showOriginalStackTrace || copyStackTrace(error, stackTraceError)), onDone(onTimeout(error), null);
    }
  });
}
function waitForWrapper(callback, options) {
  let stackTraceError = new Error("STACK_TRACE_MESSAGE");
  return getConfig2().asyncWrapper(() => waitFor(callback, {
    stackTraceError,
    ...options
  }));
}
function getElementError(message, container) {
  return getConfig2().getElementError(message, container);
}
function getMultipleElementsFoundError(message, container) {
  return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
}
function queryAllByAttribute(attribute, container, text, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim: trim2,
    normalizer
  } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  });
  return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
}
function queryByAttribute(attribute, container, text, options) {
  let els = queryAllByAttribute(attribute, container, text, options);
  if (els.length > 1)
    throw getMultipleElementsFoundError("Found multiple elements by [" + attribute + "=" + text + "]", container);
  return els[0] || null;
}
function makeSingleQuery(allQuery, getMultipleError2) {
  return function(container) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    let els = allQuery(container, ...args);
    if (els.length > 1) {
      let elementStrings = els.map((element) => getElementError(null, element).message).join(`

`);
      throw getMultipleElementsFoundError(getMultipleError2(container, ...args) + `

Here are the matching elements:

` + elementStrings, container);
    }
    return els[0] || null;
  };
}
function getSuggestionError(suggestion, container) {
  return getConfig2().getElementError(`A better query is available, try this:
` + suggestion.toString() + `
`, container);
}
function makeGetAllQuery(allQuery, getMissingError2) {
  return function(container) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
      args[_key2 - 1] = arguments[_key2];
    let els = allQuery(container, ...args);
    if (!els.length)
      throw getConfig2().getElementError(getMissingError2(container, ...args), container);
    return els;
  };
}
function makeFindQuery(getter) {
  return (container, text, options, waitForOptions) => waitForWrapper(() => getter(container, text, options), {
    container,
    ...waitForOptions
  });
}
var wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
    args[_key3 - 1] = arguments[_key3];
  let element = query(container, ...args), [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (element && suggest) {
    let suggestion = getSuggestedQuery(element, variant);
    if (suggestion && !queryAllByName.endsWith(suggestion.queryName))
      throw getSuggestionError(suggestion.toString(), container);
  }
  return element;
}, wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
    args[_key4 - 1] = arguments[_key4];
  let els = query(container, ...args), [{
    suggest = getConfig2().throwSuggestions
  } = {}] = args.slice(-1);
  if (els.length && suggest) {
    let uniqueSuggestionMessages = [...new Set(els.map((element) => {
      var _getSuggestedQuery;
      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        getSuggestedQuery(els[0], variant).queryName
      )
    )
      throw getSuggestionError(uniqueSuggestionMessages[0], container);
  }
  return els;
};
function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
  let queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query"), getAllBy = makeGetAllQuery(queryAllBy, getMissingError2), getBy = makeSingleQuery(getAllBy, getMultipleError2), getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get"), getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll"), findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll")), findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
}
var queryHelpers = Object.freeze({
  __proto__: null,
  getElementError,
  wrapAllByQueryWithSuggestion,
  wrapSingleQueryWithSuggestion,
  getMultipleElementsFoundError,
  queryAllByAttribute,
  queryByAttribute,
  makeSingleQuery,
  makeGetAllQuery,
  makeFindQuery,
  buildQueries
});
function queryAllLabels(container) {
  return Array.from(container.querySelectorAll("label,input")).map((node) => ({
    node,
    textToMatch: getLabelContent(node)
  })).filter((_ref) => {
    let {
      textToMatch
    } = _ref;
    return textToMatch !== null;
  });
}
var queryAllLabelsByText = function(container, text, _temp) {
  let {
    exact = true,
    trim: trim2,
    collapseWhitespace,
    normalizer
  } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  });
  return queryAllLabels(container).filter((_ref2) => {
    let {
      node,
      textToMatch
    } = _ref2;
    return matcher(textToMatch, node, text, matchNormalizer);
  }).map((_ref3) => {
    let {
      node
    } = _ref3;
    return node;
  });
}, queryAllByLabelText = function(container, text, _temp2) {
  let {
    selector = "*",
    exact = true,
    collapseWhitespace,
    trim: trim2,
    normalizer
  } = _temp2 === void 0 ? {} : _temp2;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  }), matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => getRealLabels(element).length || element.hasAttribute("aria-labelledby")).reduce((labelledElements, labelledElement) => {
    let labelList = getLabels3(container, labelledElement, {
      selector
    });
    labelList.filter((label) => !!label.formControl).forEach((label) => {
      matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl && labelledElements.push(label.formControl);
    });
    let labelsValue = labelList.filter((label) => !!label.content).map((label) => label.content);
    return matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement), labelsValue.length > 1 && labelsValue.forEach((labelValue, index2) => {
      matcher(labelValue, labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
      let labelsFiltered = [...labelsValue];
      labelsFiltered.splice(index2, 1), labelsFiltered.length > 1 && matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
    }), labelledElements;
  }, []).concat(queryAllByAttribute("aria-label", container, text, {
    exact,
    normalizer: matchNormalizer
  }));
  return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
}, getAllByLabelText = function(container, text) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
    rest[_key - 2] = arguments[_key];
  let els = queryAllByLabelText(container, text, ...rest);
  if (!els.length) {
    let labels = queryAllLabelsByText(container, text, ...rest);
    if (labels.length) {
      let tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
      throw tagNames.length ? getConfig2().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join(`

`), container) : getConfig2().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
    } else
      throw getConfig2().getElementError("Unable to find a label with the text of: " + text, container);
  }
  return els;
};
function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
  let htmlFor = label.getAttribute("for");
  if (!htmlFor)
    return null;
  let element = container.querySelector('[id="' + htmlFor + '"]');
  return element ? element.tagName.toLowerCase() : null;
}
var getMultipleError$7 = (c2, text) => "Found multiple elements with the text of: " + text, queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query"), getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7), findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll")), findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find")), getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll"), getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get"), queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll"), queryAllByPlaceholderText = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return checkContainerType(args[0]), queryAllByAttribute("placeholder", ...args);
}, getMultipleError$6 = (c2, text) => "Found multiple elements with the placeholder text of: " + text, getMissingError$6 = (c2, text) => "Unable to find an element with the placeholder text of: " + text, queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll"), [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6), queryAllByText = function(container, text, _temp) {
  let {
    selector = "*",
    exact = true,
    collapseWhitespace,
    trim: trim2,
    ignore: ignore2 = getConfig2().defaultIgnore,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  }), baseArray = [];
  return typeof container.matches == "function" && container.matches(selector) && (baseArray = [container]), [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore2 || !node.matches(ignore2)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
}, getMultipleError$5 = (c2, text) => "Found multiple elements with the text: " + text, getMissingError$5 = function(c2, text, options) {
  options === void 0 && (options = {});
  let {
    collapseWhitespace,
    trim: trim2,
    normalizer,
    selector
  } = options, normalizedText = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  })(text.toString()), isNormalizedDifferent = normalizedText !== text.toString(), isCustomSelector = (selector ?? "*") !== "*";
  return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll"), [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5), queryAllByDisplayValue = function(container, value, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim: trim2,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  });
  return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => node.tagName === "SELECT" ? Array.from(node.options).filter((option) => option.selected).some((optionNode) => matcher(getNodeText(optionNode), optionNode, value, matchNormalizer)) : matcher(node.value, node, value, matchNormalizer));
}, getMultipleError$4 = (c2, value) => "Found multiple elements with the display value: " + value + ".", getMissingError$4 = (c2, value) => "Unable to find an element with the display value: " + value + ".", queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll"), [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4), VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i, queryAllByAltText = function(container, alt, options) {
  return options === void 0 && (options = {}), checkContainerType(container), queryAllByAttribute("alt", container, alt, options).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
}, getMultipleError$3 = (c2, alt) => "Found multiple elements with the alt text: " + alt, getMissingError$3 = (c2, alt) => "Unable to find an element with the alt text: " + alt, queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll"), [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3), isSvgTitle = (node) => {
  var _node$parentElement;
  return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
}, queryAllByTitle = function(container, text, _temp) {
  let {
    exact = true,
    collapseWhitespace,
    trim: trim2,
    normalizer
  } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({
    collapseWhitespace,
    trim: trim2,
    normalizer
  });
  return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
}, getMultipleError$2 = (c2, title) => "Found multiple elements with the title: " + title + ".", getMissingError$2 = (c2, title) => "Unable to find an element with the title: " + title + ".", queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll"), [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2), queryAllByRole = function(container, role, _temp) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description,
    queryFallbacks = false,
    selected,
    busy,
    checked,
    pressed,
    current,
    level,
    expanded,
    value: {
      now: valueNow,
      min: valueMin,
      max: valueMax,
      text: valueText
    } = {}
  } = _temp === void 0 ? {} : _temp;
  if (checkContainerType(container), selected !== void 0) {
    var _allRoles$get;
    if (((_allRoles$get = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + role + '".');
  }
  if (busy !== void 0) {
    var _allRoles$get2;
    if (((_allRoles$get2 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + role + '".');
  }
  if (checked !== void 0) {
    var _allRoles$get3;
    if (((_allRoles$get3 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + role + '".');
  }
  if (pressed !== void 0) {
    var _allRoles$get4;
    if (((_allRoles$get4 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + role + '".');
  }
  if (current !== void 0) {
    var _allRoles$get5;
    if (((_allRoles$get5 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + role + '".');
  }
  if (level !== void 0 && role !== "heading")
    throw new Error('Role "' + role + '" cannot have "level" property.');
  if (valueNow !== void 0) {
    var _allRoles$get6;
    if (((_allRoles$get6 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
  }
  if (valueMax !== void 0) {
    var _allRoles$get7;
    if (((_allRoles$get7 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
  }
  if (valueMin !== void 0) {
    var _allRoles$get8;
    if (((_allRoles$get8 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
  }
  if (valueText !== void 0) {
    var _allRoles$get9;
    if (((_allRoles$get9 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
  }
  if (expanded !== void 0) {
    var _allRoles$get0;
    if (((_allRoles$get0 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get0.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + role + '".');
  }
  let subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
  function cachedIsSubtreeInaccessible(element) {
    return subtreeIsInaccessibleCache.has(element) || subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element)), subtreeIsInaccessibleCache.get(element);
  }
  return Array.from(container.querySelectorAll(
    // Only query elements that can be matched by the following filters
    makeRoleSelector(role)
  )).filter((node) => {
    if (node.hasAttribute("role")) {
      let roleValue = node.getAttribute("role");
      if (queryFallbacks)
        return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
      let [firstRoleAttributeToken] = roleValue.split(" ");
      return firstRoleAttributeToken === role;
    }
    return getImplicitAriaRoles2(node).some((implicitRole) => implicitRole === role);
  }).filter((element) => {
    if (selected !== void 0)
      return selected === computeAriaSelected(element);
    if (busy !== void 0)
      return busy === computeAriaBusy(element);
    if (checked !== void 0)
      return checked === computeAriaChecked(element);
    if (pressed !== void 0)
      return pressed === computeAriaPressed(element);
    if (current !== void 0)
      return current === computeAriaCurrent(element);
    if (expanded !== void 0)
      return expanded === computeAriaExpanded(element);
    if (level !== void 0)
      return level === computeHeadingLevel(element);
    if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
      let valueMatches = true;
      if (valueNow !== void 0 && valueMatches && (valueMatches = valueNow === computeAriaValueNow(element)), valueMax !== void 0 && valueMatches && (valueMatches = valueMax === computeAriaValueMax(element)), valueMin !== void 0 && valueMatches && (valueMatches = valueMin === computeAriaValueMin(element)), valueText !== void 0) {
        var _computeAriaValueText;
        valueMatches && (valueMatches = matches2((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
      }
      return valueMatches;
    }
    return true;
  }).filter((element) => name === void 0 ? true : matches2(computeAccessibleName2(element, {
    computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
  }), element, name, (text) => text)).filter((element) => description === void 0 ? true : matches2(computeAccessibleDescription2(element, {
    computedStyleSupportsPseudoElements: getConfig2().computedStyleSupportsPseudoElements
  }), element, description, (text) => text)).filter((element) => hidden === false ? isInaccessible(element, {
    isSubtreeInaccessible: cachedIsSubtreeInaccessible
  }) === false : true);
};
function makeRoleSelector(role) {
  var _roleElements$get;
  let explicitRoleSelector = '*[role~="' + role + '"]', roleRelations = (_roleElements$get = import_aria_query3.roleElements.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set(), implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
    let {
      name
    } = _ref;
    return name;
  }));
  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
}
var getNameHint = (name) => {
  let nameHint = "";
  return name === void 0 ? nameHint = "" : typeof name == "string" ? nameHint = ' and name "' + name + '"' : nameHint = " and name `" + name + "`", nameHint;
}, getMultipleError$1 = function(c2, role, _temp2) {
  let {
    name
  } = _temp2 === void 0 ? {} : _temp2;
  return 'Found multiple elements with the role "' + role + '"' + getNameHint(name);
}, getMissingError$1 = function(container, role, _temp3) {
  let {
    hidden = getConfig2().defaultHidden,
    name,
    description
  } = _temp3 === void 0 ? {} : _temp3;
  if (getConfig2()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + role + '"' + getNameHint(name);
  let roles3 = "";
  Array.from(container.children).forEach((childElement) => {
    roles3 += prettyRoles(childElement, {
      hidden,
      includeDescription: description !== void 0
    });
  });
  let roleMessage;
  roles3.length === 0 ? hidden === false ? roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : roleMessage = "There are no available roles." : roleMessage = (`
Here are the ` + (hidden === false ? "accessible" : "available") + ` roles:

  ` + roles3.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let nameHint = "";
  name === void 0 ? nameHint = "" : typeof name == "string" ? nameHint = ' and name "' + name + '"' : nameHint = " and name `" + name + "`";
  let descriptionHint = "";
  return description === void 0 ? descriptionHint = "" : typeof description == "string" ? descriptionHint = ' and description "' + description + '"' : descriptionHint = " and description `" + description + "`", (`
Unable to find an ` + (hidden === false ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + `

` + roleMessage).trim();
}, queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll"), [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1), getTestIdAttribute = () => getConfig2().testIdAttribute, queryAllByTestId = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return checkContainerType(args[0]), queryAllByAttribute(getTestIdAttribute(), ...args);
}, getMultipleError = (c2, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]', getMissingError = (c2, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]', queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll"), [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError), queries = Object.freeze({
  __proto__: null,
  queryAllByLabelText: queryAllByLabelTextWithSuggestions,
  queryByLabelText,
  getAllByLabelText: getAllByLabelTextWithSuggestions,
  getByLabelText: getByLabelTextWithSuggestions,
  findAllByLabelText,
  findByLabelText,
  queryByPlaceholderText,
  queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions,
  getByPlaceholderText,
  getAllByPlaceholderText,
  findAllByPlaceholderText,
  findByPlaceholderText,
  queryByText,
  queryAllByText: queryAllByTextWithSuggestions,
  getByText,
  getAllByText,
  findAllByText,
  findByText,
  queryByDisplayValue,
  queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions,
  getByDisplayValue,
  getAllByDisplayValue,
  findAllByDisplayValue,
  findByDisplayValue,
  queryByAltText,
  queryAllByAltText: queryAllByAltTextWithSuggestions,
  getByAltText,
  getAllByAltText,
  findAllByAltText,
  findByAltText,
  queryByTitle,
  queryAllByTitle: queryAllByTitleWithSuggestions,
  getByTitle,
  getAllByTitle,
  findAllByTitle,
  findByTitle,
  queryByRole,
  queryAllByRole: queryAllByRoleWithSuggestions,
  getAllByRole,
  getByRole,
  findAllByRole,
  findByRole,
  queryByTestId,
  queryAllByTestId: queryAllByTestIdWithSuggestions,
  getByTestId,
  getAllByTestId,
  findAllByTestId,
  findByTestId
});
function getQueriesForElement(element, queries$1, initialValue2) {
  return queries$1 === void 0 && (queries$1 = queries), initialValue2 === void 0 && (initialValue2 = {}), Object.keys(queries$1).reduce((helpers, key) => {
    let fn3 = queries$1[key];
    return helpers[key] = fn3.bind(null, element), helpers;
  }, initialValue2);
}
var isRemoved = (result) => !result || Array.isArray(result) && !result.length;
function initialCheck(elements2) {
  if (isRemoved(elements2))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
async function waitForElementToBeRemoved(callback, options) {
  let timeoutError = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof callback != "function") {
    initialCheck(callback);
    let getRemainingElements = (Array.isArray(callback) ? callback : [callback]).map((element) => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      for (; parent.parentElement; ) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = () => getRemainingElements.map((c2) => c2()).filter(Boolean);
  }
  return initialCheck(callback()), waitForWrapper(() => {
    let result;
    try {
      result = callback();
    } catch (error) {
      if (error.name === "TestingLibraryElementError")
        return;
      throw error;
    }
    if (!isRemoved(result))
      throw timeoutError;
  }, options);
}
var eventMap = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: true
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      button: 0,
      composed: true
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
}, eventAliasMap = {
  doubleClick: "dblClick"
};
function fireEvent(element, event) {
  return getConfig2().eventWrapper(() => {
    if (!event)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!element)
      throw new Error('Unable to fire a "' + event.type + '" event - please provide a DOM element.');
    return element.dispatchEvent(event);
  });
}
function createEvent(eventName, node, init2, _temp) {
  let {
    EventType = "Event",
    defaultInit = {}
  } = _temp === void 0 ? {} : _temp;
  if (!node)
    throw new Error('Unable to fire a "' + eventName + '" event - please provide a DOM element.');
  let eventInit = {
    ...defaultInit,
    ...init2
  }, {
    target: {
      value,
      files,
      ...targetProperties
    } = {}
  } = eventInit;
  value !== void 0 && setNativeValue(node, value), files !== void 0 && Object.defineProperty(node, "files", {
    configurable: true,
    enumerable: true,
    writable: true,
    value: files
  }), Object.assign(node, targetProperties);
  let window2 = getWindowFromNode(node), EventConstructor = window2[EventType] || window2.Event, event;
  if (typeof EventConstructor == "function")
    event = new EventConstructor(eventName, eventInit);
  else {
    event = window2.document.createEvent(EventType);
    let {
      bubbles,
      cancelable,
      detail,
      ...otherInit
    } = eventInit;
    event.initEvent(eventName, bubbles, cancelable, detail), Object.keys(otherInit).forEach((eventKey) => {
      event[eventKey] = otherInit[eventKey];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((dataTransferKey) => {
    let dataTransferValue = eventInit[dataTransferKey];
    typeof dataTransferValue == "object" && (typeof window2.DataTransfer == "function" ? Object.defineProperty(event, dataTransferKey, {
      value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => (Object.defineProperty(acc, propName, {
        value: dataTransferValue[propName]
      }), acc), new window2.DataTransfer())
    }) : Object.defineProperty(event, dataTransferKey, {
      value: dataTransferValue
    }));
  }), event;
}
Object.keys(eventMap).forEach((key) => {
  let {
    EventType,
    defaultInit
  } = eventMap[key], eventName = key.toLowerCase();
  createEvent[key] = (node, init2) => createEvent(eventName, node, init2, {
    EventType,
    defaultInit
  }), fireEvent[key] = (node, init2) => fireEvent(node, createEvent[key](node, init2));
});
function setNativeValue(element, value) {
  let {
    set: valueSetter
  } = Object.getOwnPropertyDescriptor(element, "value") || {}, prototype = Object.getPrototypeOf(element), {
    set: prototypeValueSetter
  } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
  if (prototypeValueSetter && valueSetter !== prototypeValueSetter)
    prototypeValueSetter.call(element, value);
  else if (valueSetter)
    valueSetter.call(element, value);
  else
    throw new Error("The given element does not have a value setter");
}
Object.keys(eventAliasMap).forEach((aliasKey) => {
  let key = eventAliasMap[aliasKey];
  fireEvent[aliasKey] = function() {
    return fireEvent[key](...arguments);
  };
});
function unindent(string) {
  return string.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
function encode(value) {
  return import_lz_string.default.compressToEncodedURIComponent(unindent(value));
}
function getPlaygroundUrl(markup) {
  return "https://testing-playground.com/#markup=" + encode(markup);
}
var debug = (element, maxLength, options) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options)) : logDOM(element, maxLength, options), logTestingPlaygroundURL = function(element) {
  if (element === void 0 && (element = getDocument$2().body), !element || !("innerHTML" in element)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!element.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  let playgroundUrl = getPlaygroundUrl(element.innerHTML);
  return console.log(`Open this URL in your browser

` + playgroundUrl), playgroundUrl;
}, initialValue = {
  debug,
  logTestingPlaygroundURL
}, screen = typeof document < "u" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key) => (helpers[key] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, helpers), initialValue);
function isElementType(element, tag, props) {
  return element.namespaceURI && element.namespaceURI !== "http://www.w3.org/1999/xhtml" || (tag = Array.isArray(tag) ? tag : [
    tag
  ], !tag.includes(element.tagName.toLowerCase())) ? false : props ? Object.entries(props).every(([k2, v2]) => element[k2] === v2) : true;
}
function getWindow$3(node) {
  var _node_ownerDocument;
  if (isDocument$1(node) && node.defaultView)
    return node.defaultView;
  if (!((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0) && _node_ownerDocument.defaultView)
    return node.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
}
function isDocument$1(node) {
  return node.nodeType === 9;
}
function describe(val) {
  return typeof val == "function" ? `function ${val.name}` : val === null ? "null" : String(val);
}
function readBlobText(blob, FileReader) {
  return new Promise((res, rej) => {
    let fr = new FileReader();
    fr.onerror = rej, fr.onabort = rej, fr.onload = () => {
      res(String(fr.result));
    }, fr.readAsText(blob);
  });
}
function createFileList(window2, files) {
  let list = {
    ...files,
    length: files.length,
    item: (index2) => list[index2],
    [Symbol.iterator]: function* () {
      for (let i2 = 0; i2 < list.length; i2++)
        yield list[i2];
    }
  };
  return list.constructor = window2.FileList, window2.FileList && Object.setPrototypeOf(list, window2.FileList.prototype), Object.freeze(list), list;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var DataTransferItemStub = class {
  getAsFile() {
    return this.file;
  }
  getAsString(callback) {
    typeof this.data == "string" && callback(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(dataOrFile, type5) {
    _define_property(this, "kind", void 0), _define_property(this, "type", void 0), _define_property(this, "file", null), _define_property(this, "data", void 0), typeof dataOrFile == "string" ? (this.kind = "string", this.type = String(type5), this.data = dataOrFile) : (this.kind = "file", this.type = dataOrFile.type, this.file = dataOrFile);
  }
}, DataTransferItemListStub = class extends Array {
  add(...args) {
    let item = new DataTransferItemStub(args[0], args[1]);
    return this.push(item), item;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(index2) {
    this.splice(index2, 1);
  }
};
function getTypeMatcher(type5, exact) {
  let [group, sub] = type5.split("/"), isGroup = !sub || sub === "*";
  return (item) => exact ? item.type === (isGroup ? group : type5) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
}
function createDataTransferStub(window2) {
  return new class {
    getData(format4) {
      var _this_items_find;
      let match = (_this_items_find = this.items.find(getTypeMatcher(format4, true))) !== null && _this_items_find !== void 0 ? _this_items_find : this.items.find(getTypeMatcher(format4, false)), text = "";
      return match?.getAsString((t22) => {
        text = t22;
      }), text;
    }
    setData(format4, data) {
      let matchIndex = this.items.findIndex(getTypeMatcher(format4, true)), item = new DataTransferItemStub(data, format4);
      matchIndex >= 0 ? this.items.splice(matchIndex, 1, item) : this.items.push(item);
    }
    clearData(format4) {
      if (format4) {
        let matchIndex = this.items.findIndex(getTypeMatcher(format4, true));
        matchIndex >= 0 && this.items.remove(matchIndex);
      } else
        this.items.clear();
    }
    get types() {
      let t22 = [];
      return this.files.length && t22.push("Files"), this.items.forEach((i2) => t22.push(i2.type)), Object.freeze(t22), t22;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      _define_property(this, "dropEffect", "none"), _define_property(this, "effectAllowed", "uninitialized"), _define_property(this, "items", new DataTransferItemListStub()), _define_property(this, "files", createFileList(window2, []));
    }
  }();
}
function createDataTransfer(window2, files = []) {
  let dt = typeof window2.DataTransfer > "u" ? createDataTransferStub(window2) : (
    /* istanbul ignore next */
    new window2.DataTransfer()
  );
  return Object.defineProperty(dt, "files", {
    get: () => createFileList(window2, files)
  }), dt;
}
async function getBlobFromDataTransferItem(window2, item) {
  return item.kind === "file" ? item.getAsFile() : new window2.Blob([
    await new Promise((r2) => item.getAsString(r2))
  ], {
    type: item.type
  });
}
function _define_property2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
function createClipboardItem(window2, ...blobs) {
  let dataMap = Object.fromEntries(blobs.map((b2) => [
    typeof b2 == "string" ? "text/plain" : b2.type,
    Promise.resolve(b2)
  ]));
  return typeof window2.ClipboardItem < "u" ? new window2.ClipboardItem(dataMap) : new class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(type5) {
      let value = await this.data[type5];
      if (!value)
        throw new Error(`${type5} is not one of the available MIME types on this item.`);
      return value instanceof window2.Blob ? value : new window2.Blob([
        value
      ], {
        type: type5
      });
    }
    constructor(d) {
      _define_property2(this, "data", void 0), this.data = d;
    }
  }(dataMap);
}
var ClipboardStubControl = Symbol("Manage ClipboardSub");
function createClipboardStub(window2, control) {
  return Object.assign(new class extends window2.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let text = "";
      for (let item of this.items) {
        let type5 = item.types.includes("text/plain") ? "text/plain" : item.types.find((t22) => t22.startsWith("text/"));
        type5 && (text += await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader)));
      }
      return text;
    }
    async write(data) {
      this.items = data;
    }
    async writeText(text) {
      this.items = [
        createClipboardItem(window2, text)
      ];
    }
    constructor(...args) {
      super(...args), _define_property2(this, "items", []);
    }
  }(), {
    [ClipboardStubControl]: control
  });
}
function isClipboardStub(clipboard) {
  return !!clipboard?.[ClipboardStubControl];
}
function attachClipboardStubToView(window2) {
  if (isClipboardStub(window2.navigator.clipboard))
    return window2.navigator.clipboard[ClipboardStubControl];
  let realClipboard = Object.getOwnPropertyDescriptor(window2.navigator, "clipboard"), stub, control = {
    resetClipboardStub: () => {
      stub = createClipboardStub(window2, control);
    },
    detachClipboardStub: () => {
      realClipboard ? Object.defineProperty(window2.navigator, "clipboard", realClipboard) : Object.defineProperty(window2.navigator, "clipboard", {
        value: void 0,
        configurable: true
      });
    }
  };
  return stub = createClipboardStub(window2, control), Object.defineProperty(window2.navigator, "clipboard", {
    get: () => stub,
    configurable: true
  }), stub[ClipboardStubControl];
}
function resetClipboardStubOnView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
}
function detachClipboardStubFromView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
}
async function readDataTransferFromClipboard(document7) {
  let window2 = document7.defaultView, clipboard = window2?.navigator.clipboard, items = clipboard && await clipboard.read();
  if (!items)
    throw new Error("The Clipboard API is unavailable.");
  let dt = createDataTransfer(window2);
  for (let item of items)
    for (let type5 of item.types)
      dt.setData(type5, await item.getType(type5).then((b2) => readBlobText(b2, window2.FileReader)));
  return dt;
}
async function writeDataTransferToClipboard(document7, clipboardData) {
  let window2 = getWindow$3(document7), clipboard = window2.navigator.clipboard, items = [];
  for (let i2 = 0; i2 < clipboardData.items.length; i2++) {
    let dtItem = clipboardData.items[i2], blob = await getBlobFromDataTransferItem(window2, dtItem);
    items.push(createClipboardItem(window2, blob));
  }
  if (!(clipboard && await clipboard.write(items).then(
    () => true,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => false
  )))
    throw new Error("The Clipboard API is unavailable.");
}
var g = globalThis;
typeof g.afterEach == "function" && g.afterEach(() => {
  typeof globalThis.window < "u" && resetClipboardStubOnView(globalThis.window);
});
typeof g.afterAll == "function" && g.afterAll(() => {
  typeof globalThis.window < "u" && detachClipboardStubFromView(globalThis.window);
});
var FOCUSABLE_SELECTOR = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function isFocusable(element) {
  return element.matches(FOCUSABLE_SELECTOR);
}
function cloneEvent(event) {
  return new event.constructor(event.type, event);
}
function isDisabled2(element) {
  for (let el = element; el; el = el.parentElement)
    if (isElementType(el, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (el.hasAttribute("disabled"))
        return true;
    } else if (isElementType(el, "fieldset")) {
      var _el_querySelector;
      if (el.hasAttribute("disabled") && !(!((_el_querySelector = el.querySelector(":scope > legend")) === null || _el_querySelector === void 0) && _el_querySelector.contains(element)))
        return true;
    } else if (el.tagName.includes("-") && el.constructor.formAssociated && el.hasAttribute("disabled"))
      return true;
  return false;
}
function getActiveElement(document7) {
  let activeElement2 = document7.activeElement;
  return activeElement2?.shadowRoot ? getActiveElement(activeElement2.shadowRoot) : isDisabled2(activeElement2) ? document7.ownerDocument ? (
    /* istanbul ignore next */
    document7.ownerDocument.body
  ) : document7.body : activeElement2;
}
function getActiveElementOrBody(document7) {
  var _getActiveElement;
  return (_getActiveElement = getActiveElement(document7)) !== null && _getActiveElement !== void 0 ? _getActiveElement : (
    /* istanbul ignore next */
    document7.body
  );
}
function findClosest(element, callback) {
  let el = element;
  do {
    if (callback(el))
      return el;
    el = el.parentElement;
  } while (el && el !== element.ownerDocument.body);
}
function isContentEditable$1(element) {
  return element.hasAttribute("contenteditable") && (element.getAttribute("contenteditable") == "true" || element.getAttribute("contenteditable") == "");
}
function getContentEditable(node) {
  let element = getElement(node);
  return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
}
function getElement(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
var clickableInputTypes = function(clickableInputTypes2) {
  return clickableInputTypes2.button = "button", clickableInputTypes2.color = "color", clickableInputTypes2.file = "file", clickableInputTypes2.image = "image", clickableInputTypes2.reset = "reset", clickableInputTypes2.submit = "submit", clickableInputTypes2.checkbox = "checkbox", clickableInputTypes2.radio = "radio", clickableInputTypes2;
}(clickableInputTypes || {});
function isClickableInput(element) {
  return isElementType(element, "button") || isElementType(element, "input") && element.type in clickableInputTypes;
}
function isEditable(element) {
  return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable$1(element);
}
var editableInputTypes = function(editableInputTypes2) {
  return editableInputTypes2.text = "text", editableInputTypes2.date = "date", editableInputTypes2["datetime-local"] = "datetime-local", editableInputTypes2.email = "email", editableInputTypes2.month = "month", editableInputTypes2.number = "number", editableInputTypes2.password = "password", editableInputTypes2.search = "search", editableInputTypes2.tel = "tel", editableInputTypes2.time = "time", editableInputTypes2.url = "url", editableInputTypes2.week = "week", editableInputTypes2;
}(editableInputTypes || {});
function isEditableInputOrTextArea(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in editableInputTypes;
}
function hasOwnSelection(node) {
  return isElement3(node) && isEditableInputOrTextArea(node);
}
function hasNoSelection(node) {
  return isElement3(node) && isClickableInput(node);
}
function isElement3(node) {
  return node.nodeType === 1;
}
function updateSelectionOnFocus(element) {
  let selection = element.ownerDocument.getSelection();
  if (selection?.focusNode && hasOwnSelection(element)) {
    let contenteditable = getContentEditable(selection.focusNode);
    if (contenteditable) {
      if (!selection.isCollapsed) {
        var _contenteditable_firstChild;
        let focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
        selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
      }
    } else
      selection.setBaseAndExtent(element, 0, element, 0);
  }
}
function wrapEvent(cb, _element) {
  return getConfig2().eventWrapper(cb);
}
function focusElement(element) {
  let target = findClosest(element, isFocusable), activeElement2 = getActiveElement(element.ownerDocument);
  (target ?? element.ownerDocument.body) !== activeElement2 && (target ? wrapEvent(() => target.focus()) : wrapEvent(() => activeElement2?.blur()), updateSelectionOnFocus(target ?? element.ownerDocument.body));
}
function blurElement(element) {
  !isFocusable(element) || !(getActiveElement(element.ownerDocument) === element) || wrapEvent(() => element.blur());
}
var behavior = {};
behavior.click = (event, target, instance) => {
  let context = target.closest("button,input,label,select,textarea"), control = context && isElementType(context, "label") && context.control;
  if (control && control !== target)
    return () => {
      isFocusable(control) && (focusElement(control), instance.dispatchEvent(control, cloneEvent(event)));
    };
  if (isElementType(target, "input", {
    type: "file"
  }))
    return () => {
      blurElement(target), target.dispatchEvent(new (getWindow$3(target)).Event("fileDialog")), focusElement(target);
    };
};
var UIValue = Symbol("Displayed value in UI"), UISelection = Symbol("Displayed selection in UI"), InitialValue = Symbol("Initial value to compare on blur");
function isUIValue(value) {
  return typeof value == "object" && UIValue in value;
}
function isUISelectionStart(start) {
  return !!start && typeof start == "object" && UISelection in start;
}
function setUIValue(element, value) {
  element[InitialValue] === void 0 && (element[InitialValue] = element.value), element[UIValue] = value, element.value = Object.assign(new String(value), {
    [UIValue]: true
  });
}
function getUIValue(element) {
  return element[UIValue] === void 0 ? element.value : String(element[UIValue]);
}
function setUIValueClean(element) {
  element[UIValue] = void 0;
}
function clearInitialValue(element) {
  element[InitialValue] = void 0;
}
function getInitialValue(element) {
  return element[InitialValue];
}
function setUISelectionRaw(element, selection) {
  element[UISelection] = selection;
}
function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = "replace") {
  let valueLength = getUIValue(element).length, sanitizeOffset = (o2) => Math.max(0, Math.min(valueLength, o2)), anchorOffset = mode === "replace" || element[UISelection] === void 0 ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset, focusOffset = sanitizeOffset(focusOffsetParam), startOffset = Math.min(anchorOffset, focusOffset), endOffset = Math.max(anchorOffset, focusOffset);
  if (element[UISelection] = {
    anchorOffset,
    focusOffset
  }, element.selectionStart === startOffset && element.selectionEnd === endOffset)
    return;
  let startObj = Object.assign(new Number(startOffset), {
    [UISelection]: true
  });
  try {
    element.setSelectionRange(startObj, endOffset);
  } catch {
  }
}
function getUISelection(element) {
  var _element_selectionStart, _element_selectionEnd, _element_UISelection;
  let sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== void 0 ? _element_UISelection : {
    anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== void 0 ? _element_selectionStart : 0,
    focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== void 0 ? _element_selectionEnd : 0
  };
  return {
    ...sel,
    startOffset: Math.min(sel.anchorOffset, sel.focusOffset),
    endOffset: Math.max(sel.anchorOffset, sel.focusOffset)
  };
}
function hasUISelection(element) {
  return !!element[UISelection];
}
function setUISelectionClean(element) {
  element[UISelection] = void 0;
}
var parseInt2 = globalThis.parseInt;
function buildTimeValue(value) {
  let onlyDigitsValue = value.replace(/\D/g, "");
  if (onlyDigitsValue.length < 2)
    return value;
  let firstDigit = parseInt2(onlyDigitsValue[0], 10), secondDigit = parseInt2(onlyDigitsValue[1], 10);
  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
    let index2;
    return firstDigit >= 3 ? index2 = 1 : index2 = 2, build2(onlyDigitsValue, index2);
  }
  return value.length === 2 ? value : build2(onlyDigitsValue, 2);
}
function build2(onlyDigitsValue, index2) {
  let hours = onlyDigitsValue.slice(0, index2), validHours = Math.min(parseInt2(hours, 10), 23), minuteCharacters = onlyDigitsValue.slice(index2), parsedMinutes = parseInt2(minuteCharacters, 10), validMinutes = Math.min(parsedMinutes, 59);
  return `${validHours.toString().padStart(2, "0")}:${validMinutes.toString().padStart(2, "0")}`;
}
function isValidDateOrTimeValue(element, value) {
  let clone3 = element.cloneNode();
  return clone3.value = value, clone3.value === value;
}
var maxLengthSupportedTypes = function(maxLengthSupportedTypes2) {
  return maxLengthSupportedTypes2.email = "email", maxLengthSupportedTypes2.password = "password", maxLengthSupportedTypes2.search = "search", maxLengthSupportedTypes2.telephone = "telephone", maxLengthSupportedTypes2.text = "text", maxLengthSupportedTypes2.url = "url", maxLengthSupportedTypes2;
}(maxLengthSupportedTypes || {});
function getMaxLength(element) {
  var _element_getAttribute;
  let attr2 = (_element_getAttribute = element.getAttribute("maxlength")) !== null && _element_getAttribute !== void 0 ? _element_getAttribute : "";
  return /^\d+$/.test(attr2) && Number(attr2) >= 0 ? Number(attr2) : void 0;
}
function supportsMaxLength(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in maxLengthSupportedTypes;
}
function getNextCursorPosition(node, offset2, direction, inputType) {
  if (isTextNode(node) && offset2 + direction >= 0 && offset2 + direction <= node.nodeValue.length)
    return {
      node,
      offset: offset2 + direction
    };
  let nextNode = getNextCharacterContentNode(node, offset2, direction);
  if (nextNode) {
    if (isTextNode(nextNode))
      return {
        node: nextNode,
        offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0)
      };
    if (isElementType(nextNode, "br")) {
      let nextPlusOne = getNextCharacterContentNode(nextNode, void 0, direction);
      return nextPlusOne ? isTextNode(nextPlusOne) ? {
        node: nextPlusOne,
        offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length
      } : direction < 0 && isElementType(nextPlusOne, "br") ? {
        node: nextNode.parentNode,
        offset: getOffset(nextNode)
      } : {
        node: nextPlusOne.parentNode,
        offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1)
      } : direction < 0 && inputType === "deleteContentBackward" ? {
        node: nextNode.parentNode,
        offset: getOffset(nextNode)
      } : void 0;
    } else
      return {
        node: nextNode.parentNode,
        offset: getOffset(nextNode) + (direction > 0 ? 1 : 0)
      };
  }
}
function getNextCharacterContentNode(node, offset2, direction) {
  let nextOffset = Number(offset2) + (direction < 0 ? -1 : 0);
  return offset2 !== void 0 && isElement4(node) && nextOffset >= 0 && nextOffset < node.children.length && (node = node.children[nextOffset]), walkNodes(node, direction === 1 ? "next" : "previous", isTreatedAsCharacterContent);
}
function isTreatedAsCharacterContent(node) {
  if (isTextNode(node))
    return true;
  if (isElement4(node)) {
    if (isElementType(node, [
      "input",
      "textarea"
    ]))
      return node.type !== "hidden";
    if (isElementType(node, "br"))
      return true;
  }
  return false;
}
function getOffset(node) {
  let i2 = 0;
  for (; node.previousSibling; )
    i2++, node = node.previousSibling;
  return i2;
}
function isElement4(node) {
  return node.nodeType === 1;
}
function isTextNode(node) {
  return node.nodeType === 3;
}
function walkNodes(node, direction, callback) {
  for (; ; ) {
    var _node_ownerDocument;
    let sibling = node[`${direction}Sibling`];
    if (sibling) {
      if (node = getDescendant(sibling, direction === "next" ? "first" : "last"), callback(node))
        return node;
    } else if (node.parentNode && (!isElement4(node.parentNode) || !isContentEditable$1(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body)))
      node = node.parentNode;
    else
      break;
  }
}
function getDescendant(node, direction) {
  for (; node.hasChildNodes(); )
    node = node[`${direction}Child`];
  return node;
}
var TrackChanges = Symbol("Track programmatic changes for React workaround");
function isReact17Element(element) {
  return Object.getOwnPropertyNames(element).some((k2) => k2.startsWith("__react")) && getWindow$3(element).REACT_VERSION === 17;
}
function startTrackValue(element) {
  isReact17Element(element) && (element[TrackChanges] = {
    previousValue: String(element.value),
    tracked: []
  });
}
function trackOrSetValue(element, v2) {
  var _element_TrackChanges_tracked, _element_TrackChanges;
  (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 || (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 || _element_TrackChanges_tracked.push(v2), element[TrackChanges] || (setUIValueClean(element), setUISelection(element, {
    focusOffset: v2.length
  }));
}
function commitValueAfterInput(element, cursorOffset) {
  var _changes_tracked;
  let changes = element[TrackChanges];
  if (element[TrackChanges] = void 0, !(!(changes == null || (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0) && _changes_tracked.length))
    return;
  let isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
  isJustReactStateUpdate || setUIValueClean(element), hasUISelection(element) && setUISelection(element, {
    focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length
  });
}
function getTargetTypeAndSelection(node) {
  let element = getElement2(node);
  if (element && hasOwnSelection(element))
    return {
      type: "input",
      selection: getUISelection(element)
    };
  let selection = element?.ownerDocument.getSelection();
  return {
    type: getContentEditable(node) && selection?.anchorNode && getContentEditable(selection.anchorNode) ? "contenteditable" : "default",
    selection
  };
}
function getElement2(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
function getInputRange(focusNode) {
  let typeAndSelection = getTargetTypeAndSelection(focusNode);
  if (typeAndSelection.type === "input")
    return typeAndSelection.selection;
  if (typeAndSelection.type === "contenteditable") {
    var _typeAndSelection_selection;
    return (_typeAndSelection_selection = typeAndSelection.selection) === null || _typeAndSelection_selection === void 0 ? void 0 : _typeAndSelection_selection.getRangeAt(0);
  }
}
function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
  var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
  if (getTargetTypeAndSelection(focusNode).type === "input")
    return setUISelection(focusNode, {
      anchorOffset,
      focusOffset
    });
  (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === void 0 || (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === void 0 || _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}
function isDateOrTime(element) {
  return isElementType(element, "input") && [
    "date",
    "time"
  ].includes(element.type);
}
function input(instance, element, data, inputType = "insertText") {
  let inputRange = getInputRange(element);
  inputRange && (!isDateOrTime(element) && !instance.dispatchUIEvent(element, "beforeinput", {
    inputType,
    data
  }) || ("startContainer" in inputRange ? editContenteditable(instance, element, inputRange, data, inputType) : editInputElement(instance, element, inputRange, data, inputType)));
}
function editContenteditable(instance, element, inputRange, data, inputType) {
  let del = false;
  if (!inputRange.collapsed)
    del = true, inputRange.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(inputType)) {
    let nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === "deleteContentBackward" ? -1 : 1, inputType);
    if (nextPosition) {
      del = true;
      let delRange = inputRange.cloneRange();
      delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0 ? delRange.setStart(nextPosition.node, nextPosition.offset) : delRange.setEnd(nextPosition.node, nextPosition.offset), delRange.deleteContents();
    }
  }
  if (data)
    if (inputRange.endContainer.nodeType === 3) {
      let offset2 = inputRange.endOffset;
      inputRange.endContainer.insertData(offset2, data), inputRange.setStart(inputRange.endContainer, offset2 + data.length), inputRange.setEnd(inputRange.endContainer, offset2 + data.length);
    } else {
      let text = element.ownerDocument.createTextNode(data);
      inputRange.insertNode(text), inputRange.setStart(text, data.length), inputRange.setEnd(text, data.length);
    }
  (del || data) && instance.dispatchUIEvent(element, "input", {
    inputType
  });
}
function editInputElement(instance, element, inputRange, data, inputType) {
  let dataToInsert = data;
  if (supportsMaxLength(element)) {
    let maxLength = getMaxLength(element);
    if (maxLength !== void 0 && data.length > 0) {
      let spaceUntilMaxLength = maxLength - element.value.length;
      if (spaceUntilMaxLength > 0)
        dataToInsert = data.substring(0, spaceUntilMaxLength);
      else
        return;
    }
  }
  let { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
  newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset || isElementType(element, "input", {
    type: "number"
  }) && !isValidNumberInput(newValue) || (setUIValue(element, newValue), setSelection({
    focusNode: element,
    anchorOffset: newOffset,
    focusOffset: newOffset
  }), isDateOrTime(element) ? isValidDateOrTimeValue(element, newValue) && (commitInput(instance, element, newOffset, {}), instance.dispatchUIEvent(element, "change"), clearInitialValue(element)) : commitInput(instance, element, newOffset, {
    data,
    inputType
  }));
}
function calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {
  let value = getUIValue(node), prologEnd = Math.max(0, startOffset === endOffset && inputType === "deleteContentBackward" ? startOffset - 1 : startOffset), prolog = value.substring(0, prologEnd), epilogStart = Math.min(value.length, startOffset === endOffset && inputType === "deleteContentForward" ? startOffset + 1 : endOffset), epilog = value.substring(epilogStart, value.length), newValue = `${prolog}${inputData}${epilog}`, newOffset = prologEnd + inputData.length;
  if (isElementType(node, "input", {
    type: "time"
  })) {
    let builtValue = buildTimeValue(newValue);
    builtValue !== "" && isValidDateOrTimeValue(node, builtValue) && (newValue = builtValue, newOffset = builtValue.length);
  }
  return {
    oldValue: value,
    newValue,
    newOffset
  };
}
function commitInput(instance, element, newOffset, inputInit) {
  instance.dispatchUIEvent(element, "input", inputInit), commitValueAfterInput(element, newOffset);
}
function isValidNumberInput(value) {
  var _value_match, _value_match1;
  let valueParts = value.split("e", 2);
  return !(/[^\d.\-e]/.test(value) || Number((_value_match = value.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value.match(/\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
}
behavior.cut = (event, target, instance) => () => {
  isEditable(target) && input(instance, target, "", "deleteByCut");
};
function getValueOrTextContent(element) {
  return element ? isContentEditable$1(element) ? element.textContent : getUIValue(element) : null;
}
function isVisible(element) {
  let window2 = getWindow$3(element);
  for (let el = element; el?.ownerDocument; el = el.parentElement) {
    let { display: display2, visibility } = window2.getComputedStyle(el);
    if (display2 === "none" || visibility === "hidden")
      return false;
  }
  return true;
}
function getTabDestination(activeElement2, shift2) {
  let document7 = activeElement2.ownerDocument, focusableElements = document7.querySelectorAll(FOCUSABLE_SELECTOR), enabledElements = Array.from(focusableElements).filter((el) => el === activeElement2 || !(Number(el.getAttribute("tabindex")) < 0 || isDisabled2(el)));
  Number(activeElement2.getAttribute("tabindex")) >= 0 && enabledElements.sort((a2, b2) => {
    let i2 = Number(a2.getAttribute("tabindex")), j2 = Number(b2.getAttribute("tabindex"));
    return i2 === j2 ? 0 : i2 === 0 ? 1 : j2 === 0 ? -1 : i2 - j2;
  });
  let checkedRadio = {}, prunedElements = [
    document7.body
  ], activeRadioGroup = isElementType(activeElement2, "input", {
    type: "radio"
  }) ? activeElement2.name : void 0;
  enabledElements.forEach((currentElement) => {
    let el = currentElement;
    if (isElementType(el, "input", {
      type: "radio"
    }) && el.name) {
      if (el === activeElement2) {
        prunedElements.push(el);
        return;
      } else if (el.name === activeRadioGroup)
        return;
      if (el.checked) {
        prunedElements = prunedElements.filter((e2) => !isElementType(e2, "input", {
          type: "radio",
          name: el.name
        })), prunedElements.push(el), checkedRadio[el.name] = el;
        return;
      }
      if (typeof checkedRadio[el.name] < "u")
        return;
    }
    prunedElements.push(el);
  });
  for (let index2 = prunedElements.findIndex((el) => el === activeElement2); ; )
    if (index2 += shift2 ? -1 : 1, index2 === prunedElements.length ? index2 = 0 : index2 === -1 && (index2 = prunedElements.length - 1), prunedElements[index2] === activeElement2 || prunedElements[index2] === document7.body || isVisible(prunedElements[index2]))
      return prunedElements[index2];
}
function moveSelection(node, direction) {
  if (hasOwnSelection(node)) {
    let selection = getUISelection(node);
    setSelection({
      focusNode: node,
      focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset
    });
  } else {
    let selection = node.ownerDocument.getSelection();
    if (!selection?.focusNode)
      return;
    if (selection.isCollapsed) {
      let nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
      nextPosition && setSelection({
        focusNode: nextPosition.node,
        focusOffset: nextPosition.offset
      });
    } else
      selection[direction < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
function selectAll(target) {
  if (hasOwnSelection(target))
    return setSelection({
      focusNode: target,
      anchorOffset: 0,
      focusOffset: getUIValue(target).length
    });
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body;
  setSelection({
    focusNode,
    anchorOffset: 0,
    focusOffset: focusNode.childNodes.length
  });
}
function isAllSelected(target) {
  if (hasOwnSelection(target))
    return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body, selection = target.ownerDocument.getSelection();
  return selection?.anchorNode === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
}
function setSelectionRange(element, anchorOffset, focusOffset) {
  var _element_firstChild;
  if (hasOwnSelection(element))
    return setSelection({
      focusNode: element,
      anchorOffset,
      focusOffset
    });
  if (isContentEditable$1(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === void 0 ? void 0 : _element_firstChild.nodeType) === 3)
    return setSelection({
      focusNode: element.firstChild,
      anchorOffset,
      focusOffset
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
function walkRadio(instance, el, direction) {
  let window2 = getWindow$3(el), group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window2.CSS.escape(el.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let i2 = group.findIndex((e2) => e2 === el) + direction; ; i2 += direction) {
    if (group[i2] || (i2 = direction > 0 ? 0 : group.length - 1), group[i2] === el)
      return;
    if (!isDisabled2(group[i2])) {
      focusElement(group[i2]), instance.dispatchUIEvent(group[i2], "click");
      return;
    }
  }
}
behavior.keydown = (event, target, instance) => {
  var _keydownBehavior_event_key, _keydownBehavior_event_key1;
  return (_keydownBehavior_event_key1 = (_keydownBehavior_event_key = keydownBehavior[event.key]) === null || _keydownBehavior_event_key === void 0 ? void 0 : _keydownBehavior_event_key.call(keydownBehavior, event, target, instance)) !== null && _keydownBehavior_event_key1 !== void 0 ? _keydownBehavior_event_key1 : combinationBehavior(event, target, instance);
};
var keydownBehavior = {
  ArrowDown: (event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    }))
      return () => walkRadio(instance, target, 1);
  },
  ArrowLeft: (event, target, instance) => isElementType(target, "input", {
    type: "radio"
  }) ? () => walkRadio(instance, target, -1) : () => moveSelection(target, -1),
  ArrowRight: (event, target, instance) => isElementType(target, "input", {
    type: "radio"
  }) ? () => walkRadio(instance, target, 1) : () => moveSelection(target, 1),
  ArrowUp: (event, target, instance) => {
    if (isElementType(target, "input", {
      type: "radio"
    }))
      return () => walkRadio(instance, target, -1);
  },
  Backspace: (event, target, instance) => {
    if (isEditable(target))
      return () => {
        input(instance, target, "", "deleteContentBackward");
      };
  },
  Delete: (event, target, instance) => {
    if (isEditable(target))
      return () => {
        input(instance, target, "", "deleteContentForward");
      };
  },
  End: (event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable$1(target))
      return () => {
        var _getValueOrTextContent, _getValueOrTextContent_length;
        let newPos = (_getValueOrTextContent_length = (_getValueOrTextContent = getValueOrTextContent(target)) === null || _getValueOrTextContent === void 0 ? void 0 : _getValueOrTextContent.length) !== null && _getValueOrTextContent_length !== void 0 ? _getValueOrTextContent_length : (
          /* istanbul ignore next */
          0
        );
        setSelectionRange(target, newPos, newPos);
      };
  },
  Home: (event, target) => {
    if (isElementType(target, [
      "input",
      "textarea"
    ]) || isContentEditable$1(target))
      return () => {
        setSelectionRange(target, 0, 0);
      };
  },
  PageDown: (event, target) => {
    if (isElementType(target, [
      "input"
    ]))
      return () => {
        let newPos = getUIValue(target).length;
        setSelectionRange(target, newPos, newPos);
      };
  },
  PageUp: (event, target) => {
    if (isElementType(target, [
      "input"
    ]))
      return () => {
        setSelectionRange(target, 0, 0);
      };
  },
  Tab: (event, target, instance) => () => {
    let dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
    focusElement(dest), hasOwnSelection(dest) && setUISelection(dest, {
      anchorOffset: 0,
      focusOffset: dest.value.length
    });
  }
}, combinationBehavior = (event, target, instance) => {
  if (event.code === "KeyA" && instance.system.keyboard.modifiers.Control)
    return () => selectAll(target);
};
behavior.keypress = (event, target, instance) => {
  if (event.key === "Enter") {
    if (isElementType(target, "button") || isElementType(target, "input") && ClickInputOnEnter.includes(target.type) || isElementType(target, "a") && target.href)
      return () => {
        instance.dispatchUIEvent(target, "click");
      };
    if (isElementType(target, "input")) {
      let form = target.form, submit = form?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return submit ? () => instance.dispatchUIEvent(submit, "click") : form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll("input").length === 1 ? () => instance.dispatchUIEvent(form, "submit") : void 0;
    }
  }
  if (isEditable(target)) {
    let inputType = event.key === "Enter" ? isContentEditable$1(target) && !instance.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", inputData = event.key === "Enter" ? `
` : event.key;
    return () => input(instance, target, inputData, inputType);
  }
};
var ClickInputOnEnter = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], SubmitSingleInputOnEnter = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];
behavior.keyup = (event, target, instance) => {
  var _keyupBehavior_event_key;
  return (_keyupBehavior_event_key = keyupBehavior[event.key]) === null || _keyupBehavior_event_key === void 0 ? void 0 : _keyupBehavior_event_key.call(keyupBehavior, event, target, instance);
};
var keyupBehavior = {
  " ": (event, target, instance) => {
    if (isClickableInput(target))
      return () => instance.dispatchUIEvent(target, "click");
  }
};
behavior.paste = (event, target, instance) => {
  if (isEditable(target))
    return () => {
      var _event_clipboardData;
      let insertData = (_event_clipboardData = event.clipboardData) === null || _event_clipboardData === void 0 ? void 0 : _event_clipboardData.getData("text");
      insertData && input(instance, target, insertData, "insertFromPaste");
    };
};
var eventMap2 = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
};
function getEventClass(type5) {
  return eventMap2[type5].EventType;
}
var mouseEvents = [
  "MouseEvent",
  "PointerEvent"
];
function isMouseEvent(type5) {
  return mouseEvents.includes(getEventClass(type5));
}
function isKeyboardEvent(type5) {
  return getEventClass(type5) === "KeyboardEvent";
}
var eventInitializer = {
  ClipboardEvent: [
    initClipboardEvent
  ],
  Event: [],
  FocusEvent: [
    initUIEvent,
    initFocusEvent
  ],
  InputEvent: [
    initUIEvent,
    initInputEvent
  ],
  MouseEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent
  ],
  PointerEvent: [
    initUIEvent,
    initUIEventModifiers,
    initMouseEvent,
    initPointerEvent
  ],
  KeyboardEvent: [
    initUIEvent,
    initUIEventModifiers,
    initKeyboardEvent
  ]
};
function createEvent2(type5, target, init2) {
  let window2 = getWindow$3(target), { EventType, defaultInit } = eventMap2[type5], event = new (getEventConstructors(window2))[EventType](type5, defaultInit);
  return eventInitializer[EventType].forEach((f4) => f4(event, init2 ?? {})), event;
}
function getEventConstructors(window2) {
  var _window_Event;
  let Event2 = (_window_Event = window2.Event) !== null && _window_Event !== void 0 ? _window_Event : class {
  };
  var _window_AnimationEvent;
  let AnimationEvent = (_window_AnimationEvent = window2.AnimationEvent) !== null && _window_AnimationEvent !== void 0 ? _window_AnimationEvent : class extends Event2 {
  };
  var _window_ClipboardEvent;
  let ClipboardEvent = (_window_ClipboardEvent = window2.ClipboardEvent) !== null && _window_ClipboardEvent !== void 0 ? _window_ClipboardEvent : class extends Event2 {
  };
  var _window_PopStateEvent;
  let PopStateEvent = (_window_PopStateEvent = window2.PopStateEvent) !== null && _window_PopStateEvent !== void 0 ? _window_PopStateEvent : class extends Event2 {
  };
  var _window_ProgressEvent;
  let ProgressEvent = (_window_ProgressEvent = window2.ProgressEvent) !== null && _window_ProgressEvent !== void 0 ? _window_ProgressEvent : class extends Event2 {
  };
  var _window_TransitionEvent;
  let TransitionEvent = (_window_TransitionEvent = window2.TransitionEvent) !== null && _window_TransitionEvent !== void 0 ? _window_TransitionEvent : class extends Event2 {
  };
  var _window_UIEvent;
  let UIEvent = (_window_UIEvent = window2.UIEvent) !== null && _window_UIEvent !== void 0 ? _window_UIEvent : class extends Event2 {
  };
  var _window_CompositionEvent;
  let CompositionEvent = (_window_CompositionEvent = window2.CompositionEvent) !== null && _window_CompositionEvent !== void 0 ? _window_CompositionEvent : class extends UIEvent {
  };
  var _window_FocusEvent;
  let FocusEvent = (_window_FocusEvent = window2.FocusEvent) !== null && _window_FocusEvent !== void 0 ? _window_FocusEvent : class extends UIEvent {
  };
  var _window_InputEvent;
  let InputEvent = (_window_InputEvent = window2.InputEvent) !== null && _window_InputEvent !== void 0 ? _window_InputEvent : class extends UIEvent {
  };
  var _window_KeyboardEvent;
  let KeyboardEvent2 = (_window_KeyboardEvent = window2.KeyboardEvent) !== null && _window_KeyboardEvent !== void 0 ? _window_KeyboardEvent : class extends UIEvent {
  };
  var _window_MouseEvent;
  let MouseEvent = (_window_MouseEvent = window2.MouseEvent) !== null && _window_MouseEvent !== void 0 ? _window_MouseEvent : class extends UIEvent {
  };
  var _window_DragEvent;
  let DragEvent = (_window_DragEvent = window2.DragEvent) !== null && _window_DragEvent !== void 0 ? _window_DragEvent : class extends MouseEvent {
  };
  var _window_PointerEvent;
  let PointerEvent = (_window_PointerEvent = window2.PointerEvent) !== null && _window_PointerEvent !== void 0 ? _window_PointerEvent : class extends MouseEvent {
  };
  var _window_TouchEvent;
  let TouchEvent = (_window_TouchEvent = window2.TouchEvent) !== null && _window_TouchEvent !== void 0 ? _window_TouchEvent : class extends UIEvent {
  };
  return {
    Event: Event2,
    AnimationEvent,
    ClipboardEvent,
    PopStateEvent,
    ProgressEvent,
    TransitionEvent,
    UIEvent,
    CompositionEvent,
    FocusEvent,
    InputEvent,
    KeyboardEvent: KeyboardEvent2,
    MouseEvent,
    DragEvent,
    PointerEvent,
    TouchEvent
  };
}
function assignProps(obj, props) {
  for (let [key, value] of Object.entries(props))
    Object.defineProperty(obj, key, {
      get: () => value ?? null
    });
}
function sanitizeNumber(n2) {
  return Number(n2 ?? 0);
}
function initClipboardEvent(event, { clipboardData }) {
  assignProps(event, {
    clipboardData
  });
}
function initFocusEvent(event, { relatedTarget }) {
  assignProps(event, {
    relatedTarget
  });
}
function initInputEvent(event, { data, inputType, isComposing }) {
  assignProps(event, {
    data,
    isComposing: !!isComposing,
    inputType: String(inputType)
  });
}
function initUIEvent(event, { view, detail }) {
  assignProps(event, {
    view,
    detail: sanitizeNumber(detail ?? 0)
  });
}
function initUIEventModifiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
  assignProps(event, {
    altKey: !!altKey,
    ctrlKey: !!ctrlKey,
    metaKey: !!metaKey,
    shiftKey: !!shiftKey,
    getModifierState(k2) {
      return !!{
        Alt: altKey,
        AltGraph: modifierAltGraph,
        CapsLock: modifierCapsLock,
        Control: ctrlKey,
        Fn: modifierFn,
        FnLock: modifierFnLock,
        Meta: metaKey,
        NumLock: modifierNumLock,
        ScrollLock: modifierScrollLock,
        Shift: shiftKey,
        Symbol: modifierSymbol,
        SymbolLock: modifierSymbolLock
      }[k2];
    }
  });
}
function initKeyboardEvent(event, { key, code, location: location2, repeat, isComposing, charCode }) {
  assignProps(event, {
    key: String(key),
    code: String(code),
    location: sanitizeNumber(location2),
    repeat: !!repeat,
    isComposing: !!isComposing,
    charCode
  });
}
function initMouseEvent(event, { x: x2, y: y2, screenX, screenY, clientX = x2, clientY = y2, button, buttons, relatedTarget, offsetX, offsetY, pageX, pageY }) {
  assignProps(event, {
    screenX: sanitizeNumber(screenX),
    screenY: sanitizeNumber(screenY),
    clientX: sanitizeNumber(clientX),
    x: sanitizeNumber(clientX),
    clientY: sanitizeNumber(clientY),
    y: sanitizeNumber(clientY),
    button: sanitizeNumber(button),
    buttons: sanitizeNumber(buttons),
    relatedTarget,
    offsetX: sanitizeNumber(offsetX),
    offsetY: sanitizeNumber(offsetY),
    pageX: sanitizeNumber(pageX),
    pageY: sanitizeNumber(pageY)
  });
}
function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
  assignProps(event, {
    pointerId: sanitizeNumber(pointerId),
    width: sanitizeNumber(width ?? 1),
    height: sanitizeNumber(height ?? 1),
    pressure: sanitizeNumber(pressure),
    tangentialPressure: sanitizeNumber(tangentialPressure),
    tiltX: sanitizeNumber(tiltX),
    tiltY: sanitizeNumber(tiltY),
    twist: sanitizeNumber(twist),
    pointerType: String(pointerType),
    isPrimary: !!isPrimary
  });
}
function dispatchUIEvent(target, type5, init2, preventDefault = false) {
  (isMouseEvent(type5) || isKeyboardEvent(type5)) && (init2 = {
    ...init2,
    ...this.system.getUIEventModifiers()
  });
  let event = createEvent2(type5, target, init2);
  return dispatchEvent.call(this, target, event, preventDefault);
}
function dispatchEvent(target, event, preventDefault = false) {
  var _behavior_type;
  let type5 = event.type, behaviorImplementation = preventDefault ? () => {
  } : (_behavior_type = behavior[type5]) === null || _behavior_type === void 0 ? void 0 : _behavior_type.call(behavior, event, target, this);
  if (behaviorImplementation) {
    event.preventDefault();
    let defaultPrevented = false;
    return Object.defineProperty(event, "defaultPrevented", {
      get: () => defaultPrevented
    }), Object.defineProperty(event, "preventDefault", {
      value: () => {
        defaultPrevented = event.cancelable;
      }
    }), wrapEvent(() => target.dispatchEvent(event)), defaultPrevented || behaviorImplementation(), !defaultPrevented;
  }
  return wrapEvent(() => target.dispatchEvent(event));
}
function dispatchDOMEvent(target, type5, init2) {
  let event = createEvent2(type5, target, init2);
  wrapEvent(() => target.dispatchEvent(event));
}
var patched = Symbol("patched focus/blur methods");
function patchFocus(HTMLElement2) {
  if (HTMLElement2.prototype[patched])
    return;
  let { focus, blur } = HTMLElement2.prototype;
  Object.defineProperties(HTMLElement2.prototype, {
    focus: {
      configurable: true,
      get: () => patchedFocus2
    },
    blur: {
      configurable: true,
      get: () => patchedBlur
    },
    [patched]: {
      configurable: true,
      get: () => ({
        focus,
        blur
      })
    }
  });
  let activeCall;
  function patchedFocus2(options) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return focus.call(this, options);
    let blurred = getActiveTarget(this.ownerDocument);
    if (blurred === this)
      return;
    let thisCall = Symbol("focus call");
    activeCall = thisCall, blurred && (blur.call(blurred), dispatchDOMEvent(blurred, "blur", {
      relatedTarget: this
    }), dispatchDOMEvent(blurred, "focusout", {
      relatedTarget: activeCall === thisCall ? this : null
    })), activeCall === thisCall && (focus.call(this, options), dispatchDOMEvent(this, "focus", {
      relatedTarget: blurred
    })), activeCall === thisCall && dispatchDOMEvent(this, "focusin", {
      relatedTarget: blurred
    });
  }
  function patchedBlur() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return blur.call(this);
    let blurred = getActiveTarget(this.ownerDocument);
    if (blurred !== this)
      return;
    activeCall = Symbol("blur call"), blur.call(this), dispatchDOMEvent(blurred, "blur", {
      relatedTarget: null
    }), dispatchDOMEvent(blurred, "focusout", {
      relatedTarget: null
    });
  }
}
function getActiveTarget(document7) {
  let active = getActiveElement(document7);
  return active?.tagName === "BODY" ? null : active;
}
var Interceptor = Symbol("Interceptor for programmatical calls");
function prepareInterceptor(element, propName, interceptorImpl) {
  let prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName), objectDescriptor = Object.getOwnPropertyDescriptor(element, propName), target = prototypeDescriptor?.set ? "set" : "value";
  if (typeof prototypeDescriptor?.[target] != "function" || prototypeDescriptor[target][Interceptor])
    throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
  function intercept(...args) {
    let { applyNative = false, realArgs, then } = interceptorImpl.call(this, ...args), realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
    target === "set" ? realFunc.call(this, realArgs) : realFunc.call(this, ...realArgs), then?.();
  }
  intercept[Interceptor] = Interceptor, Object.defineProperty(element, propName, {
    ...objectDescriptor ?? prototypeDescriptor,
    [target]: intercept
  });
}
function prepareValueInterceptor(element) {
  prepareInterceptor(element, "value", function(v2) {
    let isUI = isUIValue(v2);
    return isUI && startTrackValue(this), {
      applyNative: !!isUI,
      realArgs: sanitizeValue(this, v2),
      then: isUI ? void 0 : () => trackOrSetValue(this, String(v2))
    };
  });
}
function sanitizeValue(element, v2) {
  return isElementType(element, "input", {
    type: "number"
  }) && String(v2) !== "" && !Number.isNaN(Number(v2)) ? String(Number(v2)) : String(v2);
}
function prepareSelectionInterceptor(element) {
  prepareInterceptor(element, "setSelectionRange", function(start, ...others) {
    let isUI = isUISelectionStart(start);
    return {
      applyNative: !!isUI,
      realArgs: [
        Number(start),
        ...others
      ],
      then: () => isUI ? void 0 : setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "selectionStart", function(v2) {
    return {
      realArgs: v2,
      then: () => setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "selectionEnd", function(v2) {
    return {
      realArgs: v2,
      then: () => setUISelectionClean(element)
    };
  }), prepareInterceptor(element, "select", function() {
    return {
      realArgs: [],
      then: () => setUISelectionRaw(element, {
        anchorOffset: 0,
        focusOffset: getUIValue(element).length
      })
    };
  });
}
function prepareRangeTextInterceptor(element) {
  prepareInterceptor(element, "setRangeText", function(...realArgs) {
    return {
      realArgs,
      then: () => {
        setUIValueClean(element), setUISelectionClean(element);
      }
    };
  });
}
var isPrepared = Symbol("Node prepared with document state workarounds");
function prepareDocument(document7) {
  document7[isPrepared] || (document7.addEventListener("focus", (e2) => {
    let el = e2.target;
    prepareElement(el);
  }, {
    capture: true,
    passive: true
  }), document7.activeElement && prepareElement(document7.activeElement), document7.addEventListener("blur", (e2) => {
    let el = e2.target, initialValue2 = getInitialValue(el);
    initialValue2 !== void 0 && (el.value !== initialValue2 && dispatchDOMEvent(el, "change"), clearInitialValue(el));
  }, {
    capture: true,
    passive: true
  }), document7[isPrepared] = isPrepared);
}
function prepareElement(el) {
  el[isPrepared] || (isElementType(el, [
    "input",
    "textarea"
  ]) && (prepareValueInterceptor(el), prepareSelectionInterceptor(el), prepareRangeTextInterceptor(el)), el[isPrepared] = isPrepared);
}
function getDocumentFromNode(el) {
  return isDocument2(el) ? el : el.ownerDocument;
}
function isDocument2(node) {
  return node.nodeType === 9;
}
var ApiLevel = function(ApiLevel2) {
  return ApiLevel2[ApiLevel2.Trigger = 2] = "Trigger", ApiLevel2[ApiLevel2.Call = 1] = "Call", ApiLevel2;
}({});
function setLevelRef(instance, level) {
  instance.levelRefs[level] = {};
}
function getLevelRef(instance, level) {
  return instance.levelRefs[level];
}
function wait(config4) {
  let delay = config4.delay;
  if (typeof delay == "number")
    return Promise.all([
      new Promise((resolve) => globalThis.setTimeout(() => resolve(), delay)),
      config4.advanceTimers(delay)
    ]);
}
var PointerEventsCheckLevel = function(PointerEventsCheckLevel2) {
  return PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTrigger = 4] = "EachTrigger", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachApiCall = 2] = "EachApiCall", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTarget = 1] = "EachTarget", PointerEventsCheckLevel2[PointerEventsCheckLevel2.Never = 0] = "Never", PointerEventsCheckLevel2;
}({});
function _define_property3(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var DOM_KEY_LOCATION = function(DOM_KEY_LOCATION2) {
  return DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.STANDARD = 0] = "STANDARD", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.LEFT = 1] = "LEFT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.RIGHT = 2] = "RIGHT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.NUMPAD = 3] = "NUMPAD", DOM_KEY_LOCATION2;
}({}), modifierKeys = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function isModifierKey(key) {
  return modifierKeys.includes(key);
}
var modifierLocks = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function isModifierLock(key) {
  return modifierLocks.includes(key);
}
var KeyboardHost = class {
  isKeyPressed(keyDef) {
    return this.pressed.has(String(keyDef.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((p2) => p2.keyDef);
  }
  /** Press a key */
  async keydown(instance, keyDef) {
    let key = String(keyDef.key), code = String(keyDef.code), target = getActiveElementOrBody(instance.config.document);
    this.setKeydownTarget(target), this.pressed.add(code, keyDef), isModifierKey(key) && (this.modifiers[key] = true);
    let unprevented = instance.dispatchUIEvent(target, "keydown", {
      key,
      code
    });
    isModifierLock(key) && !this.modifiers[key] && (this.modifiers[key] = true, this.modifierLockStart[key] = true), unprevented && this.pressed.setUnprevented(code), unprevented && this.hasKeyPress(key) && instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keypress", {
      key,
      code,
      charCode: keyDef.key === "Enter" ? 13 : String(keyDef.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(instance, keyDef) {
    let key = String(keyDef.key), code = String(keyDef.code), unprevented = this.pressed.isUnprevented(code);
    this.pressed.delete(code), isModifierKey(key) && !this.pressed.values().find((p2) => p2.keyDef.key === key) && (this.modifiers[key] = false), instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keyup", {
      key,
      code
    }, !unprevented), isModifierLock(key) && this.modifiers[key] && (this.modifierLockStart[key] ? this.modifierLockStart[key] = false : this.modifiers[key] = false);
  }
  setKeydownTarget(target) {
    target !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = target;
  }
  hasKeyPress(key) {
    return (key.length === 1 || key === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(system) {
    _define_property3(this, "system", void 0), _define_property3(this, "modifiers", {
      Alt: false,
      AltGraph: false,
      CapsLock: false,
      Control: false,
      Fn: false,
      FnLock: false,
      Meta: false,
      NumLock: false,
      ScrollLock: false,
      Shift: false,
      Symbol: false,
      SymbolLock: false
    }), _define_property3(this, "pressed", new class {
      add(code, keyDef) {
        var _this_registry, _code, _;
        (_ = (_this_registry = this.registry)[_code = code]) !== null && _ !== void 0 || (_this_registry[_code] = {
          keyDef,
          unpreventedDefault: false
        });
      }
      has(code) {
        return !!this.registry[code];
      }
      setUnprevented(code) {
        let o2 = this.registry[code];
        o2 && (o2.unpreventedDefault = true);
      }
      isUnprevented(code) {
        var _this_registry_code;
        return !!(!((_this_registry_code = this.registry[code]) === null || _this_registry_code === void 0) && _this_registry_code.unpreventedDefault);
      }
      delete(code) {
        delete this.registry[code];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        _define_property3(this, "registry", {});
      }
    }()), _define_property3(this, "carryChar", ""), _define_property3(this, "lastKeydownTarget", void 0), _define_property3(this, "modifierLockStart", {}), this.system = system;
  }
};
var defaultKeyMap = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((c2) => ({
    code: `Digit${c2}`,
    key: c2
  })),
  ...")!@#$%^&*(".split("").map((c2, i2) => ({
    code: `Digit${i2}`,
    key: c2,
    shiftKey: true
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((c2) => ({
    code: `Key${c2.toUpperCase()}`,
    key: c2
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((c2) => ({
    code: `Key${c2}`,
    key: c2,
    shiftKey: true
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: true
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: true
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: DOM_KEY_LOCATION.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: DOM_KEY_LOCATION.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
];
var defaultKeyMap2 = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];
function _define_property4(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var Buttons = class {
  getButtons() {
    let v2 = 0;
    for (let button of Object.keys(this.pressed))
      v2 |= 2 ** Number(button);
    return v2;
  }
  down(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed) {
      this.pressed[button].push(keyDef);
      return;
    }
    return this.pressed[button] = [
      keyDef
    ], button;
  }
  up(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed && (this.pressed[button] = this.pressed[button].filter((k2) => k2.name !== keyDef.name), this.pressed[button].length === 0))
      return delete this.pressed[button], button;
  }
  constructor() {
    _define_property4(this, "pressed", {});
  }
}, MouseButton = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function getMouseButtonId(button = 0) {
  return button in MouseButton ? MouseButton[button] : Number(button);
}
var MouseButtonFlip = {
  1: 2,
  2: 1
};
function getMouseEventButton(button) {
  return button = getMouseButtonId(button), button in MouseButtonFlip ? MouseButtonFlip[button] : button;
}
function _define_property5(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var Device = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(keyDef) {
    return this.pressedKeys.has(keyDef.name);
  }
  addPressed(keyDef) {
    return this.pressedKeys.add(keyDef.name);
  }
  removePressed(keyDef) {
    return this.pressedKeys.delete(keyDef.name);
  }
  constructor() {
    _define_property5(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
function getTreeDiff(a2, b2) {
  let treeA = [];
  for (let el = a2; el; el = el.parentElement)
    treeA.push(el);
  let treeB = [];
  for (let el = b2; el; el = el.parentElement)
    treeB.push(el);
  let i2 = 0;
  for (; !(i2 >= treeA.length || i2 >= treeB.length || treeA[treeA.length - 1 - i2] !== treeB[treeB.length - 1 - i2]); i2++)
    ;
  return [
    treeA.slice(0, treeA.length - i2),
    treeB.slice(0, treeB.length - i2),
    treeB.slice(treeB.length - i2)
  ];
}
function resolveCaretPosition({ target, node, offset: offset2 }) {
  return hasOwnSelection(target) ? {
    node: target,
    offset: offset2 ?? getUIValue(target).length
  } : node ? {
    node,
    offset: offset2 ?? (node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length)
  } : findNodeAtTextOffset(target, offset2);
}
function findNodeAtTextOffset(node, offset2, isRoot = true) {
  let i2 = offset2 === void 0 ? node.childNodes.length - 1 : 0, step2 = offset2 === void 0 ? -1 : 1;
  for (; offset2 === void 0 ? i2 >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i2 <= node.childNodes.length; ) {
    if (offset2 && i2 === node.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    let c2 = node.childNodes.item(i2), text = String(c2.textContent);
    if (text.length)
      if (offset2 !== void 0 && text.length < offset2)
        offset2 -= text.length;
      else {
        if (c2.nodeType === 1)
          return findNodeAtTextOffset(c2, offset2, false);
        if (c2.nodeType === 3)
          return {
            node: c2,
            offset: offset2 ?? c2.nodeValue.length
          };
      }
    i2 += step2;
  }
  return {
    node,
    offset: node.childNodes.length
  };
}
function setSelectionPerMouseDown({ document: document7, target, clickCount, node, offset: offset2 }) {
  if (hasNoSelection(target))
    return;
  let targetHasOwnSelection = hasOwnSelection(target), text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent), [start, end] = node ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      offset2,
      offset2
    ]
  ) : getTextRange(text, offset2, clickCount);
  if (targetHasOwnSelection)
    return setUISelection(target, {
      anchorOffset: start ?? text.length,
      focusOffset: end ?? text.length
    }), {
      node: target,
      start: start ?? 0,
      end: end ?? text.length
    };
  {
    let { node: startNode, offset: startOffset } = resolveCaretPosition({
      target,
      node,
      offset: start
    }), { node: endNode, offset: endOffset } = resolveCaretPosition({
      target,
      node,
      offset: end
    }), range = target.ownerDocument.createRange();
    try {
      range.setStart(startNode, startOffset), range.setEnd(endNode, endOffset);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    let selection = document7.getSelection();
    return selection?.removeAllRanges(), selection?.addRange(range.cloneRange()), range;
  }
}
function getTextRange(text, pos, clickCount) {
  if (clickCount % 3 === 1 || text.length === 0)
    return [
      pos,
      pos
    ];
  let textPos = pos ?? text.length;
  return clickCount % 3 === 2 ? [
    textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length,
    pos === void 0 ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length,
    pos === void 0 ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length
  ];
}
function modifySelectionPerMouseMove(selectionRange, { document: document7, target, node, offset: offset2 }) {
  let selectionFocus = resolveCaretPosition({
    target,
    node,
    offset: offset2
  });
  if ("node" in selectionRange) {
    if (selectionFocus.node === selectionRange.node) {
      let anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start, focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
      setUISelection(selectionRange.node, {
        anchorOffset,
        focusOffset
      });
    }
  } else {
    let range = selectionRange.cloneRange(), cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
    cmp < 0 ? range.setStart(selectionFocus.node, selectionFocus.offset) : cmp > 0 && range.setEnd(selectionFocus.node, selectionFocus.offset);
    let selection = document7.getSelection();
    selection?.removeAllRanges(), selection?.addRange(range.cloneRange());
  }
}
function isDifferentPointerPosition(positionA, positionB) {
  var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_coords2, _positionB_coords2, _positionA_coords3, _positionB_coords3, _positionA_coords4, _positionB_coords4, _positionA_coords5, _positionB_coords5, _positionA_coords6, _positionB_coords6, _positionA_coords7, _positionB_coords7, _positionA_coords8, _positionB_coords8, _positionA_coords9, _positionB_coords9, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
  return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === void 0 ? void 0 : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === void 0 ? void 0 : _positionB_coords.x) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === void 0 ? void 0 : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === void 0 ? void 0 : _positionB_coords1.y) || ((_positionA_coords2 = positionA.coords) === null || _positionA_coords2 === void 0 ? void 0 : _positionA_coords2.clientX) !== ((_positionB_coords2 = positionB.coords) === null || _positionB_coords2 === void 0 ? void 0 : _positionB_coords2.clientX) || ((_positionA_coords3 = positionA.coords) === null || _positionA_coords3 === void 0 ? void 0 : _positionA_coords3.clientY) !== ((_positionB_coords3 = positionB.coords) === null || _positionB_coords3 === void 0 ? void 0 : _positionB_coords3.clientY) || ((_positionA_coords4 = positionA.coords) === null || _positionA_coords4 === void 0 ? void 0 : _positionA_coords4.offsetX) !== ((_positionB_coords4 = positionB.coords) === null || _positionB_coords4 === void 0 ? void 0 : _positionB_coords4.offsetX) || ((_positionA_coords5 = positionA.coords) === null || _positionA_coords5 === void 0 ? void 0 : _positionA_coords5.offsetY) !== ((_positionB_coords5 = positionB.coords) === null || _positionB_coords5 === void 0 ? void 0 : _positionB_coords5.offsetY) || ((_positionA_coords6 = positionA.coords) === null || _positionA_coords6 === void 0 ? void 0 : _positionA_coords6.pageX) !== ((_positionB_coords6 = positionB.coords) === null || _positionB_coords6 === void 0 ? void 0 : _positionB_coords6.pageX) || ((_positionA_coords7 = positionA.coords) === null || _positionA_coords7 === void 0 ? void 0 : _positionA_coords7.pageY) !== ((_positionB_coords7 = positionB.coords) === null || _positionB_coords7 === void 0 ? void 0 : _positionB_coords7.pageY) || ((_positionA_coords8 = positionA.coords) === null || _positionA_coords8 === void 0 ? void 0 : _positionA_coords8.screenX) !== ((_positionB_coords8 = positionB.coords) === null || _positionB_coords8 === void 0 ? void 0 : _positionB_coords8.screenX) || ((_positionA_coords9 = positionA.coords) === null || _positionA_coords9 === void 0 ? void 0 : _positionA_coords9.screenY) !== ((_positionB_coords9 = positionB.coords) === null || _positionB_coords9 === void 0 ? void 0 : _positionB_coords9.screenY) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === void 0 ? void 0 : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === void 0 ? void 0 : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === void 0 ? void 0 : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === void 0 ? void 0 : _positionB_caret1.offset);
}
function _define_property6(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var Mouse = class {
  move(instance, position, isPrevented) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position))
      return;
    let nextTarget = this.getTarget(instance), init2 = this.getEventInit("mousemove"), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: () => {
        prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "mouseout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "mouseleave", init2)));
      },
      enter: () => {
        prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "mouseover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "mouseenter", init2)));
      },
      move: () => {
        isPrevented || (instance.dispatchUIEvent(nextTarget, "mousemove", init2), this.modifySelecting(instance));
      }
    };
  }
  down(instance, keyDef, isPrevented) {
    let button = this.buttons.down(keyDef);
    if (button === void 0)
      return;
    let target = this.getTarget(instance);
    this.buttonDownTarget[button] = target;
    let init2 = this.getEventInit("mousedown", keyDef.button), disabled = isDisabled2(target);
    !isPrevented && (disabled || instance.dispatchUIEvent(target, "mousedown", init2)) && (this.startSelecting(instance, init2.detail), focusElement(target)), !disabled && getMouseEventButton(keyDef.button) === 2 && instance.dispatchUIEvent(target, "contextmenu", this.getEventInit("contextmenu", keyDef.button));
  }
  up(instance, keyDef, isPrevented) {
    let button = this.buttons.up(keyDef);
    if (button === void 0)
      return;
    let target = this.getTarget(instance);
    if (!isDisabled2(target)) {
      if (!isPrevented) {
        let mouseUpInit = this.getEventInit("mouseup", keyDef.button);
        instance.dispatchUIEvent(target, "mouseup", mouseUpInit), this.endSelecting();
      }
      let clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
      if (clickTarget) {
        let init2 = this.getEventInit("click", keyDef.button);
        init2.detail && (instance.dispatchUIEvent(clickTarget, init2.button === 0 ? "click" : "auxclick", init2), init2.button === 0 && init2.detail === 2 && instance.dispatchUIEvent(clickTarget, "dblclick", {
          ...this.getEventInit("dblclick", keyDef.button),
          detail: init2.detail
        }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(type5, button) {
    let init2 = {
      ...this.position.coords
    };
    return init2.button = getMouseEventButton(button), init2.buttons = this.buttons.getButtons(), type5 === "mousedown" ? init2.detail = this.clickCount.getOnDown(init2.button) : type5 === "mouseup" ? init2.detail = this.clickCount.getOnUp(init2.button) : (type5 === "click" || type5 === "auxclick") && (init2.detail = this.clickCount.incOnClick(init2.button)), init2;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  startSelecting(instance, clickCount) {
    var _this_position_caret, _this_position_caret1;
    this.selecting = setSelectionPerMouseDown({
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset,
      clickCount
    });
  }
  modifySelecting(instance) {
    var _this_position_caret, _this_position_caret1;
    this.selecting && modifySelectionPerMouseMove(this.selecting, {
      document: instance.config.document,
      target: this.getTarget(instance),
      node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node,
      offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    _define_property6(this, "position", {}), _define_property6(this, "buttons", new Buttons()), _define_property6(this, "selecting", void 0), _define_property6(this, "buttonDownTarget", {}), _define_property6(this, "clickCount", new class {
      incOnClick(button) {
        let current = this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
        return this.count = this.count[button] === void 0 ? {} : {
          [button]: Number(this.count[button]) + 1
        }, current;
      }
      getOnDown(button) {
        var _this_count_button;
        this.down = {
          [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== void 0 ? _this_count_button : 0
        };
        var _this_count_button1;
        return this.count = {
          [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== void 0 ? _this_count_button1 : 0
        }, Number(this.count[button]) + 1;
      }
      getOnUp(button) {
        return this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        _define_property6(this, "down", {}), _define_property6(this, "count", {});
      }
    }());
  }
};
function hasPointerEvents(instance, element) {
  var _checkPointerEvents;
  return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === void 0 ? void 0 : _checkPointerEvents.pointerEvents) !== "none";
}
function closestPointerEventsDeclaration(element) {
  let window2 = getWindow$3(element);
  for (let el = element, tree = []; el?.ownerDocument; el = el.parentElement) {
    tree.push(el);
    let pointerEvents = window2.getComputedStyle(el).pointerEvents;
    if (pointerEvents && ![
      "inherit",
      "unset"
    ].includes(pointerEvents))
      return {
        pointerEvents,
        tree
      };
  }
}
var PointerEventsCheck = Symbol("Last check for pointer-events");
function checkPointerEvents(instance, element) {
  let lastCheck = element[PointerEventsCheck];
  if (!(instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger))))
    return lastCheck?.result;
  let declaration = closestPointerEventsDeclaration(element);
  return element[PointerEventsCheck] = {
    [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call),
    [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger),
    result: declaration
  }, declaration;
}
function assertPointerEvents(instance, element) {
  let declaration = checkPointerEvents(instance, element);
  if (declaration?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      printTree(declaration.tree)
    ].join(`
`));
}
function printTree(tree) {
  return tree.reverse().map((el, i2) => [
    "".padEnd(i2),
    el.tagName,
    el.id && `#${el.id}`,
    el.hasAttribute("data-testid") && `(testId=${el.getAttribute("data-testid")})`,
    getLabelDescr(el),
    tree.length > 1 && i2 === 0 && "  <-- This element declared `pointer-events: none`",
    tree.length > 1 && i2 === tree.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
function getLabelDescr(element) {
  var _element_labels;
  let label;
  if (element.hasAttribute("aria-label"))
    label = element.getAttribute("aria-label");
  else if (element.hasAttribute("aria-labelledby")) {
    var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
    label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute("aria-labelledby"))) === null || _element_ownerDocument_getElementById === void 0 || (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === void 0 ? void 0 : _element_ownerDocument_getElementById_textContent.trim();
  } else if (isElementType(element, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && (!((_element_labels = element.labels) === null || _element_labels === void 0) && _element_labels.length))
    label = Array.from(element.labels).map((el) => {
      var _el_textContent;
      return (_el_textContent = el.textContent) === null || _el_textContent === void 0 ? void 0 : _el_textContent.trim();
    }).join("|");
  else if (isElementType(element, "button")) {
    var _element_textContent;
    label = (_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim();
  }
  return label = label?.replace(/\n/g, "  "), Number(label?.length) > 30 && (label = `${label?.substring(0, 29)}`), label ? `(label=${label})` : "";
}
function hasBitFlag(conf, flag3) {
  return (conf & flag3) > 0;
}
function _define_property7(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var Pointer = class {
  init(instance) {
    let target = this.getTarget(instance), [, enter] = getTreeDiff(null, target), init2 = this.getEventInit();
    return assertPointerEvents(instance, target), instance.dispatchUIEvent(target, "pointerover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2)), this;
  }
  move(instance, position) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position))
      return;
    let nextTarget = this.getTarget(instance), init2 = this.getEventInit(-1), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return {
      leave: () => {
        hasPointerEvents(instance, prevTarget) && prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "pointerout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2)));
      },
      enter: () => {
        assertPointerEvents(instance, nextTarget), prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "pointerover", init2), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init2)));
      },
      move: () => {
        instance.dispatchUIEvent(nextTarget, "pointermove", init2);
      }
    };
  }
  down(instance, button = 0) {
    if (this.isDown)
      return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isDown = true, this.isPrevented = !instance.dispatchUIEvent(target, "pointerdown", this.getEventInit(button));
  }
  up(instance, button = 0) {
    if (!this.isDown)
      return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isPrevented = false, this.isDown = false, instance.dispatchUIEvent(target, "pointerup", this.getEventInit(button));
  }
  release(instance) {
    let target = this.getTarget(instance), [leave] = getTreeDiff(target, null), init2 = this.getEventInit();
    hasPointerEvents(instance, target) && (instance.dispatchUIEvent(target, "pointerout", init2), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init2))), this.isCancelled = true;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  getEventInit(button) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: getMouseEventButton(button),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId, pointerType, isPrimary }, buttons) {
    _define_property7(this, "pointerId", void 0), _define_property7(this, "pointerType", void 0), _define_property7(this, "isPrimary", void 0), _define_property7(this, "buttons", void 0), _define_property7(this, "isMultitouch", false), _define_property7(this, "isCancelled", false), _define_property7(this, "isDown", false), _define_property7(this, "isPrevented", false), _define_property7(this, "position", {}), this.pointerId = pointerId, this.pointerType = pointerType, this.isPrimary = isPrimary, this.isMultitouch = !isPrimary, this.buttons = buttons;
  }
};
function _define_property8(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var PointerHost = class {
  isKeyPressed(keyDef) {
    return this.devices.get(keyDef.pointerType).isPressed(keyDef);
  }
  async press(instance, keyDef, position) {
    this.devices.get(keyDef.pointerType).addPressed(keyDef), this.buttons.down(keyDef);
    let pointerName = this.getPointerName(keyDef), pointer4 = keyDef.pointerType === "touch" ? this.pointers.new(pointerName, keyDef.pointerType, this.buttons) : this.pointers.get(pointerName);
    pointer4.position = position, pointer4.pointerType !== "touch" && (this.mouse.position = position), pointer4.pointerType === "touch" && pointer4.init(instance), pointer4.down(instance, keyDef.button), pointer4.pointerType !== "touch" && this.mouse.down(instance, keyDef, pointer4.isPrevented);
  }
  async move(instance, pointerName, position) {
    let pointer4 = this.pointers.get(pointerName), pointermove = pointer4.move(instance, position), mousemove = pointer4.pointerType === "touch" ? void 0 : this.mouse.move(instance, position, pointer4.isPrevented);
    pointermove?.leave(), mousemove?.leave(), pointermove?.enter(), mousemove?.enter(), pointermove?.move(), mousemove?.move();
  }
  async release(instance, keyDef, position) {
    let device = this.devices.get(keyDef.pointerType);
    device.removePressed(keyDef), this.buttons.up(keyDef);
    let pointer4 = this.pointers.get(this.getPointerName(keyDef)), isPrevented = pointer4.isPrevented;
    if (pointer4.position = position, pointer4.pointerType !== "touch" && (this.mouse.position = position), device.countPressed === 0 && pointer4.up(instance, keyDef.button), pointer4.pointerType === "touch" && pointer4.release(instance), pointer4.pointerType === "touch" && !pointer4.isMultitouch) {
      let mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove?.leave(), mousemove?.enter(), mousemove?.move(), this.mouse.down(instance, keyDef, isPrevented);
    }
    if (!pointer4.isMultitouch) {
      let mousemove = this.mouse.move(instance, position, isPrevented);
      mousemove?.leave(), mousemove?.enter(), mousemove?.move(), this.mouse.up(instance, keyDef, isPrevented);
    }
  }
  getPointerName(keyDef) {
    return keyDef.pointerType === "touch" ? keyDef.name : keyDef.pointerType;
  }
  getPreviousPosition(pointerName) {
    return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(instance) {
    var _this_mouse_position_target;
    return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== void 0 ? _this_mouse_position_target : instance.config.document.body;
  }
  setMousePosition(position) {
    this.mouse.position = position, this.pointers.get("mouse").position = position;
  }
  constructor(system) {
    _define_property8(this, "system", void 0), _define_property8(this, "mouse", void 0), _define_property8(this, "buttons", void 0), _define_property8(this, "devices", new class {
      get(k2) {
        var _this_registry, _k, _;
        return (_ = (_this_registry = this.registry)[_k = k2]) !== null && _ !== void 0 ? _ : _this_registry[_k] = new Device();
      }
      constructor() {
        _define_property8(this, "registry", {});
      }
    }()), _define_property8(this, "pointers", new class {
      new(pointerName, pointerType, buttons) {
        let isPrimary = pointerType !== "touch" || !Object.values(this.registry).some((p2) => p2.pointerType === "touch" && !p2.isCancelled);
        return isPrimary || Object.values(this.registry).forEach((p2) => {
          p2.pointerType === pointerType && !p2.isCancelled && (p2.isMultitouch = true);
        }), this.registry[pointerName] = new Pointer({
          pointerId: this.nextId++,
          pointerType,
          isPrimary
        }, buttons), this.registry[pointerName];
      }
      get(pointerName) {
        if (!this.has(pointerName))
          throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
        return this.registry[pointerName];
      }
      has(pointerName) {
        return pointerName in this.registry;
      }
      constructor() {
        _define_property8(this, "registry", {}), _define_property8(this, "nextId", 1);
      }
    }()), this.system = system, this.buttons = new Buttons(), this.mouse = new Mouse(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};
function _define_property9(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var System = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    _define_property9(this, "keyboard", new KeyboardHost(this)), _define_property9(this, "pointer", new PointerHost(this));
  }
};
async function click(element) {
  let pointerIn = [];
  return this.config.skipHover || pointerIn.push({
    target: element
  }), pointerIn.push({
    keys: "[MouseLeft]",
    target: element
  }), this.pointer(pointerIn);
}
async function dblClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
async function tripleClick(element) {
  return this.pointer([
    {
      target: element
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
async function hover(element) {
  return this.pointer({
    target: element
  });
}
async function unhover(element) {
  return assertPointerEvents(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: element.ownerDocument.body
  });
}
async function tab({ shift: shift2 } = {}) {
  return this.keyboard(shift2 === true ? "{Shift>}{Tab}{/Shift}" : shift2 === false ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
var bracketDict = function(bracketDict2) {
  return bracketDict2["{"] = "}", bracketDict2["["] = "]", bracketDict2;
}(bracketDict || {});
function readNextDescriptor(text, context) {
  let pos = 0, startBracket = text[pos] in bracketDict ? text[pos] : "";
  pos += startBracket.length;
  let type5 = new RegExp(`^\\${startBracket}{2}`).test(text) ? "" : startBracket;
  return {
    type: type5,
    ...type5 === "" ? readPrintableChar(text, pos, context) : readTag(text, pos, type5, context)
  };
}
function readPrintableChar(text, pos, context) {
  let descriptor = text[pos];
  return assertDescriptor(descriptor, text, pos, context), pos += descriptor.length, {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  let releasePreviousModifier = text[pos] === "/" ? "/" : "";
  pos += releasePreviousModifier.length;
  let escapedDescriptor = startBracket === "{" && text[pos] === "\\";
  pos += Number(escapedDescriptor);
  let descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context), pos += descriptor.length;
  var _text_slice_match_;
  let repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : "";
  pos += repeatModifier.length;
  let releaseSelfModifier = text[pos] === "/" || !repeatModifier && text[pos] === ">" ? text[pos] : "";
  pos += releaseSelfModifier.length;
  let expectedEndBracket = bracketDict[startBracket], endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : "";
  if (!endBracket)
    throw new Error(getErrorMessage([
      !repeatModifier && "repeat modifier",
      !releaseSelfModifier && "release modifier",
      `"${expectedEndBracket}"`
    ].filter(Boolean).join(" or "), text[pos], text, context));
  return pos += endBracket.length, {
    consumedLength: pos,
    descriptor,
    releasePrevious: !!releasePreviousModifier,
    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
  };
}
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor)
    throw new Error(getErrorMessage("key descriptor", text[pos], text, context));
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier)
    return releaseSelfModifier === "/";
  if (repeatModifier)
    return false;
}
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found ?? ""}" in "${text}"
    See ${context === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
function parseKeyDef(keyboardMap, text) {
  let defs = [];
  do {
    let { type: type5, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, "keyboard");
    var _keyboardMap_find;
    let keyDef = (_keyboardMap_find = keyboardMap.find((def) => {
      if (type5 === "[") {
        var _def_code;
        return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
      } else if (type5 === "{") {
        var _def_key;
        return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
      }
      return def.key === descriptor;
    })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : {
      key: "Unknown",
      code: "Unknown",
      [type5 === "[" ? "code" : "key"]: descriptor
    };
    defs.push({
      keyDef,
      releasePrevious,
      releaseSelf,
      repeat
    }), text = text.slice(consumedLength);
  } while (text);
  return defs;
}
async function keyboard(text) {
  let actions2 = parseKeyDef(this.config.keyboardMap, text);
  for (let i2 = 0; i2 < actions2.length; i2++)
    await wait(this.config), await keyboardAction(this, actions2[i2]);
}
async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
  let { system } = instance;
  if (system.keyboard.isKeyPressed(keyDef) && await system.keyboard.keyup(instance, keyDef), !releasePrevious) {
    for (let i2 = 1; i2 <= repeat; i2++)
      await system.keyboard.keydown(instance, keyDef), i2 < repeat && await wait(instance.config);
    releaseSelf && await system.keyboard.keyup(instance, keyDef);
  }
}
async function releaseAllKeys(instance) {
  for (let k2 of instance.system.keyboard.getPressedKeys())
    await instance.system.keyboard.keyup(instance, k2);
}
function copySelection(target) {
  let data = hasOwnSelection(target) ? {
    "text/plain": readSelectedValueFromInput(target)
  } : {
    "text/plain": String(target.ownerDocument.getSelection())
  }, dt = createDataTransfer(getWindow$3(target));
  for (let type5 in data)
    data[type5] && dt.setData(type5, data[type5]);
  return dt;
}
function readSelectedValueFromInput(target) {
  let sel = getUISelection(target);
  return getUIValue(target).substring(sel.startOffset, sel.endOffset);
}
async function copy() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  ), clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0)
    return this.dispatchUIEvent(target, "copy", {
      clipboardData
    }) && this.config.writeToClipboard && await writeDataTransferToClipboard(doc, clipboardData), clipboardData;
}
async function cut() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  ), clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0)
    return this.dispatchUIEvent(target, "cut", {
      clipboardData
    }) && this.config.writeToClipboard && await writeDataTransferToClipboard(target.ownerDocument, clipboardData), clipboardData;
}
async function paste(clipboardData) {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : (
    /* istanbul ignore next */
    doc.body
  );
  var _ref;
  let dataTransfer = (_ref = typeof clipboardData == "string" ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && _ref !== void 0 ? _ref : await readDataTransferFromClipboard(doc).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(target, "paste", {
    clipboardData: dataTransfer
  });
}
function getClipboardDataFromString(doc, text) {
  let dt = createDataTransfer(getWindow$3(doc));
  return dt.setData("text", text), dt;
}
function parseKeyDef2(pointerMap, keys2) {
  let defs = [];
  do {
    let { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys2, "pointer"), keyDef = pointerMap.find((p2) => p2.name === descriptor);
    keyDef && defs.push({
      keyDef,
      releasePrevious,
      releaseSelf
    }), keys2 = keys2.slice(consumedLength);
  } while (keys2);
  return defs;
}
async function pointer(input2) {
  let { pointerMap } = this.config, actions2 = [];
  (Array.isArray(input2) ? input2 : [
    input2
  ]).forEach((actionInput) => {
    typeof actionInput == "string" ? actions2.push(...parseKeyDef2(pointerMap, actionInput)) : "keys" in actionInput ? actions2.push(...parseKeyDef2(pointerMap, actionInput.keys).map((i2) => ({
      ...actionInput,
      ...i2
    }))) : actions2.push(actionInput);
  });
  for (let i2 = 0; i2 < actions2.length; i2++)
    await wait(this.config), await pointerAction(this, actions2[i2]);
  this.system.pointer.resetClickCount();
}
async function pointerAction(instance, action2) {
  var _previousPosition_caret, _previousPosition_caret1;
  let pointerName = "pointerName" in action2 && action2.pointerName ? action2.pointerName : "keyDef" in action2 ? instance.system.pointer.getPointerName(action2.keyDef) : "mouse", previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
  var _action_target, _action_coords, _action_node, _action_offset;
  let position = {
    target: (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : getPrevTarget(instance, previousPosition),
    coords: (_action_coords = action2.coords) !== null && _action_coords !== void 0 ? _action_coords : previousPosition?.coords,
    caret: {
      node: (_action_node = action2.node) !== null && _action_node !== void 0 ? _action_node : hasCaretPosition(action2) || previousPosition == null || (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === void 0 ? void 0 : _previousPosition_caret.node,
      offset: (_action_offset = action2.offset) !== null && _action_offset !== void 0 ? _action_offset : hasCaretPosition(action2) || previousPosition == null || (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === void 0 ? void 0 : _previousPosition_caret1.offset
    }
  };
  "keyDef" in action2 ? (instance.system.pointer.isKeyPressed(action2.keyDef) && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action2.keyDef, position)), action2.releasePrevious || (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.press(instance, action2.keyDef, position), action2.releaseSelf && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action2.keyDef, position)))) : (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.move(instance, pointerName, position));
}
function hasCaretPosition(action2) {
  var _action_target, _ref;
  return !!((_ref = (_action_target = action2.target) !== null && _action_target !== void 0 ? _action_target : action2.node) !== null && _ref !== void 0 ? _ref : action2.offset !== void 0);
}
function getPrevTarget(instance, position) {
  if (!position)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var _position_target;
  return (_position_target = position.target) !== null && _position_target !== void 0 ? _position_target : instance.config.document.body;
}
async function clear(element) {
  if (!isEditable(element) || isDisabled2(element))
    throw new Error("clear()` is only supported on editable elements.");
  if (focusElement(element), element.ownerDocument.activeElement !== element)
    throw new Error("The element to be cleared could not be focused.");
  if (selectAll(element), !isAllSelected(element))
    throw new Error("The element content to be cleared could not be selected.");
  input(this, element, "", "deleteContentBackward");
}
async function selectOptions(select, values) {
  return selectOptionsBase.call(this, true, select, values);
}
async function deselectOptions(select, values) {
  return selectOptionsBase.call(this, false, select, values);
}
async function selectOptionsBase(newValue, select, values) {
  if (!newValue && !select.multiple)
    throw getConfig2().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", select);
  let valArray = Array.isArray(values) ? values : [
    values
  ], allOptions = Array.from(select.querySelectorAll('option, [role="option"]')), selectedOptions = valArray.map((val) => {
    if (typeof val != "string" && allOptions.includes(val))
      return val;
    {
      let matchingOption = allOptions.find((o2) => o2.value === val || o2.innerHTML === val);
      if (matchingOption)
        return matchingOption;
      throw getConfig2().getElementError(`Value "${String(val)}" not found in options`, select);
    }
  }).filter((option) => !isDisabled2(option));
  if (isDisabled2(select) || !selectedOptions.length) return;
  let selectOption = (option) => {
    option.selected = newValue, this.dispatchUIEvent(select, "input", {
      bubbles: true,
      cancelable: false,
      composed: true
    }), this.dispatchUIEvent(select, "change");
  };
  if (isElementType(select, "select"))
    if (select.multiple)
      for (let option of selectedOptions) {
        let withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
        withPointerEvents && (this.dispatchUIEvent(option, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(option, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(option, "pointermove"), this.dispatchUIEvent(option, "mousemove"), this.dispatchUIEvent(option, "pointerdown"), this.dispatchUIEvent(option, "mousedown")), focusElement(select), withPointerEvents && (this.dispatchUIEvent(option, "pointerup"), this.dispatchUIEvent(option, "mouseup")), selectOption(option), withPointerEvents && this.dispatchUIEvent(option, "click"), await wait(this.config);
      }
    else if (selectedOptions.length === 1) {
      let withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
      withPointerEvents ? await this.click(select) : focusElement(select), selectOption(selectedOptions[0]), withPointerEvents && (this.dispatchUIEvent(select, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(select, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(select, "pointerup"), this.dispatchUIEvent(select, "mouseup"), this.dispatchUIEvent(select, "click")), await wait(this.config);
    } else
      throw getConfig2().getElementError("Cannot select multiple options on a non-multiple select", select);
  else if (select.getAttribute("role") === "listbox")
    for (let option of selectedOptions)
      await this.click(option), await this.unhover(option);
  else
    throw getConfig2().getElementError("Cannot select options on elements that are neither select nor listbox elements", select);
}
async function type3(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
  element.disabled || (skipClick || await this.click(element), initialSelectionStart !== void 0 && setSelectionRange(element, initialSelectionStart, initialSelectionEnd ?? initialSelectionStart), await this.keyboard(text), skipAutoClose || await releaseAllKeys(this));
}
var fakeFiles = Symbol("files and value properties are mocked");
function restoreProperty(obj, prop, descriptor) {
  descriptor ? Object.defineProperty(obj, prop, descriptor) : delete obj[prop];
}
function setFiles(el, files) {
  var _el_fakeFiles;
  (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === void 0 || _el_fakeFiles.restore();
  let typeDescr = Object.getOwnPropertyDescriptor(el, "type"), valueDescr = Object.getOwnPropertyDescriptor(el, "value"), filesDescr = Object.getOwnPropertyDescriptor(el, "files");
  function restore() {
    restoreProperty(el, "type", typeDescr), restoreProperty(el, "value", valueDescr), restoreProperty(el, "files", filesDescr);
  }
  el[fakeFiles] = {
    restore
  }, Object.defineProperties(el, {
    files: {
      configurable: true,
      get: () => files
    },
    value: {
      configurable: true,
      get: () => files.length ? `C:\\fakepath\\${files[0].name}` : "",
      set(v2) {
        if (v2 === "")
          restore();
        else {
          var _valueDescr_set;
          valueDescr == null || (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === void 0 || _valueDescr_set.call(el, v2);
        }
      }
    },
    type: {
      configurable: true,
      get: () => "file",
      set(v2) {
        v2 !== "file" && (restore(), el.type = v2);
      }
    }
  });
}
async function upload(element, fileOrFiles) {
  let input2 = isElementType(element, "label") ? element.control : element;
  if (!input2 || !isElementType(input2, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${input2 === element ? "given" : "associated"} ${input2?.tagName} element does not accept file uploads`);
  if (isDisabled2(element)) return;
  let files = (Array.isArray(fileOrFiles) ? fileOrFiles : [
    fileOrFiles
  ]).filter((file) => !this.config.applyAccept || isAcceptableFile(file, input2.accept)).slice(0, input2.multiple ? void 0 : 1), fileDialog = () => {
    var _input_files;
    files.length === ((_input_files = input2.files) === null || _input_files === void 0 ? void 0 : _input_files.length) && files.every((f4, i2) => {
      var _input_files2;
      return f4 === ((_input_files2 = input2.files) === null || _input_files2 === void 0 ? void 0 : _input_files2.item(i2));
    }) || (setFiles(input2, createFileList(getWindow$3(element), files)), this.dispatchUIEvent(input2, "input"), this.dispatchUIEvent(input2, "change"));
  };
  input2.addEventListener("fileDialog", fileDialog), await this.click(element), input2.removeEventListener("fileDialog", fileDialog);
}
function normalize3(nameOrType) {
  return nameOrType.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
function isAcceptableFile(file, accept) {
  if (!accept)
    return true;
  let wildcards = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return normalize3(accept).trim().split(/\s*,\s*/).some((acceptToken) => acceptToken.startsWith(".") ? normalize3(file.name).endsWith(acceptToken) : wildcards.includes(acceptToken) ? normalize3(file.type).startsWith(acceptToken.replace("*", "")) : normalize3(file.type) === acceptToken);
}
var userEventApi = {
  click,
  dblClick,
  tripleClick,
  hover,
  unhover,
  tab,
  keyboard,
  copy,
  cut,
  paste,
  pointer,
  clear,
  deselectOptions,
  selectOptions,
  type: type3,
  upload
};
function wrapAsync(implementation) {
  return getConfig2().asyncWrapper(implementation);
}
var defaultOptionsDirect = {
  applyAccept: true,
  autoModify: true,
  delay: 0,
  document: globalThis.document,
  keyboardMap: defaultKeyMap,
  pointerMap: defaultKeyMap2,
  pointerEventsCheck: PointerEventsCheckLevel.EachApiCall,
  skipAutoClose: false,
  skipClick: false,
  skipHover: false,
  writeToClipboard: false,
  advanceTimers: () => Promise.resolve()
}, defaultOptionsSetup = {
  ...defaultOptionsDirect,
  writeToClipboard: true
};
function createConfig(options = {}, defaults = defaultOptionsSetup, node) {
  let document7 = getDocument2(options, node, defaults);
  return {
    ...defaults,
    ...options,
    document: document7
  };
}
function setupMain(options = {}) {
  let config4 = createConfig(options);
  prepareDocument(config4.document), patchFocus(getWindow$3(config4.document).HTMLElement);
  var _config_document_defaultView;
  let view = (_config_document_defaultView = config4.document.defaultView) !== null && _config_document_defaultView !== void 0 ? _config_document_defaultView : (
    /* istanbul ignore next */
    globalThis.window
  );
  return attachClipboardStubToView(view), createInstance(config4).api;
}
function setupDirect({ keyboardState, pointerState, ...options } = {}, node) {
  let config4 = createConfig(options, defaultOptionsDirect, node);
  prepareDocument(config4.document), patchFocus(getWindow$3(config4.document).HTMLElement);
  var _ref;
  let system = (_ref = pointerState ?? keyboardState) !== null && _ref !== void 0 ? _ref : new System();
  return {
    api: createInstance(config4, system).api,
    system
  };
}
function setupSub(options) {
  return createInstance({
    ...this.config,
    ...options
  }, this.system).api;
}
function wrapAndBindImpl(instance, impl) {
  function method(...args) {
    return setLevelRef(instance, ApiLevel.Call), wrapAsync(() => impl.apply(instance, args).then(async (ret) => (await wait(instance.config), ret)));
  }
  return Object.defineProperty(method, "name", {
    get: () => impl.name
  }), method;
}
function createInstance(config4, system = new System()) {
  let instance = {};
  return Object.assign(instance, {
    config: config4,
    dispatchEvent: dispatchEvent.bind(instance),
    dispatchUIEvent: dispatchUIEvent.bind(instance),
    system,
    levelRefs: {},
    ...userEventApi
  }), {
    instance,
    api: {
      ...Object.fromEntries(Object.entries(userEventApi).map(([name, api]) => [
        name,
        wrapAndBindImpl(instance, api)
      ])),
      setup: setupSub.bind(instance)
    }
  };
}
function getDocument2(options, node, defaults) {
  var _options_document, _ref;
  return (_ref = (_options_document = options.document) !== null && _options_document !== void 0 ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== void 0 ? _ref : defaults.document;
}
var directApi_exports = {};
__export$4(directApi_exports, {
  clear: () => clear2,
  click: () => click2,
  copy: () => copy2,
  cut: () => cut2,
  dblClick: () => dblClick2,
  deselectOptions: () => deselectOptions2,
  hover: () => hover2,
  keyboard: () => keyboard2,
  paste: () => paste2,
  pointer: () => pointer2,
  selectOptions: () => selectOptions2,
  tab: () => tab2,
  tripleClick: () => tripleClick2,
  type: () => type4,
  unhover: () => unhover2,
  upload: () => upload2
});
function clear2(element) {
  return setupDirect().api.clear(element);
}
function click2(element, options = {}) {
  return setupDirect(options, element).api.click(element);
}
function copy2(options = {}) {
  return setupDirect(options).api.copy();
}
function cut2(options = {}) {
  return setupDirect(options).api.cut();
}
function dblClick2(element, options = {}) {
  return setupDirect(options).api.dblClick(element);
}
function deselectOptions2(select, values, options = {}) {
  return setupDirect(options).api.deselectOptions(select, values);
}
function hover2(element, options = {}) {
  return setupDirect(options).api.hover(element);
}
async function keyboard2(text, options = {}) {
  let { api, system } = setupDirect(options);
  return api.keyboard(text).then(() => system);
}
async function pointer2(input2, options = {}) {
  let { api, system } = setupDirect(options);
  return api.pointer(input2).then(() => system);
}
function paste2(clipboardData, options) {
  return setupDirect(options).api.paste(clipboardData);
}
function selectOptions2(select, values, options = {}) {
  return setupDirect(options).api.selectOptions(select, values);
}
function tripleClick2(element, options = {}) {
  return setupDirect(options).api.tripleClick(element);
}
function type4(element, text, options = {}) {
  return setupDirect(options, element).api.type(element, text, options);
}
function unhover2(element, options = {}) {
  let { api, system } = setupDirect(options);
  return system.pointer.setMousePosition({
    target: element
  }), api.unhover(element);
}
function upload2(element, fileOrFiles, options = {}) {
  return setupDirect(options).api.upload(element, fileOrFiles);
}
function tab2(options = {}) {
  return setupDirect().api.tab(options);
}
var userEvent = {
  ...directApi_exports,
  setup: setupMain
};
var testingLibrary = instrument(
  { ...dom_esm_exports },
  {
    getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"),
    intercept: (method, path) => path[0] === "fireEvent" || method.startsWith("find") || method.startsWith("waitFor")
  }
);
testingLibrary.screen = new Proxy(testingLibrary.screen, {
  get(target, prop, receiver) {
    return typeof window < "u" && globalThis.location?.href?.includes("viewMode=docs") && once.warn(dedent$1`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `), Reflect.get(target, prop, receiver);
  }
});
var {
  buildQueries: buildQueries2,
  configure: configure2,
  createEvent: createEvent3,
  fireEvent: fireEvent2,
  findAllByAltText: findAllByAltText2,
  findAllByDisplayValue: findAllByDisplayValue2,
  findAllByLabelText: findAllByLabelText2,
  findAllByPlaceholderText: findAllByPlaceholderText2,
  findAllByRole: findAllByRole2,
  findAllByTestId: findAllByTestId2,
  findAllByText: findAllByText2,
  findAllByTitle: findAllByTitle2,
  findByAltText: findByAltText2,
  findByDisplayValue: findByDisplayValue2,
  findByLabelText: findByLabelText2,
  findByPlaceholderText: findByPlaceholderText2,
  findByRole: findByRole2,
  findByTestId: findByTestId2,
  findByText: findByText2,
  findByTitle: findByTitle2,
  getAllByAltText: getAllByAltText2,
  getAllByDisplayValue: getAllByDisplayValue2,
  getAllByLabelText: getAllByLabelText2,
  getAllByPlaceholderText: getAllByPlaceholderText2,
  getAllByRole: getAllByRole2,
  getAllByTestId: getAllByTestId2,
  getAllByText: getAllByText2,
  getAllByTitle: getAllByTitle2,
  getByAltText: getByAltText2,
  getByDisplayValue: getByDisplayValue2,
  getByLabelText: getByLabelText2,
  getByPlaceholderText: getByPlaceholderText2,
  getByRole: getByRole2,
  getByTestId: getByTestId2,
  getByText: getByText2,
  getByTitle: getByTitle2,
  getConfig: getConfig3,
  getDefaultNormalizer: getDefaultNormalizer2,
  getElementError: getElementError2,
  getNodeText: getNodeText2,
  getQueriesForElement: getQueriesForElement2,
  getRoles: getRoles2,
  getSuggestedQuery: getSuggestedQuery2,
  isInaccessible: isInaccessible2,
  logDOM: logDOM2,
  logRoles: logRoles2,
  prettyDOM: prettyDOM2,
  queries: queries2,
  queryAllByAltText: queryAllByAltText2,
  queryAllByAttribute: queryAllByAttribute2,
  queryAllByDisplayValue: queryAllByDisplayValue2,
  queryAllByLabelText: queryAllByLabelText2,
  queryAllByPlaceholderText: queryAllByPlaceholderText2,
  queryAllByRole: queryAllByRole2,
  queryAllByTestId: queryAllByTestId2,
  queryAllByText: queryAllByText2,
  queryAllByTitle: queryAllByTitle2,
  queryByAltText: queryByAltText2,
  queryByAttribute: queryByAttribute2,
  queryByDisplayValue: queryByDisplayValue2,
  queryByLabelText: queryByLabelText2,
  queryByPlaceholderText: queryByPlaceholderText2,
  queryByRole: queryByRole2,
  queryByTestId: queryByTestId2,
  queryByText: queryByText2,
  queryByTitle: queryByTitle2,
  queryHelpers: queryHelpers2,
  screen: screen2,
  waitFor: waitFor2,
  waitForElementToBeRemoved: waitForElementToBeRemoved2,
  within,
  prettyFormat: prettyFormat2
} = testingLibrary, uninstrumentedUserEvent = userEvent, { userEvent: userEvent2 } = instrument(
  { userEvent },
  { intercept: true, getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper") }
);
var { expect: expect3 } = instrument(
  { expect: expect2 },
  {
    getKeys: (obj, depth) => {
      if ("constructor" in obj && obj.constructor === Assertion) {
        let privateApi = ["assert", "__methods", "__flags", "_obj"], keys2 = Object.keys(Object.getPrototypeOf(obj)).filter(
          (it) => !privateApi.includes(it)
        );
        return depth > 2 ? keys2 : [...keys2, "not"];
      }
      return "any" in obj ? Object.keys(obj).filter((it) => it !== "any") : Object.keys(obj);
    },
    mutate: true,
    intercept: (method) => method !== "expect"
  }
), sb = {
  mock: () => {
  }
};
var subscribed = false, logActionsWhenMockCalled = (context) => {
  let { parameters: parameters2 } = context;
  parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
    let name = mock.getMockName();
    name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((prefix2) => name.startsWith(prefix2))) && action(name)(args);
  }), subscribed = true);
}, loaders = [logActionsWhenMockCalled];
var preview_default = () => ({
  ...addArgs_exports,
  ...loaders_exports
});
var PARAM_KEY2 = "backgrounds";
var DEFAULT_BACKGROUNDS = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};
var { document: document3 } = globalThis, isReduceMotionEnabled = () => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : false, clearStyles = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
}, clearStyle = (selector) => {
  if (!document3)
    return;
  let element = document3.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
}, addGridStyle = (selector, css2) => {
  if (!document3)
    return;
  let existingStyle = document3.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
  else {
    let style = document3.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css2, document3.head.appendChild(style);
  }
}, addBackgroundStyle = (selector, css2, storyId) => {
  if (!document3)
    return;
  let existingStyle = document3.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
  else {
    let style = document3.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css2;
    let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document3.getElementById(gridStyleSelector);
    existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document3.head.appendChild(style);
  }
};
var defaultGrid = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, BG_SELECTOR_BASE = "addon-backgrounds", GRID_SELECTOR_BASE = "addon-backgrounds-grid", transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;", withBackgroundAndGrid = (StoryFn, context) => {
  let { globals = {}, parameters: parameters2 = {}, viewMode, id } = context, {
    options = DEFAULT_BACKGROUNDS,
    disable,
    grid = defaultGrid
  } = parameters2[PARAM_KEY2] || {}, data = globals[PARAM_KEY2] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? false : data.grid || false, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id : null;
  useEffect$1(() => {
    let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value} !important;
      ${transitionStyle}
      }`;
    if (!shownBackground) {
      clearStyles(backgroundSelectorId);
      return;
    }
    addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
  }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value]);
  let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id}` : `${GRID_SELECTOR_BASE}`;
  return useEffect$1(() => {
    if (!showGrid) {
      clearStyles(gridSelectorId);
      return;
    }
    let gridSize = [
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
      `${cellSize}px ${cellSize}px`,
      `${cellSize}px ${cellSize}px`
    ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
    addGridStyle(gridSelectorId, gridStyles);
  }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
};
var decorators$3 = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters$4 = {
  [PARAM_KEY2]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
}, initialGlobals = {
  [PARAM_KEY2]: { value: void 0, grid: false }
}, preview_default2 = () => ({
  decorators: decorators$3,
  parameters: parameters$4,
  initialGlobals
});
var { step } = instrument(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: async (label, play, context) => play(context)
  },
  { intercept: true }
), preview_default3 = () => ({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: step
});
var ADDON_ID3 = "storybook/highlight", HIGHLIGHT = `${ADDON_ID3}/add`, REMOVE_HIGHLIGHT = `${ADDON_ID3}/remove`, RESET_HIGHLIGHT = `${ADDON_ID3}/reset`, SCROLL_INTO_VIEW = `${ADDON_ID3}/scroll-into-view`, MAX_Z_INDEX = 2147483647, MIN_TOUCH_AREA_SIZE = 28;
var iconPaths = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), createElement$1 = (type5, props = {}, children) => {
  let element = svgElements.includes(type5) ? document.createElementNS("http://www.w3.org/2000/svg", type5) : document.createElement(type5);
  return Object.entries(props).forEach(([key, val]) => {
    /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e2) => {
      (e2.key === "Enter" || e2.key === " ") && (e2.preventDefault(), val());
    })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
  }), children?.forEach((child) => {
    if (!(child == null || child === false))
      try {
        element.appendChild(child);
      } catch {
        element.appendChild(document.createTextNode(String(child)));
      }
  }), element;
}, createIcon = (name) => iconPaths[name] && createElement$1(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  iconPaths[name].map(
    (d) => createElement$1("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d
    })
  )
), normalizeOptions = (options) => {
  if ("elements" in options) {
    let { elements: elements2, color, style } = options;
    return {
      id: void 0,
      priority: 0,
      selectors: elements2,
      styles: {
        outline: `2px ${style} ${color}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu, ...rest } = options;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...rest,
    menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
  };
}, isFunction2 = (obj) => obj instanceof Function, state = /* @__PURE__ */ new Map(), listeners2 = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = (initialValue2) => {
  let key = Symbol();
  return listeners2.set(key, []), state.set(key, initialValue2), { get: () => state.get(key), set: (update) => {
    let current = state.get(key), next = isFunction2(update) ? update(current) : update;
    next !== current && (state.set(key, next), listeners2.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
    }));
  }, subscribe: (listener) => (listeners2.get(key)?.push(listener), () => {
    let list = listeners2.get(key);
    list && listeners2.set(
      key,
      list.filter((l2) => l2 !== listener)
    );
  }), teardown: () => {
    listeners2.get(key)?.forEach((listener) => {
      teardowns.get(listener)?.(), teardowns.delete(listener);
    }), listeners2.delete(key), state.delete(key);
  } };
}, mapElements = (highlights) => {
  let root2 = document.getElementById("storybook-root"), map2 = /* @__PURE__ */ new Map();
  for (let highlight of highlights) {
    let { priority = 0 } = highlight;
    for (let selector of highlight.selectors) {
      let elements2 = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...root2?.querySelectorAll(selector) || []
      ];
      for (let element of elements2) {
        let existing = map2.get(element);
        (!existing || existing.priority <= priority) && map2.set(element, {
          ...highlight,
          priority,
          selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
        });
      }
    }
  }
  return map2;
}, mapBoxes = (elements2) => Array.from(elements2.entries()).map(([element, { selectors, styles: styles3, hoverStyles, focusStyles, menu }]) => {
  let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
  return {
    element,
    selectors,
    styles: styles3,
    hoverStyles,
    focusStyles,
    menu,
    top: position === "fixed" ? top : top + window.scrollY,
    left: position === "fixed" ? left : left + window.scrollX,
    width,
    height
  };
}).sort((a2, b2) => b2.width * b2.height - a2.width * a2.height), isOverMenu = (menuElement, coordinates) => {
  let menu = menuElement.getBoundingClientRect(), { x: x2, y: y2 } = coordinates;
  return menu?.top && menu?.left && x2 >= menu.left && x2 <= menu.left + menu.width && y2 >= menu.top && y2 <= menu.top + menu.height;
}, isTargeted = (box, boxElement, coordinates) => {
  if (!boxElement || !coordinates)
    return false;
  let { left, top, width, height } = box;
  height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left += window.scrollX, top += window.scrollY);
  let { x: x2, y: y2 } = coordinates;
  return x2 >= left && x2 <= left + width && y2 >= top && y2 <= top + height;
}, keepInViewport = (element, targetCoordinates, options = {}) => {
  let { x: x2, y: y2 } = targetCoordinates, { margin = 5, topOffset = 0, centered = false } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(
    element.style.position === "fixed" ? y2 - scrollY : y2,
    windowHeight - element.clientHeight - margin - topOffset + scrollY
  ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === "fixed" ? Math.max(Math.min(x2 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
    Math.min(x2, windowWidth - leftOffset - margin + scrollX),
    leftOffset + margin + scrollX
  );
  Object.assign(element.style, {
    ...left !== x2 && { left: `${left}px` },
    ...top !== y2 && { top: `${top}px` }
  });
}, showPopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
}, hidePopover = (element) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
}, getEventDetails = (target) => ({
  top: target.top,
  left: target.left,
  width: target.width,
  height: target.height,
  selectors: target.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(target.element.attributes).map((attr2) => [attr2.name, attr2.value])
    ),
    localName: target.element.localName,
    tagName: target.element.tagName,
    outerHTML: target.element.outerHTML
  }
});
var menuId = "storybook-highlights-menu", rootId = "storybook-highlights-root", storybookRootId = "storybook-root", useHighlights = (channel2) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  let { document: document7 } = globalThis, highlights = useStore([]), elements2 = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root2 = document7.getElementById(rootId);
  highlights.subscribe(() => {
    root2 || (root2 = createElement$1("div", { id: rootId }), document7.body.appendChild(root2));
  }), highlights.subscribe((value) => {
    let storybookRoot = document7.getElementById(storybookRootId);
    if (!storybookRoot)
      return;
    elements2.set(mapElements(value));
    let observer = new MutationObserver(() => elements2.set(mapElements(value)));
    return observer.observe(storybookRoot, { subtree: true, childList: true }), () => {
      observer.disconnect();
    };
  }), elements2.subscribe((value) => {
    let updateBoxes = () => requestAnimationFrame(() => boxes.set(mapBoxes(value))), observer = new ResizeObserver(updateBoxes);
    observer.observe(document7.body), Array.from(value.keys()).forEach((element) => observer.observe(element));
    let scrollers = Array.from(document7.body.querySelectorAll("*")).filter((el) => {
      let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
      return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
    });
    return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
      observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
    };
  }), elements2.subscribe((value) => {
    let sticky = Array.from(value.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = () => requestAnimationFrame(() => {
      boxes.set(
        (current) => current.map((box) => {
          if (sticky.includes(box.element)) {
            let { top, left } = box.element.getBoundingClientRect();
            return { ...box, top: top + window.scrollY, left: left + window.scrollX };
          }
          return box;
        })
      );
    });
    return document7.addEventListener("scroll", updateBoxes), () => document7.removeEventListener("scroll", updateBoxes);
  }), elements2.subscribe((value) => {
    targets.set((t22) => t22.filter(({ element }) => value.has(element)));
  }), targets.subscribe((value) => {
    value.length ? (selected.set((s3) => value.some((t22) => t22.element === s3?.element) ? s3 : void 0), focused.set((s3) => value.some((t22) => t22.element === s3?.element) ? s3 : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
  });
  let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
  highlights.subscribe((value) => {
    value.forEach(({ keyframes }) => {
      if (keyframes) {
        let style = styleElementByHighlight.get(keyframes);
        style || (style = document7.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes, style), document7.head.appendChild(style)), style.innerHTML = keyframes;
      }
    }), styleElementByHighlight.forEach((style, keyframes) => {
      value.some((v2) => v2.keyframes === keyframes) || (style.remove(), styleElementByHighlight.delete(keyframes));
    });
  });
  let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
  boxes.subscribe((value) => {
    value.forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (root2 && !boxElement) {
        let props = {
          popover: "manual",
          "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
        };
        boxElement = root2.appendChild(
          createElement$1("div", props, [createElement$1("div")])
        ), boxElementByTargetElement.set(box.element, boxElement);
      }
    }), boxElementByTargetElement.forEach((box, element) => {
      value.some(({ element: e2 }) => e2 === element) || (box.remove(), boxElementByTargetElement.delete(element));
    });
  }), boxes.subscribe((value) => {
    let targetable = value.filter((box) => box.menu);
    if (!targetable.length)
      return;
    let onClick = (event) => {
      requestAnimationFrame(() => {
        let menu = document7.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
        if (menu && !isOverMenu(menu, coords)) {
          let results = targetable.filter((box) => {
            let boxElement = boxElementByTargetElement.get(box.element);
            return isTargeted(box, boxElement, coords);
          });
          clickCoords.set(results.length ? coords : void 0), targets.set(results);
        }
      });
    };
    return document7.addEventListener("click", onClick), () => document7.removeEventListener("click", onClick);
  });
  let updateHovered = () => {
    let menu = document7.getElementById(menuId), coords = hoverCoords.get();
    !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
      let update = boxes.get().filter((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        return isTargeted(box, boxElement, coords);
      }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
      return additions.length || hasRemovals ? [...existing, ...additions] : current;
    });
  };
  hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
  let updateBoxStyles = () => {
    let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
    boxes.get().forEach((box) => {
      let boxElement = boxElementByTargetElement.get(box.element);
      if (boxElement) {
        let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
        Object.assign(boxElement.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...box.styles,
          ...isHovered ? box.hoverStyles : {},
          ...isFocused ? box.focusStyles : {},
          position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: MAX_Z_INDEX - 10,
          top: `${box.top}px`,
          left: `${box.left}px`,
          width: `${box.width}px`,
          height: `${box.height}px`,
          margin: 0,
          padding: 0,
          cursor: box.menu && isHovered ? "pointer" : "default",
          pointerEvents: box.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(boxElement.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
          minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
          boxSizing: "content-box",
          padding: boxElement.style.outlineWidth || "0px"
        }), showPopover(boxElement);
      }
    });
  };
  boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
  let renderMenu = () => {
    if (!root2)
      return;
    let menu = document7.getElementById(menuId);
    if (menu)
      menu.innerHTML = "";
    else {
      let props = { id: menuId, popover: "manual" };
      menu = root2.appendChild(createElement$1("div", props)), root2.appendChild(
        createElement$1("style", {}, [
          `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
    if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
      createElement$1(
        "ul",
        { class: "element-list" },
        elementList.map((target) => {
          let selectable = elementList.length > 1 && !!target.menu?.some(
            (group) => group.some(
              (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
            )
          ), props = selectable ? {
            class: "selectable",
            onClick: () => selected.set(target),
            onMouseEnter: () => focused.set(target),
            onMouseLeave: () => focused.set(void 0)
          } : selectedElement ? { class: "selected", onClick: () => selected.set(void 0) } : {}, asButton = selectable || selectedElement;
          return createElement$1("li", props, [
            createElement$1(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
              selectedElement ? createIcon("chevronLeft") : null,
              createElement$1("code", {}, [target.element.outerHTML]),
              selectable ? createIcon("chevronRight") : null
            ])
          ]);
        })
      )
    )), selected.get() || targets.get().length === 1) {
      let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
        (group) => group.some(
          (item) => !item.selectors || item.selectors.some((s3) => target.selectors.includes(s3))
        )
      );
      menuGroups?.length && menu.appendChild(
        createElement$1(
          "ul",
          { class: "menu-list" },
          menuGroups.map(
            (menuItems) => createElement$1("li", {}, [
              createElement$1(
                "ul",
                { class: "menu-items" },
                menuItems.map(
                  ({ id, title, description, iconLeft, iconRight, clickEvent: event }) => {
                    let onClick = event && (() => channel2.emit(event, id, getEventDetails(target)));
                    return createElement$1("li", {}, [
                      createElement$1(
                        onClick ? "button" : "div",
                        onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                        [
                          iconLeft ? createIcon(iconLeft) : null,
                          createElement$1("div", { class: "menu-item-content" }, [
                            createElement$1(description ? "strong" : "span", {}, [title]),
                            description && createElement$1("span", {}, [description])
                          ]),
                          iconRight ? createIcon(iconRight) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let coords = clickCoords.get();
    coords ? (Object.assign(menu.style, {
      display: "block",
      left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
      top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
    }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: true }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
  };
  targets.subscribe(renderMenu), selected.subscribe(renderMenu);
  let addHighlight = (highlight) => {
    let info = normalizeOptions(highlight);
    highlights.set((value) => {
      let others = info.id ? value.filter((h3) => h3.id !== info.id) : value;
      return info.selectors?.length ? [...others, info] : others;
    });
  }, removeHighlight = (id) => {
    id && highlights.set((value) => value.filter((h3) => h3.id !== id));
  }, resetState = () => {
    highlights.set([]), elements2.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
  }, removeTimeout, scrollIntoView = (target, options) => {
    let id = "scrollIntoView-highlight";
    clearTimeout(removeTimeout), removeHighlight(id);
    let element = document7.querySelector(target);
    if (!element) {
      console.warn(`Cannot scroll into view: ${target} not found`);
      return;
    }
    element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
    let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
    highlights.set((value) => [
      ...value,
      {
        id,
        priority: 1e3,
        selectors: [target],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${keyframeName} 3s linear forwards`
        },
        keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), removeTimeout = setTimeout(() => removeHighlight(id), 3500);
  }, onMouseMove = (event) => {
    requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
  };
  document7.body.addEventListener("mousemove", onMouseMove), channel2.on(HIGHLIGHT, addHighlight), channel2.on(REMOVE_HIGHLIGHT, removeHighlight), channel2.on(RESET_HIGHLIGHT, resetState), channel2.on(SCROLL_INTO_VIEW, scrollIntoView), channel2.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
    newPhase === "loading" && resetState();
  });
};
globalThis?.FEATURES?.highlight && addons$2?.ready && addons$2.ready().then(useHighlights);
var preview_default4 = () => ({});
var PARAM_KEY3 = "measureEnabled";
function getDocumentWidthAndHeight() {
  let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
  return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
}
function createCanvas() {
  let canvas = scope.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  let context = canvas.getContext("2d");
  invariant(context != null);
  let { width, height } = getDocumentWidthAndHeight();
  return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
}
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
  let scale = scope.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
}
var state2 = {};
function init() {
  state2.canvas || (state2 = createCanvas());
}
function clear3() {
  state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
}
function draw(callback) {
  clear3(), callback(state2.context);
}
function rescale() {
  invariant(state2.canvas), invariant(state2.context), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
  let { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
}
function destroy() {
  state2.canvas && (clear3(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
}
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, labelPadding = 6;
function roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: r2 }) {
  x2 = x2 - w2 / 2, y2 = y2 - h3 / 2, w2 < 2 * r2 && (r2 = w2 / 2), h3 < 2 * r2 && (r2 = h3 / 2), context.beginPath(), context.moveTo(x2 + r2, y2), context.arcTo(x2 + w2, y2, x2 + w2, y2 + h3, r2), context.arcTo(x2 + w2, y2 + h3, x2, y2 + h3, r2), context.arcTo(x2, y2 + h3, x2, y2, r2), context.arcTo(x2, y2, x2 + w2, y2, r2), context.closePath();
}
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x2 = left + border.left + padding.left, y2 = top + border.top + padding.top;
  return position === "top" ? x2 += contentWidth / 2 : position === "right" ? (x2 += contentWidth, y2 += contentHeight / 2) : position === "bottom" ? (x2 += contentWidth / 2, y2 += contentHeight) : position === "left" ? y2 += contentHeight / 2 : position === "center" && (x2 += contentWidth / 2, y2 += contentHeight / 2), { x: x2, y: y2 };
}
function offset$3(type5, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift2 = (dir) => 0, offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  return type5 === "padding" ? shift2 = (dir) => padding[dir] * locationMultiplier + labelPaddingShift : type5 === "border" ? shift2 = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift : type5 === "margin" && (shift2 = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift), position === "top" ? offsetY = -shift2("top") : position === "right" ? offsetX = shift2("right") : position === "bottom" ? offsetY = shift2("bottom") : position === "left" && (offsetX = -shift2("left")), { offsetX, offsetY };
}
function collide(a2, b2) {
  return Math.abs(a2.x - b2.x) < Math.abs(a2.w + b2.w) / 2 && Math.abs(a2.y - b2.y) < Math.abs(a2.h + b2.h) / 2;
}
function overlapAdjustment(position, currentRect, prevRect) {
  return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
}
function textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text) {
  return roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 }), context.fillStyle = `${colors[type5]}dd`, context.fill(), context.strokeStyle = colors[type5], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x2, y2), roundedRect(context, { x: x2, y: y2, w: w2, h: h3, r: 3 }), context.fillStyle = `${colors[type5]}dd`, context.fill(), context.strokeStyle = colors[type5], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x2, y2), { x: x2, y: y2, w: w2, h: h3 };
}
function configureText(context, text) {
  context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
  let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w2 = metrics.width + labelPadding * 2, h3 = actualHeight + labelPadding * 2;
  return { w: w2, h: h3 };
}
function drawLabel(context, measurements, { type: type5, position = "center", text }, prevRect, external = false) {
  let { x: x2, y: y2 } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset$3(type5, position, measurements, labelPadding + 1, external);
  x2 += offsetX, y2 += offsetY;
  let { w: w2, h: h3 } = configureText(context, text);
  if (prevRect && collide({ x: x2, y: y2, w: w2, h: h3 }, prevRect)) {
    let adjusted = overlapAdjustment(position, { x: x2, y: y2, w: w2 }, prevRect);
    x2 = adjusted.x, y2 = adjusted.y;
  }
  return textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
function floatingOffset(alignment, { w: w2, h: h3 }) {
  let deltaW = w2 * 0.5 + labelPadding, deltaH = h3 * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
function drawFloatingLabel(context, measurements, { type: type5, text }) {
  let { floatingAlignment: floatingAlignment2, extremities } = measurements, x2 = extremities[floatingAlignment2.x], y2 = extremities[floatingAlignment2.y], { w: w2, h: h3 } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w: w2,
    h: h3
  });
  return x2 += offsetX, y2 += offsetY, textWithRect(context, type5, { x: x2, y: y2, w: w2, h: h3 }, text);
}
function drawStack(context, measurements, stack2, external) {
  let rects = [];
  stack2.forEach((l2, idx) => {
    let rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
function labelStacks(context, measurements, labels, externalLabels) {
  let stacks = labels.reduce((acc, l2) => (Object.prototype.hasOwnProperty.call(acc, l2.position) || (acc[l2.position] = []), acc[l2.position]?.push(l2), acc), {});
  stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
}
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
function round$1(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
function filterZeroValues(labels) {
  return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
}
function floatingAlignment(extremities) {
  let windowExtremities = {
    top: scope.window.scrollY,
    bottom: scope.window.scrollY + scope.window.innerHeight,
    left: scope.window.scrollX,
    right: scope.window.scrollX + scope.window.innerWidth
  }, distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
function measureElement(element) {
  let style = scope.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + scope.window.scrollY, left = left + scope.window.scrollX, bottom = bottom + scope.window.scrollY, right = right + scope.window.scrollX;
  let margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  }, padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  }, border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  }, extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  let marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  let marginLabels = [
    {
      type: "margin",
      text: round$1(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round$1(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round$1(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round$1(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  ), context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  let paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  let borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  let borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
function drawContent(context, { padding, border, width, height, top, left }) {
  let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  return context.fillStyle = colors2.content, context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  ), [
    {
      type: "content",
      position: "center",
      text: `${round$1(contentWidth)} x ${round$1(contentHeight)}`
    }
  ];
}
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}
var deepElementFromPoint = (x2, y2) => {
  let element = scope.document.elementFromPoint(x2, y2), crawlShadows = (node) => {
    if (node && node.shadowRoot) {
      let nestedElement = node.shadowRoot.elementFromPoint(x2, y2);
      return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
    }
    return node;
  };
  return crawlShadows(element) || element;
};
var nodeAtPointerRef, pointer3 = { x: 0, y: 0 };
function findAndDrawElement(x2, y2) {
  nodeAtPointerRef = deepElementFromPoint(x2, y2), drawSelectedElement(nodeAtPointerRef);
}
var withMeasure = (StoryFn, context) => {
  let { measureEnabled } = context.globals || {};
  return useEffect$1(() => {
    if (typeof globalThis.document > "u")
      return;
    let onPointerMove = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), pointer3.x = event.clientX, pointer3.y = event.clientY;
      });
    };
    return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
      globalThis.document.removeEventListener("pointermove", onPointerMove);
    };
  }, []), useEffect$1(() => {
    let onPointerOver = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
      });
    }, onResize = () => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    };
    return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer3.x, pointer3.y)), () => {
      globalThis.window.removeEventListener("resize", onResize), destroy();
    };
  }, [measureEnabled, context.viewMode]), StoryFn();
};
var decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {
  [PARAM_KEY3]: false
}, preview_default5 = () => ({
  decorators: decorators2,
  initialGlobals: initialGlobals2
});
var PARAM_KEY4 = "outline";
var clearStyles2 = (selector) => {
  (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
}, clearStyle2 = (input2) => {
  let selector = typeof input2 == "string" ? input2 : input2.join(""), element = scope.document.getElementById(selector);
  element && element.parentElement && element.parentElement.removeChild(element);
}, addOutlineStyles = (selector, css2) => {
  let existingStyle = scope.document.getElementById(selector);
  if (existingStyle)
    existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
  else {
    let style = scope.document.createElement("style");
    style.setAttribute("id", selector), style.innerHTML = css2, scope.document.head.appendChild(style);
  }
};
function outlineCSS(selector) {
  return dedent$1`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
var withOutline = (StoryFn, context) => {
  let globals = context.globals || {}, isActive = [true, "true"].includes(globals[PARAM_KEY4]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
  return useEffect$1(() => {
    let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
    return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
      clearStyles2(selectorId);
    };
  }, [isActive, outlineStyles, context]), StoryFn();
};
var decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {
  [PARAM_KEY4]: false
}, preview_default6 = () => ({ decorators: decorators3, initialGlobals: initialGlobals3 });
var resetAllMocksLoader = ({ parameters: parameters2 }) => {
  parameters2?.test?.mockReset === true ? resetAllMocks() : parameters2?.test?.clearMocks === true ? clearAllMocks() : parameters2?.test?.restoreMocks !== false && restoreAllMocks();
}, traverseArgs = (value, depth = 0, key) => {
  if (depth > 5 || value == null)
    return value;
  if (isMockFunction(value))
    return key && value.mockName(key), value;
  if (typeof value == "function" && "isAction" in value && value.isAction && !("implicit" in value && value.implicit)) {
    let mock = fn2(value);
    return key && mock.mockName(key), mock;
  }
  if (Array.isArray(value)) {
    depth++;
    for (let i2 = 0; i2 < value.length; i2++)
      Object.getOwnPropertyDescriptor(value, i2)?.writable && (value[i2] = traverseArgs(value[i2], depth));
    return value;
  }
  if (typeof value == "object" && value.constructor === Object) {
    depth++;
    for (let [k2, v2] of Object.entries(value))
      Object.getOwnPropertyDescriptor(value, k2)?.writable && (value[k2] = traverseArgs(v2, depth, k2));
    return value;
  }
  return value;
}, nameSpiesAndWrapActionsInSpies = ({ initialArgs }) => {
  traverseArgs(initialArgs);
}, patchedFocus = false, enhanceContext = async (context) => {
  globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));
  let clipboard = globalThis.window?.navigator?.clipboard;
  if (clipboard && (context.userEvent = instrument(
    { userEvent: uninstrumentedUserEvent.setup() },
    {
      intercept: true,
      getKeys: (obj) => Object.keys(obj).filter((key) => key !== "eventWrapper")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: () => clipboard,
    configurable: true
  }), !patchedFocus)) {
    let originalFocus = HTMLElement.prototype.focus, currentFocus = HTMLElement.prototype.focus, focusingElements = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: true,
        set: (newFocus) => {
          currentFocus = newFocus;
        },
        get() {
          return focusingElements.has(this) ? originalFocus : (focusingElements.add(this), setTimeout(() => focusingElements.delete(this), 0), currentFocus);
        }
      }
    }), patchedFocus = true;
  }
}, preview_default7 = () => ({
  loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
});
var PARAM_KEY5 = "viewport";
var initialGlobals4 = {
  [PARAM_KEY5]: { value: void 0, isRotated: false }
}, preview_default8 = () => ({
  initialGlobals: initialGlobals4
});
function getCoreAnnotations() {
  return [
    // @ts-expect-error CJS fallback
    (preview_default5.default ?? preview_default5)(),
    // @ts-expect-error CJS fallback
    (preview_default2.default ?? preview_default2)(),
    // @ts-expect-error CJS fallback
    (preview_default4.default ?? preview_default4)(),
    // @ts-expect-error CJS fallback
    (preview_default6.default ?? preview_default6)(),
    // @ts-expect-error CJS fallback
    (preview_default8.default ?? preview_default8)(),
    // @ts-expect-error CJS fallback
    (preview_default.default ?? preview_default)(),
    // @ts-expect-error CJS fallback
    (preview_default3.default ?? preview_default3)(),
    // @ts-expect-error CJS fallback
    (preview_default7.default ?? preview_default7)()
  ];
}
function isMeta(input2) {
  return input2 != null && typeof input2 == "object" && "_tag" in input2 && input2?._tag === "Meta";
}
function isStory(input2) {
  return input2 != null && typeof input2 == "object" && "_tag" in input2 && input2?._tag === "Story";
}
function getStoryChildren(story) {
  return "__children" in story ? story.__children : [];
}
var sanitize = (string) => string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), sanitizeSafe = (string, part) => {
  let sanitized = sanitize(string);
  if (sanitized === "")
    throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
  return sanitized;
}, toId = (kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, toTestId = (parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, storyNameFromExport = (key) => toStartCaseStr(key);
function matches3(storyKey, arrayOrRegex) {
  return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);
}
function isExportStory(key, { includeStories, excludeStories }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    key !== "__esModule" && (!includeStories || matches3(key, includeStories)) && (!excludeStories || !matches3(key, excludeStories))
  );
}
var combineTags = (...tags) => {
  let result = tags.reduce((acc, tag) => (tag.startsWith("!") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());
  return Array.from(result);
};
function getSymbols$1(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function getTag2(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var regexpTag$1 = "[object RegExp]", stringTag$1 = "[object String]", numberTag$1 = "[object Number]", booleanTag$1 = "[object Boolean]", argumentsTag$1 = "[object Arguments]", symbolTag2 = "[object Symbol]", dateTag$1 = "[object Date]", mapTag$1 = "[object Map]", setTag$1 = "[object Set]", arrayTag$1 = "[object Array]", functionTag$1 = "[object Function]", arrayBufferTag$1 = "[object ArrayBuffer]", objectTag$1 = "[object Object]", errorTag$1 = "[object Error]", dataViewTag$1 = "[object DataView]", uint8ArrayTag$1 = "[object Uint8Array]", uint8ClampedArrayTag$1 = "[object Uint8ClampedArray]", uint16ArrayTag$1 = "[object Uint16Array]", uint32ArrayTag$1 = "[object Uint32Array]", bigUint64ArrayTag$1 = "[object BigUint64Array]", int8ArrayTag$1 = "[object Int8Array]", int16ArrayTag$1 = "[object Int16Array]", int32ArrayTag$1 = "[object Int32Array]", bigInt64ArrayTag$1 = "[object BigInt64Array]", float32ArrayTag$1 = "[object Float32Array]", float64ArrayTag$1 = "[object Float64Array]";
function isPlainObject$3(value) {
  if (!value || typeof value != "object")
    return false;
  let proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === "[object Object]" : false;
}
function mapValues$1(object, getNewValue) {
  let result = {}, keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2], value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}
function pickBy(obj, shouldPick) {
  let result = {}, keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2], value = obj[key];
    shouldPick(value, key) && (result[key] = value);
  }
  return result;
}
var import_memoizerific2 = __toESM$3(require_memoizerific(), 1);
function eq3(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function isEqualWith(a2, b2, areValuesEqual) {
  return isEqualWithImpl(a2, b2, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b2, property, aParent, bParent, stack2, areValuesEqual) {
  let result = areValuesEqual(a2, b2, property, aParent, bParent, stack2);
  if (result !== void 0)
    return result;
  if (typeof a2 == typeof b2)
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return a2 === b2;
      case "number":
        return a2 === b2 || Object.is(a2, b2);
      case "function":
        return a2 === b2;
      case "object":
        return areObjectsEqual(a2, b2, stack2, areValuesEqual);
    }
  return areObjectsEqual(a2, b2, stack2, areValuesEqual);
}
function areObjectsEqual(a2, b2, stack2, areValuesEqual) {
  if (Object.is(a2, b2))
    return true;
  let aTag = getTag2(a2), bTag = getTag2(b2);
  if (aTag === argumentsTag$1 && (aTag = objectTag$1), bTag === argumentsTag$1 && (bTag = objectTag$1), aTag !== bTag)
    return false;
  switch (aTag) {
    case stringTag$1:
      return a2.toString() === b2.toString();
    case numberTag$1: {
      let x2 = a2.valueOf(), y2 = b2.valueOf();
      return eq3(x2, y2);
    }
    case booleanTag$1:
    case dateTag$1:
    case symbolTag2:
      return Object.is(a2.valueOf(), b2.valueOf());
    case regexpTag$1:
      return a2.source === b2.source && a2.flags === b2.flags;
    case functionTag$1:
      return a2 === b2;
  }
  stack2 = stack2 ?? /* @__PURE__ */ new Map();
  let aStack = stack2.get(a2), bStack = stack2.get(b2);
  if (aStack != null && bStack != null)
    return aStack === b2;
  stack2.set(a2, b2), stack2.set(b2, a2);
  try {
    switch (aTag) {
      case mapTag$1: {
        if (a2.size !== b2.size)
          return false;
        for (let [key, value] of a2.entries())
          if (!b2.has(key) || !isEqualWithImpl(value, b2.get(key), key, a2, b2, stack2, areValuesEqual))
            return false;
        return true;
      }
      case setTag$1: {
        if (a2.size !== b2.size)
          return false;
        let aValues = Array.from(a2.values()), bValues = Array.from(b2.values());
        for (let i2 = 0; i2 < aValues.length; i2++) {
          let aValue = aValues[i2], index2 = bValues.findIndex((bValue) => isEqualWithImpl(aValue, bValue, void 0, a2, b2, stack2, areValuesEqual));
          if (index2 === -1)
            return false;
          bValues.splice(index2, 1);
        }
        return true;
      }
      case arrayTag$1:
      case uint8ArrayTag$1:
      case uint8ClampedArrayTag$1:
      case uint16ArrayTag$1:
      case uint32ArrayTag$1:
      case bigUint64ArrayTag$1:
      case int8ArrayTag$1:
      case int16ArrayTag$1:
      case int32ArrayTag$1:
      case bigInt64ArrayTag$1:
      case float32ArrayTag$1:
      case float64ArrayTag$1: {
        if (typeof Buffer < "u" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b2) || a2.length !== b2.length)
          return false;
        for (let i2 = 0; i2 < a2.length; i2++)
          if (!isEqualWithImpl(a2[i2], b2[i2], i2, a2, b2, stack2, areValuesEqual))
            return false;
        return true;
      }
      case arrayBufferTag$1:
        return a2.byteLength !== b2.byteLength ? false : areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack2, areValuesEqual);
      case dataViewTag$1:
        return a2.byteLength !== b2.byteLength || a2.byteOffset !== b2.byteOffset ? false : areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack2, areValuesEqual);
      case errorTag$1:
        return a2.name === b2.name && a2.message === b2.message;
      case objectTag$1: {
        if (!(areObjectsEqual(a2.constructor, b2.constructor, stack2, areValuesEqual) || isPlainObject$3(a2) && isPlainObject$3(b2)))
          return false;
        let aKeys = [...Object.keys(a2), ...getSymbols$1(a2)], bKeys = [...Object.keys(b2), ...getSymbols$1(b2)];
        if (aKeys.length !== bKeys.length)
          return false;
        for (let i2 = 0; i2 < aKeys.length; i2++) {
          let propKey = aKeys[i2], aProp = a2[propKey];
          if (!Object.hasOwn(b2, propKey))
            return false;
          let bProp = b2[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b2, stack2, areValuesEqual))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    stack2.delete(a2), stack2.delete(b2);
  }
}
function noop2() {
}
function isEqual2(a2, b2) {
  return isEqualWith(a2, b2, noop2);
}
var INCOMPATIBLE = Symbol("incompatible"), map = (arg, argType) => {
  let type5 = argType.type;
  if (arg == null || !type5 || argType.mapping)
    return arg;
  switch (type5.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return String(arg) === "true";
    case "array":
      return !type5.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index2) => {
        let mapped = map(item, { type: type5.value });
        return mapped !== INCOMPATIBLE && (acc[index2] = mapped), acc;
      }, new Array(arg.length));
    case "object":
      return typeof arg == "string" || typeof arg == "number" ? arg : !type5.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
        let mapped = map(val, { type: type5.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    case "other": {
      let isPrimitiveArg = typeof arg == "string" || typeof arg == "number" || typeof arg == "boolean";
      return type5.value === "ReactNode" && isPrimitiveArg ? arg : INCOMPATIBLE;
    }
    default:
      return INCOMPATIBLE;
  }
}, mapArgsToTypes = (args, argTypes) => Object.entries(args).reduce((acc, [key, value]) => {
  if (!argTypes[key])
    return acc;
  let mapped = map(value, argTypes[key]);
  return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
}, {}), combineArgs = (value, update) => Array.isArray(value) && Array.isArray(update) ? update.reduce(
  (acc, upd, index2) => (acc[index2] = combineArgs(value[index2], update[index2]), acc),
  [...value]
).filter((v2) => v2 !== void 0) : !isPlainObject$3(value) || !isPlainObject$3(update) ? update : Object.keys({ ...value, ...update }).reduce((acc, key) => {
  if (key in update) {
    let combined = combineArgs(value[key], update[key]);
    combined !== void 0 && (acc[key] = combined);
  } else
    acc[key] = value[key];
  return acc;
}, {}), validateOptions2 = (args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
  function allowArg() {
    return key in args && (acc[key] = args[key]), acc;
  }
  if (!options)
    return allowArg();
  if (!Array.isArray(options))
    return once.error(dedent$1`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), allowArg();
  if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
    return once.error(dedent$1`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), allowArg();
  let isArray3 = Array.isArray(args[key]), invalidIndex = isArray3 && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray3 && invalidIndex === -1;
  if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
    return allowArg();
  let field = isArray3 ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
  return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
}, {}), DEEPLY_EQUAL = Symbol("Deeply equal"), deepDiff = (value, update) => {
  if (typeof value != typeof update)
    return update;
  if (isEqual2(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    let res = update.reduce((acc, upd, index2) => {
      let diff2 = deepDiff(value[index2], upd);
      return diff2 !== DEEPLY_EQUAL && (acc[index2] = diff2), acc;
    }, new Array(update.length));
    return update.length >= value.length ? res : res.concat(new Array(value.length - update.length).fill(void 0));
  }
  return isPlainObject$3(value) && isPlainObject$3(update) ? Object.keys({ ...value, ...update }).reduce((acc, key) => {
    let diff2 = deepDiff(value?.[key], update?.[key]);
    return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
  }, {}) : update;
}, UNTARGETED = "UNTARGETED";
function groupArgsByTarget({
  args,
  argTypes
}) {
  let groupedArgs = {};
  return Object.entries(args).forEach(([name, value]) => {
    let { target = UNTARGETED } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value;
  }), groupedArgs;
}
function deleteUndefined(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id])
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
    else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
    }
  }
  updateFromDelta(story, delta) {
    let validatedDelta = validateOptions2(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId))
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {});
var GlobalsStore = class {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    let defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => (this.allowedGlobalNames.has(key) ? acc[key] = value : logger$1.warn(
      `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
    ), acc), {});
  }
  updateFromPersisted(persisted) {
    let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
    for (let key in newGlobals)
      newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);
  }
};
var import_memoizerific = __toESM$3(require_memoizerific(), 1), getImportPathMap = (0, import_memoizerific.default)(1)(
  (entries) => Object.values(entries).reduce(
    (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
    {}
  )
), StoryIndexStore = class {
  constructor({ entries } = { v: 5, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    let entries = Object.values(this.entries);
    if (specifier === "*")
      return entries[0];
    if (typeof specifier == "string")
      return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
    let { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    let storyEntry = this.entries[storyId];
    if (!storyEntry)
      throw new MissingStoryAfterHmrError({ storyId });
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};
var normalizeType = (type5) => typeof type5 == "string" ? { name: type5 } : type5, normalizeControl = (control) => typeof control == "string" ? { type: control } : control, normalizeInputType = (inputType, key) => {
  let { type: type5, control, ...rest } = inputType, normalized = {
    name: key,
    ...rest
  };
  return type5 && (normalized.type = normalizeType(type5)), control ? normalized.control = normalizeControl(control) : control === false && (normalized.control = { disable: true }), normalized;
}, normalizeInputTypes = (inputTypes) => mapValues$1(inputTypes, normalizeInputType);
var normalizeArrays = (array) => Array.isArray(array) ? array : array ? [array] : [];
var deprecatedStoryAnnotation = dedent$1`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function normalizeStory(key, storyAnnotations, meta2) {
  let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
  story && (logger$1.debug("deprecated story", story), deprecate(deprecatedStoryAnnotation));
  let exportName = storyNameFromExport(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators4 = [
    ...normalizeArrays(storyObject.decorators),
    ...normalizeArrays(story?.decorators)
  ], parameters2 = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [
    ...normalizeArrays(storyObject.beforeEach),
    ...normalizeArrays(story?.beforeEach)
  ], afterEach = [
    ...normalizeArrays(storyObject.afterEach),
    ...normalizeArrays(story?.afterEach)
  ], { render: render2, play, tags = [], globals = {} } = storyObject, id = parameters2.__id || toId(meta2.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    tags,
    decorators: decorators4,
    parameters: parameters2,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders: loaders2,
    beforeEach,
    afterEach,
    globals,
    ...render2 && { render: render2 },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  let { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}
var checkGlobals = (parameters2) => {
  let { globals, globalTypes } = parameters2;
  (globals || globalTypes) && logger$1.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals,
      globalTypes
    })
  );
}, checkStorySort = (parameters2) => {
  let { options } = parameters2;
  options?.storySort && logger$1.error("The storySort option parameter can only be set globally");
}, checkDisallowedParameters = (parameters2) => {
  parameters2 && (checkGlobals(parameters2), checkStorySort(parameters2));
};
function processCSFFile(moduleExports, importPath, title) {
  let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, firstStory = Object.values(namedExports)[0];
  if (isStory(firstStory)) {
    let meta22 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
    checkDisallowedParameters(meta22.parameters);
    let csfFile2 = { meta: meta22, stories: {}, moduleExports };
    return Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta22)) {
        let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta22);
        checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {
          let name = child.input.name, childId = toTestId(storyMeta.id, name);
          child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta22);
        });
      }
    }), csfFile2.projectAnnotations = firstStory.meta.preview.composed, csfFile2;
  }
  let meta2 = normalizeComponentAnnotations(
    defaultExport,
    title,
    importPath
  );
  checkDisallowedParameters(meta2.parameters);
  let csfFile = { meta: meta2, stories: {}, moduleExports };
  return Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta2)) {
      let storyMeta = normalizeStory(key, namedExports[key], meta2);
      checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
    }
  }), csfFile;
}
function decorateStory(storyFn, decorator, bindWithContext) {
  let boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters: parameters2,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
function defaultDecorateStory$1(storyFn, decorators4) {
  let contextStore = {}, bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    return contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    }, decoratedStoryFn(contextStore.value);
  }, decoratedWithContextStore = decorators4.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => (contextStore.value = context, decoratedWithContextStore(context));
}
var combineParameters$1 = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : isPlainObject$3(value) && isPlainObject$3(existing) ? mergeKeys[key] = true : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p2) => p2[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => isPlainObject$3(value)) ? combined[key] = combineParameters$1(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  let { moduleExport, id, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(
    storyAnnotations,
    componentAnnotations,
    projectAnnotations
  ), applyLoaders = async (context) => {
    let loaded = {};
    for (let loaders2 of [
      normalizeArrays(projectAnnotations.loaders),
      normalizeArrays(componentAnnotations.loaders),
      normalizeArrays(storyAnnotations.loaders)
    ]) {
      if (context.abortSignal.aborted)
        return loaded;
      let loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
      Object.assign(loaded, ...loadResults);
    }
    return loaded;
  }, applyBeforeEach = async (context) => {
    let cleanupCallbacks = new Array();
    for (let beforeEach of [
      ...normalizeArrays(projectAnnotations.beforeEach),
      ...normalizeArrays(componentAnnotations.beforeEach),
      ...normalizeArrays(storyAnnotations.beforeEach)
    ]) {
      if (context.abortSignal.aborted)
        return cleanupCallbacks;
      let cleanup = await beforeEach(context);
      cleanup && cleanupCallbacks.push(cleanup);
    }
    return cleanupCallbacks;
  }, applyAfterEach = async (context) => {
    let reversedFinalizers = [
      ...normalizeArrays(projectAnnotations.afterEach),
      ...normalizeArrays(componentAnnotations.afterEach),
      ...normalizeArrays(storyAnnotations.afterEach)
    ].reverse();
    for (let finalizer of reversedFinalizers) {
      if (context.abortSignal.aborted)
        return;
      await finalizer(context);
    }
  }, undecoratedStoryFn = (context) => context.originalStoryFn(context.args, context), { applyDecorators: applyDecorators3 = defaultDecorateStory$1, runStep } = projectAnnotations, decorators4 = [
    ...normalizeArrays(storyAnnotations?.decorators),
    ...normalizeArrays(componentAnnotations?.decorators),
    ...normalizeArrays(projectAnnotations?.decorators)
  ], render2 = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators3)(undecoratedStoryFn, decorators4), unboundStoryFn = (context) => decoratedStoryFn(context), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);
  if (!render2 && !usesMount)
    throw new NoRenderFunctionError({ id });
  let defaultMount = (context) => async () => (await context.renderToCanvas(), context.canvas), mount2 = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;
  return {
    storyGlobals: {},
    ...partialAnnotations,
    moduleExport,
    id,
    name,
    story: name,
    originalStoryFn: render2,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    applyBeforeEach,
    applyAfterEach,
    playFunction,
    runStep,
    mount: mount2,
    testingLibraryRender,
    renderToCanvas: projectAnnotations.renderToCanvas,
    usesMount
  };
}
function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
  return {
    ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
    moduleExport
  };
}
function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
  let defaultTags = ["dev", "test"], extraTags = scope.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [], tags = combineTags(
    ...defaultTags,
    ...extraTags,
    ...projectAnnotations.tags ?? [],
    ...componentAnnotations.tags ?? [],
    ...overrideTags,
    ...storyAnnotations?.tags ?? []
  ), parameters2 = combineParameters$1(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations?.parameters
  ), { argTypesEnhancers: argTypesEnhancers2 = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations, passedArgTypes = combineParameters$1(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations?.argTypes
  );
  if (storyAnnotations) {
    let render2 = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
    parameters2.__isArgsStory = render2 && render2.length > 0;
  }
  let passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations?.args
  }, storyGlobals = {
    ...componentAnnotations.globals,
    ...storyAnnotations?.globals
  }, contextForEnhancers = {
    componentId: componentAnnotations.id,
    title: componentAnnotations.title,
    kind: componentAnnotations.title,
    // Back compat
    id: storyAnnotations?.id || componentAnnotations.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: storyAnnotations?.name || "__meta",
    story: storyAnnotations?.name || "__meta",
    // Back compat
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    tags,
    parameters: parameters2,
    initialArgs: passedArgs,
    argTypes: passedArgTypes,
    storyGlobals
  };
  contextForEnhancers.argTypes = argTypesEnhancers2.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  let initialArgsBeforeEnhancers = { ...passedArgs };
  contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
  return withoutStoryIdentifiers;
}
function prepareContext(context) {
  let { args: unmappedArgs } = context, targetedContext = {
    ...context,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (scope.FEATURES?.argTypeTargetsV7) {
    let argsByTarget = groupArgsByTarget(context);
    targetedContext = {
      ...context,
      allArgs: context.args,
      argsByTarget,
      args: argsByTarget[UNTARGETED] || {}
    };
  }
  let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
    if (!targetedContext.argTypes[key]?.mapping)
      return acc[key] = val, acc;
    let mappingFn = (originalValue) => {
      let mapping = targetedContext.argTypes[key].mapping;
      return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
    };
    return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
  }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
    let argType = targetedContext.argTypes[key] || {};
    return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;
  }, {});
  return { ...targetedContext, unmappedArgs, args: includedArgs };
}
var inferType = (value, name, visited) => {
  let type5 = typeof value;
  switch (type5) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type5 };
  }
  return value ? visited.has(value) ? (logger$1.warn(dedent$1`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value), Array.isArray(value) ? { name: "array", value: value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues$1(value, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
}, inferArgTypes = (context) => {
  let { id, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues$1(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  })), userArgTypesNames = mapValues$1(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters$1(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;
var matches4 = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), filterArgTypes = (argTypes, include2, exclude) => !include2 && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
  let name = argType.name || key.toString();
  return !!(!include2 || matches4(name, include2)) && (!exclude || !matches4(name, exclude));
});
var inferControl = (argType, name, matchers) => {
  let { type: type5, options } = argType;
  if (type5) {
    if (matchers.color && matchers.color.test(name)) {
      let controlType = type5.name;
      if (controlType === "string")
        return { control: { type: "color" } };
      controlType !== "enum" && logger$1.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
    if (matchers.date && matchers.date.test(name))
      return { control: { type: "date" } };
    switch (type5.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value } = type5;
        return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: options ? "select" : "object" } };
    }
  }
}, inferControls = (context) => {
  let {
    argTypes,
    parameters: { __isArgsStory, controls: { include: include2 = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory)
    return argTypes;
  let filteredArgTypes = filterArgTypes(argTypes, include2, exclude), withControls = mapValues$1(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
  return combineParameters$1(withControls, filteredArgTypes);
};
inferControls.secondPass = true;
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers: argTypesEnhancers2,
  decorators: decorators4,
  loaders: loaders2,
  beforeEach,
  afterEach,
  initialGlobals: initialGlobals5,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    decorators: normalizeArrays(decorators4),
    loaders: normalizeArrays(loaders2),
    beforeEach: normalizeArrays(beforeEach),
    afterEach: normalizeArrays(afterEach),
    argTypesEnhancers: [
      ...argTypesEnhancers2 || [],
      inferArgTypes,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      inferControls
    ],
    initialGlobals: initialGlobals5,
    ...annotations
  };
}
var composeBeforeAllHooks = (hooks) => async () => {
  let cleanups2 = [];
  for (let hook of hooks) {
    let cleanup = await hook();
    cleanup && cleanups2.unshift(cleanup);
  }
  return async () => {
    for (let cleanup of cleanups2)
      await cleanup();
  };
};
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    await stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    )();
  };
}
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field, options = {}) {
  return getField(moduleExportList, field).reduce((prev, cur) => {
    let normalized = normalizeArrays(cur);
    return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
  }, []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs$1(moduleExportList) {
  let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep"), beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
  return {
    parameters: combineParameters$1(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators", {
      reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e2) => !e2.secondPass),
      ...allArgTypeEnhancers.filter((e2) => e2.secondPass)
    ],
    initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    beforeAll: composeBeforeAllHooks(beforeAllHooks),
    beforeEach: getArrayField(moduleExportList, "beforeEach"),
    afterEach: getArrayField(moduleExportList, "afterEach"),
    render: getSingletonField(moduleExportList, "render"),
    renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners),
    tags: getArrayField(moduleExportList, "tags"),
    mount: getSingletonField(moduleExportList, "mount"),
    testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
  };
}
function isTestEnvironment() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
function pauseAnimations(atEnd = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let disableStyle = document.createElement("style");
  disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(disableStyle);
  let pauseStyle = document.createElement("style");
  return pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(pauseStyle), document.body.clientHeight, document.head.removeChild(disableStyle), () => {
    pauseStyle.parentNode?.removeChild(pauseStyle);
  };
}
async function waitForAnimations(signal) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let timedOut = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((resolve) => {
      setTimeout(() => {
        let animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)], checkAnimationsFinished = async () => {
          if (timedOut || signal?.aborted)
            return;
          let runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a2) => a2.playState === "running" && !isInfiniteAnimation(a2));
          runningAnimations.length > 0 && (await Promise.all(runningAnimations.map((a2) => a2.finished)), await checkAnimationsFinished());
        };
        checkAnimationsFinished().then(resolve);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (resolve) => setTimeout(() => {
        timedOut = true, resolve(void 0);
      }, 5e3)
    )
  ]);
}
function getShadowRoots(doc) {
  return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => ("shadowRoot" in el && el.shadowRoot && acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot)), acc), []);
}
function isInfiniteAnimation(anim) {
  if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
    let style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement), index2 = style.animationName?.split(", ").indexOf(anim.animationName);
    return style.animationIterationCount.split(", ")[index2] === "infinite";
  }
  return false;
}
var ReporterAPI = class {
  constructor() {
    this.reports = [];
  }
  async addReport(report) {
    this.reports.push(report);
  }
};
function getCsfFactoryAnnotations(story, meta2, projectAnnotations) {
  return isStory(story) ? {
    story: story.input,
    meta: story.meta.input,
    preview: story.meta.preview.composed
  } : { story, meta: isMeta(meta2) ? meta2.input : meta2, preview: projectAnnotations };
}
function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
  globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
}
var DEFAULT_STORY_TITLE = "ComposedStory", DEFAULT_STORY_NAME = "Unnamed Story";
function extractAnnotation(annotation) {
  return annotation ? composeConfigs$1([annotation]) : {};
}
function setProjectAnnotations(projectAnnotations) {
  let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  return globalThis.globalProjectAnnotations = composeConfigs$1([
    ...getCoreAnnotations(),
    globalThis.defaultProjectAnnotations ?? {},
    composeConfigs$1(annotations.map(extractAnnotation))
  ]), globalThis.globalProjectAnnotations ?? {};
}
var cleanups = [];
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
  if (storyAnnotations === void 0)
    throw new Error("Expected a story but received undefined.");
  componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
  let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  ), normalizedProjectAnnotations = normalizeProjectAnnotations(
    composeConfigs$1([
      defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
      projectAnnotations ?? {}
    ])
  ), story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  ), globals = {
    ...getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes),
    ...normalizedProjectAnnotations.initialGlobals,
    ...story.storyGlobals
  }, reporting = new ReporterAPI(), initializeContext = () => {
    let context = prepareContext({
      hooks: new HooksContext(),
      globals,
      args: { ...story.initialArgs },
      viewMode: "story",
      reporting,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: (label, play2) => story.runStep(label, play2, context),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: normalizedProjectAnnotations.globalTypes,
      ...story,
      context: null,
      mount: null
    });
    return context.parameters.__isPortableStory = true, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {
      let unmount = await story.renderToCanvas?.(
        {
          componentId: story.componentId,
          title: story.title,
          id: story.id,
          name: story.name,
          tags: story.tags,
          showMain: () => {
          },
          showError: (error) => {
            throw new Error(`${error.title}
${error.description}`);
          },
          showException: (error) => {
            throw error;
          },
          forceRemount: true,
          storyContext: context,
          storyFn: () => story.unboundStoryFn(context),
          unboundStoryFn: story.unboundStoryFn
        },
        context.canvasElement
      );
      unmount && cleanups.push(unmount);
    }), context.mount = story.mount(context), context;
  }, loadedContext, play = async (extraContext) => {
    let context = initializeContext();
    return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);
  }, run = (extraContext) => {
    let context = initializeContext();
    return Object.assign(context, extraContext), runStory(story, context);
  }, playFunction = story.playFunction ? play : void 0;
  return Object.assign(
    function(extraArgs) {
      let context = initializeContext();
      return loadedContext && (context.loaded = loadedContext.loaded), context.args = {
        ...context.initialArgs,
        ...extraArgs
      }, story.unboundStoryFn(context);
    },
    {
      id: story.id,
      storyName,
      load: async () => {
        for (let callback of [...cleanups].reverse())
          await callback();
        cleanups.length = 0;
        let context = initializeContext();
        context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;
      },
      globals,
      args: story.initialArgs,
      parameters: story.parameters,
      argTypes: story.argTypes,
      play: playFunction,
      run,
      reporting,
      tags: story.tags
    }
  );
}
var defaultComposeStory = (story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName);
function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
  let { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport, meta2 = metaExport;
  return Object.entries(stories).reduce(
    (storiesMap, [exportsName, story]) => {
      let { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
      return !meta2 && componentAnnotations && (meta2 = componentAnnotations), isExportStory(exportsName, meta2) ? Object.assign(storiesMap, {
        [exportsName]: composeStoryFn(storyAnnotations, meta2, globalConfig, exportsName)
      }) : storiesMap;
    },
    {}
  );
}
function createPlaywrightTest(baseTest) {
  return baseTest.extend({
    mount: async ({ mount: mount2, page }, use2) => {
      await use2(async (storyRef, ...restArgs) => {
        if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx")
          throw new Error(dedent$1`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        let { props, ...storyRefWithoutProps } = storyRef;
        await page.evaluate(async (wrappedStoryRef) => {
          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
          return ("__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef)?.load?.();
        }, storyRefWithoutProps);
        let mountResult = await mount2(storyRef, ...restArgs);
        return await page.evaluate(async (wrappedStoryRef) => {
          let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef), story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef, canvasElement = document.querySelector("#root");
          return story?.play?.({ canvasElement });
        }, storyRefWithoutProps), mountResult;
      });
    }
  });
}
async function runStory(story, context) {
  for (let callback of [...cleanups].reverse())
    await callback();
  if (cleanups.length = 0, !context.canvasElement) {
    let container = document.createElement("div");
    globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {
      globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);
    });
  }
  if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)
    return;
  cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
  let playFunction = story.playFunction, isMountDestructured = story.usesMount;
  if (isMountDestructured || await context.mount(), context.abortSignal.aborted)
    return;
  playFunction && (isMountDestructured || (context.mount = async () => {
    throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
  }), await playFunction(context));
  let cleanUp;
  isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();
}
var CSF_CACHE_SIZE = 1e3, STORY_CACHE_SIZE = 1e4, StoryStore = class {
  constructor(storyIndex, importFn2, projectAnnotations) {
    this.importFn = importFn2;
    this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(
      composeConfigs$1([...getCoreAnnotations(), projectAnnotations])
    );
    let { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
    this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    let { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
    this.userGlobals.set({ globals: initialGlobals5, globalTypes });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: importFn2,
    storyIndex
  }) {
    importFn2 && (this.importFn = importFn2), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(storyId) {
    return this.storyIndex.storyIdToEntry(storyId);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(storyId) {
    let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);
    return this.processCSFFileWithCache(moduleExports, importPath, title);
  }
  async loadAllCSFFiles() {
    let importPaths = {};
    return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    }), (await Promise.all(
      Object.entries(importPaths).map(async ([importPath, storyId]) => ({
        importPath,
        csfFile: await this.loadCSFFileByStoryId(storyId)
      }))
    )).reduce(
      (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile }) {
    let componentAnnotations = csfFile.meta;
    return this.prepareMetaWithCache(
      componentAnnotations,
      this.projectAnnotations,
      csfFile.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId }) {
    let csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    let storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations)
      throw new MissingStoryFromCsfFileError({ storyId });
    let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      csfFile.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile
  }) {
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    let entry = await this.storyIdToEntry(id), storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([
      this.importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    let userGlobals = this.userGlobals.get(), { initialGlobals: initialGlobals5 } = this.userGlobals, reporting = new ReporterAPI();
    return prepareContext({
      ...story,
      args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
      initialGlobals: initialGlobals5,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals,
      reporting,
      globals: {
        ...userGlobals,
        ...story.storyGlobals
      },
      hooks: this.hooks[story.id]
    });
  }
  addCleanupCallbacks(story, ...callbacks) {
    this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
  }
  async cleanupStory(story) {
    this.hooks[story.id].clean();
    let callbacks = this.cleanupCallbacks[story.id];
    if (callbacks)
      for (let callback of [...callbacks].reverse())
        await callback();
    delete this.cleanupCallbacks[story.id];
  }
  extract(options = { includeDocsOnly: false }) {
    let { cachedCSFFiles } = this;
    if (console.log("extract: extracting stories", cachedCSFFiles), !cachedCSFFiles)
      throw new CalledExtractOnStoreError();
    let stories = Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, entry]) => {
        if (entry.type === "docs")
          return acc;
        let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });
        return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => key === "story" && entry.subtype === "test" ? { ...storyAcc, story: entry.parentName } : key === "moduleExport" || typeof value == "function" ? storyAcc : Array.isArray(value) ? Object.assign(storyAcc, { [key]: value.slice().sort() }) : Object.assign(storyAcc, { [key]: value }),
          {
            args: story.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...story.storyGlobals
            },
            storyId: entry.parent ? entry.parent : storyId
          }
        )), acc;
      },
      {}
    );
    return console.log("extract: stories", stories), stories;
  }
};
function slash2(path) {
  return path.startsWith("\\\\?\\") ? path : path.replace(/\\/g, "/");
}
var sanitize2 = (parts) => {
  if (parts.length === 0)
    return parts;
  let last = parts[parts.length - 1], lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (parts.length === 1)
    return [lastStripped];
  let nextToLast = parts[parts.length - 2];
  return lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase() ? [...parts.slice(0, -2), lastStripped] : lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
};
function pathJoin(paths) {
  return paths.flatMap((p2) => p2.split("/")).filter(Boolean).join("/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  typeof fileName == "number" && once.warn(dedent$1`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let normalizedFileName = slash2(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      let suffix = normalizedFileName.replace(directory, ""), parts = pathJoin([titlePrefix, suffix]).split("/");
      return parts = sanitize2(parts), parts.join("/");
    }
    return titlePrefix ? pathJoin([titlePrefix, userTitle]) : userTitle;
  }
}, userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i2 = 0; i2 < storiesEntries.length; i2 += 1) {
    let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i2], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/, storySort = (options = {}) => (a2, b2) => {
  if (a2.title === b2.title && !options.includeNames)
    return 0;
  let method = options.method || "configure", order = options.order || [], storyTitleA = a2.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b2.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  options.includeNames && (storyTitleA.push(a2.name), storyTitleB.push(b2.name));
  let depth = 0;
  for (; storyTitleA[depth] || storyTitleB[depth]; ) {
    if (!storyTitleA[depth])
      return -1;
    if (!storyTitleB[depth])
      return 1;
    let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
      return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let index2 = order.indexOf(nameA);
    index2 === -1 && (index2 = order.indexOf("*")), order = index2 !== -1 && Array.isArray(order[index2 + 1]) ? order[index2 + 1] : [], depth += 1;
  }
  return 0;
};
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
  } else
    stories.sort(
      (s1, s22) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s22.importPath)
    );
  return stories;
}, sortStoriesV7 = (stories, storySortParameter, fileNameOrder) => {
  try {
    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
  } catch (err) {
    throw new Error(dedent$1`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
};
var PREPARE_ABORTED = new Error("prepareAborted");
var { AbortController: AbortController2 } = globalThis;
function serializeError(error) {
  try {
    let { name = "Error", message = String(error), stack: stack2 } = error;
    return { name, message, stack: stack2 };
  } catch {
    return { name: "Error", message: String(error) };
  }
}
var StoryRender = class {
  constructor(channel2, store, renderToScreen, callbacks, id, viewMode, renderOptions = { autoplay: true, forceInitialArgs: false }, story) {
    this.channel = channel2;
    this.store = store;
    this.renderToScreen = renderToScreen;
    this.callbacks = callbacks;
    this.id = id;
    this.viewMode = viewMode;
    this.renderOptions = renderOptions;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = () => {
    };
    this.torndown = false;
    this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = "preparing");
  }
  async runPhase(signal, phase, phaseFn) {
    this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));
  }
  checkIfAborted(signal) {
    return signal.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), signal.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(canvasElement) {
    return this.canvasElement = canvasElement, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs });
  }
  async render({
    initial = false,
    forceRemount = false
  } = {}) {
    let { canvasElement } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let story = this.story;
    if (!canvasElement)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id,
      componentId,
      title,
      name,
      tags,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      unboundStoryFn,
      playFunction,
      runStep
    } = story;
    forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());
    let abortSignal = this.abortController.signal, mounted = false, isMountDestructured = story.usesMount;
    try {
      let context = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal,
        canvasElement,
        loaded: {},
        step: (label, play) => runStep(label, play, context),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: async () => {
          let teardown = await this.renderToScreen(renderContext, canvasElement);
          this.teardownRender = teardown || (() => {
          }), mounted = true;
        },
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: async (...args) => {
          this.callbacks.showStoryDuringRender?.();
          let mountReturn = null;
          return await this.runPhase(abortSignal, "rendering", async () => {
            mountReturn = await story.mount(context)(...args);
          }), isMountDestructured && await this.runPhase(abortSignal, "playing"), mountReturn;
        }
      };
      context.context = context;
      let renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        tags,
        ...this.callbacks,
        showError: (error) => (this.phase = "errored", this.callbacks.showError(error)),
        showException: (error) => (this.phase = "errored", this.callbacks.showException(error)),
        forceRemount: forceRemount || this.notYetRendered,
        storyContext: context,
        storyFn: () => unboundStoryFn(context),
        unboundStoryFn
      };
      if (await this.runPhase(abortSignal, "loading", async () => {
        context.loaded = await applyLoaders(context);
      }), abortSignal.aborted)
        return;
      let cleanupCallbacks = await applyBeforeEach(context);
      if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = false, abortSignal.aborted))
        return;
      let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true, unhandledErrors = /* @__PURE__ */ new Set(), onError = (event) => {
        event.error && unhandledErrors.add(event.error);
      }, onUnhandledRejection = (event) => {
        event.reason && unhandledErrors.add(event.reason);
      };
      if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
        window?.addEventListener?.("error", onError), window?.addEventListener?.("unhandledrejection", onUnhandledRejection), this.disableKeyListeners = true;
        try {
          if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {
            throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
          }, await this.runPhase(abortSignal, "playing", async () => playFunction(context))), !mounted)
            throw new NoStoryMountedError();
          this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, "errored") : await this.runPhase(abortSignal, "played");
        } catch (error) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, "errored", async () => {
            this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw error;
          console.error(error);
        }
        if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(
          UNHANDLED_ERRORS_WHILE_PLAYING,
          Array.from(unhandledErrors).map(serializeError)
        ), this.disableKeyListeners = false, window?.removeEventListener?.("unhandledrejection", onUnhandledRejection), window?.removeEventListener?.("error", onError), abortSignal.aborted)
          return;
      }
      await this.runPhase(abortSignal, "completing", async () => {
        isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);
      }), await this.runPhase(abortSignal, "completed", async () => {
        this.channel.emit(STORY_RENDERED, id);
      }), this.phase !== "errored" && await this.runPhase(abortSignal, "afterEach", async () => {
        await applyAfterEach(context);
      });
      let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(
        (report) => report.status === "failed"
      ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
      await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: hasStoryErrored ? "error" : "success",
          reporters: context.reporting.reports
        })
      );
    } catch (err) {
      this.phase = "errored", this.callbacks.showException(err), await this.runPhase(
        abortSignal,
        "finished",
        async () => this.channel.emit(STORY_FINISHED, {
          storyId: id,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let i2 = 0; i2 < 3; i2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
var { fetch: fetch2 } = scope, STORY_INDEX_PATH = "./index.json", Preview = class {
  constructor(importFn2, getProjectAnnotations2, channel2 = addons$2.getChannel(), shouldInitialize = true) {
    this.importFn = importFn2;
    this.getProjectAnnotations = getProjectAnnotations2;
    this.channel = channel2;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((resolve, reject) => {
      this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;
    }), shouldInitialize && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: (_, method) => {
          if (this.storyStoreValue)
            return deprecate("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[method];
          throw new StoryStoreAccessedBeforeInitializationError();
        }
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);
      let userAgent = globalThis?.navigator?.userAgent;
      await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
    } catch (err) {
      this.rejectStoreInitializationPromise(err);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let projectAnnotations = await this.getProjectAnnotations();
      if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)
        throw new MissingRenderToCanvasError();
      return projectAnnotations;
    } catch (err) {
      throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(projectAnnotations) {
    this.projectAnnotationsBeforeInitialization = projectAnnotations;
    try {
      let storyIndex = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(storyIndex);
    } catch (err) {
      throw this.renderPreviewEntryError("Error loading story index:", err), err;
    }
  }
  async runBeforeAllHook(projectAnnotations) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
    } catch (err) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", err), err;
    }
  }
  async getStoryIndexFromServer() {
    let result = await fetch2(STORY_INDEX_PATH);
    if (result.status === 200)
      return result.json();
    throw new StoryIndexFetchError({ text: await result.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(storyIndex) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new StoryStore(
      storyIndex,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
    let payload = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(SET_GLOBALS, payload);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: getProjectAnnotations2
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations2;
    let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(projectAnnotations);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(storyIndex);
          return;
        }
        await this.onStoriesChanged({ storyIndex });
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: importFn2,
    storyIndex
  }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: importFn2, storyIndex });
  }
  async onUpdateGlobals({
    globals: updatedGlobals,
    currentStory
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {
      let { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      });
    } else {
      let { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      this.channel.emit(GLOBALS_UPDATED, {
        initialGlobals: initialGlobals5,
        userGlobals: globals,
        storyGlobals: {},
        globals
      });
    }
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(
      this.storyRenders.filter((r2) => r2.id === storyId && !r2.renderOptions.forceInitialArgs).map(
        (r2) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r2.story && r2.story.usesMount ? r2.remount() : r2.rerender()
        )
      )
    ), this.channel.emit(STORY_ARGS_UPDATED, {
      storyId,
      args: this.storyStoreValue.args.get(storyId)
    });
  }
  async onRequestArgTypesInfo({ id, payload }) {
    try {
      await this.storeInitializationPromise;
      let story = await this.storyStoreValue?.loadStory(payload);
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: true,
        payload: { argTypes: story?.argTypes || {} },
        error: null
      });
    } catch (e2) {
      this.channel.emit(ARGTYPES_INFO_RESPONSE, {
        id,
        success: false,
        error: e2?.message
      });
    }
  }
  async onResetArgs({ storyId, argNames }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
    let story = this.storyRenders.find((r2) => r2.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(story.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(storyId))
      ])
    ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
    await this.onUpdateArgs({ storyId, updatedArgs });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
  }
  async onForceRemount({ storyId }) {
    await Promise.all(this.storyRenders.filter((r2) => r2.id === storyId).map((r2) => r2.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((r2) => r2.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(story, element, callbacks, options) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "renderStoryToElement"
      });
    let render2 = new StoryRender(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      callbacks,
      story.id,
      "docs",
      options,
      story
    );
    return render2.renderToElement(element), this.storyRenders.push(render2), async () => {
      await this.teardownRender(render2);
    };
  }
  async teardownRender(render2, { viewModeChanged } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render2), await render2?.teardown?.({ viewModeChanged });
  }
  // API
  async loadStory({ storyId }) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId });
  }
  getStoryContext(story, { forceInitialArgs = false } = {}) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
  }
  async extract(options) {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options);
  }
  // UTILITIES
  renderPreviewEntryError(reason, err) {
    this.previewEntryError = err, logger$1.error(reason), logger$1.error(err), this.channel.emit(CONFIG_ERROR, err);
  }
};
var DocsContext = class {
  constructor(channel2, store, renderStoryToElement, csfFiles) {
    this.channel = channel2;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.storyIdByName = (storyName) => {
      let storyId = this.nameToStoryId.get(storyName);
      if (storyId)
        return storyId;
      throw new Error(`No story found with that name: ${storyName}`);
    };
    this.componentStories = () => this.componentStoriesValue;
    this.componentStoriesFromCSFFile = (csfFile) => this.store.componentStoriesFromCSFFile({ csfFile });
    this.storyById = (storyId) => {
      if (!storyId) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let csfFile = this.storyIdToCSFFile.get(storyId);
      if (!csfFile)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
      return this.store.storyFromCSFFile({ storyId, csfFile });
    };
    this.getStoryContext = (story) => ({
      ...this.store.getStoryContext(story),
      loaded: {},
      viewMode: "docs"
    });
    this.loadStory = (id) => this.store.loadStory({ storyId: id });
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index2) => {
      this.referenceCSFFile(csfFile);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(csfFile) {
    this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      let annotation = csfFile.stories[story.id];
      this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
    });
  }
  attachCSFFile(csfFile) {
    if (!this.exportsToCSFFile.has(csfFile.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(csfFile))
      return;
    this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
      this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
    });
  }
  referenceMeta(metaExports, attach) {
    let resolved = this.resolveModuleExport(metaExports);
    if (resolved.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    attach && this.attachCSFFile(resolved.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations } = this.store;
    if (!projectAnnotations)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return projectAnnotations;
  }
  resolveAttachedModuleExportType(moduleExportType) {
    if (moduleExportType === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
    if (moduleExportType === "meta")
      return { type: "meta", csfFile: firstAttachedCSFFile };
    let { component } = firstAttachedCSFFile.meta;
    if (!component)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component };
  }
  resolveModuleExport(moduleExportOrType) {
    let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
    if (!csfFile && moduleExportOrType && typeof moduleExportOrType == "object" && "default" in moduleExportOrType && (csfFile = this.exportsToCSFFile.get(moduleExportOrType.default)), csfFile)
      return { type: "meta", csfFile };
    let story = this.exportToStory.get(
      isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
    );
    return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
  }
  resolveOf(moduleExportOrType, validTypes = []) {
    let resolved;
    if (["component", "meta", "story"].includes(moduleExportOrType)) {
      let type5 = moduleExportOrType;
      resolved = this.resolveAttachedModuleExportType(type5);
    } else
      resolved = this.resolveModuleExport(moduleExportOrType);
    if (validTypes.length && !validTypes.includes(resolved.type)) {
      let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
      throw new Error(dedent$1`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (resolved.type) {
      case "component":
        return {
          ...resolved,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...resolved,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
        };
      case "story":
      default:
        return resolved;
    }
  }
};
var CsfDocsRender = class {
  constructor(channel2, store, entry, callbacks) {
    this.channel = channel2;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(
      entryExports,
      importPath,
      title
    ), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.story && this.story === other.story);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
    return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
    if (!docsParameter)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let renderer = await docsParameter.renderer(), { render: render2 } = renderer, renderDocs = async () => {
      try {
        await render2(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
      !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged }), this.torndown = true;
  }
};
var MdxDocsRender = class {
  constructor(channel2, store, entry, callbacks) {
    this.channel = channel2;
    this.store = store;
    this.entry = entry;
    this.callbacks = callbacks;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = entry.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw PREPARE_ABORTED;
    this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = false;
  }
  isEqual(other) {
    return !!(this.id === other.id && this.exports && this.exports === other.exports);
  }
  docsContext(renderStoryToElement) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new DocsContext(
      this.channel,
      this.store,
      renderStoryToElement,
      this.csfFiles
    );
  }
  async renderToElement(canvasElement, renderStoryToElement) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters ?? {};
    if (!docs)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render: render2 } = renderer, renderDocs = async () => {
      try {
        await render2(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
      } catch (err) {
        this.callbacks.showException(err);
      }
    };
    return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
      !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = true);
    }, renderDocs();
  }
  async teardown({ viewModeChanged } = {}) {
    this.teardownRender?.({ viewModeChanged }), this.torndown = true;
  }
};
var globalWindow = globalThis;
function focusInInput(event) {
  let target = event.composedPath && event.composedPath()[0] || event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
}
var ATTACHED_MDX_TAG = "attached-mdx", UNATTACHED_MDX_TAG = "unattached-mdx";
function isMdxEntry({ tags }) {
  return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
}
function isStoryRender(r2) {
  return r2.type === "story";
}
function isDocsRender(r2) {
  return r2.type === "docs";
}
function isCsfDocsRender(r2) {
  return isDocsRender(r2) && r2.subtype === "csf";
}
var PreviewWithSelection = class extends Preview {
  constructor(importFn2, getProjectAnnotations2, selectionStore, view) {
    super(importFn2, getProjectAnnotations2, void 0, false);
    this.importFn = importFn2;
    this.getProjectAnnotations = getProjectAnnotations2;
    this.selectionStore = selectionStore;
    this.view = view;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
    let { globals } = this.selectionStore.selectionSpecifier || {};
    globals && this.storyStoreValue.userGlobals.updateFromPersisted(globals), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(storyIndex) {
    return await super.initializeWithStoryIndex(storyIndex), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new CalledPreviewMethodBeforeInitializationError({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
    if (!entry) {
      storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new EmptyIndexError()) : this.renderStoryLoadingException(
        storySpecifier,
        new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
      );
      return;
    }
    let { id: storyId, type: viewMode } = entry;
    this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: getProjectAnnotations2
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: getProjectAnnotations2 }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: importFn2,
    storyIndex
  }) {
    await super.onStoriesChanged({ importFn: importFn2, storyIndex }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(event) {
    if (!this.storyRenders.find((r2) => r2.disableKeyListeners) && !focusInInput(event)) {
      let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
      this.channel.emit(PREVIEW_KEYDOWN, {
        event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
      });
    }
  }
  async onSetCurrentStory(selection) {
    this.selectionStore.setSelection({ viewMode: "story", ...selection }), await this.storeInitializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(queryParams) {
    this.selectionStore.setQueryParams(queryParams);
  }
  async onUpdateGlobals({ globals }) {
    let currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals, currentStory }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId, updatedArgs }) {
    super.onUpdateArgs({ storyId, updatedArgs });
  }
  async onPreloadStories({ ids }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(ids.map((id) => this.storyStoreValue?.loadEntry(id)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs } = {}) {
    let { renderToCanvas: renderToCanvas2 } = this;
    if (!this.storyStoreValue || !renderToCanvas2)
      throw new CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
    let { selection } = this.selectionStore;
    if (!selection)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId } = selection, entry;
    try {
      entry = await this.storyStoreValue.storyIdToEntry(storyId);
    } catch (err) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
      return;
    }
    let storyIdChanged = this.currentSelection?.storyId !== storyId, viewModeChanged = this.currentRender?.type !== entry.type;
    entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let render2;
    entry.type === "story" ? render2 = new StoryRender(
      this.channel,
      this.storyStoreValue,
      renderToCanvas2,
      this.mainStoryCallbacks(storyId),
      storyId,
      "story"
    ) : isMdxEntry(entry) ? render2 = new MdxDocsRender(
      this.channel,
      this.storyStoreValue,
      entry,
      this.mainStoryCallbacks(storyId)
    ) : render2 = new CsfDocsRender(
      this.channel,
      this.storyStoreValue,
      entry,
      this.mainStoryCallbacks(storyId)
    );
    let lastSelection = this.currentSelection;
    this.currentSelection = selection;
    let lastRender = this.currentRender;
    this.currentRender = render2;
    try {
      await render2.prepare();
    } catch (err) {
      lastRender && await this.teardownRender(lastRender), err !== PREPARE_ABORTED && this.renderStoryLoadingException(storyId, err);
      return;
    }
    let implementationChanged = !storyIdChanged && lastRender && !render2.isEqual(lastRender);
    if (persistedArgs && isStoryRender(render2) && (invariant(!!render2.story), this.storyStoreValue.args.updateFromPersisted(render2.story, persistedArgs)), lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
      this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
      return;
    }
    if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED$1, storyId), isStoryRender(render2)) {
      invariant(!!render2.story);
      let {
        parameters: parameters2,
        initialArgs,
        argTypes,
        unmappedArgs,
        initialGlobals: initialGlobals5,
        userGlobals,
        storyGlobals,
        globals
      } = this.storyStoreValue.getStoryContext(render2.story);
      this.channel.emit(STORY_PREPARED, {
        id: storyId,
        parameters: parameters2,
        initialArgs,
        argTypes,
        args: unmappedArgs
      }), this.channel.emit(GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
    } else {
      let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(GLOBALS_UPDATED, {
        globals,
        initialGlobals: initialGlobals5,
        storyGlobals: {},
        userGlobals: globals
      }), isCsfDocsRender(render2) || render2.entry.tags?.includes(ATTACHED_MDX_TAG)) {
        if (!render2.csfFiles)
          throw new MdxFileWithNoCsfReferencesError({ storyId });
        ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: render2.csfFiles[0]
        }));
      }
      this.channel.emit(DOCS_PREPARED, {
        id: storyId,
        parameters: parameters2
      });
    }
    isStoryRender(render2) ? (invariant(!!render2.story), this.storyRenders.push(render2), this.currentRender.renderToElement(
      this.view.prepareForStory(render2.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(render2, { viewModeChanged = false } = {}) {
    this.storyRenders = this.storyRenders.filter((r2) => r2 !== render2), await render2?.teardown?.({ viewModeChanged });
  }
  // UTILITIES
  mainStoryCallbacks(storyId) {
    return {
      showStoryDuringRender: () => this.view.showStoryDuringRender(),
      showMain: () => this.view.showMain(),
      showError: (err) => this.renderError(storyId, err),
      showException: (err) => this.renderException(storyId, err)
    };
  }
  renderPreviewEntryError(reason, err) {
    super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
  }
  renderStoryLoadingException(storySpecifier, err) {
    logger$1.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(storyId, error) {
    let { name = "Error", message = String(error), stack: stack2 } = error, renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack: stack2 }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay(error), logger$1.error(`Error rendering story '${storyId}':`), logger$1.error(error);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(storyId, { title, description }) {
    let renderId = this.currentRender?.renderId;
    this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay({ message: title, stack: description }), logger$1.error(`Error rendering story ${title}: ${description}`);
  }
};
var import_picoquery2 = __toESM$3(require_main(), 1);
var import_picoquery = __toESM$3(require_main(), 1);
var VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/, NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/, HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, validateArgs = (key = "", value) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? false : value == null || value instanceof Date || typeof value == "number" || typeof value == "boolean" ? true : typeof value == "string" ? VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value) : Array.isArray(value) ? value.every((v2) => validateArgs(key, v2)) : isPlainObject$3(value) ? Object.entries(value).every(([k2, v2]) => validateArgs(k2, v2)) : false, QUERY_OPTIONS = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(str2) {
    if (str2.startsWith("!")) {
      if (str2 === "!undefined")
        return;
      if (str2 === "!null")
        return null;
      if (str2 === "!true")
        return true;
      if (str2 === "!false")
        return false;
      if (str2.startsWith("!date(") && str2.endsWith(")"))
        return new Date(str2.replaceAll(" ", "+").slice(6, -1));
      if (str2.startsWith("!hex(") && str2.endsWith(")"))
        return `#${str2.slice(5, -1)}`;
      let color = str2.slice(1).match(COLOR_REGEXP);
      if (color)
        return str2.startsWith("!rgba") || str2.startsWith("!RGBA") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})` : str2.startsWith("!hsla") || str2.startsWith("!HSLA") ? `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})` : str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;
    }
    return NUMBER_REGEXP.test(str2) ? Number(str2) : str2;
  }
}, parseArgsParam = (argsString) => {
  let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
  return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value]) => validateArgs(key, value) ? Object.assign(acc, { [key]: value }) : (once.warn(dedent$1`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), acc), {});
};
var { history, document: document4 } = scope;
function pathToId(path) {
  let match = (path || "").match(/^\/story\/(.+)/);
  if (!match)
    throw new Error(`Invalid path '${path}',  must start with '/story/'`);
  return match[1];
}
var getQueryString = ({
  selection,
  extraParams
}) => {
  let search = document4?.location.search.slice(1), { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
  return `?${(0, import_picoquery2.stringify)({
    ...rest,
    ...extraParams,
    ...selection && { id: selection.storyId, viewMode: selection.viewMode }
  })}`;
}, setPath = (selection) => {
  if (!selection)
    return;
  let query = getQueryString({ selection }), { hash = "" } = document4.location;
  document4.title = selection.storyId, history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
}, isObject6 = (val) => val != null && typeof val == "object" && Array.isArray(val) === false, getFirstString = (v2) => {
  if (v2 !== void 0) {
    if (typeof v2 == "string")
      return v2;
    if (Array.isArray(v2))
      return getFirstString(v2[0]);
    if (isObject6(v2))
      return getFirstString(
        Object.values(v2).filter(Boolean)
      );
  }
}, getSelectionSpecifierFromPath = () => {
  if (typeof document4 < "u") {
    let queryStr = document4.location.search.slice(1), query = (0, import_picoquery2.parse)(queryStr), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
    if (typeof viewMode != "string" || !viewMode)
      viewMode = "story";
    else if (!viewMode.match(/docs|story/))
      return null;
    let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
    if (storyId)
      return { storySpecifier: storyId, args, globals, viewMode };
  }
  return null;
}, UrlStore = class {
  constructor() {
    this.selectionSpecifier = getSelectionSpecifierFromPath();
  }
  setSelection(selection) {
    this.selection = selection, setPath(this.selection);
  }
  setQueryParams(queryParams) {
    let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document4.location;
    history.replaceState({}, "", `${document4.location.pathname}${query}${hash}`);
  }
};
var import_ansi_to_html = __toESM$3(require_ansi_to_html(), 1), import_picoquery3 = __toESM$3(require_main(), 1);
var { document: document5 } = scope, PREPARING_DELAY = 100, Mode = /* @__PURE__ */ ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {}), classes = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, layoutClassMap = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, ansiConverter = new import_ansi_to_html.default({
  escapeXML: true
}), WebView = class {
  constructor() {
    this.testing = false;
    if (typeof document5 < "u") {
      let { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document5.location.search.slice(1));
      switch (__SPECIAL_TEST_PARAMETER__) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(story) {
    return this.showStory(), this.applyLayout(story.parameters.layout), document5.documentElement.scrollTop = 0, document5.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return document5.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), document5.documentElement.scrollTop = 0, document5.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return document5.getElementById("storybook-docs");
  }
  applyLayout(layout = "padded") {
    if (layout === "none") {
      document5.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(layout);
    let layoutClass = layoutClassMap[layout];
    document5.body.classList.remove(this.currentLayoutClass), document5.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
  }
  checkIfLayoutExists(layout) {
    layoutClassMap[layout] || logger$1.warn(
      dedent$1`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
    );
  }
  showMode(mode) {
    clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
      otherMode === mode ? document5.body.classList.add(classes[otherMode]) : document5.body.classList.remove(classes[otherMode]);
    });
  }
  showErrorDisplay({ message = "", stack: stack2 = "" }) {
    let header = message, detail = stack2, parts = message.split(`
`);
    parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`).replace(/^\n/, "")), document5.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document5.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode(
      "ERROR"
      /* ERROR */
    );
  }
  showNoPreview() {
    this.testing || (this.showMode(
      "NOPREVIEW"
      /* NOPREVIEW */
    ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode(
      "PREPARING_STORY"
      /* PREPARING_STORY */
    ) : this.preparingTimeout = setTimeout(
      () => this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ),
      PREPARING_DELAY
    );
  }
  showPreparingDocs({ immediate = false } = {}) {
    clearTimeout(this.preparingTimeout), immediate ? this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ) : this.preparingTimeout = setTimeout(() => this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ), PREPARING_DELAY);
  }
  showMain() {
    this.showMode(
      "MAIN"
      /* MAIN */
    );
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    document5.body.classList.add(classes.MAIN);
  }
};
var PreviewWeb$1 = class PreviewWeb extends PreviewWithSelection {
  constructor(importFn2, getProjectAnnotations2) {
    super(importFn2, getProjectAnnotations2, new UrlStore(), new WebView());
    this.importFn = importFn2;
    this.getProjectAnnotations = getProjectAnnotations2;
    scope.__STORYBOOK_PREVIEW__ = this;
  }
};
var { document: document6 } = scope, runScriptTypes = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], SCRIPT = "script", SCRIPTS_ROOT_ID = "scripts-root";
function simulateDOMContentLoaded() {
  let DOMContentLoadedEvent = document6.createEvent("Event");
  DOMContentLoadedEvent.initEvent("DOMContentLoaded", true, true), document6.dispatchEvent(DOMContentLoadedEvent);
}
function insertScript($script, callback, $scriptRoot) {
  let scriptEl = document6.createElement("script");
  scriptEl.type = $script.type === "module" ? "module" : "text/javascript", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document6.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();
}
function insertScriptsSequentially(scriptsToExecute, callback, index2 = 0) {
  scriptsToExecute[index2](() => {
    index2++, index2 === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index2);
  });
}
function simulatePageLoad($container) {
  let $scriptsRoot = document6.getElementById(SCRIPTS_ROOT_ID);
  $scriptsRoot ? $scriptsRoot.innerHTML = "" : ($scriptsRoot = document6.createElement("div"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document6.body.appendChild($scriptsRoot));
  let $scripts = Array.from($container.querySelectorAll(SCRIPT));
  if ($scripts.length) {
    let scriptsToExecute = [];
    $scripts.forEach(($script) => {
      let typeAttr = $script.getAttribute("type");
      (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
    }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
  } else
    simulateDOMContentLoaded();
}
var Markers$1;
(function(Markers2) {
  Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
})(Markers$1 = Markers$1 || (Markers$1 = {}));
var import_jsdoc_type_pratt_parser$1 = __toESM$3(require_dist$2(), 1);
var jsdocStringifyRules$1 = (0, import_jsdoc_type_pratt_parser$1.stringifyRules)(), originalJsdocStringifyObject$1 = jsdocStringifyRules$1.JsdocTypeObject;
jsdocStringifyRules$1.JsdocTypeAny = () => "any";
jsdocStringifyRules$1.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject$1(result, transform)})`;
jsdocStringifyRules$1.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules$1.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules$1.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules$1.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
var ADDON_ID6 = "storybook/docs";
var SNIPPET_RENDERED$1 = `${ADDON_ID6}/snippet-rendered`;
async function emitTransformCode$1(source, context) {
  let transform = context.parameters?.docs?.source?.transform, { id, unmappedArgs } = context, transformed = transform && source ? transform?.(source, context) : source, result = transformed ? await transformed : void 0;
  addons$2.getChannel().emit(SNIPPET_RENDERED$1, {
    id,
    source: result,
    args: unmappedArgs
  });
}
var config3 = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
}, configureActions = (options = {}) => {
  Object.assign(config3, options);
};
var findProto = (obj, callback) => {
  let proto = Object.getPrototypeOf(obj);
  return !proto || callback(proto) ? proto : findProto(proto, callback);
}, isReactSyntheticEvent = (e2) => !!(typeof e2 == "object" && e2 && findProto(e2, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e2.persist == "function"), serializeArg = (a2) => {
  if (isReactSyntheticEvent(a2)) {
    let e2 = Object.create(
      a2.constructor.prototype,
      Object.getOwnPropertyDescriptors(a2)
    );
    e2.persist();
    let viewDescriptor = Object.getOwnPropertyDescriptor(e2, "view"), view = viewDescriptor?.value;
    return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e2, "view", {
      ...viewDescriptor,
      value: Object.create(view.constructor.prototype)
    }), e2;
  }
  return a2;
};
function action(name, options = {}) {
  let actionOptions = {
    ...config3,
    ...options
  }, handler = function(...args) {
    if (options.implicit) {
      let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (render2) => render2.phase === "playing" || render2.phase === "rendering"
      );
      if (storyRenderer) {
        let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
          phase: storyRenderer.phase,
          name,
          deprecated
        });
        if (deprecated)
          console.warn(error);
        else
          throw error;
      }
    }
    let channel2 = addons$2.getChannel(), id = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3)
      }
    };
    channel2.emit(EVENT_ID, actionDisplayToEmit);
  };
  return handler.isAction = true, handler.implicit = options.implicit, handler;
}
var actions = (...args) => {
  let options = config3, names = args;
  names.length === 1 && Array.isArray(names[0]) && ([names] = names), names.length !== 1 && typeof names[names.length - 1] != "string" && (options = {
    ...config3,
    ...names.pop()
  });
  let namesObject = names[0];
  (names.length !== 1 || typeof namesObject == "string") && (namesObject = {}, names.forEach((name) => {
    namesObject[name] = name;
  }));
  let actionsObject = {};
  return Object.keys(namesObject).forEach((name) => {
    actionsObject[name] = action(namesObject[name], options);
  }), actionsObject;
};
var globalsNameValueMap = {
  "@storybook/global": dist_exports,
  "storybook/test": test_exports,
  "storybook/actions": actions_exports,
  "storybook/preview-api": preview_api_exports,
  "storybook/internal/channels": channels_exports,
  "storybook/internal/client-logger": client_logger_exports,
  "storybook/internal/core-events": core_events_exports,
  "storybook/internal/types": types_exports,
  "storybook/internal/preview-errors": preview_errors_exports,
  "storybook/internal/preview-api": preview_api_exports
};
async function maybeSetupPreviewNavigator() {
  let url = new URL(window.location.href);
  if (url.searchParams.get("navigator") !== "true" || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = true;
  let index2 = await (await fetch("/index.json")).json(), currentEntryId = url.searchParams.get("id");
  if (!currentEntryId) {
    let firstEntry = Object.values(index2.entries)[0];
    firstEntry && (url.searchParams.set("id", firstEntry.id), url.searchParams.set("viewMode", firstEntry.type), window.location.href = url.toString());
    return;
  }
  setupPreviewNavigator(index2, currentEntryId);
}
var setupPreviewNavigator = async (index2, currentEntryId) => {
  let tree = { entries: {} };
  for (let entry of Object.values(index2.entries)) {
    let titleParts = entry.title.split("/"), currentNode = tree;
    for (let titlePart of titleParts)
      currentNode.entries || (currentNode.entries = {}), currentNode.entries[titlePart] ? currentEntryId === entry.id && (currentNode.entries[titlePart].isActive = true) : currentNode.entries[titlePart] = {
        title: titlePart,
        isActive: currentEntryId === entry.id,
        entries: {}
      }, currentNode = currentNode.entries[titlePart];
    currentNode.entries || (currentNode.entries = {}), currentNode.entries[entry.name] = {
      id: entry.id,
      name: entry.name,
      href: `?id=${entry.id}&viewMode=${entry.type}&navigator=true`,
      isActive: currentEntryId === entry.id
    };
  }
  let createHtmlForNode = (node) => {
    if ("entries" in node && "title" in node) {
      let branchNode = node;
      return `
      <li class="sb-navigator-branch">
        <details${branchNode.isActive ? " open" : ""}>
          <summary class="sb-navigator-title">
            ${branchNode.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${branchNode.title}">
            ${Object.values(branchNode.entries).map(createHtmlForNode).join("")}
          </ul>
        </details>
      </li>
      `;
    }
    let leafNode = node;
    return `
      <li class="sb-navigator-story-item">
        <a href="${leafNode.href}" 
           class="sb-navigator-story-link${leafNode.isActive ? " active" : ""}" 
           aria-current="${leafNode.isActive ? "location" : "false"}">${leafNode.name}</a>
      </li>
    `;
  }, navItems = Object.values(tree.entries).map(createHtmlForNode).join(""), nav = document.createElement("nav");
  nav.id = "sb-navigator-container", nav.setAttribute("role", "navigation"), nav.setAttribute("aria-label", "Story navigation"), nav.innerHTML = `
    <ul class="sb-navigator-list">${navItems}</ul>
  `, document.body.insertBefore(nav, document.body.firstChild);
  let style = document.createElement("style");
  style.id = "sb-navigator-style", style.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: hsl(212 100 46);
    }
  `, document.head.appendChild(style), nav.querySelector(".sb-navigator-story-link.active")?.closest("details")?.scrollIntoView({ block: "center" });
};
var import_browser_dtector = __toESM$3(require_browser_dtector_umd_min(), 1), browserInfo;
function getBrowserInfo() {
  return browserInfo || (browserInfo = new import_browser_dtector.default(scope.navigator?.userAgent).getBrowserInfo()), browserInfo;
}
function prepareForTelemetry(error) {
  return error.browserInfo = getBrowserInfo(), error;
}
function errorListener(args) {
  let error = args.error || args;
  error.fromStorybook && scope.sendTelemetryError(error);
}
function unhandledRejectionListener({ reason }) {
  reason.fromStorybook && scope.sendTelemetryError(reason);
}
function setup() {
  globalPackages.forEach((key) => {
    scope[globalsNameReferenceMap[key]] = globalsNameValueMap[key];
  }), scope.sendTelemetryError = (error) => {
    scope.__STORYBOOK_ADDONS_CHANNEL__.emit(TELEMETRY_ERROR, prepareForTelemetry(error));
  }, document.addEventListener("DOMContentLoaded", () => {
    scope.__STORYBOOK_ADDONS_CHANNEL__.on(MANAGER_INERT_ATTRIBUTE_CHANGED, (isInert3) => {
      isInert3 ? document.body.setAttribute("inert", "true") : document.body.removeAttribute("inert");
    });
  }), scope.addEventListener("error", errorListener), scope.addEventListener("unhandledrejection", unhandledRejectionListener), maybeSetupPreviewNavigator();
}
setup();
const { createBrowserChannel } = __STORYBOOK_MODULE_CHANNELS__;
const { addons: addons$1 } = __STORYBOOK_MODULE_PREVIEW_API__;
const channel = createBrowserChannel({ page: "preview" });
addons$1.setChannel(channel);
window.__STORYBOOK_ADDONS_CHANNEL__ = channel;
if (window.CONFIG_TYPE === "DEVELOPMENT") {
  window.__STORYBOOK_SERVER_CHANNEL__ = channel;
}
var __create$2 = Object.create;
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf, __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __require$1 = /* @__PURE__ */ ((x2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require < "u" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS$2 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export$3 = (target, all) => {
  for (var name in all)
    __defProp$4(target, name, { get: all[name], enumerable: true });
}, __copyProps$2 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames$2(from))
      !__hasOwnProp$3.call(to, key) && key !== except && __defProp$4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable });
  return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp$4(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
function isPlainObject$2(value) {
  if (!value || typeof value != "object")
    return false;
  let proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === "[object Object]" : false;
}
function isPrimitive(value) {
  return value == null || typeof value != "object" && typeof value != "function";
}
function isTypedArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var regexpTag = "[object RegExp]", stringTag = "[object String]", numberTag = "[object Number]", booleanTag = "[object Boolean]", argumentsTag = "[object Arguments]", symbolTag = "[object Symbol]", dateTag = "[object Date]", mapTag = "[object Map]", setTag = "[object Set]", arrayTag = "[object Array]", functionTag = "[object Function]", arrayBufferTag = "[object ArrayBuffer]", objectTag = "[object Object]", errorTag = "[object Error]", dataViewTag = "[object DataView]", uint8ArrayTag = "[object Uint8Array]", uint8ClampedArrayTag = "[object Uint8ClampedArray]", uint16ArrayTag = "[object Uint16Array]", uint32ArrayTag = "[object Uint32Array]", bigUint64ArrayTag = "[object BigUint64Array]", int8ArrayTag = "[object Int8Array]", int16ArrayTag = "[object Int16Array]", int32ArrayTag = "[object Int32Array]", bigInt64ArrayTag = "[object BigInt64Array]", float32ArrayTag = "[object Float32Array]", float64ArrayTag = "[object Float64Array]";
function mapValues(object, getNewValue) {
  let result = {}, keys2 = Object.keys(object);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2], value = object[key];
    result[key] = getNewValue(value, key, object);
  }
  return result;
}
function isUnsafeProperty(key) {
  return key === "__proto__";
}
function mergeWith(target, source, merge2) {
  let sourceKeys = Object.keys(source);
  for (let i2 = 0; i2 < sourceKeys.length; i2++) {
    let key = sourceKeys[i2];
    if (isUnsafeProperty(key))
      continue;
    let sourceValue = source[key], targetValue = target[key], merged = merge2(targetValue, sourceValue, key, target, source);
    merged !== void 0 ? target[key] = merged : Array.isArray(sourceValue) ? Array.isArray(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith([], sourceValue, merge2) : isPlainObject$2(sourceValue) ? isPlainObject$2(targetValue) ? target[key] = mergeWith(targetValue, sourceValue, merge2) : target[key] = mergeWith({}, sourceValue, merge2) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
  }
  return target;
}
function pick(obj, keys2) {
  let result = {};
  for (let i2 = 0; i2 < keys2.length; i2++) {
    let key = keys2[i2];
    Object.hasOwn(obj, key) && (result[key] = obj[key]);
  }
  return result;
}
function clone(obj) {
  if (isPrimitive(obj))
    return obj;
  if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && obj instanceof SharedArrayBuffer)
    return obj.slice(0);
  let prototype = Object.getPrototypeOf(obj), Constructor = prototype.constructor;
  if (obj instanceof Date || obj instanceof Map || obj instanceof Set)
    return new Constructor(obj);
  if (obj instanceof RegExp) {
    let newRegExp = new Constructor(obj);
    return newRegExp.lastIndex = obj.lastIndex, newRegExp;
  }
  if (obj instanceof DataView)
    return new Constructor(obj.buffer.slice(0));
  if (obj instanceof Error) {
    let newError = new Constructor(obj.message);
    return newError.stack = obj.stack, newError.name = obj.name, newError.cause = obj.cause, newError;
  }
  if (typeof File < "u" && obj instanceof File)
    return new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
  if (typeof obj == "object") {
    let newObject = Object.create(prototype);
    return Object.assign(newObject, obj);
  }
  return obj;
}
function toMerged(target, source) {
  return mergeWith(clone(target), source, function mergeRecursively(targetValue, sourceValue) {
    if (Array.isArray(sourceValue))
      return Array.isArray(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith([], sourceValue, mergeRecursively);
    if (isPlainObject$2(sourceValue))
      return isPlainObject$2(targetValue) ? mergeWith(clone(targetValue), sourceValue, mergeRecursively) : mergeWith({}, sourceValue, mergeRecursively);
  });
}
var require_dist$1 = __commonJS$2({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module2) {
    (function(global3, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global3 = typeof globalThis < "u" ? globalThis : global3 || self, factory(global3.jtpp = {}));
    })(exports, function(exports2) {
      function tokenToString(token) {
        return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
      }
      class NoParsletFoundError extends Error {
        constructor(token) {
          super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, NoParsletFoundError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class EarlyEndOfParseError extends Error {
        constructor(token) {
          super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
        }
        getToken() {
          return this.token;
        }
      }
      class UnexpectedTypeError extends Error {
        constructor(result, message) {
          let error = `Unexpected type: '${result.type}'.`;
          message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
        }
      }
      function makePunctuationRule(type5) {
        return (text) => text.startsWith(type5) ? { type: type5, text: type5 } : null;
      }
      function getQuoted(text) {
        let position = 0, char, mark = text[0], escaped = false;
        if (mark !== "'" && mark !== '"')
          return null;
        for (; position < text.length; ) {
          if (position++, char = text[position], !escaped && char === mark) {
            position++;
            break;
          }
          escaped = !escaped && char === "\\";
        }
        if (char !== mark)
          throw new Error("Unterminated String");
        return text.slice(0, position);
      }
      let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char))
          return null;
        let position = 1;
        do {
          if (char = text[position], !identifierContinueRegex.test(char))
            break;
          position++;
        } while (position < text.length);
        return text.slice(0, position);
      }
      let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function getNumber(text) {
        var _a3, _b;
        return (_b = (_a3 = numberRegex.exec(text)) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : null;
      }
      let identifierRule = (text) => {
        let value = getIdentifier(text);
        return value == null ? null : {
          type: "Identifier",
          text: value
        };
      };
      function makeKeyWordRule(type5) {
        return (text) => {
          if (!text.startsWith(type5))
            return null;
          let prepends = text[type5.length];
          return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
            type: type5,
            text: type5
          };
        };
      }
      let stringValueRule = (text) => {
        let value = getQuoted(text);
        return value == null ? null : {
          type: "StringValue",
          text: value
        };
      }, eofRule = (text) => text.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, numberRule = (text) => {
        let value = getNumber(text);
        return value === null ? null : {
          type: "Number",
          text: value
        };
      }, rules = [
        eofRule,
        makePunctuationRule("=>"),
        makePunctuationRule("("),
        makePunctuationRule(")"),
        makePunctuationRule("{"),
        makePunctuationRule("}"),
        makePunctuationRule("["),
        makePunctuationRule("]"),
        makePunctuationRule("|"),
        makePunctuationRule("&"),
        makePunctuationRule("<"),
        makePunctuationRule(">"),
        makePunctuationRule(","),
        makePunctuationRule(";"),
        makePunctuationRule("*"),
        makePunctuationRule("?"),
        makePunctuationRule("!"),
        makePunctuationRule("="),
        makePunctuationRule(":"),
        makePunctuationRule("..."),
        makePunctuationRule("."),
        makePunctuationRule("#"),
        makePunctuationRule("~"),
        makePunctuationRule("/"),
        makePunctuationRule("@"),
        makeKeyWordRule("undefined"),
        makeKeyWordRule("null"),
        makeKeyWordRule("function"),
        makeKeyWordRule("this"),
        makeKeyWordRule("new"),
        makeKeyWordRule("module"),
        makeKeyWordRule("event"),
        makeKeyWordRule("extends"),
        makeKeyWordRule("external"),
        makeKeyWordRule("infer"),
        makeKeyWordRule("typeof"),
        makeKeyWordRule("keyof"),
        makeKeyWordRule("readonly"),
        makeKeyWordRule("import"),
        makeKeyWordRule("is"),
        makeKeyWordRule("in"),
        makeKeyWordRule("asserts"),
        numberRule,
        identifierRule,
        stringValueRule
      ], breakingWhitespaceRegex = /^\s*\n\s*/;
      class Lexer {
        static create(text) {
          let current = this.read(text);
          text = current.text;
          let next = this.read(text);
          return text = next.text, new Lexer(text, void 0, current.token, next.token);
        }
        constructor(text, previous, current, next) {
          this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
        }
        static read(text, startOfLine = false) {
          startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
          for (let rule of rules) {
            let partial = rule(text);
            if (partial !== null) {
              let token = Object.assign(Object.assign({}, partial), { startOfLine });
              return text = text.slice(token.text.length), { text, token };
            }
          }
          throw new Error("Unexpected Token " + text);
        }
        advance() {
          let next = Lexer.read(this.text);
          return new Lexer(next.text, this.current, this.next, next.token);
        }
      }
      function assertRootResult(result) {
        if (result === void 0)
          throw new Error("Unexpected undefined");
        if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertPlainKeyValueOrRootResult(result) {
        return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
      }
      function assertPlainKeyValueOrNameResult(result) {
        return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
      }
      function assertPlainKeyValueResult(result) {
        if (result.type !== "JsdocTypeKeyValue")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertNumberOrVariadicNameResult(result) {
        var _a3;
        if (result.type === "JsdocTypeVariadic") {
          if (((_a3 = result.element) === null || _a3 === void 0 ? void 0 : _a3.type) === "JsdocTypeName")
            return result;
          throw new UnexpectedTypeError(result);
        }
        if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
          throw new UnexpectedTypeError(result);
        return result;
      }
      function assertArrayOrTupleResult(result) {
        if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
          return result;
        throw new UnexpectedTypeError(result);
      }
      function isSquaredProperty(result) {
        return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
      }
      var Precedence;
      (function(Precedence2) {
        Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(Precedence || (Precedence = {}));
      class Parser {
        constructor(grammar, textOrLexer, baseParser) {
          this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          let result = this.parseType(Precedence.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new EarlyEndOfParseError(this.lexer.current);
          return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
          return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
          let result = this.tryParslets(null, precedence);
          if (result === null)
            throw new NoParsletFoundError(this.lexer.current);
          return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
          let result = this.tryParslets(left, precedence);
          for (; result !== null; )
            left = result, result = this.tryParslets(left, precedence);
          return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
          for (let parslet of this.grammar) {
            let result = parslet(this, precedence, left);
            if (result !== null)
              return result;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
          return Array.isArray(types) || (types = [types]), types.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), true) : false;
        }
        acceptLexerState(parser) {
          this._lexer = parser.lexer;
        }
      }
      function isQuestionMarkUnknownType(next) {
        return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
      }
      let nullableParslet = (parser, precedence, left) => {
        let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
        return left == null && type5 === "?" && !isQuestionMarkUnknownType(next) || left != null && type5 === "?" ? (parser.consume("?"), left == null ? {
          type: "JsdocTypeNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        }) : null;
      };
      function composeParslet(options) {
        let parslet = (parser, curPrecedence, left) => {
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (left === null) {
            if ("parsePrefix" in options && options.accept(type5, next))
              return options.parsePrefix(parser);
          } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type5, next))
            return options.parseInfix(parser, left);
          return null;
        };
        return Object.defineProperty(parslet, "name", {
          value: options.name
        }), parslet;
      }
      let optionalParslet = composeParslet({
        name: "optionalParslet",
        accept: (type5) => type5 === "=",
        precedence: Precedence.OPTIONAL,
        parsePrefix: (parser) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: parser.parseType(Precedence.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("="), {
          type: "JsdocTypeOptional",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      }), numberParslet = composeParslet({
        name: "numberParslet",
        accept: (type5) => type5 === "Number",
        parsePrefix: (parser) => {
          let value = parseFloat(parser.lexer.current.text);
          return parser.consume("Number"), {
            type: "JsdocTypeNumber",
            value
          };
        }
      }), parenthesisParslet = composeParslet({
        name: "parenthesisParslet",
        accept: (type5) => type5 === "(",
        parsePrefix: (parser) => {
          if (parser.consume("("), parser.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          let result = parser.parseIntermediateType(Precedence.ALL);
          if (!parser.consume(")"))
            throw new Error("Unterminated parenthesis");
          return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [result]
          } : {
            type: "JsdocTypeParenthesis",
            element: assertRootResult(result)
          };
        }
      }), specialTypesParslet = composeParslet({
        name: "specialTypesParslet",
        accept: (type5, next) => type5 === "?" && isQuestionMarkUnknownType(next) || type5 === "null" || type5 === "undefined" || type5 === "*",
        parsePrefix: (parser) => {
          if (parser.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (parser.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (parser.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (parser.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + parser.lexer.current.text);
        }
      }), notNullableParslet = composeParslet({
        name: "notNullableParslet",
        accept: (type5) => type5 === "!",
        precedence: Precedence.NULLABLE,
        parsePrefix: (parser) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: parser.parseType(Precedence.NULLABLE),
          meta: {
            position: "prefix"
          }
        }),
        parseInfix: (parser, left) => (parser.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: assertRootResult(left),
          meta: {
            position: "suffix"
          }
        })
      });
      function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
          name: "parameterListParslet",
          accept: (type5) => type5 === ",",
          precedence: Precedence.PARAMETER_LIST,
          parseInfix: (parser, left) => {
            let elements2 = [
              assertPlainKeyValueOrRootResult(left)
            ];
            parser.consume(",");
            do
              try {
                let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                elements2.push(assertPlainKeyValueOrRootResult(next));
              } catch (e2) {
                if (e2 instanceof NoParsletFoundError)
                  break;
                throw e2;
              }
            while (parser.consume(","));
            if (elements2.length > 0 && elements2.slice(0, -1).some((e2) => e2.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements: elements2
            };
          }
        });
      }
      let genericParslet = composeParslet({
        name: "genericParslet",
        accept: (type5, next) => type5 === "<" || type5 === "." && next === "<",
        precedence: Precedence.GENERIC,
        parseInfix: (parser, left) => {
          let dot = parser.consume(".");
          parser.consume("<");
          let objects = [], infer = false;
          if (parser.consume("infer")) {
            infer = true;
            let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left2.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
            objects.push(left2);
          } else
            do
              objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            while (parser.consume(","));
          if (!parser.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {
            brackets: "angle",
            dot
          } });
        }
      }), unionParslet = composeParslet({
        name: "unionParslet",
        accept: (type5) => type5 === "|",
        precedence: Precedence.UNION,
        parseInfix: (parser, left) => {
          parser.consume("|");
          let elements2 = [];
          do
            elements2.push(parser.parseType(Precedence.UNION));
          while (parser.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [assertRootResult(left), ...elements2]
          };
        }
      }), baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
          allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
      ];
      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
        return function(parser, precedence, left) {
          if (left == null || precedence >= Precedence.NAME_PATH)
            return null;
          let type5 = parser.lexer.current.type, next = parser.lexer.next.type;
          if (!(type5 === "." && next !== "<" || type5 === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type5 === "~" || type5 === "#")))
            return null;
          let pathType, brackets = false;
          parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = true) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
          let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
          parser.acceptLexerState(pathParser);
          let right;
          switch (parsed.type) {
            case "JsdocTypeName":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              right = {
                type: "JsdocTypeProperty",
                value: parsed.value,
                meta: {
                  quote: parsed.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (parsed.specialType === "event")
                right = parsed;
              else
                throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (brackets && !parser.consume("]")) {
            let token = parser.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: assertRootResult(left),
            right,
            pathType
          };
        };
      }
      function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
          name: "nameParslet",
          accept: (type5) => type5 === "Identifier" || type5 === "this" || type5 === "new" || allowedAdditionalTokens.includes(type5),
          parsePrefix: (parser) => {
            let { type: type5, text } = parser.lexer.current;
            return parser.consume(type5), {
              type: "JsdocTypeName",
              value: text
            };
          }
        });
      }
      let stringValueParslet = composeParslet({
        name: "stringValueParslet",
        accept: (type5) => type5 === "StringValue",
        parsePrefix: (parser) => {
          let text = parser.lexer.current.text;
          return parser.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: text.slice(1, -1),
            meta: {
              quote: text[0] === "'" ? "single" : "double"
            }
          };
        }
      });
      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
        return composeParslet({
          name: "specialNamePathParslet",
          accept: (type5) => allowedTypes.includes(type5),
          parsePrefix: (parser) => {
            let type5 = parser.lexer.current.type;
            if (parser.consume(type5), !parser.consume(":"))
              return {
                type: "JsdocTypeName",
                value: type5
              };
            let result, token = parser.lexer.current;
            if (parser.consume("StringValue"))
              result = {
                type: "JsdocTypeSpecialNamePath",
                value: token.text.slice(1, -1),
                specialType: type5,
                meta: {
                  quote: token.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let value = "", allowed = ["Identifier", "@", "/"];
              for (; allowed.some((type22) => parser.consume(type22)); )
                value += token.text, token = parser.lexer.current;
              result = {
                type: "JsdocTypeSpecialNamePath",
                value,
                specialType: type5,
                meta: {
                  quote: void 0
                }
              };
            }
            let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
            return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
          }
        });
      }
      let basePathGrammar = [
        createNameParslet({
          allowedAdditionalTokens: ["external", "module"]
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar: null
        })
      ], pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
          allowedTypes: ["event"],
          pathGrammar: basePathGrammar
        })
      ];
      function getParameters(value) {
        let parameters2;
        if (value.type === "JsdocTypeParameterList")
          parameters2 = value.elements;
        else if (value.type === "JsdocTypeParenthesis")
          parameters2 = [value.element];
        else
          throw new UnexpectedTypeError(value);
        return parameters2.map((p2) => assertPlainKeyValueOrRootResult(p2));
      }
      function getUnnamedParameters(value) {
        let parameters2 = getParameters(value);
        if (parameters2.some((p2) => p2.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return parameters2;
      }
      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
          name: "functionParslet",
          accept: (type5, next) => type5 === "function" || allowNewAsFunctionKeyword && type5 === "new" && next === "(",
          parsePrefix: (parser) => {
            let newKeyword = parser.consume("new");
            parser.consume("function");
            let hasParenthesis = parser.lexer.current.type === "(";
            if (!hasParenthesis) {
              if (!allowWithoutParenthesis)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let result = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: false,
              constructor: newKeyword,
              parenthesis: hasParenthesis
            }, value = parser.parseIntermediateType(Precedence.FUNCTION);
            if (allowNamedParameters === void 0)
              result.parameters = getUnnamedParameters(value);
            else {
              if (newKeyword && value.type === "JsdocTypeFunction" && value.arrow)
                return result = value, result.constructor = true, result;
              result.parameters = getParameters(value);
              for (let p2 of result.parameters)
                if (p2.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p2.key))
                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p2.type}`);
            }
            if (parser.consume(":"))
              result.returnType = parser.parseType(Precedence.PREFIX);
            else if (!allowNoReturnType)
              throw new Error("function is missing return type");
            return result;
          }
        });
      }
      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
          name: "variadicParslet",
          accept: (type5) => type5 === "...",
          precedence: Precedence.PREFIX,
          parsePrefix: (parser) => {
            parser.consume("...");
            let brackets = allowEnclosingBrackets && parser.consume("[");
            try {
              let element = parser.parseType(Precedence.PREFIX);
              if (brackets && !parser.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: assertRootResult(element),
                meta: {
                  position: "prefix",
                  squareBrackets: brackets
                }
              };
            } catch (e2) {
              if (e2 instanceof NoParsletFoundError) {
                if (brackets)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: false
                  }
                };
              } else
                throw e2;
            }
          },
          parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
            type: "JsdocTypeVariadic",
            element: assertRootResult(left),
            meta: {
              position: "suffix",
              squareBrackets: false
            }
          }) : void 0
        });
      }
      let symbolParslet = composeParslet({
        name: "symbolParslet",
        accept: (type5) => type5 === "(",
        precedence: Precedence.SYMBOL,
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          parser.consume("(");
          let result = {
            type: "JsdocTypeSymbol",
            value: left.value
          };
          if (!parser.consume(")")) {
            let next = parser.parseIntermediateType(Precedence.SYMBOL);
            if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return result;
        }
      }), arrayBracketsParslet = composeParslet({
        name: "arrayBracketsParslet",
        precedence: Precedence.ARRAY_BRACKETS,
        accept: (type5, next) => type5 === "[" && next === "]",
        parseInfix: (parser, left) => (parser.consume("["), parser.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            assertRootResult(left)
          ],
          meta: {
            brackets: "square",
            dot: false
          }
        })
      });
      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
        return composeParslet({
          name: "objectParslet",
          accept: (type5) => type5 === "{",
          parsePrefix: (parser) => {
            parser.consume("{");
            let result = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!parser.consume("}")) {
              let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
              for (; ; ) {
                fieldParser.acceptLexerState(parser);
                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                let optional = false;
                if (field.type === "JsdocTypeNullable" && (optional = true, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                  let quote2;
                  field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                    type: "JsdocTypeObjectField",
                    key: field.value.toString(),
                    right: void 0,
                    optional,
                    readonly: false,
                    meta: {
                      quote: quote2
                    }
                  });
                } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                  result.elements.push(field);
                else
                  throw new UnexpectedTypeError(field);
                if (parser.lexer.current.startOfLine)
                  separator = "linebreak", parser.consume(",") || parser.consume(";");
                else if (parser.consume(","))
                  separator = "comma";
                else if (parser.consume(";"))
                  separator = "semicolon";
                else
                  break;
                if (parser.lexer.current.type === "}")
                  break;
              }
              if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return result;
          }
        });
      }
      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
          name: "objectFieldParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            var _a3;
            let optional = false, readonlyProperty = false;
            allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = true, left = left.element);
            let parentParser = (_a3 = parser.baseParser) !== null && _a3 !== void 0 ? _a3 : parser;
            if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
              if (isSquaredProperty(left) && !allowSquaredProperties)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let quote2;
              left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeObjectField",
                key: isSquaredProperty(left) ? left : left.value.toString(),
                right,
                optional,
                readonly: readonlyProperty,
                meta: {
                  quote: quote2
                }
              };
            } else {
              if (!allowKeyTypes)
                throw new UnexpectedTypeError(left);
              parentParser.consume(":");
              let right = parentParser.parseType(Precedence.KEY_VALUE);
              return parser.acceptLexerState(parentParser), {
                type: "JsdocTypeJsdocObjectField",
                left: assertRootResult(left),
                right
              };
            }
          }
        });
      }
      function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
          name: "keyValueParslet",
          precedence: Precedence.KEY_VALUE,
          accept: (type5) => type5 === ":",
          parseInfix: (parser, left) => {
            let optional = false, variadic = false;
            if (allowOptional && left.type === "JsdocTypeNullable" && (optional = true, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = true, left = left.element), left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left);
            parser.consume(":");
            let right = parser.parseType(Precedence.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: left.value,
              right,
              optional,
              variadic
            };
          }
        });
      }
      let jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
          allowedTypes: ["module", "external", "event"],
          pathGrammar
        }),
        createVariadicParslet({
          allowEnclosingBrackets: true,
          allowPostfix: true
        }),
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        })
      ], jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            createNameParslet({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            createObjectFieldParslet({
              allowSquaredProperties: false,
              allowKeyTypes: true,
              allowOptional: false,
              allowReadonly: false
            }),
            ...jsdocBaseGrammar
          ],
          allowKeyTypes: true
        }),
        createKeyValueParslet({
          allowOptional: true,
          allowVariadic: true
        })
      ], typeOfParslet = composeParslet({
        name: "typeOfParslet",
        accept: (type5) => type5 === "typeof",
        parsePrefix: (parser) => (parser.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
        })
      }), objectFieldGrammar$1 = [
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: false,
          allowKeyTypes: false,
          allowOptional: false,
          allowReadonly: false
        })
      ], closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        typeOfParslet,
        createFunctionParslet({
          allowWithoutParenthesis: false,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: true,
          allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
          allowedAdditionalTokens: ["keyof"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        createNamePathParslet({
          allowSquareBracketsOnAnyType: false,
          allowJsdocNamePaths: true,
          pathGrammar
        }),
        createKeyValueParslet({
          allowOptional: false,
          allowVariadic: false
        }),
        symbolParslet
      ], assertsParslet = composeParslet({
        name: "assertsParslet",
        accept: (type5) => type5 === "asserts",
        parsePrefix: (parser) => {
          parser.consume("asserts");
          let left = parser.parseIntermediateType(Precedence.SYMBOL);
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
          return parser.consume("is") ? {
            type: "JsdocTypeAsserts",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: left
          };
        }
      });
      function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
          name: "tupleParslet",
          accept: (type5) => type5 === "[",
          parsePrefix: (parser) => {
            parser.consume("[");
            let result = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (parser.consume("]"))
              return result;
            let typeList = parser.parseIntermediateType(Precedence.ALL);
            if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
              throw new Error("Unterminated '['");
            if (result.elements.some((e2) => e2.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return result;
          }
        });
      }
      let keyOfParslet = composeParslet({
        name: "keyOfParslet",
        accept: (type5) => type5 === "keyof",
        parsePrefix: (parser) => (parser.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
        })
      }), importParslet = composeParslet({
        name: "importParslet",
        accept: (type5) => type5 === "import",
        parsePrefix: (parser) => {
          if (parser.consume("import"), !parser.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          let path = parser.parseType(Precedence.PREFIX);
          if (path.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!parser.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: path
          };
        }
      }), readonlyPropertyParslet = composeParslet({
        name: "readonlyPropertyParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: parser.parseIntermediateType(Precedence.KEY_VALUE)
        })
      }), arrowFunctionParslet = composeParslet({
        name: "arrowFunctionParslet",
        precedence: Precedence.ARROW,
        accept: (type5) => type5 === "=>",
        parseInfix: (parser, left) => (parser.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
          arrow: true,
          constructor: false,
          parenthesis: true,
          returnType: parser.parseType(Precedence.OBJECT)
        })
      }), genericArrowFunctionParslet = composeParslet({
        name: "genericArrowFunctionParslet",
        accept: (type5) => type5 === "<",
        parsePrefix: (parser) => {
          let typeParameters = [];
          parser.consume("<");
          do {
            let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
            if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(name);
            let constraint;
            parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
            let typeParameter = {
              type: "JsdocTypeTypeParameter",
              name
            };
            if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
              break;
          } while (parser.consume(","));
          let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
          return functionBase.typeParameters = typeParameters, functionBase;
        }
      }), intersectionParslet = composeParslet({
        name: "intersectionParslet",
        accept: (type5) => type5 === "&",
        precedence: Precedence.INTERSECTION,
        parseInfix: (parser, left) => {
          parser.consume("&");
          let elements2 = [];
          do
            elements2.push(parser.parseType(Precedence.INTERSECTION));
          while (parser.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [assertRootResult(left), ...elements2]
          };
        }
      }), predicateParslet = composeParslet({
        name: "predicateParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "is",
        parseInfix: (parser, left) => {
          if (left.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
          return parser.consume("is"), {
            type: "JsdocTypePredicate",
            left,
            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
          };
        }
      }), objectSquaredPropertyParslet = composeParslet({
        name: "objectSquareBracketPropertyParslet",
        accept: (type5) => type5 === "[",
        parsePrefix: (parser) => {
          if (parser.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          parser.consume("[");
          let key = parser.lexer.current.text;
          parser.consume("Identifier");
          let result;
          if (parser.consume(":")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeIndexSignature",
              key,
              right: parentParser.parseType(Precedence.INDEX_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else if (parser.consume("in")) {
            let parentParser = parser.baseParser;
            parentParser.acceptLexerState(parser), result = {
              type: "JsdocTypeMappedType",
              key,
              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
            }, parser.acceptLexerState(parentParser);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!parser.consume("]"))
            throw new Error("Unterminated square brackets");
          return result;
        }
      }), readonlyArrayParslet = composeParslet({
        name: "readonlyArrayParslet",
        accept: (type5) => type5 === "readonly",
        parsePrefix: (parser) => (parser.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
        })
      }), conditionalParslet = composeParslet({
        name: "conditionalParslet",
        precedence: Precedence.INFIX,
        accept: (type5) => type5 === "extends",
        parseInfix: (parser, left) => {
          parser.consume("extends");
          let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
          return parser.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: assertRootResult(left),
            extendsType,
            trueType,
            falseType: parser.parseType(Precedence.INFIX)
          };
        }
      }), objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
          allowSquaredProperties: true,
          allowKeyTypes: false,
          allowOptional: true,
          allowReadonly: true
        }),
        objectSquaredPropertyParslet
      ], typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
          allowKeyTypes: false,
          objectFieldGrammar
        }),
        readonlyArrayParslet,
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
          allowWithoutParenthesis: true,
          allowNoReturnType: false,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
          allowQuestionMark: false
        }),
        createVariadicParslet({
          allowEnclosingBrackets: false,
          allowPostfix: false
        }),
        assertsParslet,
        conditionalParslet,
        createNameParslet({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        createSpecialNamePathParslet({
          allowedTypes: ["module"],
          pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        genericArrowFunctionParslet,
        createNamePathParslet({
          allowSquareBracketsOnAnyType: true,
          allowJsdocNamePaths: false,
          pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
          allowVariadic: true,
          allowOptional: true
        })
      ];
      function parse3(expression, mode) {
        switch (mode) {
          case "closure":
            return new Parser(closureGrammar, expression).parse();
          case "jsdoc":
            return new Parser(jsdocGrammar, expression).parse();
          case "typescript":
            return new Parser(typescriptGrammar, expression).parse();
        }
      }
      function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
        let error;
        for (let mode of modes)
          try {
            return parse3(expression, mode);
          } catch (e2) {
            error = e2;
          }
        throw error;
      }
      function transform(rules2, parseResult) {
        let rule = rules2[parseResult.type];
        if (rule === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
      }
      function notAvailableTransform(parseResult) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      function extractSpecialParams(source) {
        let result = {
          params: []
        };
        for (let param of source.parameters)
          param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
        return result;
      }
      function applyPosition(position, target, value) {
        return position === "prefix" ? value + target : target + value;
      }
      function quote(value, quote2) {
        switch (quote2) {
          case "double":
            return `"${value}"`;
          case "single":
            return `'${value}'`;
          case void 0:
            return value;
        }
      }
      function stringifyRules2() {
        return {
          JsdocTypeParenthesis: (result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeKeyof: (result, transform2) => `keyof ${transform2(result.element)}`,
          JsdocTypeFunction: (result, transform2) => {
            var _a3;
            if (result.arrow) {
              if (result.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let stringified = `${result.typeParameters !== void 0 ? `<${(_a3 = result.typeParameters.map(transform2).join(", ")) !== null && _a3 !== void 0 ? _a3 : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
              return result.constructor && (stringified = "new " + stringified), stringified;
            } else {
              let stringified = result.constructor ? "new" : "function";
              return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
            }
          },
          JsdocTypeName: (result) => result.value,
          JsdocTypeTuple: (result, transform2) => `[${result.elements.map(transform2).join(", ")}]`,
          JsdocTypeVariadic: (result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."),
          JsdocTypeNamePath: (result, transform2) => {
            let left = transform2(result.left), right = transform2(result.right);
            switch (result.pathType) {
              case "inner":
                return `${left}~${right}`;
              case "instance":
                return `${left}#${right}`;
              case "property":
                return `${left}.${right}`;
              case "property-brackets":
                return `${left}[${right}]`;
            }
          },
          JsdocTypeStringValue: (result) => quote(result.value, result.meta.quote),
          JsdocTypeAny: () => "*",
          JsdocTypeGeneric: (result, transform2) => {
            if (result.meta.brackets === "square") {
              let element = result.elements[0], transformed = transform2(element);
              return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
            } else
              return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === true ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
          },
          JsdocTypeImport: (result, transform2) => `import(${transform2(result.element)})`,
          JsdocTypeObjectField: (result, transform2) => {
            let text = "";
            return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeJsdocObjectField: (result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`,
          JsdocTypeKeyValue: (result, transform2) => {
            let text = result.key;
            return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
          },
          JsdocTypeSpecialNamePath: (result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
          JsdocTypeNotNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"),
          JsdocTypeNull: () => "null",
          JsdocTypeNullable: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"),
          JsdocTypeNumber: (result) => result.value.toString(),
          JsdocTypeObject: (result, transform2) => {
            var _a3, _b;
            return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a3 = result.meta.propertyIndent) !== null && _a3 !== void 0 ? _a3 : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
          },
          JsdocTypeOptional: (result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="),
          JsdocTypeSymbol: (result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`,
          JsdocTypeTypeof: (result, transform2) => `typeof ${transform2(result.element)}`,
          JsdocTypeUndefined: () => "undefined",
          JsdocTypeUnion: (result, transform2) => result.elements.map(transform2).join(" | "),
          JsdocTypeUnknown: () => "?",
          JsdocTypeIntersection: (result, transform2) => result.elements.map(transform2).join(" & "),
          JsdocTypeProperty: (result) => quote(result.value, result.meta.quote),
          JsdocTypePredicate: (result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeIndexSignature: (result, transform2) => `[${result.key}: ${transform2(result.right)}]`,
          JsdocTypeMappedType: (result, transform2) => `[${result.key} in ${transform2(result.right)}]`,
          JsdocTypeAsserts: (result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`,
          JsdocTypeReadonlyArray: (result, transform2) => `readonly ${transform2(result.element)}`,
          JsdocTypeAssertsPlain: (result, transform2) => `asserts ${transform2(result.element)}`,
          JsdocTypeConditional: (result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`,
          JsdocTypeTypeParameter: (result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`
        };
      }
      let storedStringifyRules = stringifyRules2();
      function stringify22(result) {
        return transform(storedStringifyRules, result);
      }
      let reservedWords2 = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function makeName(value) {
        let result = {
          type: "NameExpression",
          name: value
        };
        return reservedWords2.includes(value) && (result.reservedWord = true), result;
      }
      let catharsisTransformRules = {
        JsdocTypeOptional: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.optional = true, transformed;
        },
        JsdocTypeNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = true, transformed;
        },
        JsdocTypeNotNullable: (result, transform2) => {
          let transformed = transform2(result.element);
          return transformed.nullable = false, transformed;
        },
        JsdocTypeVariadic: (result, transform2) => {
          if (result.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          let transformed = transform2(result.element);
          return transformed.repeatable = true, transformed;
        },
        JsdocTypeAny: () => ({
          type: "AllLiteral"
        }),
        JsdocTypeNull: () => ({
          type: "NullLiteral"
        }),
        JsdocTypeStringValue: (result) => makeName(quote(result.value, result.meta.quote)),
        JsdocTypeUndefined: () => ({
          type: "UndefinedLiteral"
        }),
        JsdocTypeUnknown: () => ({
          type: "UnknownLiteral"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let params = extractSpecialParams(result), transformed = {
            type: "FunctionType",
            params: params.params.map(transform2)
          };
          return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => ({
          type: "TypeApplication",
          applications: result.elements.map((o2) => transform2(o2)),
          expression: transform2(result.left)
        }),
        JsdocTypeSpecialNamePath: (result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)),
        JsdocTypeName: (result) => result.value !== "function" ? makeName(result.value) : {
          type: "FunctionType",
          params: []
        },
        JsdocTypeNumber: (result) => makeName(result.value.toString()),
        JsdocTypeObject: (result, transform2) => {
          let transformed = {
            type: "RecordType",
            fields: []
          };
          for (let field of result.elements)
            field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
              type: "FieldType",
              key: transform2(field),
              value: void 0
            }) : transformed.fields.push(transform2(field));
          return transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: makeName(quote(result.key, result.meta.quote)),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          };
        },
        JsdocTypeJsdocObjectField: (result, transform2) => ({
          type: "FieldType",
          key: transform2(result.left),
          value: transform2(result.right)
        }),
        JsdocTypeUnion: (result, transform2) => ({
          type: "TypeUnion",
          elements: result.elements.map((e2) => transform2(e2))
        }),
        JsdocTypeKeyValue: (result, transform2) => ({
          type: "FieldType",
          key: makeName(result.key),
          value: result.right === void 0 ? void 0 : transform2(result.right)
        }),
        JsdocTypeNamePath: (result, transform2) => {
          let leftResult = transform2(result.left), rightValue;
          result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
          let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
          return makeName(`${leftResult.name}${joiner}${rightValue}`);
        },
        JsdocTypeSymbol: (result) => {
          let value = "", element = result.element, trailingDots = false;
          return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value = "..." : trailingDots = true, element = element.element), element?.type === "JsdocTypeName" ? value += element.value : element?.type === "JsdocTypeNumber" && (value += element.value.toString()), trailingDots && (value += "..."), makeName(`${result.value}(${value})`);
        },
        JsdocTypeParenthesis: (result, transform2) => transform2(assertRootResult(result.element)),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
      }
      function getQuoteStyle(quote2) {
        switch (quote2) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      function getMemberType(type5) {
        switch (type5) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      function nestResults(type5, results) {
        return results.length === 2 ? {
          type: type5,
          left: results[0],
          right: results[1]
        } : {
          type: type5,
          left: results[0],
          right: nestResults(type5, results.slice(1))
        };
      }
      let jtpRules = {
        JsdocTypeOptional: (result, transform2) => ({
          type: "OPTIONAL",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }),
        JsdocTypeNullable: (result, transform2) => ({
          type: "NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }),
        JsdocTypeNotNullable: (result, transform2) => ({
          type: "NOT_NULLABLE",
          value: transform2(result.element),
          meta: {
            syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }),
        JsdocTypeVariadic: (result, transform2) => {
          let transformed = {
            type: "VARIADIC",
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
        },
        JsdocTypeName: (result) => ({
          type: "NAME",
          name: result.value
        }),
        JsdocTypeTypeof: (result, transform2) => ({
          type: "TYPE_QUERY",
          name: transform2(result.element)
        }),
        JsdocTypeTuple: (result, transform2) => ({
          type: "TUPLE",
          entries: result.elements.map(transform2)
        }),
        JsdocTypeKeyof: (result, transform2) => ({
          type: "KEY_QUERY",
          value: transform2(result.element)
        }),
        JsdocTypeImport: (result) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.element.meta.quote),
            string: result.element.value
          }
        }),
        JsdocTypeUndefined: () => ({
          type: "NAME",
          name: "undefined"
        }),
        JsdocTypeAny: () => ({
          type: "ANY"
        }),
        JsdocTypeFunction: (result, transform2) => {
          let specialParams = extractSpecialParams(result), transformed = {
            type: result.arrow ? "ARROW" : "FUNCTION",
            params: specialParams.params.map((param) => {
              if (param.type === "JsdocTypeKeyValue") {
                if (param.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: param.key,
                  typeName: transform2(param.right)
                };
              } else
                return transform2(param);
            }),
            new: null,
            returns: null
          };
          return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
        },
        JsdocTypeGeneric: (result, transform2) => {
          let transformed = {
            type: "GENERIC",
            subject: transform2(result.left),
            objects: result.elements.map(transform2),
            meta: {
              syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
            type: "NAME",
            name: "function"
          }), transformed;
        },
        JsdocTypeObjectField: (result, transform2) => {
          if (typeof result.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key.toString(),
            quoteStyle: getQuoteStyle(result.meta.quote),
            value: right,
            readonly: false
          };
        },
        JsdocTypeJsdocObjectField: () => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        },
        JsdocTypeKeyValue: (result, transform2) => {
          if (result.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: null,
              readonly: false
            };
          let right = transform2(result.right);
          return result.optional && (right = {
            type: "OPTIONAL",
            value: right,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: result.key,
            quoteStyle: "none",
            value: right,
            readonly: false
          };
        },
        JsdocTypeObject: (result, transform2) => {
          let entries = [];
          for (let field of result.elements)
            (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
          return {
            type: "RECORD",
            entries
          };
        },
        JsdocTypeSpecialNamePath: (result) => {
          if (result.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: getQuoteStyle(result.meta.quote),
              path: result.value
            }
          };
        },
        JsdocTypeNamePath: (result, transform2) => {
          let hasEventPrefix = false, name, quoteStyle;
          result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = true, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
          let transformed = {
            type: getMemberType(result.pathType),
            owner: transform2(result.left),
            name,
            quoteStyle,
            hasEventPrefix
          };
          if (transformed.owner.type === "MODULE") {
            let tModule = transformed.owner;
            return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
          } else
            return transformed;
        },
        JsdocTypeUnion: (result, transform2) => nestResults("UNION", result.elements.map(transform2)),
        JsdocTypeParenthesis: (result, transform2) => ({
          type: "PARENTHESIS",
          value: transform2(assertRootResult(result.element))
        }),
        JsdocTypeNull: () => ({
          type: "NAME",
          name: "null"
        }),
        JsdocTypeUnknown: () => ({
          type: "UNKNOWN"
        }),
        JsdocTypeStringValue: (result) => ({
          type: "STRING_VALUE",
          quoteStyle: getQuoteStyle(result.meta.quote),
          string: result.value
        }),
        JsdocTypeIntersection: (result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)),
        JsdocTypeNumber: (result) => ({
          type: "NUMBER_VALUE",
          number: result.value.toString()
        }),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform,
        JsdocTypeReadonlyArray: notAvailableTransform,
        JsdocTypeAssertsPlain: notAvailableTransform,
        JsdocTypeConditional: notAvailableTransform,
        JsdocTypeTypeParameter: notAvailableTransform
      };
      function jtpTransform(result) {
        return transform(jtpRules, result);
      }
      function identityTransformRules() {
        return {
          JsdocTypeIntersection: (result, transform2) => ({
            type: "JsdocTypeIntersection",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeGeneric: (result, transform2) => ({
            type: "JsdocTypeGeneric",
            left: transform2(result.left),
            elements: result.elements.map(transform2),
            meta: {
              dot: result.meta.dot,
              brackets: result.meta.brackets
            }
          }),
          JsdocTypeNullable: (result) => result,
          JsdocTypeUnion: (result, transform2) => ({
            type: "JsdocTypeUnion",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeUnknown: (result) => result,
          JsdocTypeUndefined: (result) => result,
          JsdocTypeTypeof: (result, transform2) => ({
            type: "JsdocTypeTypeof",
            element: transform2(result.element)
          }),
          JsdocTypeSymbol: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeSymbol",
              value: result.value
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeOptional: (result, transform2) => ({
            type: "JsdocTypeOptional",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeObject: (result, transform2) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: result.elements.map(transform2)
          }),
          JsdocTypeNumber: (result) => result,
          JsdocTypeNull: (result) => result,
          JsdocTypeNotNullable: (result, transform2) => ({
            type: "JsdocTypeNotNullable",
            element: transform2(result.element),
            meta: {
              position: result.meta.position
            }
          }),
          JsdocTypeSpecialNamePath: (result) => result,
          JsdocTypeObjectField: (result, transform2) => ({
            type: "JsdocTypeObjectField",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            readonly: result.readonly,
            meta: result.meta
          }),
          JsdocTypeJsdocObjectField: (result, transform2) => ({
            type: "JsdocTypeJsdocObjectField",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeKeyValue: (result, transform2) => ({
            type: "JsdocTypeKeyValue",
            key: result.key,
            right: result.right === void 0 ? void 0 : transform2(result.right),
            optional: result.optional,
            variadic: result.variadic
          }),
          JsdocTypeImport: (result, transform2) => ({
            type: "JsdocTypeImport",
            element: transform2(result.element)
          }),
          JsdocTypeAny: (result) => result,
          JsdocTypeStringValue: (result) => result,
          JsdocTypeNamePath: (result) => result,
          JsdocTypeVariadic: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeVariadic",
              meta: {
                position: result.meta.position,
                squareBrackets: result.meta.squareBrackets
              }
            };
            return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
          },
          JsdocTypeTuple: (result, transform2) => ({
            type: "JsdocTypeTuple",
            elements: result.elements.map(transform2)
          }),
          JsdocTypeName: (result) => result,
          JsdocTypeFunction: (result, transform2) => {
            let transformed = {
              type: "JsdocTypeFunction",
              arrow: result.arrow,
              parameters: result.parameters.map(transform2),
              constructor: result.constructor,
              parenthesis: result.parenthesis
            };
            return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
          },
          JsdocTypeKeyof: (result, transform2) => ({
            type: "JsdocTypeKeyof",
            element: transform2(result.element)
          }),
          JsdocTypeParenthesis: (result, transform2) => ({
            type: "JsdocTypeParenthesis",
            element: transform2(result.element)
          }),
          JsdocTypeProperty: (result) => result,
          JsdocTypePredicate: (result, transform2) => ({
            type: "JsdocTypePredicate",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeIndexSignature: (result, transform2) => ({
            type: "JsdocTypeIndexSignature",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeMappedType: (result, transform2) => ({
            type: "JsdocTypeMappedType",
            key: result.key,
            right: transform2(result.right)
          }),
          JsdocTypeAsserts: (result, transform2) => ({
            type: "JsdocTypeAsserts",
            left: transform2(result.left),
            right: transform2(result.right)
          }),
          JsdocTypeReadonlyArray: (result, transform2) => ({
            type: "JsdocTypeReadonlyArray",
            element: transform2(result.element)
          }),
          JsdocTypeAssertsPlain: (result, transform2) => ({
            type: "JsdocTypeAssertsPlain",
            element: transform2(result.element)
          }),
          JsdocTypeConditional: (result, transform2) => ({
            type: "JsdocTypeConditional",
            checksType: transform2(result.checksType),
            extendsType: transform2(result.extendsType),
            trueType: transform2(result.trueType),
            falseType: transform2(result.falseType)
          }),
          JsdocTypeTypeParameter: (result, transform2) => ({
            type: "JsdocTypeTypeParameter",
            name: transform2(result.name),
            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
          })
        };
      }
      let visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter?.(node, parentNode, property);
        let keysToVisit = visitorKeys[node.type];
        for (let key of keysToVisit) {
          let value = node[key];
          if (value !== void 0)
            if (Array.isArray(value))
              for (let element of value)
                _traverse(element, node, key, onEnter, onLeave);
            else
              _traverse(value, node, key, onEnter, onLeave);
        }
        onLeave?.(node, parentNode, property);
      }
      function traverse(node, onEnter, onLeave) {
        _traverse(node, void 0, void 0, onEnter, onLeave);
      }
      exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse3, exports2.stringify = stringify22, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
    });
  }
});
const { UnknownArgTypesError: UnknownArgTypesError2 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var isLiteral = (type5) => type5.name === "literal", toEnumOption = (element) => element.value.replace(/['|"]/g, ""), convertSig = (type5) => {
  switch (type5.type) {
    case "function":
      return { name: "function" };
    case "object":
      let values = {};
      return type5.signature.properties.forEach((prop) => {
        values[prop.key] = convert(prop.value);
      }), {
        name: "object",
        value: values
      };
    default:
      throw new UnknownArgTypesError2({ type: type5, language: "Flow" });
  }
}, convert = (type5) => {
  let { name, raw } = type5, base2 = {};
  switch (typeof raw < "u" && (base2.raw = raw), type5.name) {
    case "literal":
      return { ...base2, name: "other", value: type5.value };
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...base2, name };
    case "Array":
      return { ...base2, name: "array", value: type5.elements.map(convert) };
    case "signature":
      return { ...base2, ...convertSig(type5) };
    case "union":
      return type5.elements?.every(isLiteral) ? { ...base2, name: "enum", value: type5.elements?.map(toEnumOption) } : { ...base2, name, value: type5.elements?.map(convert) };
    case "intersection":
      return { ...base2, name, value: type5.elements?.map(convert) };
    default:
      return { ...base2, name: "other", value: name };
  }
};
var QUOTE_REGEX = /^['"]|['"]$/g, trimQuotes = (str2) => str2.replace(QUOTE_REGEX, ""), includesQuotes = (str2) => QUOTE_REGEX.test(str2), parseLiteral$1 = (str2) => {
  let trimmedValue = trimQuotes(str2);
  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);
};
var SIGNATURE_REGEXP = /^\(.*\) => /, convert2 = (type5) => {
  let { name, raw, computed, value } = type5, base2 = {};
  switch (typeof raw < "u" && (base2.raw = raw), name) {
    case "enum": {
      let values2 = computed ? value : value.map((v2) => parseLiteral$1(v2.value));
      return { ...base2, name, value: values2 };
    }
    case "string":
    case "number":
    case "symbol":
      return { ...base2, name };
    case "func":
      return { ...base2, name: "function" };
    case "bool":
    case "boolean":
      return { ...base2, name: "boolean" };
    case "arrayOf":
    case "array":
      return { ...base2, name: "array", value: value && convert2(value) };
    case "object":
      return { ...base2, name };
    case "objectOf":
      return { ...base2, name, value: convert2(value) };
    case "shape":
    case "exact":
      let values = mapValues(value, (field) => convert2(field));
      return { ...base2, name: "object", value: values };
    case "union":
      return { ...base2, name: "union", value: value.map((v2) => convert2(v2)) };
    case "instanceOf":
    case "element":
    case "elementType":
    default: {
      if (name?.indexOf("|") > 0)
        try {
          let literalValues = name.split("|").map((v2) => JSON.parse(v2));
          return { ...base2, name: "enum", value: literalValues };
        } catch {
        }
      let otherVal = value ? `${name}(${value})` : name, otherName = SIGNATURE_REGEXP.test(name) ? "function" : "other";
      return { ...base2, name: otherName, value: otherVal };
    }
  }
};
const { UnknownArgTypesError: UnknownArgTypesError22 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var convertSig2 = (type5) => {
  switch (type5.type) {
    case "function":
      return { name: "function" };
    case "object":
      let values = {};
      return type5.signature.properties.forEach((prop) => {
        values[prop.key] = convert3(prop.value);
      }), {
        name: "object",
        value: values
      };
    default:
      throw new UnknownArgTypesError22({ type: type5, language: "Typescript" });
  }
}, convert3 = (type5) => {
  let { name, raw } = type5, base2 = {};
  switch (typeof raw < "u" && (base2.raw = raw), type5.name) {
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...base2, name };
    case "Array":
      return { ...base2, name: "array", value: type5.elements.map(convert3) };
    case "signature":
      return { ...base2, ...convertSig2(type5) };
    case "union":
      let result;
      return type5.elements?.every((element) => element.name === "literal") ? result = {
        ...base2,
        name: "enum",
        // @ts-expect-error fix types
        value: type5.elements?.map((v2) => parseLiteral$1(v2.value))
      } : result = { ...base2, name, value: type5.elements?.map(convert3) }, result;
    case "intersection":
      return { ...base2, name, value: type5.elements?.map(convert3) };
    default:
      return { ...base2, name: "other", value: name };
  }
};
var convert4 = (docgenInfo) => {
  let { type: type5, tsType, flowType } = docgenInfo;
  try {
    if (type5 != null)
      return convert2(type5);
    if (tsType != null)
      return convert3(tsType);
    if (flowType != null)
      return convert(flowType);
  } catch (err) {
    console.error(err);
  }
  return null;
};
var TypeSystem = /* @__PURE__ */ ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = "JavaScript", TypeSystem2.FLOW = "Flow", TypeSystem2.TYPESCRIPT = "TypeScript", TypeSystem2.UNKNOWN = "Unknown", TypeSystem2))(TypeSystem || {});
var BLACKLIST = ["null", "undefined"];
function isDefaultValueBlacklisted(value) {
  return BLACKLIST.some((x2) => x2 === value);
}
var str = (obj) => {
  if (!obj)
    return "";
  if (typeof obj == "string")
    return obj;
  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);
};
function hasDocgen(component) {
  return !!component.__docgenInfo;
}
function isValidDocgenSection(docgenSection) {
  return docgenSection != null && Object.keys(docgenSection).length > 0;
}
function getDocgenSection(component, section) {
  return hasDocgen(component) ? component.__docgenInfo[section] : null;
}
function getDocgenDescription(component) {
  return hasDocgen(component) ? str(component.__docgenInfo.description) : "";
}
var Markers;
(function(Markers2) {
  Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
})(Markers = Markers || (Markers = {}));
function isSpace(source) {
  return /^\s+$/.test(source);
}
function splitCR(source) {
  let matches5 = source.match(/\r+$/);
  return matches5 == null ? ["", source] : [source.slice(-matches5[0].length), source.slice(0, -matches5[0].length)];
}
function splitSpace(source) {
  let matches5 = source.match(/^\s+/);
  return matches5 == null ? ["", source] : [source.slice(0, matches5[0].length), source.slice(matches5[0].length)];
}
function splitLines(source) {
  return source.split(/\n/);
}
function seedSpec(spec = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: false, description: "", problems: [], source: [] }, spec);
}
function seedTokens(tokens = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, tokens);
}
var reTag = /^@\S+/;
function getParser({ fence = "```" } = {}) {
  let fencer = getFencer(fence), toggleFence = (source, isFenced) => fencer(source) ? !isFenced : isFenced;
  return function(source) {
    let sections = [[]], isFenced = false;
    for (let line of source)
      reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);
    return sections;
  };
}
function getFencer(fence) {
  return typeof fence == "string" ? (source) => source.split(fence).length % 2 === 0 : fence;
}
function getParser2({ startLine = 0, markers = Markers } = {}) {
  let block = null, num = startLine;
  return function(source) {
    let rest = source, tokens = seedTokens();
    if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null)
      return num++, null;
    let isClosed = rest.trimRight().endsWith(markers.end);
    if (tokens.delimiter === "" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {
      let trimmed = rest.trimRight();
      tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);
    }
    if (tokens.description = rest, block.push({ number: num, source, tokens }), num++, isClosed) {
      let result = block.slice();
      return block = null, result;
    }
    return null;
  };
}
function getParser3({ tokenizers }) {
  return function(source) {
    var _a3;
    let spec = seedSpec({ source });
    for (let tokenize of tokenizers)
      if (spec = tokenize(spec), !((_a3 = spec.problems[spec.problems.length - 1]) === null || _a3 === void 0) && _a3.critical)
        break;
    return spec;
  };
}
function tagTokenizer() {
  return (spec) => {
    let { tokens } = spec.source[0], match = tokens.description.match(/\s*(@(\S+))(\s*)/);
    return match === null ? (spec.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: spec.source[0].number,
      critical: true
    }), spec) : (tokens.tag = match[1], tokens.postTag = match[3], tokens.description = tokens.description.slice(match[0].length), spec.tag = match[2], spec);
  };
}
function typeTokenizer(spacing = "compact") {
  let join2 = getJoiner(spacing);
  return (spec) => {
    let curlies = 0, lines = [];
    for (let [i2, { tokens }] of spec.source.entries()) {
      let type5 = "";
      if (i2 === 0 && tokens.description[0] !== "{")
        return spec;
      for (let ch of tokens.description)
        if (ch === "{" && curlies++, ch === "}" && curlies--, type5 += ch, curlies === 0)
          break;
      if (lines.push([tokens, type5]), curlies === 0)
        break;
    }
    if (curlies !== 0)
      return spec.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: spec.source[0].number,
        critical: true
      }), spec;
    let parts = [], offset2 = lines[0][0].postDelimiter.length;
    for (let [i2, [tokens, type5]] of lines.entries())
      tokens.type = type5, i2 > 0 && (tokens.type = tokens.postDelimiter.slice(offset2) + type5, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset2)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type5.length)), parts.push(tokens.type);
    return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;
  };
}
var trim = (x2) => x2.trim();
function getJoiner(spacing) {
  return spacing === "compact" ? (t3) => t3.map(trim).join("") : spacing === "preserve" ? (t3) => t3.join(`
`) : spacing;
}
var isQuoted = (s3) => s3 && s3.startsWith('"') && s3.endsWith('"');
function nameTokenizer() {
  let typeEnd = (num, { tokens }, i2) => tokens.type === "" ? num : i2;
  return (spec) => {
    let { tokens } = spec.source[spec.source.reduce(typeEnd, 0)], source = tokens.description.trimLeft(), quotedGroups = source.split('"');
    if (quotedGroups.length > 1 && quotedGroups[0] === "" && quotedGroups.length % 2 === 1)
      return spec.name = quotedGroups[1], tokens.name = `"${quotedGroups[1]}"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
    let brackets = 0, name = "", optional = false, defaultValue;
    for (let ch of source) {
      if (brackets === 0 && isSpace(ch))
        break;
      ch === "[" && brackets++, ch === "]" && brackets--, name += ch;
    }
    if (brackets !== 0)
      return spec.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: spec.source[0].number,
        critical: true
      }), spec;
    let nameToken = name;
    if (name[0] === "[" && name[name.length - 1] === "]") {
      optional = true, name = name.slice(1, -1);
      let parts = name.split("=");
      if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join("=").trim()), name === "")
        return spec.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: spec.source[0].number,
          critical: true
        }), spec;
      if (defaultValue === "")
        return spec.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: spec.source[0].number,
          critical: true
        }), spec;
      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue))
        return spec.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: spec.source[0].number,
          critical: true
        }), spec;
    }
    return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
  };
}
function descriptionTokenizer(spacing = "compact", markers = Markers) {
  let join2 = getJoiner2(spacing);
  return (spec) => (spec.description = join2(spec.source, markers), spec);
}
function getJoiner2(spacing) {
  return spacing === "compact" ? compactJoiner : spacing === "preserve" ? preserveJoiner : spacing;
}
function compactJoiner(lines, markers = Markers) {
  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== "").join(" ");
}
var lineNo = (num, { tokens }, i2) => tokens.type === "" ? num : i2, getDescription = ({ tokens }) => (tokens.delimiter === "" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description;
function preserveJoiner(lines, markers = Markers) {
  if (lines.length === 0)
    return "";
  lines[0].tokens.description === "" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));
  let lastLine = lines[lines.length - 1];
  return lastLine !== void 0 && lastLine.tokens.description === "" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`
`);
}
function getParser4({ startLine = 0, fence = "```", spacing = "compact", markers = Markers, tokenizers = [
  tagTokenizer(),
  typeTokenizer(spacing),
  nameTokenizer(),
  descriptionTokenizer(spacing)
] } = {}) {
  if (startLine < 0 || startLine % 1 > 0)
    throw new Error("Invalid startLine");
  let parseSource = getParser2({ startLine, markers }), parseBlock = getParser({ fence }), parseSpec = getParser3({ tokenizers }), joinDescription = getJoiner2(spacing);
  return function(source) {
    let blocks = [];
    for (let line of splitLines(source)) {
      let lines = parseSource(line);
      if (lines === null)
        continue;
      let sections = parseBlock(lines), specs = sections.slice(1).map(parseSpec);
      blocks.push({
        description: joinDescription(sections[0], markers),
        tags: specs,
        source: lines,
        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])
      });
    }
    return blocks;
  };
}
function parse$1(source, options = {}) {
  return getParser4(options)(source);
}
var import_jsdoc_type_pratt_parser = __toESM$2(require_dist$1(), 1);
function containsJsDoc(value) {
  return value != null && value.includes("@");
}
function parse2(content) {
  let normalisedContent = `/**
` + (content ?? "").split(`
`).map((line) => ` * ${line}`).join(`
`) + `
*/`, ast = parse$1(normalisedContent, {
    spacing: "preserve"
  });
  if (!ast || ast.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return ast[0];
}
var DEFAULT_OPTIONS = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
}, parseJsDoc = (value, options = DEFAULT_OPTIONS) => {
  if (!containsJsDoc(value))
    return {
      includesJsDoc: false,
      ignore: false
    };
  let jsDocAst = parse2(value), extractedTags = extractJsDocTags(jsDocAst, options.tags);
  return extractedTags.ignore ? {
    includesJsDoc: true,
    ignore: true
  } : {
    includesJsDoc: true,
    ignore: false,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: jsDocAst.description.trim(),
    extractedTags
  };
};
function extractJsDocTags(ast, tags) {
  let extractedTags = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: false
  };
  for (let tagSpec of ast.tags)
    if (!(tags !== void 0 && !tags.includes(tagSpec.tag)))
      if (tagSpec.tag === "ignore") {
        extractedTags.ignore = true;
        break;
      } else
        switch (tagSpec.tag) {
          // arg & argument are aliases for param.
          case "param":
          case "arg":
          case "argument": {
            let paramTag = extractParam(tagSpec);
            paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));
            break;
          }
          case "deprecated": {
            let deprecatedTag = extractDeprecated(tagSpec);
            deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);
            break;
          }
          case "returns": {
            let returnsTag = extractReturns(tagSpec);
            returnsTag != null && (extractedTags.returns = returnsTag);
            break;
          }
        }
  return extractedTags;
}
function normaliseParamName(name) {
  return name.replace(/[\.-]$/, "");
}
function extractParam(tag) {
  if (!tag.name || tag.name === "-")
    return null;
  let type5 = extractType(tag.type);
  return {
    name: tag.name,
    type: type5,
    description: normaliseDescription(tag.description),
    getPrettyName: () => normaliseParamName(tag.name),
    getTypeName: () => type5 ? extractTypeName(type5) : null
  };
}
function extractDeprecated(tag) {
  return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;
}
function joinNameAndDescription(name, desc) {
  let joined = name === "" ? desc : `${name} ${desc}`;
  return normaliseDescription(joined);
}
function normaliseDescription(text) {
  let normalised = text.replace(/^- /g, "").trim();
  return normalised === "" ? null : normalised;
}
function extractReturns(tag) {
  let type5 = extractType(tag.type);
  return type5 ? {
    type: type5,
    description: joinNameAndDescription(tag.name, tag.description),
    getTypeName: () => extractTypeName(type5)
  } : null;
}
var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
jsdocStringifyRules.JsdocTypeAny = () => "any";
jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
function extractType(typeString) {
  try {
    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, "typescript");
  } catch {
    return null;
  }
}
function extractTypeName(type5) {
  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type5);
}
function isTooLongForTypeSummary(value) {
  return value.length > 90;
}
function isTooLongForDefaultValueSummary(value) {
  return value.length > 50;
}
function createSummaryValue(summary, detail) {
  return summary === detail ? { summary } : { summary, detail };
}
function createDefaultValue$1(defaultValue, type5) {
  if (defaultValue != null) {
    let { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value))
      return isTooLongForDefaultValueSummary(value) ? createSummaryValue(type5?.name, value) : createSummaryValue(value);
  }
  return null;
}
function generateUnionElement({ name, value, elements: elements2, raw }) {
  return value ?? (elements2 != null ? elements2.map(generateUnionElement).join(" | ") : raw ?? name);
}
function generateUnion$1({ name, raw, elements: elements2 }) {
  return elements2 != null ? createSummaryValue(elements2.map(generateUnionElement).join(" | ")) : raw != null ? createSummaryValue(raw.replace(/^\|\s*/, "")) : createSummaryValue(name);
}
function generateFuncSignature$1({ type: type5, raw }) {
  return raw != null ? createSummaryValue(raw) : createSummaryValue(type5);
}
function generateObjectSignature({ type: type5, raw }) {
  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type5, raw) : createSummaryValue(raw) : createSummaryValue(type5);
}
function generateSignature(flowType) {
  let { type: type5 } = flowType;
  return type5 === "object" ? generateObjectSignature(flowType) : generateFuncSignature$1(flowType);
}
function generateDefault({ name, raw }) {
  return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);
}
function createType$1(type5) {
  if (type5 == null)
    return null;
  switch (type5.name) {
    case "union":
      return generateUnion$1(type5);
    case "signature":
      return generateSignature(type5);
    default:
      return generateDefault(type5);
  }
}
var createFlowPropDef = (propName, docgenInfo) => {
  let { flowType, description, required, defaultValue } = docgenInfo;
  return {
    name: propName,
    type: createType$1(flowType),
    required,
    description,
    defaultValue: createDefaultValue$1(defaultValue ?? null, flowType ?? null)
  };
};
function createDefaultValue2({ defaultValue }) {
  if (defaultValue != null) {
    let { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value))
      return createSummaryValue(value);
  }
  return null;
}
function createType2({ tsType, required }) {
  if (tsType == null)
    return null;
  let typeName = tsType.name;
  return required || (typeName = typeName.replace(" | undefined", "")), createSummaryValue(
    ["Array", "Record", "signature"].includes(tsType.name) ? tsType.raw : typeName
  );
}
var createTsPropDef = (propName, docgenInfo) => {
  let { description, required } = docgenInfo;
  return {
    name: propName,
    type: createType2(docgenInfo),
    required,
    description,
    defaultValue: createDefaultValue2(docgenInfo)
  };
};
function createType3(type5) {
  return type5 != null ? createSummaryValue(type5.name) : null;
}
function isReactDocgenTypescript(defaultValue) {
  let { computed, func } = defaultValue;
  return typeof computed > "u" && typeof func > "u";
}
function isStringValued(type5) {
  return type5 ? type5.name === "string" ? true : type5.name === "enum" ? Array.isArray(type5.value) && type5.value.every(
    ({ value: tv }) => typeof tv == "string" && tv[0] === '"' && tv[tv.length - 1] === '"'
  ) : false : false;
}
function createDefaultValue3(defaultValue, type5) {
  if (defaultValue != null) {
    let { value } = defaultValue;
    if (!isDefaultValueBlacklisted(value))
      return isReactDocgenTypescript(defaultValue) && isStringValued(type5) ? createSummaryValue(JSON.stringify(value)) : createSummaryValue(value);
  }
  return null;
}
function createBasicPropDef(name, type5, docgenInfo) {
  let { description, required, defaultValue } = docgenInfo;
  return {
    name,
    type: createType3(type5),
    required,
    description,
    defaultValue: createDefaultValue3(defaultValue, type5)
  };
}
function applyJsDocResult(propDef, jsDocParsingResult) {
  if (jsDocParsingResult?.includesJsDoc) {
    let { description, extractedTags } = jsDocParsingResult;
    description != null && (propDef.description = jsDocParsingResult.description);
    let value = {
      ...extractedTags,
      params: extractedTags?.params?.map(
        (x2) => ({
          name: x2.getPrettyName(),
          description: x2.description
        })
      )
    };
    Object.values(value).filter(Boolean).length > 0 && (propDef.jsDocTags = value);
  }
  return propDef;
}
var javaScriptFactory = (propName, docgenInfo, jsDocParsingResult) => {
  let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);
  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
}, tsFactory = (propName, docgenInfo, jsDocParsingResult) => {
  let propDef = createTsPropDef(propName, docgenInfo);
  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
}, flowFactory = (propName, docgenInfo, jsDocParsingResult) => {
  let propDef = createFlowPropDef(propName, docgenInfo);
  return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
}, unknownFactory = (propName, docgenInfo, jsDocParsingResult) => {
  let propDef = createBasicPropDef(propName, { name: "unknown" }, docgenInfo);
  return applyJsDocResult(propDef, jsDocParsingResult);
}, getPropDefFactory = (typeSystem) => {
  switch (typeSystem) {
    case "JavaScript":
      return javaScriptFactory;
    case "TypeScript":
      return tsFactory;
    case "Flow":
      return flowFactory;
    default:
      return unknownFactory;
  }
};
var getTypeSystem = (docgenInfo) => docgenInfo.type != null ? "JavaScript" : docgenInfo.flowType != null ? "Flow" : docgenInfo.tsType != null ? "TypeScript" : "Unknown", extractComponentSectionArray = (docgenSection) => {
  let typeSystem = getTypeSystem(docgenSection[0]), createPropDef = getPropDefFactory(typeSystem);
  return docgenSection.map((item) => {
    let sanitizedItem = item;
    return item.type?.elements && (sanitizedItem = {
      ...item,
      type: {
        ...item.type,
        value: item.type.elements
      }
    }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);
  });
}, extractComponentSectionObject = (docgenSection) => {
  let docgenPropsKeys = Object.keys(docgenSection), typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]), createPropDef = getPropDefFactory(typeSystem);
  return docgenPropsKeys.map((propName) => {
    let docgenInfo = docgenSection[propName];
    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;
  }).filter(Boolean);
}, extractComponentProps = (component, section) => {
  let docgenSection = getDocgenSection(component, section);
  return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];
};
function extractProp(propName, docgenInfo, typeSystem, createPropDef) {
  let jsDocParsingResult = parseJsDoc(docgenInfo.description);
  return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {
    propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),
    jsDocTags: jsDocParsingResult.extractedTags,
    docgenInfo,
    typeSystem
  };
}
function extractComponentDescription(component) {
  return component != null ? getDocgenDescription(component) : "";
}
var combineParameters = (...parameterSets) => {
  let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value]) => {
    let existing = acc[key];
    Array.isArray(value) || typeof existing > "u" ? acc[key] = value : isPlainObject$2(value) && isPlainObject$2(existing) ? mergeKeys[key] = true : typeof value < "u" && (acc[key] = value);
  }), acc), {});
  return Object.keys(mergeKeys).forEach((key) => {
    let mergeValues = definedParametersSets.filter(Boolean).map((p2) => p2[key]).filter((value) => typeof value < "u");
    mergeValues.every((value) => isPlainObject$2(value)) ? combined[key] = combineParameters(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
  }), combined;
};
var enhanceArgTypes = (context) => {
  let {
    component,
    argTypes: userArgTypes,
    parameters: { docs = {} }
  } = context, { extractArgTypes: extractArgTypes2 } = docs;
  if (!extractArgTypes2 || !component)
    return userArgTypes;
  let extractedArgTypes = extractArgTypes2(component);
  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;
};
var ADDON_ID = "storybook/docs", SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`, SourceType = /* @__PURE__ */ ((SourceType2) => (SourceType2.AUTO = "auto", SourceType2.CODE = "code", SourceType2.DYNAMIC = "dynamic", SourceType2))(SourceType || {});
const importers = {
  "./src/Introduction.mdx": () => __vitePreload(() => import("./Introduction-DvteuFWO.js"), true ? __vite__mapDeps([0,1,2,3,4]) : void 0, import.meta.url),
  "./src/components/AccuDrawWidget.stories.tsx": () => __vitePreload(() => import("./AccuDrawWidget.stories-DHbN83QP.js"), true ? __vite__mapDeps([5,6,7,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/components/AutoSuggest.stories.tsx": () => __vitePreload(() => import("./AutoSuggest.stories-B9ZKojap.js"), true ? __vite__mapDeps([13,14,6,7,2,8,4,9,15,16,17,18]) : void 0, import.meta.url),
  "./src/components/BackstageAppButton.stories.tsx": () => __vitePreload(() => import("./BackstageAppButton.stories-B_HqUb33.js"), true ? __vite__mapDeps([19,6,7,2,8,4,9,14,15,20]) : void 0, import.meta.url),
  "./src/components/BackstageComposer.stories.tsx": () => __vitePreload(() => import("./BackstageComposer.stories-Dfx1kj2J.js"), true ? __vite__mapDeps([21,6,7,2,8,4,9,10,3,11,12,22]) : void 0, import.meta.url),
  "./src/components/Calculator.stories.tsx": () => __vitePreload(() => import("./Calculator.stories-BxnNPcW7.js"), true ? __vite__mapDeps([23,6,7,2,8,4,9,14,15]) : void 0, import.meta.url),
  "./src/components/CardPopup.stories.tsx": () => __vitePreload(() => import("./CardPopup.stories-CUisyLSp.js"), true ? __vite__mapDeps([24,6,7,2,8,4,9,10,3,11,12,25]) : void 0, import.meta.url),
  "./src/components/ContextMenu.stories.tsx": () => __vitePreload(() => import("./ContextMenu.stories-D0loS307.js"), true ? __vite__mapDeps([26,6,7,2,8,4,9,27,28,29,14,15,30]) : void 0, import.meta.url),
  "./src/components/Editors.stories.tsx": () => __vitePreload(() => import("./Editors.stories-CQRbvIjt.js"), true ? __vite__mapDeps([31,7,6,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/components/FilterBuilder.stories.tsx": () => __vitePreload(() => import("./FilterBuilder.stories-F3GCH2q_.js"), true ? __vite__mapDeps([32,7,6,2,8,4,9,14,15]) : void 0, import.meta.url),
  "./src/components/MessageCenterField.stories.tsx": () => __vitePreload(() => import("./MessageCenterField.stories-J8YIz5V8.js"), true ? __vite__mapDeps([33,14,6,7,2,8,4,9,15,34]) : void 0, import.meta.url),
  "./src/components/NavigationAidHost.stories.tsx": () => __vitePreload(() => import("./NavigationAidHost.stories-Cq8HSary.js"), true ? __vite__mapDeps([35,6,7,2,8,4,9,10,3,11,12,36]) : void 0, import.meta.url),
  "./src/components/PropertyGrid.stories.tsx": () => __vitePreload(() => import("./PropertyGrid.stories-Dg_yKaUZ.js"), true ? __vite__mapDeps([37,7,6,2,8,4,9,38,14,15,39]) : void 0, import.meta.url),
  "./src/components/QuantityFormat.stories.tsx": () => __vitePreload(() => import("./QuantityFormat.stories-BL35cfab.js"), true ? __vite__mapDeps([40,6,7,2,8,4,9,14,15,11]) : void 0, import.meta.url),
  "./src/components/SolarTimeline.stories.tsx": () => __vitePreload(() => import("./SolarTimeline.stories-DwAuQi2R.js"), true ? __vite__mapDeps([41,14,6,7,2,8,4,9,15,42,43]) : void 0, import.meta.url),
  "./src/components/StatusBarComposer.stories.tsx": () => __vitePreload(() => import("./StatusBarComposer.stories-DWRFO4hp.js"), true ? __vite__mapDeps([44,14,6,7,2,8,4,9,15,45,46,47,48,34]) : void 0, import.meta.url),
  "./src/components/Timeline.stories.tsx": () => __vitePreload(() => import("./Timeline.stories-DVoKpkb4.js"), true ? __vite__mapDeps([49,6,7,2,8,4,9,42,14,15,50]) : void 0, import.meta.url),
  "./src/components/ToolAssistanceField.stories.tsx": () => __vitePreload(() => import("./ToolAssistanceField.stories-BhCBz7zK.js"), true ? __vite__mapDeps([51,6,7,2,8,4,9,10,3,11,12,52]) : void 0, import.meta.url),
  "./src/components/ToolSettingsPopup.stories.tsx": () => __vitePreload(() => import("./ToolSettingsPopup.stories-C8JyXdmO.js"), true ? __vite__mapDeps([53,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/components/ToolbarComposer.stories.tsx": () => __vitePreload(() => import("./ToolbarComposer.stories-C62gg-YR.js"), true ? __vite__mapDeps([54,7,6,2,8,4,9,45,46,47,48,14,15,55,11]) : void 0, import.meta.url),
  "./src/components/ToolbarPopup.stories.tsx": () => __vitePreload(() => import("./ToolbarPopup.stories-GE2AshOF.js"), true ? __vite__mapDeps([56,6,7,2,8,4,9,10,3,11,12,25]) : void 0, import.meta.url),
  "./src/components/TreeWidget.stories.tsx": () => __vitePreload(() => import("./TreeWidget.stories-B_pd7tdY.js"), true ? __vite__mapDeps([57,7,6,2,8,4,9,14,15,39]) : void 0, import.meta.url),
  "./src/components/ViewSelector.stories.tsx": () => __vitePreload(() => import("./ViewSelector.stories-CRRtP9yU.js"), true ? __vite__mapDeps([58,6,7,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/deprecated/BlockText.stories.tsx": () => __vitePreload(() => import("./BlockText.stories-BmdXpvwb.js"), true ? __vite__mapDeps([59,14,6,7,2,8,4,9,15,60]) : void 0, import.meta.url),
  "./src/deprecated/ChecklistBox.stories.tsx": () => __vitePreload(() => import("./ChecklistBox.stories-CwA3bCQ6.js"), true ? __vite__mapDeps([61,14,6,7,2,8,4,9,15,62]) : void 0, import.meta.url),
  "./src/deprecated/Dialog.stories.tsx": () => __vitePreload(() => import("./Dialog.stories-B-Yl8V_R.js"), true ? __vite__mapDeps([63,64,7,27,65,16,17,66,14,6,2,8,4,9,15]) : void 0, import.meta.url),
  "./src/deprecated/DisabledText.stories.tsx": () => __vitePreload(() => import("./DisabledText.stories-AtjTUZ-O.js"), true ? __vite__mapDeps([67,14,6,7,2,8,4,9,15,60]) : void 0, import.meta.url),
  "./src/deprecated/ElementSeparator.stories.tsx": () => __vitePreload(() => import("./ElementSeparator.stories-7vjMo9m9.js"), true ? __vite__mapDeps([68,14,6,7,2,8,4,9,15,69,65,16,17,70]) : void 0, import.meta.url),
  "./src/deprecated/ExpandableList.stories.tsx": () => __vitePreload(() => import("./ExpandableList.stories-CkSdUE0R.js"), true ? __vite__mapDeps([71,14,6,7,2,8,4,9,15]) : void 0, import.meta.url),
  "./src/deprecated/GlobalDialog.stories.tsx": () => __vitePreload(() => import("./GlobalDialog.stories-DCPDo5sL.js"), true ? __vite__mapDeps([72,64,7,27,65,16,17,66,2]) : void 0, import.meta.url),
  "./src/deprecated/Icon.stories.tsx": () => __vitePreload(() => import("./Icon.stories-Bwk1YnUQ.js"), true ? __vite__mapDeps([73,6,7,2,8,4,9,38,14,15,55]) : void 0, import.meta.url),
  "./src/deprecated/IconInput.stories.tsx": () => __vitePreload(() => import("./IconInput.stories-BJFleBqT.js"), true ? __vite__mapDeps([74,6,7,2,8,4,9,45,14,15,75]) : void 0, import.meta.url),
  "./src/deprecated/ImageCheckBox.stories.tsx": () => __vitePreload(() => import("./ImageCheckBox.stories-CfMSj6_V.js"), true ? __vite__mapDeps([76,14,6,7,2,8,4,9,15,28,29,45,46,77]) : void 0, import.meta.url),
  "./src/deprecated/InputLabel.stories.tsx": () => __vitePreload(() => import("./InputLabel.stories-C-qoCTvu.js"), true ? __vite__mapDeps([78,6,7,2,8,4,9,28,29,14,15]) : void 0, import.meta.url),
  "./src/deprecated/Listbox.stories.tsx": () => __vitePreload(() => import("./Listbox.stories-wYDbgscu.js"), true ? __vite__mapDeps([79,7,14,6,2,8,4,9,15,80]) : void 0, import.meta.url),
  "./src/deprecated/LoadingBar.stories.tsx": () => __vitePreload(() => import("./LoadingBar.stories-DSmyYOur.js"), true ? __vite__mapDeps([81,82,83,14,6,7,2,8,4,9,15]) : void 0, import.meta.url),
  "./src/deprecated/LoadingPrompt.stories.tsx": () => __vitePreload(() => import("./LoadingPrompt.stories-Vscz9A9G.js"), true ? __vite__mapDeps([84,82,83,85,7,86,87,88,6,2,8,4,9,14,15,89]) : void 0, import.meta.url),
  "./src/deprecated/LoadingSpinner.stories.tsx": () => __vitePreload(() => import("./LoadingSpinner.stories-BHlpVKoT.js"), true ? __vite__mapDeps([90,85,7,86,14,6,2,8,4,9,15]) : void 0, import.meta.url),
  "./src/deprecated/LoadingStatus.stories.tsx": () => __vitePreload(() => import("./LoadingStatus.stories-CQ0nSHpq.js"), true ? __vite__mapDeps([91,87,88,14,6,7,2,8,4,9,15]) : void 0, import.meta.url),
  "./src/deprecated/NumberInput.stories.tsx": () => __vitePreload(() => import("./NumberInput.stories-CeG6z1-f.js"), true ? __vite__mapDeps([92,7,28,6,2,8,4,9,29,14,15,93]) : void 0, import.meta.url),
  "./src/deprecated/RadialMenu.stories.tsx": () => __vitePreload(() => import("./RadialMenu.stories-BYvjp1bK.js"), true ? __vite__mapDeps([94,6,7,2,8,4,9,45,46,47,14,15]) : void 0, import.meta.url),
  "./src/deprecated/SearchBox.stories.tsx": () => __vitePreload(() => import("./SearchBox.stories-CcfIljEd.js"), true ? __vite__mapDeps([95,14,6,7,2,8,4,9,15,28,29,65,16,17,96]) : void 0, import.meta.url),
  "./src/deprecated/Tabs.stories.tsx": () => __vitePreload(() => import("./Tabs.stories-BKJPFRHA.js"), true ? __vite__mapDeps([97,14,6,7,2,8,4,9,15,98,69,28,29,45]) : void 0, import.meta.url),
  "./src/deprecated/UnderlinedButton.stories.tsx": () => __vitePreload(() => import("./UnderlinedButton.stories-DzhNL0J3.js"), true ? __vite__mapDeps([99,14,6,7,2,8,4,9,15,100]) : void 0, import.meta.url),
  "./src/deprecated/VerticalTabs.stories.tsx": () => __vitePreload(() => import("./VerticalTabs.stories-BwNvPsZK.js"), true ? __vite__mapDeps([101,14,6,7,2,8,4,9,15,98,69,28,29,45]) : void 0, import.meta.url),
  "./src/frontstage/Active.stories.tsx": () => __vitePreload(() => import("./Active.stories-Cuhjn2Zw.js"), true ? __vite__mapDeps([102,14,6,7,2,8,4,9,15,10,3,11,12,20,22]) : void 0, import.meta.url),
  "./src/frontstage/ConfigurableUiContent.stories.tsx": () => __vitePreload(() => import("./ConfigurableUiContent.stories-B-2jQo8q.js"), true ? __vite__mapDeps([103,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/Frontstage.stories.tsx": () => __vitePreload(() => import("./Frontstage.stories-BrPIHJa0.js"), true ? __vite__mapDeps([104,6,7,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/Modal.stories.tsx": () => __vitePreload(() => import("./Modal.stories-Sf6rriYu.js"), true ? __vite__mapDeps([105,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/Nested.stories.tsx": () => __vitePreload(() => import("./Nested.stories-CBwcTQkD.js"), true ? __vite__mapDeps([106,14,6,7,2,8,4,9,15,10,3,11,12,20]) : void 0, import.meta.url),
  "./src/frontstage/SplitViewport.stories.tsx": () => __vitePreload(() => import("./SplitViewport.stories-BR0wyoAE.js"), true ? __vite__mapDeps([107,7,6,2,8,4,9,14,15,10,3,11,12,36]) : void 0, import.meta.url),
  "./src/frontstage/ToolSettings.stories.tsx": () => __vitePreload(() => import("./ToolSettings.stories-D4OjtTsH.js"), true ? __vite__mapDeps([108,6,7,2,8,4,9,14,15,10,3,11,12,109,110]) : void 0, import.meta.url),
  "./src/frontstage/Visibility.stories.tsx": () => __vitePreload(() => import("./Visibility.stories-CcREanHb.js"), true ? __vite__mapDeps([111,6,7,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/notifications/InputField.stories.tsx": () => __vitePreload(() => import("./InputField.stories-s6QUryIH.js"), true ? __vite__mapDeps([112,10,6,7,2,8,4,9,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/notifications/OutputMessage.stories.tsx": () => __vitePreload(() => import("./OutputMessage.stories-_iMqGjTd.js"), true ? __vite__mapDeps([113,6,7,2,8,4,9,10,3,11,12]) : void 0, import.meta.url),
  "./src/frontstage/notifications/OutputPrompt.stories.tsx": () => __vitePreload(() => import("./OutputPrompt.stories-Dtt2b-0Y.js"), true ? __vite__mapDeps([114,6,7,2,8,4,9,10,3,11,12,52]) : void 0, import.meta.url),
  "./src/hooks/useIsBackstageOpen.mdx": () => __vitePreload(() => import("./useIsBackstageOpen-DHKACSLb.js"), true ? __vite__mapDeps([115,1,2,3,4,116,6,7,8,9,10,11,12,22,20]) : void 0, import.meta.url),
  "./src/hooks/useIsBackstageOpen.stories.tsx": () => __vitePreload(() => import("./useIsBackstageOpen.stories-DWXmtAjx.js").then((n2) => n2.s), true ? __vite__mapDeps([116,6,7,2,8,4,9,10,3,11,12,22,20]) : void 0, import.meta.url),
  "./src/keyboard/KeyboardShortcuts.stories.tsx": () => __vitePreload(() => import("./KeyboardShortcuts.stories-CrIQTeDX.js"), true ? __vite__mapDeps([117,6,7,2,8,4,9,14,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/preview/ControlWidgetVisibility.stories.tsx": () => __vitePreload(() => import("./ControlWidgetVisibility.stories-DOCz-5_f.js"), true ? __vite__mapDeps([118,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/preview/EnableMaximizedWidget.stories.tsx": () => __vitePreload(() => import("./EnableMaximizedWidget.stories-BF3JHdDK.js"), true ? __vite__mapDeps([119,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/preview/ReparentPopoutWidgets.stories.tsx": () => __vitePreload(() => import("./ReparentPopoutWidgets.stories-DnWn2Oav.js"), true ? __vite__mapDeps([120,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/preview/ToolSettingsKeyPressCommit.stories.tsx": () => __vitePreload(() => import("./ToolSettingsKeyPressCommit.stories-QgbVUiHL.js"), true ? __vite__mapDeps([121,14,6,7,2,8,4,9,15,10,3,11,12,110]) : void 0, import.meta.url),
  "./src/preview/ToolSettingsLockButton.stories.tsx": () => __vitePreload(() => import("./ToolSettingsLockButton.stories-hvK6P-5L.js"), true ? __vite__mapDeps([122,14,6,7,2,8,4,9,15,10,3,11,12,109,110]) : void 0, import.meta.url),
  "./src/preview/WidgetActionDropdown.stories.tsx": () => __vitePreload(() => import("./WidgetActionDropdown.stories-D13w0Q-I.js"), true ? __vite__mapDeps([123,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/preview/WidgetTabActions.stories.tsx": () => __vitePreload(() => import("./WidgetTabActions.stories-DAL_TXkH.js"), true ? __vite__mapDeps([124,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/widget/CanFloat.stories.tsx": () => __vitePreload(() => import("./CanFloat.stories-DvV74e_S.js"), true ? __vite__mapDeps([125,6,7,2,8,4,9,10,3,11,12,14,15]) : void 0, import.meta.url),
  "./src/widget/CanPopout.stories.tsx": () => __vitePreload(() => import("./CanPopout.stories-DMwVqL16.js"), true ? __vite__mapDeps([126,6,7,2,8,4,9,10,3,11,12,14,15]) : void 0, import.meta.url),
  "./src/widget/EmptyState.stories.tsx": () => __vitePreload(() => import("./EmptyState.stories-DCD6aLtU.js"), true ? __vite__mapDeps([127,6,7,2,8,4,9,10,3,11,12,14,15]) : void 0, import.meta.url),
  "./src/widget/Widget.stories.tsx": () => __vitePreload(() => import("./Widget.stories-cpoTz0Px.js"), true ? __vite__mapDeps([128,6,7,2,8,4,9,14,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/widget/WidgetContentLayout/WidgetContentLayout.Body.stories.tsx": () => __vitePreload(() => import("./WidgetContentLayout.Body.stories-CztbveAA.js"), true ? __vite__mapDeps([129,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/widget/WidgetContentLayout/WidgetContentLayout.Header.stories.tsx": () => __vitePreload(() => import("./WidgetContentLayout.Header.stories-DJHwFGn0.js"), true ? __vite__mapDeps([130,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url),
  "./src/widget/WidgetContentLayout/WidgetContentLayout.stories.tsx": () => __vitePreload(() => import("./WidgetContentLayout.stories-BTw7k4IQ.js"), true ? __vite__mapDeps([131,14,6,7,2,8,4,9,15,10,3,11,12]) : void 0, import.meta.url)
};
async function importFn(path) {
  return await importers[path]();
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f4 = n2.default;
  if (typeof f4 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f4, arguments, this.constructor);
      }
      return f4.apply(this, arguments);
    };
    a2.prototype = f4.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var react = { exports: {} };
var react_production = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production;
function requireReact_production() {
  if (hasRequiredReact_production) return react_production;
  hasRequiredReact_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var ReactNoopUpdateQueue = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, assign = Object.assign, emptyObject = {};
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  function ComponentDummy() {
  }
  ComponentDummy.prototype = Component.prototype;
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  var isArrayImpl = Array.isArray;
  function noop4() {
  }
  var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty5 = Object.prototype.hasOwnProperty;
  function ReactElement3(type5, key, props) {
    var refProp = props.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type5,
      key,
      ref: void 0 !== refProp ? refProp : null,
      props
    };
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    return ReactElement3(oldElement.type, newKey, oldElement.props);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function escape3(key) {
    var escaperLookup = { "=": "=0", ":": "=2" };
    return "$" + key.replace(/[=:]/g, function(match) {
      return escaperLookup[match];
    });
  }
  var userProvidedKeyEscapeRegex = /\/+/g;
  function getElementKey(element, index2) {
    return "object" === typeof element && null !== element && null != element.key ? escape3("" + element.key) : index2.toString(36);
  }
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop4, noop4) : (thenable.status = "pending", thenable.then(
          function(fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          },
          function(error) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
          }
        )), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type5 = typeof children;
    if ("undefined" === type5 || "boolean" === type5) children = null;
    var invokeCallback = false;
    if (null === children) invokeCallback = true;
    else
      switch (type5) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = true;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
          }
      }
    if (invokeCallback)
      return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
        return c2;
      })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
        callback,
        escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
          userProvidedKeyEscapeRegex,
          "$&/"
        ) + "/") + invokeCallback
      )), array.push(callback)), 1;
    invokeCallback = 0;
    var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children))
      for (var i2 = 0; i2 < children.length; i2++)
        nameSoFar = children[i2], type5 = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type5,
          callback
        );
    else if (i2 = getIteratorFn(children), "function" === typeof i2)
      for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
        nameSoFar = nameSoFar.value, type5 = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type5,
          callback
        );
    else if ("object" === type5) {
      if ("function" === typeof children.then)
        return mapIntoArray(
          resolveThenable(children),
          array,
          escapedPrefix,
          nameSoFar,
          callback
        );
      array = String(children);
      throw Error(
        "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return invokeCallback;
  }
  function mapChildren(children, func, context) {
    if (null == children) return children;
    var result = [], count2 = 0;
    mapIntoArray(children, result, "", "", function(child) {
      return func.call(context, child, count2++);
    });
    return result;
  }
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(
        function(moduleObject) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 1, payload._result = moduleObject;
        },
        function(error) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 2, payload._result = error;
        }
      );
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return payload._result.default;
    throw payload._result;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  }, Children = {
    map: mapChildren,
    forEach: function(children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function() {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function(children) {
      var n2 = 0;
      mapChildren(children, function() {
        n2++;
      });
      return n2;
    },
    toArray: function(children) {
      return mapChildren(children, function(child) {
        return child;
      }) || [];
    },
    only: function(children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
  react_production.Activity = REACT_ACTIVITY_TYPE;
  react_production.Children = Children;
  react_production.Component = Component;
  react_production.Fragment = REACT_FRAGMENT_TYPE;
  react_production.Profiler = REACT_PROFILER_TYPE;
  react_production.PureComponent = PureComponent;
  react_production.StrictMode = REACT_STRICT_MODE_TYPE;
  react_production.Suspense = REACT_SUSPENSE_TYPE;
  react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  react_production.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(size2) {
      return ReactSharedInternals.H.useMemoCache(size2);
    }
  };
  react_production.cache = function(fn3) {
    return function() {
      return fn3.apply(null, arguments);
    };
  };
  react_production.cacheSignal = function() {
    return null;
  };
  react_production.cloneElement = function(element, config4, children) {
    if (null === element || void 0 === element)
      throw Error(
        "The argument must be a React element, but you passed " + element + "."
      );
    var props = assign({}, element.props), key = element.key;
    if (null != config4)
      for (propName in void 0 !== config4.key && (key = "" + config4.key), config4)
        !hasOwnProperty5.call(config4, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config4.ref || (props[propName] = config4[propName]);
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;
    else if (1 < propName) {
      for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    return ReactElement3(element.type, key, props);
  };
  react_production.createContext = function(defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    return defaultValue;
  };
  react_production.createElement = function(type5, config4, children) {
    var propName, props = {}, key = null;
    if (null != config4)
      for (propName in void 0 !== config4.key && (key = "" + config4.key), config4)
        hasOwnProperty5.call(config4, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config4[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;
    else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    if (type5 && type5.defaultProps)
      for (propName in childrenLength = type5.defaultProps, childrenLength)
        void 0 === props[propName] && (props[propName] = childrenLength[propName]);
    return ReactElement3(type5, key, props);
  };
  react_production.createRef = function() {
    return { current: null };
  };
  react_production.forwardRef = function(render2) {
    return { $$typeof: REACT_FORWARD_REF_TYPE, render: render2 };
  };
  react_production.isValidElement = isValidElement;
  react_production.lazy = function(ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: { _status: -1, _result: ctor },
      _init: lazyInitializer
    };
  };
  react_production.memo = function(type5, compare) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type: type5,
      compare: void 0 === compare ? null : compare
    };
  };
  react_production.startTransition = function(scope2) {
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = scope2(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop4, reportGlobalError);
    } catch (error) {
      reportGlobalError(error);
    } finally {
      null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  };
  react_production.unstable_useCacheRefresh = function() {
    return ReactSharedInternals.H.useCacheRefresh();
  };
  react_production.use = function(usable) {
    return ReactSharedInternals.H.use(usable);
  };
  react_production.useActionState = function(action2, initialState, permalink) {
    return ReactSharedInternals.H.useActionState(action2, initialState, permalink);
  };
  react_production.useCallback = function(callback, deps) {
    return ReactSharedInternals.H.useCallback(callback, deps);
  };
  react_production.useContext = function(Context) {
    return ReactSharedInternals.H.useContext(Context);
  };
  react_production.useDebugValue = function() {
  };
  react_production.useDeferredValue = function(value, initialValue2) {
    return ReactSharedInternals.H.useDeferredValue(value, initialValue2);
  };
  react_production.useEffect = function(create, deps) {
    return ReactSharedInternals.H.useEffect(create, deps);
  };
  react_production.useEffectEvent = function(callback) {
    return ReactSharedInternals.H.useEffectEvent(callback);
  };
  react_production.useId = function() {
    return ReactSharedInternals.H.useId();
  };
  react_production.useImperativeHandle = function(ref, create, deps) {
    return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
  };
  react_production.useInsertionEffect = function(create, deps) {
    return ReactSharedInternals.H.useInsertionEffect(create, deps);
  };
  react_production.useLayoutEffect = function(create, deps) {
    return ReactSharedInternals.H.useLayoutEffect(create, deps);
  };
  react_production.useMemo = function(create, deps) {
    return ReactSharedInternals.H.useMemo(create, deps);
  };
  react_production.useOptimistic = function(passthrough, reducer) {
    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
  };
  react_production.useReducer = function(reducer, initialArg, init2) {
    return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);
  };
  react_production.useRef = function(initialValue2) {
    return ReactSharedInternals.H.useRef(initialValue2);
  };
  react_production.useState = function(initialState) {
    return ReactSharedInternals.H.useState(initialState);
  };
  react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
    return ReactSharedInternals.H.useSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    );
  };
  react_production.useTransition = function() {
    return ReactSharedInternals.H.useTransition();
  };
  react_production.version = "19.2.1";
  return react_production;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production();
  }
  return react.exports;
}
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React8 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
const { defaultDecorateStory } = __STORYBOOK_MODULE_PREVIEW_API__;
var applyDecorators = (storyFn, decorators4) => defaultDecorateStory((context) => React.createElement(storyFn, context), decorators4);
var __create$1 = Object.create;
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf, __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export$2 = (target, all) => {
  for (var name in all)
    __defProp$3(target, name, { get: all[name], enumerable: true });
}, __copyProps$1 = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames$1(from))
      !__hasOwnProp$2.call(to, key) && key !== except && __defProp$3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable });
  return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp$3(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var entry_preview_exports = {};
__export$2(entry_preview_exports, {
  applyDecorators: () => applyDecorators,
  beforeAll: () => beforeAll,
  decorators: () => decorators$2,
  mount: () => mount,
  parameters: () => parameters$3,
  render: () => render,
  renderToCanvas: () => renderToCanvas
});
const { global: global2 } = __STORYBOOK_MODULE_GLOBAL__;
const { configure } = __STORYBOOK_MODULE_TEST__;
function setReactActEnvironment(isReactActEnvironment) {
  globalThis.IS_REACT_ACT_ENVIRONMENT = isReactActEnvironment;
}
function getReactActEnvironment() {
  return globalThis.IS_REACT_ACT_ENVIRONMENT;
}
var getAct = async ({ disableAct = false } = {}) => {
  return (cb) => cb();
};
var render = (args, context) => {
  let { id, component: Component } = context;
  if (!Component)
    throw new Error(
      `Unable to render story ${id} as the component annotation is missing from the default export`
    );
  return React.createElement(Component, { ...args });
};
const { global: global$2 } = __STORYBOOK_MODULE_GLOBAL__;
var { FRAMEWORK_OPTIONS } = global$2, ErrorBoundary = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidMount() {
    let { hasError } = this.state, { showMain } = this.props;
    hasError || showMain();
  }
  componentDidCatch(err) {
    let { showException } = this.props;
    showException(err);
  }
  render() {
    let { hasError } = this.state, { children } = this.props;
    return hasError ? null : children;
  }
}, Wrapper = FRAMEWORK_OPTIONS?.strictMode ? reactExports.StrictMode : reactExports.Fragment, actQueue = [], isActing = false, processActQueue = async () => {
  if (isActing || actQueue.length === 0)
    return;
  isActing = true;
  let actTask = actQueue.shift();
  actTask && await actTask(), isActing = false, processActQueue();
};
async function renderToCanvas({
  storyContext,
  unboundStoryFn,
  showMain,
  showException,
  forceRemount
}, canvasElement) {
  let { renderElement, unmountElement } = await __vitePreload(async () => {
    const { renderElement: renderElement2, unmountElement: unmountElement2 } = await import("./react-18-DZdtAi6r.js");
    return { renderElement: renderElement2, unmountElement: unmountElement2 };
  }, true ? __vite__mapDeps([132,8,2]) : void 0, import.meta.url), Story = unboundStoryFn, content = storyContext.parameters.__isPortableStory ? React.createElement(Story, { ...storyContext }) : React.createElement(ErrorBoundary, { key: storyContext.id, showMain, showException }, React.createElement(Story, { ...storyContext })), element = Wrapper ? React.createElement(Wrapper, null, content) : content;
  forceRemount && unmountElement(canvasElement);
  let act = await getAct({ disableAct: storyContext.viewMode === "docs" });
  return await new Promise(async (resolve, reject) => {
    actQueue.push(async () => {
      try {
        await act(async () => {
          await renderElement(element, canvasElement, storyContext?.parameters?.react?.rootOptions);
        }), resolve();
      } catch (e2) {
        reject(e2);
      }
    }), processActQueue();
  }), async () => {
    await act(() => {
      unmountElement(canvasElement);
    });
  };
}
var mount = (context) => async (ui) => (ui != null && (context.originalStoryFn = () => ui), await context.renderToCanvas(), context.canvas);
var decorators$2 = [
  (story, context) => {
    if (!context.parameters?.react?.rsc)
      return story();
    let [major, minor] = reactExports.version.split(".").map((part) => parseInt(part, 10));
    if (!Number.isInteger(major) || !Number.isInteger(minor))
      throw new Error("Unable to parse React version");
    if (major < 18 || major === 18 && minor < 3)
      throw new Error("React Server Components require React >= 18.3");
    return reactExports.createElement(reactExports.Suspense, null, story());
  },
  (story, context) => {
    if (context.tags?.includes("test-fn") && !global2.FEATURES?.experimentalTestSyntax)
      throw new Error(
        "To use the experimental test function, you must enable the experimentalTestSyntax feature flag. See https://storybook.js.org/docs/10/api/main-config/main-config-features#experimentalTestSyntax"
      );
    return story();
  }
], parameters$3 = {
  renderer: "react"
}, beforeAll = async () => {
  try {
    let act = await getAct();
    configure({
      unstable_advanceTimersWrapper: (cb) => act(cb),
      // For more context about why we need disable act warnings in waitFor:
      // https://github.com/reactwg/react-18/discussions/102
      asyncWrapper: async (cb) => {
        let previousActEnvironment = getReactActEnvironment();
        setReactActEnvironment(false);
        try {
          let result = await cb();
          return await new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, 0), jestFakeTimersAreEnabled() && jest.advanceTimersByTime(0);
          }), result;
        } finally {
          setReactActEnvironment(previousActEnvironment);
        }
      },
      eventWrapper: (cb) => {
        let result;
        return act(() => (result = cb(), result)), result;
      }
    });
  } catch {
  }
};
function jestFakeTimersAreEnabled() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === true || // modern timers
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : false;
}
const entry_preview_19440 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyDecorators,
  beforeAll,
  decorators: decorators$2,
  mount,
  parameters: parameters$3,
  render,
  renderToCanvas
}, Symbol.toStringTag, { value: "Module" }));
var require_dist = __commonJS$1({
  "../../node_modules/@base2/pretty-print-object/dist/index.js"(exports) {
    var __assign = exports && exports.__assign || function() {
      return __assign = Object.assign || function(t3) {
        for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s3 = arguments[i2];
          for (var p2 in s3) Object.prototype.hasOwnProperty.call(s3, p2) && (t3[p2] = s3[p2]);
        }
        return t3;
      }, __assign.apply(this, arguments);
    }, __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s3 += arguments[i2].length;
      for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var seen = [];
    function isObj(value) {
      var type5 = typeof value;
      return value !== null && (type5 === "object" || type5 === "function");
    }
    function isRegexp(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    }
    function getOwnEnumPropSymbols(object) {
      return Object.getOwnPropertySymbols(object).filter(function(keySymbol) {
        return Object.prototype.propertyIsEnumerable.call(object, keySymbol);
      });
    }
    function prettyPrint2(input2, options, pad) {
      pad === void 0 && (pad = "");
      var defaultOptions2 = {
        indent: "	",
        singleQuotes: true
      }, combinedOptions = __assign(__assign({}, defaultOptions2), options), tokens;
      combinedOptions.inlineCharacterLimit === void 0 ? tokens = {
        newLine: `
`,
        newLineOrSpace: `
`,
        pad,
        indent: pad + combinedOptions.indent
      } : tokens = {
        newLine: "@@__PRETTY_PRINT_NEW_LINE__@@",
        newLineOrSpace: "@@__PRETTY_PRINT_NEW_LINE_OR_SPACE__@@",
        pad: "@@__PRETTY_PRINT_PAD__@@",
        indent: "@@__PRETTY_PRINT_INDENT__@@"
      };
      var expandWhiteSpace = function(string) {
        if (combinedOptions.inlineCharacterLimit === void 0)
          return string;
        var oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
        return oneLined.length <= combinedOptions.inlineCharacterLimit ? oneLined : string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), `
`).replace(new RegExp(tokens.pad, "g"), pad).replace(new RegExp(tokens.indent, "g"), pad + combinedOptions.indent);
      };
      if (seen.indexOf(input2) !== -1)
        return '"[Circular]"';
      if (input2 == null || typeof input2 == "number" || typeof input2 == "boolean" || typeof input2 == "function" || typeof input2 == "symbol" || isRegexp(input2))
        return String(input2);
      if (input2 instanceof Date)
        return "new Date('" + input2.toISOString() + "')";
      if (Array.isArray(input2)) {
        if (input2.length === 0)
          return "[]";
        seen.push(input2);
        var ret = "[" + tokens.newLine + input2.map(function(el, i2) {
          var eol = input2.length - 1 === i2 ? tokens.newLine : "," + tokens.newLineOrSpace, value = prettyPrint2(el, combinedOptions, pad + combinedOptions.indent);
          return combinedOptions.transform && (value = combinedOptions.transform(input2, i2, value)), tokens.indent + value + eol;
        }).join("") + tokens.pad + "]";
        return seen.pop(), expandWhiteSpace(ret);
      }
      if (isObj(input2)) {
        var objKeys_1 = __spreadArrays(Object.keys(input2), getOwnEnumPropSymbols(input2));
        if (combinedOptions.filter && (objKeys_1 = objKeys_1.filter(function(el) {
          return combinedOptions.filter && combinedOptions.filter(input2, el);
        })), objKeys_1.length === 0)
          return "{}";
        seen.push(input2);
        var ret = "{" + tokens.newLine + objKeys_1.map(function(el, i2) {
          var eol = objKeys_1.length - 1 === i2 ? tokens.newLine : "," + tokens.newLineOrSpace, isSymbol2 = typeof el == "symbol", isClassic = !isSymbol2 && /^[a-z$_][a-z$_0-9]*$/i.test(el.toString()), key = isSymbol2 || isClassic ? el : prettyPrint2(el, combinedOptions), value = prettyPrint2(input2[el], combinedOptions, pad + combinedOptions.indent);
          return combinedOptions.transform && (value = combinedOptions.transform(input2, el, value)), tokens.indent + String(key) + ": " + value + eol;
        }).join("") + tokens.pad + "}";
        return seen.pop(), expandWhiteSpace(ret);
      }
      return input2 = String(input2).replace(/[\r\n]/g, function(x2) {
        return x2 === `
` ? "\\n" : "\\r";
      }), combinedOptions.singleQuotes ? (input2 = input2.replace(/\\?'/g, "\\'"), "'" + input2 + "'") : (input2 = input2.replace(/"/g, '\\"'), '"' + input2 + '"');
    }
    exports.prettyPrint = prettyPrint2;
  }
});
var require_react_is_production_min = __commonJS$1({
  "../../node_modules/react-element-to-jsx-string/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e2 = Symbol.for("react.strict_mode"), f4 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h3 = Symbol.for("react.context"), k2 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t3 = Symbol.for("react.offscreen"), u3;
    u3 = Symbol.for("react.module.reference");
    function v2(a2) {
      if (typeof a2 == "object" && a2 !== null) {
        var r2 = a2.$$typeof;
        switch (r2) {
          case b2:
            switch (a2 = a2.type, a2) {
              case d:
              case f4:
              case e2:
              case m:
              case n2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k2:
                  case h3:
                  case l2:
                  case q:
                  case p2:
                  case g2:
                    return a2;
                  default:
                    return r2;
                }
            }
          case c2:
            return r2;
        }
      }
    }
    exports.ContextConsumer = h3;
    exports.ContextProvider = g2;
    exports.Element = b2;
    exports.ForwardRef = l2;
    exports.Fragment = d;
    exports.Lazy = q;
    exports.Memo = p2;
    exports.Portal = c2;
    exports.Profiler = f4;
    exports.StrictMode = e2;
    exports.Suspense = m;
    exports.SuspenseList = n2;
    exports.isAsyncMode = function() {
      return false;
    };
    exports.isConcurrentMode = function() {
      return false;
    };
    exports.isContextConsumer = function(a2) {
      return v2(a2) === h3;
    };
    exports.isContextProvider = function(a2) {
      return v2(a2) === g2;
    };
    exports.isElement = function(a2) {
      return typeof a2 == "object" && a2 !== null && a2.$$typeof === b2;
    };
    exports.isForwardRef = function(a2) {
      return v2(a2) === l2;
    };
    exports.isFragment = function(a2) {
      return v2(a2) === d;
    };
    exports.isLazy = function(a2) {
      return v2(a2) === q;
    };
    exports.isMemo = function(a2) {
      return v2(a2) === p2;
    };
    exports.isPortal = function(a2) {
      return v2(a2) === c2;
    };
    exports.isProfiler = function(a2) {
      return v2(a2) === f4;
    };
    exports.isStrictMode = function(a2) {
      return v2(a2) === e2;
    };
    exports.isSuspense = function(a2) {
      return v2(a2) === m;
    };
    exports.isSuspenseList = function(a2) {
      return v2(a2) === n2;
    };
    exports.isValidElementType = function(a2) {
      return typeof a2 == "string" || typeof a2 == "function" || a2 === d || a2 === f4 || a2 === e2 || a2 === m || a2 === n2 || a2 === t3 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h3 || a2.$$typeof === l2 || a2.$$typeof === u3 || a2.getModuleId !== void 0);
    };
    exports.typeOf = v2;
  }
});
var require_react_is = __commonJS$1({
  "../../node_modules/react-element-to-jsx-string/node_modules/react-is/index.js"(exports, module2) {
    module2.exports = require_react_is_production_min();
  }
});
var isMemo = (component) => component.$$typeof === Symbol.for("react.memo"), isForwardRef = (component) => component.$$typeof === Symbol.for("react.forward_ref");
function isObject(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainObject$1(o2) {
  var ctor, prot;
  return isObject(o2) === false ? false : (ctor = o2.constructor, ctor === void 0 ? true : (prot = ctor.prototype, !(isObject(prot) === false || prot.hasOwnProperty("isPrototypeOf") === false)));
}
var import_pretty_print_object = __toESM$1(require_dist()), import_react_is = __toESM$1(require_react_is());
var spacer = function(times, tabStop) {
  return times === 0 ? "" : new Array(times * tabStop).fill(" ").join("");
};
function _arrayLikeToArray(r2, a2) {
  (a2 == null || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _defineProperty(e2, r2, t3) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t3, e2;
}
function _iterableToArray(r2) {
  if (typeof Symbol < "u" && r2[Symbol.iterator] != null || r2["@@iterator"] != null) return Array.from(r2);
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ownKeys(e2, r2) {
  var t3 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t3.push.apply(t3, o2);
  }
  return t3;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t3), true).forEach(function(r22) {
      _defineProperty(e2, r22, t3[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t3, r22));
    });
  }
  return e2;
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _toPrimitive(t3, r2) {
  if (typeof t3 != "object" || !t3) return t3;
  var e2 = t3[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i2 = e2.call(t3, r2);
    if (typeof i2 != "object") return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r2 === "string" ? String : Number)(t3);
}
function _toPropertyKey(t3) {
  var i2 = _toPrimitive(t3, "string");
  return typeof i2 == "symbol" ? i2 : i2 + "";
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof(o2);
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if (typeof r2 == "string") return _arrayLikeToArray(r2, a2);
    var t3 = {}.toString.call(r2).slice(8, -1);
    return t3 === "Object" && r2.constructor && (t3 = r2.constructor.name), t3 === "Map" || t3 === "Set" ? Array.from(r2) : t3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function safeSortObject(value, seen) {
  if (value === null || _typeof(value) !== "object" || value instanceof Date || value instanceof RegExp)
    return value;
  if (reactExports.isValidElement(value)) {
    var copyObj = _objectSpread2({}, value);
    return delete copyObj._owner, copyObj;
  }
  return seen.add(value), Array.isArray(value) ? value.map(function(v2) {
    return safeSortObject(v2, seen);
  }) : Object.keys(value).sort().reduce(function(result, key) {
    return key === "current" || seen.has(value[key]) ? result[key] = "[Circular]" : result[key] = safeSortObject(value[key], seen), result;
  }, {});
}
function sortObject(value) {
  return safeSortObject(value, /* @__PURE__ */ new WeakSet());
}
var createStringTreeNode = function(value) {
  return {
    type: "string",
    value
  };
}, createNumberTreeNode = function(value) {
  return {
    type: "number",
    value
  };
}, createReactElementTreeNode = function(displayName, props, defaultProps, childrens) {
  return {
    type: "ReactElement",
    displayName,
    props,
    defaultProps,
    childrens
  };
}, createReactFragmentTreeNode = function(key, childrens) {
  return {
    type: "ReactFragment",
    key,
    childrens
  };
}, supportFragment = !!reactExports.Fragment, getFunctionTypeName = function(functionType) {
  return !functionType.name || functionType.name === "_default" ? "No Display Name" : functionType.name;
}, _getWrappedComponentDisplayName = function(Component) {
  switch (true) {
    case !!Component.displayName:
      return Component.displayName;
    case Component.$$typeof === import_react_is.Memo:
      return _getWrappedComponentDisplayName(Component.type);
    case Component.$$typeof === import_react_is.ForwardRef:
      return _getWrappedComponentDisplayName(Component.render);
    default:
      return getFunctionTypeName(Component);
  }
}, getReactElementDisplayName = function(element) {
  switch (true) {
    case typeof element.type == "string":
      return element.type;
    case typeof element.type == "function":
      return element.type.displayName ? element.type.displayName : getFunctionTypeName(element.type);
    case (0, import_react_is.isForwardRef)(element):
    case (0, import_react_is.isMemo)(element):
      return _getWrappedComponentDisplayName(element.type);
    case (0, import_react_is.isContextConsumer)(element):
      return "".concat(element.type._context.displayName || "Context", ".Consumer");
    case (0, import_react_is.isContextProvider)(element):
      return "".concat(element.type._context.displayName || "Context", ".Provider");
    case (0, import_react_is.isLazy)(element):
      return "Lazy";
    case (0, import_react_is.isProfiler)(element):
      return "Profiler";
    case (0, import_react_is.isStrictMode)(element):
      return "StrictMode";
    case (0, import_react_is.isSuspense)(element):
      return "Suspense";
    default:
      return "UnknownElementType";
  }
}, noChildren = function(propsValue, propName) {
  return propName !== "children";
}, onlyMeaningfulChildren = function(children) {
  return children !== true && children !== false && children !== null && children !== "";
}, filterProps = function(originalProps, cb) {
  var filteredProps = {};
  return Object.keys(originalProps).filter(function(key) {
    return cb(originalProps[key], key);
  }).forEach(function(key) {
    return filteredProps[key] = originalProps[key];
  }), filteredProps;
}, _parseReactElement = function(element, options) {
  var _options$displayName = options.displayName, displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;
  if (typeof element == "string")
    return createStringTreeNode(element);
  if (typeof element == "number")
    return createNumberTreeNode(element);
  if (!React.isValidElement(element))
    throw new Error("react-element-to-jsx-string: Expected a React.Element, got `".concat(_typeof(element), "`"));
  var displayName = displayNameFn(element), props = filterProps(element.props, noChildren);
  element.ref !== null && (props.ref = element.ref);
  var key = element.key;
  typeof key == "string" && key.search(/^\./) && (props.key = key);
  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren), childrens = React.Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function(child) {
    return _parseReactElement(child, options);
  });
  return supportFragment && element.type === reactExports.Fragment ? createReactFragmentTreeNode(key, childrens) : createReactElementTreeNode(displayName, props, defaultProps, childrens);
};
function noRefCheck() {
}
var inlineFunction = function(fn3) {
  return fn3.toString().split(`
`).map(function(line) {
    return line.trim();
  }).join("");
};
var defaultFunctionValue = inlineFunction, formatFunction = function(fn3, options) {
  var _options$functionValu = options.functionValue, functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu, showFunctions = options.showFunctions;
  return functionValue(!showFunctions && functionValue === defaultFunctionValue ? noRefCheck : fn3);
}, formatComplexDataStructure = function(value, inline2, lvl, options) {
  var normalizedValue = sortObject(value), stringifiedValue = (0, import_pretty_print_object.prettyPrint)(normalizedValue, {
    transform: function(currentObj, prop, originalResult) {
      var currentValue = currentObj[prop];
      return currentValue && reactExports.isValidElement(currentValue) ? formatTreeNode(_parseReactElement(currentValue, options), true, lvl, options) : typeof currentValue == "function" ? formatFunction(currentValue, options) : originalResult;
    }
  });
  return inline2 ? stringifiedValue.replace(/\s+/g, " ").replace(/{ /g, "{").replace(/ }/g, "}").replace(/\[ /g, "[").replace(/ ]/g, "]") : stringifiedValue.replace(/\t/g, spacer(1, options.tabStop)).replace(/\n([^$])/g, `
`.concat(spacer(lvl + 1, options.tabStop), "$1"));
}, escape$1 = function(s3) {
  return s3.replace(/"/g, "&quot;");
}, formatPropValue = function(propValue, inline2, lvl, options) {
  if (typeof propValue == "number")
    return "{".concat(String(propValue), "}");
  if (typeof propValue == "string")
    return '"'.concat(escape$1(propValue), '"');
  if (_typeof(propValue) === "symbol") {
    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\((.*)\)/, "$1");
    return symbolDescription ? "{Symbol('".concat(symbolDescription, "')}") : "{Symbol()}";
  }
  return typeof propValue == "function" ? "{".concat(formatFunction(propValue, options), "}") : reactExports.isValidElement(propValue) ? "{".concat(formatTreeNode(_parseReactElement(propValue, options), true, lvl, options), "}") : propValue instanceof Date ? isNaN(propValue.valueOf()) ? "{new Date(NaN)}" : '{new Date("'.concat(propValue.toISOString(), '")}') : isPlainObject$1(propValue) || Array.isArray(propValue) ? "{".concat(formatComplexDataStructure(propValue, inline2, lvl, options), "}") : "{".concat(String(propValue), "}");
}, formatProp = function(name, hasValue, value, hasDefaultValue, defaultValue, inline2, lvl, options) {
  if (!hasValue && !hasDefaultValue)
    throw new Error('The prop "'.concat(name, '" has no value and no default: could not be formatted'));
  var usedValue = hasValue ? value : defaultValue, useBooleanShorthandSyntax = options.useBooleanShorthandSyntax, tabStop = options.tabStop, formattedPropValue = formatPropValue(usedValue, inline2, lvl, options), attributeFormattedInline = " ", attributeFormattedMultiline = `
`.concat(spacer(lvl + 1, tabStop)), isMultilineAttribute = formattedPropValue.includes(`
`);
  return useBooleanShorthandSyntax && formattedPropValue === "{false}" && !hasDefaultValue ? (attributeFormattedInline = "", attributeFormattedMultiline = "") : useBooleanShorthandSyntax && formattedPropValue === "{true}" ? (attributeFormattedInline += "".concat(name), attributeFormattedMultiline += "".concat(name)) : (attributeFormattedInline += "".concat(name, "=").concat(formattedPropValue), attributeFormattedMultiline += "".concat(name, "=").concat(formattedPropValue)), {
    attributeFormattedInline,
    attributeFormattedMultiline,
    isMultilineAttribute
  };
}, mergeSiblingPlainStringChildrenReducer = function(previousNodes, currentNode) {
  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0), previousNode = previousNodes[previousNodes.length - 1];
  return previousNode && (currentNode.type === "string" || currentNode.type === "number") && (previousNode.type === "string" || previousNode.type === "number") ? nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value))) : (previousNode && nodes.push(previousNode), nodes.push(currentNode)), nodes;
}, isKeyOrRefProps = function(propName) {
  return ["key", "ref"].includes(propName);
}, sortPropsByNames = function(shouldSortUserProps) {
  return function(props) {
    var haveKeyProp = props.includes("key"), haveRefProp = props.includes("ref"), userPropsOnly = props.filter(function(oneProp) {
      return !isKeyOrRefProps(oneProp);
    }), sortedProps = _toConsumableArray(shouldSortUserProps ? userPropsOnly.sort() : userPropsOnly);
    return haveRefProp && sortedProps.unshift("ref"), haveKeyProp && sortedProps.unshift("key"), sortedProps;
  };
};
function createPropFilter(props, filter) {
  return Array.isArray(filter) ? function(key) {
    return filter.indexOf(key) === -1;
  } : function(key) {
    return filter(props[key], key);
  };
}
var compensateMultilineStringElementIndentation = function(element, formattedElement, inline2, lvl, options) {
  var tabStop = options.tabStop;
  return element.type === "string" ? formattedElement.split(`
`).map(function(line, offset2) {
    return offset2 === 0 ? line : "".concat(spacer(lvl, tabStop)).concat(line);
  }).join(`
`) : formattedElement;
}, formatOneChildren = function(inline2, lvl, options) {
  return function(element) {
    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline2, lvl, options), inline2, lvl, options);
  };
}, onlyPropsWithOriginalValue = function(defaultProps, props) {
  return function(propName) {
    var haveDefaultValue = Object.keys(defaultProps).includes(propName);
    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];
  };
}, isInlineAttributeTooLong = function(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {
  return maxInlineAttributesLineLength ? spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength : attributes.length > 1;
}, shouldRenderMultilineAttr = function(attributes, inlineAttributeString, containsMultilineAttr, inline2, lvl, tabStop, maxInlineAttributesLineLength) {
  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline2;
}, formatReactElementNode = function(node, inline2, lvl, options) {
  var type5 = node.type, _node$displayName = node.displayName, displayName = _node$displayName === void 0 ? "" : _node$displayName, childrens = node.childrens, _node$props = node.props, props = _node$props === void 0 ? {} : _node$props, _node$defaultProps = node.defaultProps, defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;
  if (type5 !== "ReactElement")
    throw new Error('The "formatReactElementNode" function could only format node of type "ReactElement". Given:  '.concat(type5));
  var filterProps3 = options.filterProps, maxInlineAttributesLineLength = options.maxInlineAttributesLineLength, showDefaultProps = options.showDefaultProps, sortProps = options.sortProps, tabStop = options.tabStop, out = "<".concat(displayName), outInlineAttr = out, outMultilineAttr = out, containsMultilineAttr = false, visibleAttributeNames = [], propFilter = createPropFilter(props, filterProps3);
  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function(propName) {
    return visibleAttributeNames.push(propName);
  }), Object.keys(defaultProps).filter(propFilter).filter(function() {
    return showDefaultProps;
  }).filter(function(defaultPropName) {
    return !visibleAttributeNames.includes(defaultPropName);
  }).forEach(function(defaultPropName) {
    return visibleAttributeNames.push(defaultPropName);
  });
  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);
  if (attributes.forEach(function(attributeName) {
    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline2, lvl, options), attributeFormattedInline = _formatProp.attributeFormattedInline, attributeFormattedMultiline = _formatProp.attributeFormattedMultiline, isMultilineAttribute = _formatProp.isMultilineAttribute;
    isMultilineAttribute && (containsMultilineAttr = true), outInlineAttr += attributeFormattedInline, outMultilineAttr += attributeFormattedMultiline;
  }), outMultilineAttr += `
`.concat(spacer(lvl, tabStop)), shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline2, lvl, tabStop, maxInlineAttributesLineLength) ? out = outMultilineAttr : out = outInlineAttr, childrens && childrens.length > 0) {
    var newLvl = lvl + 1;
    out += ">", inline2 || (out += `
`, out += spacer(newLvl, tabStop)), out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline2, newLvl, options)).join(inline2 ? "" : `
`.concat(spacer(newLvl, tabStop))), inline2 || (out += `
`, out += spacer(newLvl - 1, tabStop)), out += "</".concat(displayName, ">");
  } else
    isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength) || (out += " "), out += "/>";
  return out;
}, REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = "", REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = "React.Fragment", toReactElementTreeNode = function(displayName, key, childrens) {
  var props = {};
  return key && (props = {
    key
  }), {
    type: "ReactElement",
    displayName,
    props,
    defaultProps: {},
    childrens
  };
}, isKeyedFragment = function(_ref) {
  var key = _ref.key;
  return !!key;
}, hasNoChildren = function(_ref2) {
  var childrens = _ref2.childrens;
  return childrens.length === 0;
}, formatReactFragmentNode = function(node, inline2, lvl, options) {
  var type5 = node.type, key = node.key, childrens = node.childrens;
  if (type5 !== "ReactFragment")
    throw new Error('The "formatReactFragmentNode" function could only format node of type "ReactFragment". Given: '.concat(type5));
  var useFragmentShortSyntax = options.useFragmentShortSyntax, displayName;
  return useFragmentShortSyntax ? hasNoChildren(node) || isKeyedFragment(node) ? displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX : displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX : displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX, formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline2, lvl, options);
}, jsxStopChars = ["<", ">", "{", "}"], shouldBeEscaped = function(s3) {
  return jsxStopChars.some(function(jsxStopChar) {
    return s3.includes(jsxStopChar);
  });
}, escape2 = function(s3) {
  return shouldBeEscaped(s3) ? "{`".concat(s3, "`}") : s3;
}, preserveTrailingSpace = function(s3) {
  var result = s3;
  return result.endsWith(" ") && (result = result.replace(/^(.*?)(\s+)$/, "$1{'$2'}")), result.startsWith(" ") && (result = result.replace(/^(\s+)(.*)$/, "{'$1'}$2")), result;
}, formatTreeNode = function(node, inline2, lvl, options) {
  if (node.type === "number")
    return String(node.value);
  if (node.type === "string")
    return node.value ? "".concat(preserveTrailingSpace(escape2(String(node.value)))) : "";
  if (node.type === "ReactElement")
    return formatReactElementNode(node, inline2, lvl, options);
  if (node.type === "ReactFragment")
    return formatReactFragmentNode(node, inline2, lvl, options);
  throw new TypeError('Unknow format type "'.concat(node.type, '"'));
}, formatTree = function(node, options) {
  return formatTreeNode(node, false, 0, options);
}, reactElementToJsxString = function(element) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$filterProps = _ref.filterProps, filterProps3 = _ref$filterProps === void 0 ? [] : _ref$filterProps, _ref$showDefaultProps = _ref.showDefaultProps, showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps, _ref$showFunctions = _ref.showFunctions, showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions, functionValue = _ref.functionValue, _ref$tabStop = _ref.tabStop, tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop, _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax, useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth, _ref$useFragmentShort = _ref.useFragmentShortSyntax, useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort, _ref$sortProps = _ref.sortProps, sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps, maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength, displayName = _ref.displayName;
  if (!element)
    throw new Error("react-element-to-jsx-string: Expected a ReactElement");
  var options = {
    filterProps: filterProps3,
    showDefaultProps,
    showFunctions,
    functionValue,
    tabStop,
    useBooleanShorthandSyntax,
    useFragmentShortSyntax,
    sortProps,
    maxInlineAttributesLineLength,
    displayName
  };
  return formatTree(_parseReactElement(element, options), options);
};
var require_estraverse = __commonJS$1({
  "../../node_modules/estraverse/estraverse.js"(exports) {
    (function clone2(exports2) {
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj)
          obj.hasOwnProperty(key) && (val = obj[key], typeof val == "object" && val !== null ? ret[key] = deepCopy(val) : ret[key] = val);
        return ret;
      }
      function upperBound(array, func) {
        var diff2, len, i2, current;
        for (len = array.length, i2 = 0; len; )
          diff2 = len >>> 1, current = i2 + diff2, func(array[current]) ? len = diff2 : (i2 = current + 1, len -= diff2 + 1);
        return i2;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, BREAK = {}, SKIP = {}, REMOVE = {}, VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent, this.key = key;
      }
      Reference.prototype.replace = function(node) {
        this.parent[this.key] = node;
      }, Reference.prototype.remove = function() {
        return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), true) : (this.replace(null), false);
      };
      function Element2(node, path, wrap, ref) {
        this.node = node, this.path = path, this.wrap = wrap, this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function() {
        var i2, iz, j2, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2))
            for (j2 = 0, jz = path2.length; j2 < jz; ++j2)
              result2.push(path2[j2]);
          else
            result2.push(path2);
        }
        if (!this.__current.path)
          return null;
        for (result = [], i2 = 2, iz = this.__leavelist.length; i2 < iz; ++i2)
          element = this.__leavelist[i2], addToPath(result, element.path);
        return addToPath(result, this.__current.path), result;
      }, Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      }, Controller.prototype.parents = function() {
        var i2, iz, result;
        for (result = [], i2 = 1, iz = this.__leavelist.length; i2 < iz; ++i2)
          result.push(this.__leavelist[i2].node);
        return result;
      }, Controller.prototype.current = function() {
        return this.__current.node;
      }, Controller.prototype.__execute = function(callback, element) {
        var previous, result;
        return result = void 0, previous = this.__current, this.__current = element, this.__state = null, callback && (result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = previous, result;
      }, Controller.prototype.notify = function(flag3) {
        this.__state = flag3;
      }, Controller.prototype.skip = function() {
        this.notify(SKIP);
      }, Controller.prototype.break = function() {
        this.notify(BREAK);
      }, Controller.prototype.remove = function() {
        this.notify(REMOVE);
      }, Controller.prototype.__initialize = function(root2, visitor) {
        this.visitor = visitor, this.root = root2, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, visitor.fallback === "iteration" ? this.__fallback = Object.keys : typeof visitor.fallback == "function" && (this.__fallback = visitor.fallback), this.__keys = VisitorKeys, visitor.keys && (this.__keys = Object.assign(Object.create(this.__keys), visitor.keys));
      };
      function isNode2(node) {
        return node == null ? false : typeof node == "object" && typeof node.type == "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && key === "properties";
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i2 = leavelist.length - 1; i2 >= 0; --i2)
          if (leavelist[i2].node === candidate)
            return true;
        return false;
      }
      Controller.prototype.traverse = function(root2, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        for (this.__initialize(root2, visitor), sentinel = {}, worklist = this.__worklist, leavelist = this.__leavelist, worklist.push(new Element2(root2, null, null, null)), leavelist.push(new Element2(null, null, null, null)); worklist.length; ) {
          if (element = worklist.pop(), element === sentinel) {
            if (element = leavelist.pop(), ret = this.__execute(visitor.leave, element), this.__state === BREAK || ret === BREAK)
              return;
            continue;
          }
          if (element.node) {
            if (ret = this.__execute(visitor.enter, element), this.__state === BREAK || ret === BREAK)
              return;
            if (worklist.push(sentinel), leavelist.push(element), this.__state === SKIP || ret === SKIP)
              continue;
            if (node = element.node, nodeType = node.type || element.wrap, candidates = this.__keys[nodeType], !candidates)
              if (this.__fallback)
                candidates = this.__fallback(node);
              else
                throw new Error("Unknown node type " + nodeType + ".");
            for (current = candidates.length; (current -= 1) >= 0; )
              if (key = candidates[current], candidate = node[key], !!candidate) {
                if (Array.isArray(candidate)) {
                  for (current2 = candidate.length; (current2 -= 1) >= 0; )
                    if (candidate[current2] && !candidateExistsInLeaveList(leavelist, candidate[current2])) {
                      if (isProperty(nodeType, candidates[current]))
                        element = new Element2(candidate[current2], [key, current2], "Property", null);
                      else if (isNode2(candidate[current2]))
                        element = new Element2(candidate[current2], [key, current2], null, null);
                      else
                        continue;
                      worklist.push(element);
                    }
                } else if (isNode2(candidate)) {
                  if (candidateExistsInLeaveList(leavelist, candidate))
                    continue;
                  worklist.push(new Element2(candidate, key, null, null));
                }
              }
          }
        }
      }, Controller.prototype.replace = function(root2, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i2, key2, nextElem, parent;
          if (element2.ref.remove()) {
            for (key2 = element2.ref.key, parent = element2.ref.parent, i2 = worklist.length; i2--; )
              if (nextElem = worklist[i2], nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2)
                  break;
                --nextElem.ref.key;
              }
          }
        }
        for (this.__initialize(root2, visitor), sentinel = {}, worklist = this.__worklist, leavelist = this.__leavelist, outer = {
          root: root2
        }, element = new Element2(root2, null, null, new Reference(outer, "root")), worklist.push(element), leavelist.push(element); worklist.length; ) {
          if (element = worklist.pop(), element === sentinel) {
            if (element = leavelist.pop(), target = this.__execute(visitor.leave, element), target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE && element.ref.replace(target), (this.__state === REMOVE || target === REMOVE) && removeElem(element), this.__state === BREAK || target === BREAK)
              return outer.root;
            continue;
          }
          if (target = this.__execute(visitor.enter, element), target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE && (element.ref.replace(target), element.node = target), (this.__state === REMOVE || target === REMOVE) && (removeElem(element), element.node = null), this.__state === BREAK || target === BREAK)
            return outer.root;
          if (node = element.node, !!node && (worklist.push(sentinel), leavelist.push(element), !(this.__state === SKIP || target === SKIP))) {
            if (nodeType = node.type || element.wrap, candidates = this.__keys[nodeType], !candidates)
              if (this.__fallback)
                candidates = this.__fallback(node);
              else
                throw new Error("Unknown node type " + nodeType + ".");
            for (current = candidates.length; (current -= 1) >= 0; )
              if (key = candidates[current], candidate = node[key], !!candidate)
                if (Array.isArray(candidate)) {
                  for (current2 = candidate.length; (current2 -= 1) >= 0; )
                    if (candidate[current2]) {
                      if (isProperty(nodeType, candidates[current]))
                        element = new Element2(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                      else if (isNode2(candidate[current2]))
                        element = new Element2(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                      else
                        continue;
                      worklist.push(element);
                    }
                } else isNode2(candidate) && worklist.push(new Element2(candidate, key, null, new Reference(node, key)));
          }
        }
        return outer.root;
      };
      function traverse(root2, visitor) {
        var controller = new Controller();
        return controller.traverse(root2, visitor);
      }
      function replace(root2, visitor) {
        var controller = new Controller();
        return controller.replace(root2, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        return target = upperBound(tokens, function(token) {
          return token.range[0] > comment.range[0];
        }), comment.extendedRange = [comment.range[0], comment.range[1]], target !== tokens.length && (comment.extendedRange[1] = tokens[target].range[0]), target -= 1, target >= 0 && (comment.extendedRange[0] = tokens[target].range[1]), comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i2, cursor;
        if (!tree.range)
          throw new Error("attachComments needs range information");
        if (!tokens.length) {
          if (providedComments.length) {
            for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1)
              comment = deepCopy(providedComments[i2]), comment.extendedRange = [0, tree.range[0]], comments.push(comment);
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1)
          comments.push(extendCommentRange(deepCopy(providedComments[i2]), tokens));
        return cursor = 0, traverse(tree, {
          enter: function(node) {
            for (var comment2; cursor < comments.length && (comment2 = comments[cursor], !(comment2.extendedRange[1] > node.range[0])); )
              comment2.extendedRange[1] === node.range[0] ? (node.leadingComments || (node.leadingComments = []), node.leadingComments.push(comment2), comments.splice(cursor, 1)) : cursor += 1;
            if (cursor === comments.length)
              return VisitorOption.Break;
            if (comments[cursor].extendedRange[0] > node.range[1])
              return VisitorOption.Skip;
          }
        }), cursor = 0, traverse(tree, {
          leave: function(node) {
            for (var comment2; cursor < comments.length && (comment2 = comments[cursor], !(node.range[1] < comment2.extendedRange[0])); )
              node.range[1] === comment2.extendedRange[0] ? (node.trailingComments || (node.trailingComments = []), node.trailingComments.push(comment2), comments.splice(cursor, 1)) : cursor += 1;
            if (cursor === comments.length)
              return VisitorOption.Break;
            if (comments[cursor].extendedRange[0] > node.range[1])
              return VisitorOption.Skip;
          }
        }), tree;
      }
      return exports2.Syntax = Syntax, exports2.traverse = traverse, exports2.replace = replace, exports2.attachComments = attachComments, exports2.VisitorKeys = VisitorKeys, exports2.VisitorOption = VisitorOption, exports2.Controller = Controller, exports2.cloneEnvironment = function() {
        return clone2({});
      }, exports2;
    })(exports);
  }
});
var require_ast = __commonJS$1({
  "../../node_modules/esutils/lib/ast.js"(exports, module2) {
    (function() {
      function isExpression(node) {
        if (node == null)
          return false;
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null)
          return false;
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null)
          return false;
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            return node.alternate != null ? node.alternate : node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement" || node.alternate == null)
          return false;
        current = node.consequent;
        do {
          if (current.type === "IfStatement" && current.alternate == null)
            return true;
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module2.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});
var require_code = __commonJS$1({
  "../../node_modules/esutils/lib/code.js"(exports, module2) {
    (function() {
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      }, ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535)
          return String.fromCharCode(cp);
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296), cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      for (IDENTIFIER_START = new Array(128), ch = 0; ch < 128; ++ch)
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      for (IDENTIFIER_PART = new Array(128), ch = 0; ch < 128; ++ch)
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module2.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});
var require_keyword = __commonJS$1({
  "../../node_modules/esutils/lib/keyword.js"(exports, module2) {
    (function() {
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        return !strict && id === "yield" ? false : isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id))
          return true;
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i2, iz, ch;
        if (id.length === 0 || (ch = id.charCodeAt(0), !code.isIdentifierStartES5(ch)))
          return false;
        for (i2 = 1, iz = id.length; i2 < iz; ++i2)
          if (ch = id.charCodeAt(i2), !code.isIdentifierPartES5(ch))
            return false;
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i2, iz, ch, lowCh, check;
        if (id.length === 0)
          return false;
        for (check = code.isIdentifierStartES6, i2 = 0, iz = id.length; i2 < iz; ++i2) {
          if (ch = id.charCodeAt(i2), 55296 <= ch && ch <= 56319) {
            if (++i2, i2 >= iz || (lowCh = id.charCodeAt(i2), !(56320 <= lowCh && lowCh <= 57343)))
              return false;
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch))
            return false;
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module2.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});
var require_utils = __commonJS$1({
  "../../node_modules/esutils/lib/utils.js"(exports) {
    (function() {
      exports.ast = require_ast(), exports.code = require_code(), exports.keyword = require_keyword();
    })();
  }
});
var require_base64 = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length)
        return intToCharMap[number];
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
      return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
    };
  }
});
var require_base64_vlq = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function(aValue) {
      var encoded = "", digit, vlq = toVLQSigned(aValue);
      do
        digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit);
      while (vlq > 0);
      return encoded;
    };
    exports.decode = function(aStr, aIndex, aOutParam) {
      var strLen = aStr.length, result = 0, shift2 = 0, continuation, digit;
      do {
        if (aIndex >= strLen)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1)
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift2), shift2 += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
    };
  }
});
var require_util = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      return match ? {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      } : null;
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize4(aPath) {
      var path = aPath, url = urlParse(aPath);
      if (url) {
        if (!url.path)
          return aPath;
        path = url.path;
      }
      for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--)
        part = parts[i2], part === "." ? parts.splice(i2, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i2 + 1, up), up = 0) : (parts.splice(i2, 2), up--));
      return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
    }
    exports.normalize = normalize4;
    function join(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize4(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0 || (aRoot = aRoot.slice(0, index2), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity2(s3) {
      return s3;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports.toSetString = supportsNullProto ? identity2 : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
    function isProtoString(s3) {
      if (!s3)
        return false;
      var length = s3.length;
      if (length < 9 || s3.charCodeAt(length - 1) !== 95 || s3.charCodeAt(length - 2) !== 95 || s3.charCodeAt(length - 3) !== 111 || s3.charCodeAt(length - 4) !== 116 || s3.charCodeAt(length - 5) !== 111 || s3.charCodeAt(length - 6) !== 114 || s3.charCodeAt(length - 7) !== 112 || s3.charCodeAt(length - 8) !== 95 || s3.charCodeAt(length - 9) !== 95)
        return false;
      for (var i2 = length - 10; i2 >= 0; i2--)
        if (s3.charCodeAt(i2) !== 36)
          return false;
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          index2 >= 0 && (parsed.path = parsed.path.substring(0, index2 + 1));
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize4(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});
var require_array_set = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util(), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
    function ArraySet() {
      this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function(aArray, aAllowDuplicates) {
      for (var set = new ArraySet(), i2 = 0, len = aArray.length; i2 < len; i2++)
        set.add(aArray[i2], aAllowDuplicates);
      return set;
    };
    ArraySet.prototype.size = function() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
      (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
    };
    ArraySet.prototype.has = function(aStr) {
      if (hasNativeMap)
        return this._set.has(aStr);
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    };
    ArraySet.prototype.indexOf = function(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0)
          return idx;
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr))
          return this._set[sStr];
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length)
        return this._array[aIdx];
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});
var require_mapping_list = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function(aMapping) {
      generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = false, this._array.push(aMapping));
    };
    MappingList.prototype.toArray = function() {
      return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
    };
    exports.MappingList = MappingList;
  }
});
var require_source_map_generator = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq(), util = require_util(), ArraySet = require_array_set().ArraySet, MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", false), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      return aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
      }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && generator.setSourceContent(sourceFile, content);
      }), generator;
    };
    SourceMapGenerator.prototype.addMapping = function(aArgs) {
      var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
      this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
    };
    SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
      var newSources = new ArraySet(), newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
        }
        var source = mapping.source;
        source != null && !newSources.has(source) && newSources.add(source);
        var name = mapping.name;
        name != null && !newNames.has(name) && newNames.add(name);
      }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        content != null && (aSourceMapPath != null && (sourceFile2 = util.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
          return;
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function() {
      for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i2 = 0, len = mappings.length; i2 < len; i2++) {
        if (mapping = mappings[i2], next = "", mapping.generatedLine !== previousGeneratedLine)
          for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
            next += ";", previousGeneratedLine++;
        else if (i2 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1]))
            continue;
          next += ",";
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents)
          return null;
        aSourceRoot != null && (source = util.relative(aSourceRoot, source));
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function() {
      var map2 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      return this._file != null && (map2.file = this._file), this._sourceRoot != null && (map2.sourceRoot = this._sourceRoot), this._sourcesContents && (map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot)), map2;
    };
    SourceMapGenerator.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});
var require_binary_search = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], true);
      return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index2 < 0)
        return -1;
      for (; index2 - 1 >= 0 && aCompare(aHaystack[index2], aHaystack[index2 - 1], true) === 0; )
        --index2;
      return index2;
    };
  }
});
var require_quick_sort = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x2, y2) {
      var temp = ary[x2];
      ary[x2] = ary[y2], ary[y2] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p2, r2) {
      if (p2 < r2) {
        var pivotIndex = randomIntInRange(p2, r2), i2 = p2 - 1;
        swap(ary, pivotIndex, r2);
        for (var pivot = ary[r2], j2 = p2; j2 < r2; j2++)
          comparator(ary[j2], pivot) <= 0 && (i2 += 1, swap(ary, i2, j2));
        swap(ary, i2 + 1, j2);
        var q = i2 + 1;
        doQuickSort(ary, comparator, p2, q - 1), doQuickSort(ary, comparator, q + 1, r2);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});
var require_source_map_consumer = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util(), binarySearch = require_binary_search(), ArraySet = require_array_set().ArraySet, base64VLQ = require_base64_vlq(), quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      return typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index2) {
      var c2 = aStr.charAt(index2);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
      var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        return source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
      var line = util.getArg(aArgs, "line"), needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
        return [];
      var mappings = [], index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0)
          for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index2];
        else
          for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index2];
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      sourceRoot && (sourceRoot = util.normalize(sourceRoot)), sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      }), this._names = ArraySet.fromArray(names.map(String), true), this._sources = ArraySet.fromArray(sources, true), this._absoluteSources = this._sources.toArray().map(function(s3) {
        return util.computeSourceURL(sourceRoot, s3, aSourceMapURL);
      }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
        return this._sources.indexOf(relativeSource);
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2)
        if (this._absoluteSources[i2] == aSource)
          return i2;
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s3) {
        return util.computeSourceURL(smc.sourceRoot, s3, aSourceMapURL);
      });
      for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2], destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
      }
      return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index2 = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str2, segment, end, value; index2 < length; )
        if (aStr.charAt(index2) === ";")
          generatedLine++, index2++, previousGeneratedColumn = 0;
        else if (aStr.charAt(index2) === ",")
          index2++;
        else {
          for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index2; end < length && !this._charIsMappingSeparator(aStr, end); end++)
            ;
          if (str2 = aStr.slice(index2, end), segment = cachedSegments[str2], segment)
            index2 += str2.length;
          else {
            for (segment = []; index2 < end; )
              base64VLQ.decode(aStr, index2, temp), value = temp.value, index2 = temp.rest, segment.push(value);
            if (segment.length === 2)
              throw new Error("Found a source, but no line and column");
            if (segment.length === 3)
              throw new Error("Found a source and line, but no column");
            cachedSegments[str2] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
        }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0)
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      if (aNeedle[aColumnName] < 0)
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = 1 / 0;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, index2 = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          source !== null && (source = this._sources.at(source), source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
          var name = util.getArg(mapping, "name", null);
          return name !== null && (name = this._names.at(name)), {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      }) : false;
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      if (!this.sourcesContent)
        return null;
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0)
        return this.sourcesContent[index2];
      var relativeSource = aSource;
      this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource));
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource))
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (source = this._findSourceIndex(source), source < 0)
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      }, index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source)
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
      var version = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      this._sources = new ArraySet(), this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s3) {
        if (s3.url)
          throw new Error("Support for url field in sections not implemented.");
        var offset2 = util.getArg(s3, "offset"), offsetLine = util.getArg(offset2, "line"), offsetColumn = util.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
          throw new Error("Section offsets must be ordered and non-overlapping.");
        return lastOffset = offset2, {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s3, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        for (var sources = [], i2 = 0; i2 < this._sections.length; i2++)
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++)
            sources.push(this._sections[i2].consumer.sources[j2]);
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      }, sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      ), section = this._sections[sectionIndex];
      return section ? section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      }) : {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this._sections.every(function(s3) {
        return s3.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2], content = section.consumer.sourceContentFor(aSource, true);
        if (content)
          return content;
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) !== -1) {
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      this.__generatedMappings = [], this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++)
        for (var section = this._sections[i2], sectionMappings = section.consumer._generatedMappings, j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2], source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
          var name = null;
          mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
        }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});
var require_source_node = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator, util = require_util(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = true, aChunks != null && this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
        var lineContents = getNextLine(), newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
      return aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null)
          if (lastGeneratedLine < mapping.generatedLine)
            addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
          else {
            var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
            return;
          }
        for (; lastGeneratedLine < mapping.generatedLine; )
          node.add(shiftNextLine()), lastGeneratedLine++;
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
      }), node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0)
          node.add(code);
        else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function(aChunk) {
      if (Array.isArray(aChunk))
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        aChunk && this.children.push(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.prepend = function(aChunk) {
      if (Array.isArray(aChunk))
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--)
          this.prepend(aChunk[i2]);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        this.children.unshift(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.walk = function(aFn) {
      for (var chunk, i2 = 0, len = this.children.length; i2 < len; i2++)
        chunk = this.children[i2], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
    };
    SourceNode.prototype.join = function(aSep) {
      var newChildren, i2, len = this.children.length;
      if (len > 0) {
        for (newChildren = [], i2 = 0; i2 < len - 1; i2++)
          newChildren.push(this.children[i2]), newChildren.push(aSep);
        newChildren.push(this.children[i2]), this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
    };
    SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++)
        this.children[i2][isSourceNode] && this.children[i2].walkSourceContents(aFn);
      for (var sources = Object.keys(this.sourceContents), i2 = 0, len = sources.length; i2 < len; i2++)
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
    };
    SourceNode.prototype.toString = function() {
      var str2 = "";
      return this.walk(function(chunk) {
        str2 += chunk;
      }), str2;
    };
    SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      }, map2 = new SourceMapGenerator(aArgs), sourceMappingActive = false, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
      return this.walk(function(chunk, original) {
        generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map2.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = true) : sourceMappingActive && (map2.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        }), lastOriginalSource = null, sourceMappingActive = false);
        for (var idx = 0, length = chunk.length; idx < length; idx++)
          chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = false) : sourceMappingActive && map2.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          })) : generated.column++;
      }), this.walkSourceContents(function(sourceFile, sourceContent) {
        map2.setSourceContent(sourceFile, sourceContent);
      }), { code: generated.code, map: map2 };
    };
    exports.SourceNode = SourceNode;
  }
});
var require_source_map = __commonJS$1({
  "../../node_modules/escodegen/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});
var require_package = __commonJS$1({
  "../../node_modules/escodegen/package.json"(exports, module2) {
    module2.exports = {
      name: "escodegen",
      description: "ECMAScript code generator",
      homepage: "http://github.com/estools/escodegen",
      main: "escodegen.js",
      bin: {
        esgenerate: "./bin/esgenerate.js",
        escodegen: "./bin/escodegen.js"
      },
      files: [
        "LICENSE.BSD",
        "README.md",
        "bin",
        "escodegen.js",
        "package.json"
      ],
      version: "2.1.0",
      engines: {
        node: ">=6.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "http://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/estools/escodegen.git"
      },
      dependencies: {
        estraverse: "^5.2.0",
        esutils: "^2.0.2",
        esprima: "^4.0.1"
      },
      optionalDependencies: {
        "source-map": "~0.6.1"
      },
      devDependencies: {
        acorn: "^8.0.4",
        bluebird: "^3.4.7",
        "bower-registry-client": "^1.0.0",
        chai: "^4.2.0",
        "chai-exclude": "^2.0.2",
        "commonjs-everywhere": "^0.9.7",
        gulp: "^4.0.2",
        "gulp-eslint": "^6.0.0",
        "gulp-mocha": "^7.0.2",
        minimist: "^1.2.5",
        optionator: "^0.9.1",
        semver: "^7.3.4"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "gulp travis",
        "unit-test": "gulp test",
        lint: "gulp lint",
        release: "node tools/release.js",
        "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
        build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
      }
    };
  }
});
var require_escodegen = __commonJS$1({
  "../../node_modules/escodegen/escodegen.js"(exports) {
    (function() {
      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base2, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse22, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse = require_estraverse(), esutils = require_utils(), Syntax = estraverse.Syntax;
      function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
      }
      function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
      }
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      }, BinaryPrecedence = {
        "??": Precedence.Coalesce,
        "||": Precedence.LogicalOR,
        "&&": Precedence.LogicalAND,
        "|": Precedence.BitwiseOR,
        "^": Precedence.BitwiseXOR,
        "&": Precedence.BitwiseAND,
        "==": Precedence.Equality,
        "!=": Precedence.Equality,
        "===": Precedence.Equality,
        "!==": Precedence.Equality,
        is: Precedence.Equality,
        isnt: Precedence.Equality,
        "<": Precedence.Relational,
        ">": Precedence.Relational,
        "<=": Precedence.Relational,
        ">=": Precedence.Relational,
        in: Precedence.Relational,
        instanceof: Precedence.Relational,
        "<<": Precedence.BitwiseSHIFT,
        ">>": Precedence.BitwiseSHIFT,
        ">>>": Precedence.BitwiseSHIFT,
        "+": Precedence.Additive,
        "-": Precedence.Additive,
        "*": Precedence.Multiplicative,
        "%": Precedence.Multiplicative,
        "/": Precedence.Multiplicative,
        "**": Precedence.Exponentiation
      };
      var F_ALLOW_IN = 1, F_ALLOW_CALL = 2, F_ALLOW_UNPARATH_NEW = 4, F_FUNC_BODY = 8, F_DIRECTIVE_CTX = 16, F_SEMICOLON_OPT = 32, F_FOUND_COALESCE = 64, E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW, S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
      function getDefaultOptions2() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: false
            },
            newline: `
`,
            space: " ",
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: "single",
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false,
            preserveBlankLines: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          raw: true,
          verbatim: null,
          sourceCode: null
        };
      }
      function stringRepeat(str2, num) {
        var result = "";
        for (num |= 0; num > 0; num >>>= 1, str2 += str2)
          num & 1 && (result += str2);
        return result;
      }
      function hasLineTerminator(str2) {
        return /[\r\n]/g.test(str2);
      }
      function endsWithLineTerminator(str2) {
        var len = str2.length;
        return len && esutils.code.isLineTerminator(str2.charCodeAt(len - 1));
      }
      function merge(target, override) {
        var key;
        for (key in override)
          override.hasOwnProperty(key) && (target[key] = override[key]);
        return target;
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target2) {
          return typeof target2 == "object" && target2 instanceof Object && !(target2 instanceof RegExp);
        }
        for (key in override)
          override.hasOwnProperty(key) && (val = override[key], isHashObject(val) ? isHashObject(target[key]) ? updateDeeply(target[key], val) : target[key] = updateDeeply({}, val) : target[key] = val);
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value)
          throw new Error("Numeric literal whose value is NaN");
        if (value < 0 || value === 0 && 1 / value < 0)
          throw new Error("Numeric literal whose value is negative");
        if (value === 1 / 0)
          return json ? "null" : renumber ? "1e400" : "1e+400";
        if (result = "" + value, !renumber || result.length < 3)
          return result;
        for (point = result.indexOf("."), !json && result.charCodeAt(0) === 48 && point === 1 && (point = 0, result = result.slice(1)), temp = result, result = result.replace("e+", "e"), exponent = 0, (pos = temp.indexOf("e")) > 0 && (exponent = +temp.slice(pos + 1), temp = temp.slice(0, pos)), point >= 0 && (exponent -= temp.length - point - 1, temp = +(temp.slice(0, point) + temp.slice(point + 1)) + ""), pos = 0; temp.charCodeAt(temp.length + pos - 1) === 48; )
          --pos;
        return pos !== 0 && (exponent -= pos, temp = temp.slice(0, pos)), exponent !== 0 && (temp += "e" + exponent), (temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value && (result = temp), result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        return (ch & -2) === 8232 ? (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029") : ch === 10 || ch === 13 ? (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r") : String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match, result, flags, i2, iz, ch, characterInBrack, previousIsBackslash;
        if (result = reg.toString(), reg.source) {
          if (match = result.match(/\/([^/]*)$/), !match)
            return result;
          for (flags = match[1], result = "", characterInBrack = false, previousIsBackslash = false, i2 = 0, iz = reg.source.length; i2 < iz; ++i2)
            ch = reg.source.charCodeAt(i2), previousIsBackslash ? (result += escapeRegExpCharacter(ch, previousIsBackslash), previousIsBackslash = false) : (characterInBrack ? ch === 93 && (characterInBrack = false) : ch === 47 ? result += "\\" : ch === 91 && (characterInBrack = true), result += escapeRegExpCharacter(ch, previousIsBackslash), previousIsBackslash = ch === 92);
          return "/" + result + "/" + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code, next) {
        var hex3;
        return code === 8 ? "\\b" : code === 12 ? "\\f" : code === 9 ? "\\t" : (hex3 = code.toString(16).toUpperCase(), json || code > 255 ? "\\u" + "0000".slice(hex3.length) + hex3 : code === 0 && !esutils.code.isDecimalDigit(next) ? "\\0" : code === 11 ? "\\x0B" : "\\x" + "00".slice(hex3.length) + hex3);
      }
      function escapeDisallowedCharacter(code) {
        if (code === 92)
          return "\\\\";
        if (code === 10)
          return "\\n";
        if (code === 13)
          return "\\r";
        if (code === 8232)
          return "\\u2028";
        if (code === 8233)
          return "\\u2029";
        throw new Error("Incorrectly classified character");
      }
      function escapeDirective(str2) {
        var i2, iz, code, quote;
        for (quote = quotes === "double" ? '"' : "'", i2 = 0, iz = str2.length; i2 < iz; ++i2)
          if (code = str2.charCodeAt(i2), code === 39) {
            quote = '"';
            break;
          } else if (code === 34) {
            quote = "'";
            break;
          } else code === 92 && ++i2;
        return quote + str2 + quote;
      }
      function escapeString(str2) {
        var result = "", i2, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i2 = 0, len = str2.length; i2 < len; ++i2) {
          if (code = str2.charCodeAt(i2), code === 39)
            ++singleQuotes;
          else if (code === 34)
            ++doubleQuotes;
          else if (code === 47 && json)
            result += "\\";
          else if (esutils.code.isLineTerminator(code) || code === 92) {
            result += escapeDisallowedCharacter(code);
            continue;
          } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 32 || !json && !escapeless && (code < 32 || code > 126))) {
            result += escapeAllowedCharacter(code, str2.charCodeAt(i2 + 1));
            continue;
          }
          result += String.fromCharCode(code);
        }
        if (single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes), quote = single ? "'" : '"', !(single ? singleQuotes : doubleQuotes))
          return quote + result + quote;
        for (str2 = result, result = quote, i2 = 0, len = str2.length; i2 < len; ++i2)
          code = str2.charCodeAt(i2), (code === 39 && single || code === 34 && !single) && (result += "\\"), result += String.fromCharCode(code);
        return result + quote;
      }
      function flattenToString(arr) {
        var i2, iz, elem, result = "";
        for (i2 = 0, iz = arr.length; i2 < iz; ++i2)
          elem = arr[i2], result += Array.isArray(elem) ? flattenToString(elem) : elem;
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap)
          return Array.isArray(generated) ? flattenToString(generated) : generated;
        if (node == null) {
          if (generated instanceof SourceNode)
            return generated;
          node = {};
        }
        return node.loc == null ? new SourceNode(null, null, sourceMap, generated, node.name || null) : new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
      }
      function noEmptySpace() {
        return space || " ";
      }
      function join(left, right) {
        var leftSource, rightSource, leftCharCode, rightCharCode;
        return leftSource = toSourceNodeWhenNeeded(left).toString(), leftSource.length === 0 ? [right] : (rightSource = toSourceNodeWhenNeeded(right).toString(), rightSource.length === 0 ? [left] : (leftCharCode = leftSource.charCodeAt(leftSource.length - 1), rightCharCode = rightSource.charCodeAt(0), (leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105 ? [left, noEmptySpace(), right] : esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode) ? [left, right] : [left, space, right]));
      }
      function addIndent(stmt) {
        return [base2, stmt];
      }
      function withIndent(fn3) {
        var previousBase;
        previousBase = base2, base2 += indent, fn3(base2), base2 = previousBase;
      }
      function calculateSpaces(str2) {
        var i2;
        for (i2 = str2.length - 1; i2 >= 0 && !esutils.code.isLineTerminator(str2.charCodeAt(i2)); --i2)
          ;
        return str2.length - 1 - i2;
      }
      function adjustMultilineComment(value, specialBase) {
        var array, i2, len, line, j2, spaces, previousBase, sn;
        for (array = value.split(/\r\n|[\r\n]/), spaces = Number.MAX_VALUE, i2 = 1, len = array.length; i2 < len; ++i2) {
          for (line = array[i2], j2 = 0; j2 < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j2)); )
            ++j2;
          spaces > j2 && (spaces = j2);
        }
        for (typeof specialBase < "u" ? (previousBase = base2, array[1][spaces] === "*" && (specialBase += " "), base2 = specialBase) : (spaces & 1 && --spaces, previousBase = base2), i2 = 1, len = array.length; i2 < len; ++i2)
          sn = toSourceNodeWhenNeeded(addIndent(array[i2].slice(spaces))), array[i2] = sourceMap ? sn.join("") : sn;
        return base2 = previousBase, array.join(`
`);
      }
      function generateComment(comment, specialBase) {
        if (comment.type === "Line") {
          if (endsWithLineTerminator(comment.value))
            return "//" + comment.value;
          var result = "//" + comment.value;
          return preserveBlankLines || (result += `
`), result;
        }
        return extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value) ? adjustMultilineComment("/*" + comment.value + "*/", specialBase) : "/*" + comment.value + "*/";
      }
      function addComments(stmt, result) {
        var i2, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix2, infix, suffix, count2;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          if (save = result, preserveBlankLines) {
            for (comment = stmt.leadingComments[0], result = [], extRange = comment.extendedRange, range = comment.range, prefix2 = sourceCode.substring(extRange[0], range[0]), count2 = (prefix2.match(/\n/g) || []).length, count2 > 0 ? (result.push(stringRepeat(`
`, count2)), result.push(addIndent(generateComment(comment)))) : (result.push(prefix2), result.push(generateComment(comment))), prevRange = range, i2 = 1, len = stmt.leadingComments.length; i2 < len; i2++)
              comment = stmt.leadingComments[i2], range = comment.range, infix = sourceCode.substring(prevRange[1], range[0]), count2 = (infix.match(/\n/g) || []).length, result.push(stringRepeat(`
`, count2)), result.push(addIndent(generateComment(comment))), prevRange = range;
            suffix = sourceCode.substring(range[1], extRange[1]), count2 = (suffix.match(/\n/g) || []).length, result.push(stringRepeat(`
`, count2));
          } else
            for (comment = stmt.leadingComments[0], result = [], safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0 && result.push(`
`), result.push(generateComment(comment)), endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) || result.push(`
`), i2 = 1, len = stmt.leadingComments.length; i2 < len; ++i2)
              comment = stmt.leadingComments[i2], fragment = [generateComment(comment)], endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) || fragment.push(`
`), result.push(addIndent(fragment));
          result.push(addIndent(save));
        }
        if (stmt.trailingComments)
          if (preserveBlankLines)
            comment = stmt.trailingComments[0], extRange = comment.extendedRange, range = comment.range, prefix2 = sourceCode.substring(extRange[0], range[0]), count2 = (prefix2.match(/\n/g) || []).length, count2 > 0 ? (result.push(stringRepeat(`
`, count2)), result.push(addIndent(generateComment(comment)))) : (result.push(prefix2), result.push(generateComment(comment)));
          else
            for (tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()), specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base2, result, indent]).toString())), i2 = 0, len = stmt.trailingComments.length; i2 < len; ++i2)
              comment = stmt.trailingComments[i2], tailingToStatement ? (i2 === 0 ? result = [result, indent] : result = [result, specialBase], result.push(generateComment(comment, specialBase))) : result = [result, addIndent(generateComment(comment))], i2 !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) && (result = [result, `
`]);
        return result;
      }
      function generateBlankLines(start, end, result) {
        var j2, newlineCount = 0;
        for (j2 = start; j2 < end; j2++)
          sourceCode[j2] === `
` && newlineCount++;
        for (j2 = 1; j2 < newlineCount; j2++)
          result.push(newline);
      }
      function parenthesize(text, current, should2) {
        return current < should2 ? ["(", text, ")"] : text;
      }
      function generateVerbatimString(string) {
        var i2, iz, result;
        for (result = string.split(/\r\n|\n/), i2 = 1, iz = result.length; i2 < iz; i2++)
          result[i2] = newline + base2 + result[i2];
        return result;
      }
      function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        return verbatim = expr[extra.verbatim], typeof verbatim == "string" ? result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence) : (result = generateVerbatimString(verbatim.content), prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence, result = parenthesize(result, prec, precedence)), toSourceNodeWhenNeeded(result, expr);
      }
      function CodeGenerator() {
      }
      CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;
        return noLeadingComment = !extra.comment || !stmt.leadingComments, stmt.type === Syntax.BlockStatement && noLeadingComment ? [space, this.generateStatement(stmt, flags)] : stmt.type === Syntax.EmptyStatement && noLeadingComment ? ";" : (withIndent(function() {
          result = [
            newline,
            addIndent(that.generateStatement(stmt, flags))
          ];
        }), result);
      }, CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        return stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends ? [result, space] : ends ? [result, base2] : [result, newline, base2];
      };
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
      }
      function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? "*" + space : "";
      }
      function generateMethodPrefix(prop) {
        var func = prop.value, prefix2 = "";
        return func.async && (prefix2 += generateAsyncPrefix(func, !prop.computed)), func.generator && (prefix2 += generateStarSuffix(func) ? "*" : ""), prefix2;
      }
      CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
        return node.type === Syntax.Identifier ? generateIdentifier(node) : this.generateExpression(node, precedence, flags);
      }, CodeGenerator.prototype.generateFunctionParams = function(node) {
        var i2, iz, result, hasDefault;
        if (hasDefault = false, node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier)
          result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        else {
          for (result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [], result.push("("), node.defaults && (hasDefault = true), i2 = 0, iz = node.params.length; i2 < iz; ++i2)
            hasDefault && node.defaults[i2] ? result.push(this.generateAssignment(node.params[i2], node.defaults[i2], "=", Precedence.Assignment, E_TTT)) : result.push(this.generatePattern(node.params[i2], Precedence.Assignment, E_TTT)), i2 + 1 < iz && result.push("," + space);
          node.rest && (node.params.length && result.push("," + space), result.push("..."), result.push(generateIdentifier(node.rest))), result.push(")");
        }
        return result;
      }, CodeGenerator.prototype.generateFunctionBody = function(node) {
        var result, expr;
        return result = this.generateFunctionParams(node), node.type === Syntax.ArrowFunctionExpression && (result.push(space), result.push("=>")), node.expression ? (result.push(space), expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT), expr.toString().charAt(0) === "{" && (expr = ["(", expr, ")"]), result.push(expr)) : result.push(this.maybeBlock(node.body, S_TTFF)), result;
      }, CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
        var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
        return withIndent(function() {
          stmt.left.type === Syntax.VariableDeclaration ? withIndent(function() {
            result.push(stmt.left.kind + noEmptySpace()), result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
          }) : result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT)), result = join(result, operator), result = [join(
            result,
            that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
          ), ")"];
        }), result.push(this.maybeBlock(stmt.body, flags)), result;
      }, CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
        var result = [];
        return computed && result.push("["), result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT)), computed && result.push("]"), result;
      }, CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
        return Precedence.Assignment < precedence && (flags |= F_ALLOW_IN), parenthesize(
          [
            this.generateExpression(left, Precedence.Call, flags),
            space + operator + space,
            this.generateExpression(right, Precedence.Assignment, flags)
          ],
          Precedence.Assignment,
          precedence
        );
      }, CodeGenerator.prototype.semicolon = function(flags) {
        return !semicolons && flags & F_SEMICOLON_OPT ? "" : ";";
      }, CodeGenerator.Statement = {
        BlockStatement: function(stmt, flags) {
          var range, content, result = ["{", newline], that = this;
          return withIndent(function() {
            stmt.body.length === 0 && preserveBlankLines && (range = stmt.range, range[1] - range[0] > 2 && (content = sourceCode.substring(range[0] + 1, range[1] - 1), content[0] === `
` && (result = ["{"]), result.push(content)));
            var i2, iz, fragment, bodyFlags;
            for (bodyFlags = S_TFFF, flags & F_FUNC_BODY && (bodyFlags |= F_DIRECTIVE_CTX), i2 = 0, iz = stmt.body.length; i2 < iz; ++i2)
              preserveBlankLines && (i2 === 0 && (stmt.body[0].leadingComments && (range = stmt.body[0].leadingComments[0].extendedRange, content = sourceCode.substring(range[0], range[1]), content[0] === `
` && (result = ["{"])), stmt.body[0].leadingComments || generateBlankLines(stmt.range[0], stmt.body[0].range[0], result)), i2 > 0 && !stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments && generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result)), i2 === iz - 1 && (bodyFlags |= F_SEMICOLON_OPT), stmt.body[i2].leadingComments && preserveBlankLines ? fragment = that.generateStatement(stmt.body[i2], bodyFlags) : fragment = addIndent(that.generateStatement(stmt.body[i2], bodyFlags)), result.push(fragment), endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) || preserveBlankLines && i2 < iz - 1 && stmt.body[i2 + 1].leadingComments || result.push(newline), preserveBlankLines && i2 === iz - 1 && (stmt.body[i2].trailingComments || generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result));
          }), result.push(addIndent("}")), result;
        },
        BreakStatement: function(stmt, flags) {
          return stmt.label ? "break " + stmt.label.name + this.semicolon(flags) : "break" + this.semicolon(flags);
        },
        ContinueStatement: function(stmt, flags) {
          return stmt.label ? "continue " + stmt.label.name + this.semicolon(flags) : "continue" + this.semicolon(flags);
        },
        ClassBody: function(stmt, flags) {
          var result = ["{", newline], that = this;
          return withIndent(function(indent2) {
            var i2, iz;
            for (i2 = 0, iz = stmt.body.length; i2 < iz; ++i2)
              result.push(indent2), result.push(that.generateExpression(stmt.body[i2], Precedence.Sequence, E_TTT)), i2 + 1 < iz && result.push(newline);
          }), endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) || result.push(newline), result.push(base2), result.push("}"), result;
        },
        ClassDeclaration: function(stmt, flags) {
          var result, fragment;
          return result = ["class"], stmt.id && (result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT))), stmt.superClass && (fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT)), result = join(result, fragment)), result.push(space), result.push(this.generateStatement(stmt.body, S_TFFT)), result;
        },
        DirectiveStatement: function(stmt, flags) {
          return extra.raw && stmt.raw ? stmt.raw + this.semicolon(flags) : escapeDirective(stmt.directive) + this.semicolon(flags);
        },
        DoWhileStatement: function(stmt, flags) {
          var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
          return result = this.maybeBlockSuffix(stmt.body, result), join(result, [
            "while" + space + "(",
            this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")" + this.semicolon(flags)
          ]);
        },
        CatchClause: function(stmt, flags) {
          var result, that = this;
          return withIndent(function() {
            var guard;
            stmt.param ? (result = [
              "catch" + space + "(",
              that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
              ")"
            ], stmt.guard && (guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT), result.splice(2, 0, " if ", guard))) : result = ["catch"];
          }), result.push(this.maybeBlock(stmt.body, S_TFFF)), result;
        },
        DebuggerStatement: function(stmt, flags) {
          return "debugger" + this.semicolon(flags);
        },
        EmptyStatement: function(stmt, flags) {
          return ";";
        },
        ExportDefaultDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags;
          return bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF, result = join(result, "default"), isStatement(stmt.declaration) ? result = join(result, this.generateStatement(stmt.declaration, bodyFlags)) : result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags)), result;
        },
        ExportNamedDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags, that = this;
          return bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF, stmt.declaration ? join(result, this.generateStatement(stmt.declaration, bodyFlags)) : (stmt.specifiers && (stmt.specifiers.length === 0 ? result = join(result, "{" + space + "}") : stmt.specifiers[0].type === Syntax.ExportBatchSpecifier ? result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT)) : (result = join(result, "{"), withIndent(function(indent2) {
            var i2, iz;
            for (result.push(newline), i2 = 0, iz = stmt.specifiers.length; i2 < iz; ++i2)
              result.push(indent2), result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT)), i2 + 1 < iz && result.push("," + newline);
          }), endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) || result.push(newline), result.push(base2 + "}")), stmt.source ? result = join(result, [
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]) : result.push(this.semicolon(flags))), result);
        },
        ExportAllDeclaration: function(stmt, flags) {
          return [
            "export" + space,
            "*" + space,
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        },
        ExpressionStatement: function(stmt, flags) {
          var result, fragment;
          function isClassPrefixed(fragment2) {
            var code;
            return fragment2.slice(0, 5) !== "class" ? false : (code = fragment2.charCodeAt(5), code === 123 || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code));
          }
          function isFunctionPrefixed(fragment2) {
            var code;
            return fragment2.slice(0, 8) !== "function" ? false : (code = fragment2.charCodeAt(8), code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code));
          }
          function isAsyncPrefixed(fragment2) {
            var code, i2, iz;
            if (fragment2.slice(0, 5) !== "async" || !esutils.code.isWhiteSpace(fragment2.charCodeAt(5)))
              return false;
            for (i2 = 6, iz = fragment2.length; i2 < iz && esutils.code.isWhiteSpace(fragment2.charCodeAt(i2)); ++i2)
              ;
            return i2 === iz || fragment2.slice(i2, i2 + 8) !== "function" ? false : (code = fragment2.charCodeAt(i2 + 8), code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code));
          }
          return result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)], fragment = toSourceNodeWhenNeeded(result).toString(), fragment.charCodeAt(0) === 123 || // ObjectExpression
          isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value == "string" ? result = ["(", result, ")" + this.semicolon(flags)] : result.push(this.semicolon(flags)), result;
        },
        ImportDeclaration: function(stmt, flags) {
          var result, cursor, that = this;
          return stmt.specifiers.length === 0 ? [
            "import",
            space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ] : (result = [
            "import"
          ], cursor = 0, stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier && (result = join(result, [
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]), ++cursor), stmt.specifiers[cursor] && (cursor !== 0 && result.push(","), stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier ? result = join(result, [
            space,
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]) : (result.push(space + "{"), stmt.specifiers.length - cursor === 1 ? (result.push(space), result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)), result.push(space + "}" + space)) : (withIndent(function(indent2) {
            var i2, iz;
            for (result.push(newline), i2 = cursor, iz = stmt.specifiers.length; i2 < iz; ++i2)
              result.push(indent2), result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT)), i2 + 1 < iz && result.push("," + newline);
          }), endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) || result.push(newline), result.push(base2 + "}" + space)))), result = join(result, [
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]), result);
        },
        VariableDeclarator: function(stmt, flags) {
          var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
          return stmt.init ? [
            this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
            space,
            "=",
            space,
            this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
          ] : this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },
        VariableDeclaration: function(stmt, flags) {
          var result, i2, iz, node, bodyFlags, that = this;
          result = [stmt.kind], bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
          function block() {
            for (node = stmt.declarations[0], extra.comment && node.leadingComments ? (result.push(`
`), result.push(addIndent(that.generateStatement(node, bodyFlags)))) : (result.push(noEmptySpace()), result.push(that.generateStatement(node, bodyFlags))), i2 = 1, iz = stmt.declarations.length; i2 < iz; ++i2)
              node = stmt.declarations[i2], extra.comment && node.leadingComments ? (result.push("," + newline), result.push(addIndent(that.generateStatement(node, bodyFlags)))) : (result.push("," + space), result.push(that.generateStatement(node, bodyFlags)));
          }
          return stmt.declarations.length > 1 ? withIndent(block) : block(), result.push(this.semicolon(flags)), result;
        },
        ThrowStatement: function(stmt, flags) {
          return [join(
            "throw",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        },
        TryStatement: function(stmt, flags) {
          var result, i2, iz, guardedHandlers;
          if (result = ["try", this.maybeBlock(stmt.block, S_TFFF)], result = this.maybeBlockSuffix(stmt.block, result), stmt.handlers)
            for (i2 = 0, iz = stmt.handlers.length; i2 < iz; ++i2)
              result = join(result, this.generateStatement(stmt.handlers[i2], S_TFFF)), (stmt.finalizer || i2 + 1 !== iz) && (result = this.maybeBlockSuffix(stmt.handlers[i2].body, result));
          else {
            for (guardedHandlers = stmt.guardedHandlers || [], i2 = 0, iz = guardedHandlers.length; i2 < iz; ++i2)
              result = join(result, this.generateStatement(guardedHandlers[i2], S_TFFF)), (stmt.finalizer || i2 + 1 !== iz) && (result = this.maybeBlockSuffix(guardedHandlers[i2].body, result));
            if (stmt.handler)
              if (Array.isArray(stmt.handler))
                for (i2 = 0, iz = stmt.handler.length; i2 < iz; ++i2)
                  result = join(result, this.generateStatement(stmt.handler[i2], S_TFFF)), (stmt.finalizer || i2 + 1 !== iz) && (result = this.maybeBlockSuffix(stmt.handler[i2].body, result));
              else
                result = join(result, this.generateStatement(stmt.handler, S_TFFF)), stmt.finalizer && (result = this.maybeBlockSuffix(stmt.handler.body, result));
          }
          return stmt.finalizer && (result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)])), result;
        },
        SwitchStatement: function(stmt, flags) {
          var result, fragment, i2, iz, bodyFlags, that = this;
          if (withIndent(function() {
            result = [
              "switch" + space + "(",
              that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
              ")" + space + "{" + newline
            ];
          }), stmt.cases)
            for (bodyFlags = S_TFFF, i2 = 0, iz = stmt.cases.length; i2 < iz; ++i2)
              i2 === iz - 1 && (bodyFlags |= F_SEMICOLON_OPT), fragment = addIndent(this.generateStatement(stmt.cases[i2], bodyFlags)), result.push(fragment), endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) || result.push(newline);
          return result.push(addIndent("}")), result;
        },
        SwitchCase: function(stmt, flags) {
          var result, fragment, i2, iz, bodyFlags, that = this;
          return withIndent(function() {
            for (stmt.test ? result = [
              join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
              ":"
            ] : result = ["default:"], i2 = 0, iz = stmt.consequent.length, iz && stmt.consequent[0].type === Syntax.BlockStatement && (fragment = that.maybeBlock(stmt.consequent[0], S_TFFF), result.push(fragment), i2 = 1), i2 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) && result.push(newline), bodyFlags = S_TFFF; i2 < iz; ++i2)
              i2 === iz - 1 && flags & F_SEMICOLON_OPT && (bodyFlags |= F_SEMICOLON_OPT), fragment = addIndent(that.generateStatement(stmt.consequent[i2], bodyFlags)), result.push(fragment), i2 + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) && result.push(newline);
          }), result;
        },
        IfStatement: function(stmt, flags) {
          var result, bodyFlags, semicolonOptional, that = this;
          return withIndent(function() {
            result = [
              "if" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          }), semicolonOptional = flags & F_SEMICOLON_OPT, bodyFlags = S_TFFF, semicolonOptional && (bodyFlags |= F_SEMICOLON_OPT), stmt.alternate ? (result.push(this.maybeBlock(stmt.consequent, S_TFFF)), result = this.maybeBlockSuffix(stmt.consequent, result), stmt.alternate.type === Syntax.IfStatement ? result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]) : result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)))) : result.push(this.maybeBlock(stmt.consequent, bodyFlags)), result;
        },
        ForStatement: function(stmt, flags) {
          var result, that = this;
          return withIndent(function() {
            result = ["for" + space + "("], stmt.init ? stmt.init.type === Syntax.VariableDeclaration ? result.push(that.generateStatement(stmt.init, S_FFFF)) : (result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT)), result.push(";")) : result.push(";"), stmt.test && (result.push(space), result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT))), result.push(";"), stmt.update && (result.push(space), result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT))), result.push(")");
          }), result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)), result;
        },
        ForInStatement: function(stmt, flags) {
          return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        ForOfStatement: function(stmt, flags) {
          return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        LabeledStatement: function(stmt, flags) {
          return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },
        Program: function(stmt, flags) {
          var result, fragment, i2, iz, bodyFlags;
          for (iz = stmt.body.length, result = [safeConcatenation && iz > 0 ? `
` : ""], bodyFlags = S_TFTF, i2 = 0; i2 < iz; ++i2)
            !safeConcatenation && i2 === iz - 1 && (bodyFlags |= F_SEMICOLON_OPT), preserveBlankLines && (i2 === 0 && (stmt.body[0].leadingComments || generateBlankLines(stmt.range[0], stmt.body[i2].range[0], result)), i2 > 0 && !stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments && generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result)), fragment = addIndent(this.generateStatement(stmt.body[i2], bodyFlags)), result.push(fragment), i2 + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) && (preserveBlankLines && stmt.body[i2 + 1].leadingComments || result.push(newline)), preserveBlankLines && i2 === iz - 1 && (stmt.body[i2].trailingComments || generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result));
          return result;
        },
        FunctionDeclaration: function(stmt, flags) {
          return [
            generateAsyncPrefix(stmt, true),
            "function",
            generateStarSuffix(stmt) || noEmptySpace(),
            stmt.id ? generateIdentifier(stmt.id) : "",
            this.generateFunctionBody(stmt)
          ];
        },
        ReturnStatement: function(stmt, flags) {
          return stmt.argument ? [join(
            "return",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)] : ["return" + this.semicolon(flags)];
        },
        WhileStatement: function(stmt, flags) {
          var result, that = this;
          return withIndent(function() {
            result = [
              "while" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          }), result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)), result;
        },
        WithStatement: function(stmt, flags) {
          var result, that = this;
          return withIndent(function() {
            result = [
              "with" + space + "(",
              that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
              ")"
            ];
          }), result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)), result;
        }
      }, merge(CodeGenerator.prototype, CodeGenerator.Statement), CodeGenerator.Expression = {
        SequenceExpression: function(expr, precedence, flags) {
          var result, i2, iz;
          for (Precedence.Sequence < precedence && (flags |= F_ALLOW_IN), result = [], i2 = 0, iz = expr.expressions.length; i2 < iz; ++i2)
            result.push(this.generateExpression(expr.expressions[i2], Precedence.Assignment, flags)), i2 + 1 < iz && result.push("," + space);
          return parenthesize(result, Precedence.Sequence, precedence);
        },
        AssignmentExpression: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },
        ArrowFunctionExpression: function(expr, precedence, flags) {
          return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },
        ConditionalExpression: function(expr, precedence, flags) {
          return Precedence.Conditional < precedence && (flags |= F_ALLOW_IN), parenthesize(
            [
              this.generateExpression(expr.test, Precedence.Coalesce, flags),
              space + "?" + space,
              this.generateExpression(expr.consequent, Precedence.Assignment, flags),
              space + ":" + space,
              this.generateExpression(expr.alternate, Precedence.Assignment, flags)
            ],
            Precedence.Conditional,
            precedence
          );
        },
        LogicalExpression: function(expr, precedence, flags) {
          return expr.operator === "??" && (flags |= F_FOUND_COALESCE), this.BinaryExpression(expr, precedence, flags);
        },
        BinaryExpression: function(expr, precedence, flags) {
          var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
          return currentPrecedence = BinaryPrecedence[expr.operator], leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence, rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1, currentPrecedence < precedence && (flags |= F_ALLOW_IN), fragment = this.generateExpression(expr.left, leftPrecedence, flags), leftSource = fragment.toString(), leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0)) ? result = [fragment, noEmptySpace(), expr.operator] : result = join(fragment, expr.operator), fragment = this.generateExpression(expr.right, rightPrecedence, flags), expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--" ? (result.push(noEmptySpace()), result.push(fragment)) : result = join(result, fragment), expr.operator === "in" && !(flags & F_ALLOW_IN) ? ["(", result, ")"] : (expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE ? ["(", result, ")"] : parenthesize(result, currentPrecedence, precedence);
        },
        CallExpression: function(expr, precedence, flags) {
          var result, i2, iz;
          for (result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)], expr.optional && result.push("?."), result.push("("), i2 = 0, iz = expr.arguments.length; i2 < iz; ++i2)
            result.push(this.generateExpression(expr.arguments[i2], Precedence.Assignment, E_TTT)), i2 + 1 < iz && result.push("," + space);
          return result.push(")"), flags & F_ALLOW_CALL ? parenthesize(result, Precedence.Call, precedence) : ["(", result, ")"];
        },
        ChainExpression: function(expr, precedence, flags) {
          Precedence.OptionalChaining < precedence && (flags |= F_ALLOW_CALL);
          var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
          return parenthesize(result, Precedence.OptionalChaining, precedence);
        },
        NewExpression: function(expr, precedence, flags) {
          var result, length, i2, iz, itemFlags;
          if (length = expr.arguments.length, itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF, result = join(
            "new",
            this.generateExpression(expr.callee, Precedence.New, itemFlags)
          ), !(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
            for (result.push("("), i2 = 0, iz = length; i2 < iz; ++i2)
              result.push(this.generateExpression(expr.arguments[i2], Precedence.Assignment, E_TTT)), i2 + 1 < iz && result.push("," + space);
            result.push(")");
          }
          return parenthesize(result, Precedence.New, precedence);
        },
        MemberExpression: function(expr, precedence, flags) {
          var result, fragment;
          return result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)], expr.computed ? (expr.optional && result.push("?."), result.push("["), result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT)), result.push("]")) : (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value == "number" && (fragment = toSourceNodeWhenNeeded(result).toString(), fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) && result.push(" ")), result.push(expr.optional ? "?." : "."), result.push(generateIdentifier(expr.property))), parenthesize(result, Precedence.Member, precedence);
        },
        MetaProperty: function(expr, precedence, flags) {
          var result;
          return result = [], result.push(typeof expr.meta == "string" ? expr.meta : generateIdentifier(expr.meta)), result.push("."), result.push(typeof expr.property == "string" ? expr.property : generateIdentifier(expr.property)), parenthesize(result, Precedence.Member, precedence);
        },
        UnaryExpression: function(expr, precedence, flags) {
          var result, fragment, rightCharCode, leftSource, leftCharCode;
          return fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT), space === "" ? result = join(expr.operator, fragment) : (result = [expr.operator], expr.operator.length > 2 ? result = join(result, fragment) : (leftSource = toSourceNodeWhenNeeded(result).toString(), leftCharCode = leftSource.charCodeAt(leftSource.length - 1), rightCharCode = fragment.toString().charCodeAt(0), ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) && result.push(noEmptySpace()), result.push(fragment))), parenthesize(result, Precedence.Unary, precedence);
        },
        YieldExpression: function(expr, precedence, flags) {
          var result;
          return expr.delegate ? result = "yield*" : result = "yield", expr.argument && (result = join(
            result,
            this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
          )), parenthesize(result, Precedence.Yield, precedence);
        },
        AwaitExpression: function(expr, precedence, flags) {
          var result = join(
            expr.all ? "await*" : "await",
            this.generateExpression(expr.argument, Precedence.Await, E_TTT)
          );
          return parenthesize(result, Precedence.Await, precedence);
        },
        UpdateExpression: function(expr, precedence, flags) {
          return expr.prefix ? parenthesize(
            [
              expr.operator,
              this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
            ],
            Precedence.Unary,
            precedence
          ) : parenthesize(
            [
              this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
              expr.operator
            ],
            Precedence.Postfix,
            precedence
          );
        },
        FunctionExpression: function(expr, precedence, flags) {
          var result = [
            generateAsyncPrefix(expr, true),
            "function"
          ];
          return expr.id ? (result.push(generateStarSuffix(expr) || noEmptySpace()), result.push(generateIdentifier(expr.id))) : result.push(generateStarSuffix(expr) || space), result.push(this.generateFunctionBody(expr)), result;
        },
        ArrayPattern: function(expr, precedence, flags) {
          return this.ArrayExpression(expr, precedence, flags, true);
        },
        ArrayExpression: function(expr, precedence, flags, isPattern) {
          var result, multiline, that = this;
          return expr.elements.length ? (multiline = isPattern ? false : expr.elements.length > 1, result = ["[", multiline ? newline : ""], withIndent(function(indent2) {
            var i2, iz;
            for (i2 = 0, iz = expr.elements.length; i2 < iz; ++i2)
              expr.elements[i2] ? (result.push(multiline ? indent2 : ""), result.push(that.generateExpression(expr.elements[i2], Precedence.Assignment, E_TTT))) : (multiline && result.push(indent2), i2 + 1 === iz && result.push(",")), i2 + 1 < iz && result.push("," + (multiline ? newline : space));
          }), multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) && result.push(newline), result.push(multiline ? base2 : ""), result.push("]"), result) : "[]";
        },
        RestElement: function(expr, precedence, flags) {
          return "..." + this.generatePattern(expr.argument);
        },
        ClassExpression: function(expr, precedence, flags) {
          var result, fragment;
          return result = ["class"], expr.id && (result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT))), expr.superClass && (fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT)), result = join(result, fragment)), result.push(space), result.push(this.generateStatement(expr.body, S_TFFT)), result;
        },
        MethodDefinition: function(expr, precedence, flags) {
          var result, fragment;
          return expr.static ? result = ["static" + space] : result = [], expr.kind === "get" || expr.kind === "set" ? fragment = [
            join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
            this.generateFunctionBody(expr.value)
          ] : fragment = [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ], join(result, fragment);
        },
        Property: function(expr, precedence, flags) {
          return expr.kind === "get" || expr.kind === "set" ? [
            expr.kind,
            noEmptySpace(),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ] : expr.shorthand ? expr.value.type === "AssignmentPattern" ? this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT) : this.generatePropertyKey(expr.key, expr.computed) : expr.method ? [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ] : [
            this.generatePropertyKey(expr.key, expr.computed),
            ":" + space,
            this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
          ];
        },
        ObjectExpression: function(expr, precedence, flags) {
          var multiline, result, fragment, that = this;
          return expr.properties.length ? (multiline = expr.properties.length > 1, withIndent(function() {
            fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
          }), !multiline && !hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString()) ? ["{", space, fragment, space, "}"] : (withIndent(function(indent2) {
            var i2, iz;
            if (result = ["{", newline, indent2, fragment], multiline)
              for (result.push("," + newline), i2 = 1, iz = expr.properties.length; i2 < iz; ++i2)
                result.push(indent2), result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT)), i2 + 1 < iz && result.push("," + newline);
          }), endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) || result.push(newline), result.push(base2), result.push("}"), result)) : "{}";
        },
        AssignmentPattern: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
        },
        ObjectPattern: function(expr, precedence, flags) {
          var result, i2, iz, multiline, property, that = this;
          if (!expr.properties.length)
            return "{}";
          if (multiline = false, expr.properties.length === 1)
            property = expr.properties[0], property.type === Syntax.Property && property.value.type !== Syntax.Identifier && (multiline = true);
          else
            for (i2 = 0, iz = expr.properties.length; i2 < iz; ++i2)
              if (property = expr.properties[i2], property.type === Syntax.Property && !property.shorthand) {
                multiline = true;
                break;
              }
          return result = ["{", multiline ? newline : ""], withIndent(function(indent2) {
            var i22, iz2;
            for (i22 = 0, iz2 = expr.properties.length; i22 < iz2; ++i22)
              result.push(multiline ? indent2 : ""), result.push(that.generateExpression(expr.properties[i22], Precedence.Sequence, E_TTT)), i22 + 1 < iz2 && result.push("," + (multiline ? newline : space));
          }), multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString()) && result.push(newline), result.push(multiline ? base2 : ""), result.push("}"), result;
        },
        ThisExpression: function(expr, precedence, flags) {
          return "this";
        },
        Super: function(expr, precedence, flags) {
          return "super";
        },
        Identifier: function(expr, precedence, flags) {
          return generateIdentifier(expr);
        },
        ImportDefaultSpecifier: function(expr, precedence, flags) {
          return generateIdentifier(expr.id || expr.local);
        },
        ImportNamespaceSpecifier: function(expr, precedence, flags) {
          var result = ["*"], id = expr.id || expr.local;
          return id && result.push(space + "as" + noEmptySpace() + generateIdentifier(id)), result;
        },
        ImportSpecifier: function(expr, precedence, flags) {
          var imported = expr.imported, result = [imported.name], local = expr.local;
          return local && local.name !== imported.name && result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local)), result;
        },
        ExportSpecifier: function(expr, precedence, flags) {
          var local = expr.local, result = [local.name], exported = expr.exported;
          return exported && exported.name !== local.name && result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported)), result;
        },
        Literal: function(expr, precedence, flags) {
          var raw;
          if (expr.hasOwnProperty("raw") && parse22 && extra.raw)
            try {
              if (raw = parse22(expr.raw).body[0].expression, raw.type === Syntax.Literal && raw.value === expr.value)
                return expr.raw;
            } catch {
            }
          return expr.regex ? "/" + expr.regex.pattern + "/" + expr.regex.flags : typeof expr.value == "bigint" ? expr.value.toString() + "n" : expr.bigint ? expr.bigint + "n" : expr.value === null ? "null" : typeof expr.value == "string" ? escapeString(expr.value) : typeof expr.value == "number" ? generateNumber(expr.value) : typeof expr.value == "boolean" ? expr.value ? "true" : "false" : generateRegExp(expr.value);
        },
        GeneratorExpression: function(expr, precedence, flags) {
          return this.ComprehensionExpression(expr, precedence, flags);
        },
        ComprehensionExpression: function(expr, precedence, flags) {
          var result, i2, iz, fragment, that = this;
          return result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["], extra.moz.comprehensionExpressionStartsWithAssignment && (fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT), result.push(fragment)), expr.blocks && withIndent(function() {
            for (i2 = 0, iz = expr.blocks.length; i2 < iz; ++i2)
              fragment = that.generateExpression(expr.blocks[i2], Precedence.Sequence, E_TTT), i2 > 0 || extra.moz.comprehensionExpressionStartsWithAssignment ? result = join(result, fragment) : result.push(fragment);
          }), expr.filter && (result = join(result, "if" + space), fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT), result = join(result, ["(", fragment, ")"])), extra.moz.comprehensionExpressionStartsWithAssignment || (fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT), result = join(result, fragment)), result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]"), result;
        },
        ComprehensionBlock: function(expr, precedence, flags) {
          var fragment;
          return expr.left.type === Syntax.VariableDeclaration ? fragment = [
            expr.left.kind,
            noEmptySpace(),
            this.generateStatement(expr.left.declarations[0], S_FFFF)
          ] : fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT), fragment = join(fragment, expr.of ? "of" : "in"), fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT)), ["for" + space + "(", fragment, ")"];
        },
        SpreadElement: function(expr, precedence, flags) {
          return [
            "...",
            this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
          ];
        },
        TaggedTemplateExpression: function(expr, precedence, flags) {
          var itemFlags = E_TTF;
          flags & F_ALLOW_CALL || (itemFlags = E_TFF);
          var result = [
            this.generateExpression(expr.tag, Precedence.Call, itemFlags),
            this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
          ];
          return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },
        TemplateElement: function(expr, precedence, flags) {
          return expr.value.raw;
        },
        TemplateLiteral: function(expr, precedence, flags) {
          var result, i2, iz;
          for (result = ["`"], i2 = 0, iz = expr.quasis.length; i2 < iz; ++i2)
            result.push(this.generateExpression(expr.quasis[i2], Precedence.Primary, E_TTT)), i2 + 1 < iz && (result.push("${" + space), result.push(this.generateExpression(expr.expressions[i2], Precedence.Sequence, E_TTT)), result.push(space + "}"));
          return result.push("`"), result;
        },
        ModuleSpecifier: function(expr, precedence, flags) {
          return this.Literal(expr, precedence, flags);
        },
        ImportExpression: function(expr, precedence, flag3) {
          return parenthesize([
            "import(",
            this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
            ")"
          ], Precedence.Call, precedence);
        }
      }, merge(CodeGenerator.prototype, CodeGenerator.Expression), CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
        var result, type5;
        return type5 = expr.type || Syntax.Property, extra.verbatim && expr.hasOwnProperty(extra.verbatim) ? generateVerbatim(expr, precedence) : (result = this[type5](expr, precedence, flags), extra.comment && (result = addComments(expr, result)), toSourceNodeWhenNeeded(result, expr));
      }, CodeGenerator.prototype.generateStatement = function(stmt, flags) {
        var result, fragment;
        return result = this[stmt.type](stmt, flags), extra.comment && (result = addComments(stmt, result)), fragment = toSourceNodeWhenNeeded(result).toString(), stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === `
` && (result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "")), toSourceNodeWhenNeeded(result, stmt);
      };
      function generateInternal(node) {
        var codegen;
        if (codegen = new CodeGenerator(), isStatement(node))
          return codegen.generateStatement(node, S_TFFF);
        if (isExpression(node))
          return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        throw new Error("Unknown node type: " + node.type);
      }
      function generate2(node, options) {
        var defaultOptions2 = getDefaultOptions2(), result, pair;
        return options != null ? (typeof options.indent == "string" && (defaultOptions2.format.indent.style = options.indent), typeof options.base == "number" && (defaultOptions2.format.indent.base = options.base), options = updateDeeply(defaultOptions2, options), indent = options.format.indent.style, typeof options.base == "string" ? base2 = options.base : base2 = stringRepeat(indent, options.format.indent.base)) : (options = defaultOptions2, indent = options.format.indent.style, base2 = stringRepeat(indent, options.format.indent.base)), json = options.format.json, renumber = options.format.renumber, hexadecimal = json ? false : options.format.hexadecimal, quotes = json ? "double" : options.format.quotes, escapeless = options.format.escapeless, newline = options.format.newline, space = options.format.space, options.format.compact && (newline = space = indent = base2 = ""), parentheses = options.format.parentheses, semicolons = options.format.semicolons, safeConcatenation = options.format.safeConcatenation, directive = options.directive, parse22 = json ? null : options.parse, sourceMap = options.sourceMap, sourceCode = options.sourceCode, preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null, extra = options, sourceMap && (exports.browser ? SourceNode = global.sourceMap.SourceNode : SourceNode = require_source_map().SourceNode), result = generateInternal(node), sourceMap ? (pair = result.toStringWithSourceMap({
          file: options.file,
          sourceRoot: options.sourceMapRoot
        }), options.sourceContent && pair.map.setSourceContent(
          options.sourceMap,
          options.sourceContent
        ), options.sourceMapWithCode ? pair : pair.map.toString()) : (pair = { code: result.toString(), map: null }, options.sourceMapWithCode ? pair : pair.code);
      }
      FORMAT_MINIFY = {
        indent: {
          style: "",
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: "auto",
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      }, FORMAT_DEFAULTS = getDefaultOptions2().format, exports.version = require_package().version, exports.generate = generate2, exports.attachComments = estraverse.attachComments, exports.Precedence = updateDeeply({}, Precedence), exports.browser = false, exports.FORMAT_MINIFY = FORMAT_MINIFY, exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    })();
  }
});
var require_acorn = __commonJS$1({
  "../../node_modules/acorn/dist/acorn.js"(exports, module2) {
    (function(global22, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global22 = global22 || self, factory(global22.acorn = {}));
    })(exports, function(exports2) {
      var reservedWords2 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      }, keywordRelationalOperator = /^in(stanceof)?$/, nonASCIIidentifierStartChars = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierChars = "----------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        for (var pos = 65536, i2 = 0; i2 < set.length; i2 += 2) {
          if (pos += set[i2], pos > code)
            return false;
          if (pos += set[i2 + 1], pos >= code)
            return true;
        }
      }
      function isIdentifierStart(code, astral) {
        return code < 65 ? code === 36 : code < 91 ? true : code < 97 ? code === 95 : code < 123 ? true : code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : astral === false ? false : isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        return code < 48 ? code === 36 : code < 58 ? true : code < 65 ? false : code < 91 ? true : code < 97 ? code === 95 : code < 123 ? true : code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : astral === false ? false : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function(label, conf) {
        conf === void 0 && (conf = {}), this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, this.binop = conf.binop || null, this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true }, keywords$1 = {};
      function kw(name, options) {
        return options === void 0 && (options = {}), options.keyword = name, keywords$1[name] = new TokenType(name, options);
      }
      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      }, lineBreak = /\r\n?|\n|\u2028|\u2029/, lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code, ecma2019String) {
        return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ref = Object.prototype, hasOwnProperty5 = ref.hasOwnProperty, toString5 = ref.toString;
      function has(obj, propName) {
        return hasOwnProperty5.call(obj, propName);
      }
      var isArray2 = Array.isArray || function(obj) {
        return toString5.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position = function(line, col) {
        this.line = line, this.column = col;
      };
      Position.prototype.offset = function(n2) {
        return new Position(this.line, this.column + n2);
      };
      var SourceLocation = function(p2, start, end) {
        this.start = start, this.end = end, p2.sourceFile !== null && (this.source = p2.sourceFile);
      };
      function getLineInfo(input2, offset2) {
        for (var line = 1, cur = 0; ; ) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input2);
          if (match && match.index < offset2)
            ++line, cur = match.index + match[0].length;
          else
            return new Position(line, offset2 - cur);
        }
      }
      var defaultOptions2 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
        // (2019). This influences support for strict mode, the set of
        // reserved words, and support for new syntax features. The default
        // is 10.
        ecmaVersion: 10,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program.
        allowImportExportEverywhere: false,
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: false,
        // When enabled, hashbang directive in the beginning of file
        // is allowed and treated as a line comment.
        allowHashBang: false,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callbackthat will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callbackthat will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions2)
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions2[opt];
        if (options.ecmaVersion >= 2015 && (options.ecmaVersion -= 2009), options.allowReserved == null && (options.allowReserved = options.ecmaVersion < 5), isArray2(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        return isArray2(options.onComment) && (options.onComment = pushComment(options, options.onComment)), options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          options.locations && (comment.loc = new SourceLocation(this, startLoc, endLoc)), options.ranges && (comment.range = [start, end]), array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5, Parser2 = function(options, input2, startPos) {
        this.options = options = getOptions(options), this.sourceFile = options.sourceFile, this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          for (var v2 = options.ecmaVersion; !(reserved = reservedWords2[v2]); v2--)
            ;
          options.sourceType === "module" && (reserved += " await");
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict), this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords2.strictBind), this.input = String(input2), this.containsEsc = false, startPos ? (this.pos = startPos, this.lineStart = this.input.lastIndexOf(`
`, startPos - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = types.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = options.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(SCOPE_TOP), this.regexpState = null;
      }, prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
      Parser2.prototype.parse = function() {
        var node = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(node);
      }, prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      }, prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      }, prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      }, prototypeAccessors.allowSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
      }, prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      }, prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, Parser2.prototype.inNonArrowFunction = function() {
        return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
      }, Parser2.extend = function() {
        for (var plugins2 = [], len = arguments.length; len--; ) plugins2[len] = arguments[len];
        for (var cls = this, i2 = 0; i2 < plugins2.length; i2++)
          cls = plugins2[i2](cls);
        return cls;
      }, Parser2.parse = function(input2, options) {
        return new this(options, input2).parse();
      }, Parser2.parseExpressionAt = function(input2, pos, options) {
        var parser = new this(options, input2, pos);
        return parser.nextToken(), parser.parseExpression();
      }, Parser2.tokenizer = function(input2, options) {
        return new this(options, input2);
      }, Object.defineProperties(Parser2.prototype, prototypeAccessors);
      var pp = Parser2.prototype, literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp.strictDirective = function(start) {
        for (; ; ) {
          skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match)
            return false;
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length, next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length, skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length, this.input[start] === ";" && start++;
        }
      }, pp.eat = function(type5) {
        return this.type === type5 ? (this.next(), true) : false;
      }, pp.isContextual = function(name) {
        return this.type === types.name && this.value === name && !this.containsEsc;
      }, pp.eatContextual = function(name) {
        return this.isContextual(name) ? (this.next(), true) : false;
      }, pp.expectContextual = function(name) {
        this.eatContextual(name) || this.unexpected();
      }, pp.canInsertSemicolon = function() {
        return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }, pp.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
      }, pp.semicolon = function() {
        !this.eat(types.semi) && !this.insertSemicolon() && this.unexpected();
      }, pp.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), notNext || this.next(), true;
      }, pp.expect = function(type5) {
        this.eat(type5) || this.unexpected();
      }, pp.unexpected = function(pos) {
        this.raise(pos ?? this.start, "Unexpected token");
      };
      function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (refDestructuringErrors) {
          refDestructuringErrors.trailingComma > -1 && this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
          parens > -1 && this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      }, pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors)
          return false;
        var shorthandAssign = refDestructuringErrors.shorthandAssign, doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow)
          return shorthandAssign >= 0 || doubleProto >= 0;
        shorthandAssign >= 0 && this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"), doubleProto >= 0 && this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }, pp.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, pp.isSimpleAssignTarget = function(expr) {
        return expr.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(expr.expression) : expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1 = Parser2.prototype;
      pp$1.parseTopLevel = function(node) {
        var exports3 = {};
        for (node.body || (node.body = []); this.type !== types.eof; ) {
          var stmt = this.parseStatement(null, true, exports3);
          node.body.push(stmt);
        }
        if (this.inModule)
          for (var i2 = 0, list = Object.keys(this.undefinedExports); i2 < list.length; i2 += 1) {
            var name = list[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        return this.adaptDirectivePrologue(node.body), this.next(), node.sourceType = this.options.sourceType, this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$1.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91)
          return true;
        if (context)
          return false;
        if (nextCh === 123)
          return true;
        if (isIdentifierStart(nextCh, true)) {
          for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); )
            ++pos;
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident))
            return true;
        }
        return false;
      }, pp$1.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
      }, pp$1.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node = this.startNode(), kind;
        switch (this.isLet(context) && (starttype = types._var, kind = "let"), starttype) {
          case types._break:
          case types._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types._debugger:
            return this.parseDebuggerStatement(node);
          case types._do:
            return this.parseDoStatement(node);
          case types._for:
            return this.parseForStatement(node);
          case types._function:
            return context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(node, false, !context);
          case types._class:
            return context && this.unexpected(), this.parseClass(node, true);
          case types._if:
            return this.parseIfStatement(node);
          case types._return:
            return this.parseReturnStatement(node);
          case types._switch:
            return this.parseSwitchStatement(node);
          case types._throw:
            return this.parseThrowStatement(node);
          case types._try:
            return this.parseTryStatement(node);
          case types._const:
          case types._var:
            return kind = kind || this.value, context && kind !== "var" && this.unexpected(), this.parseVarStatement(node, kind);
          case types._while:
            return this.parseWhileStatement(node);
          case types._with:
            return this.parseWithStatement(node);
          case types.braceL:
            return this.parseBlock(true, node);
          case types.semi:
            return this.parseEmptyStatement(node);
          case types._export:
          case types._import:
            if (this.options.ecmaVersion > 10 && starttype === types._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46)
                return this.parseExpressionStatement(node, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (topLevel || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports3);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction())
              return context && this.unexpected(), this.next(), this.parseFunctionStatement(node, true, !context);
            var maybeName = this.value, expr = this.parseExpression();
            return starttype === types.name && expr.type === "Identifier" && this.eat(types.colon) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
        }
      }, pp$1.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next(), this.eat(types.semi) || this.insertSemicolon() ? node.label = null : this.type !== types.name ? this.unexpected() : (node.label = this.parseIdent(), this.semicolon());
        for (var i2 = 0; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if ((node.label == null || lab.name === node.label.name) && (lab.kind != null && (isBreak || lab.kind === "loop") || node.label && isBreak))
            break;
        }
        return i2 === this.labels.length && this.raise(node.start, "Unsyntactic " + keyword), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }, pp$1.parseDebuggerStatement = function(node) {
        return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
      }, pp$1.parseDoStatement = function(node) {
        return this.next(), this.labels.push(loopLabel), node.body = this.parseStatement("do"), this.labels.pop(), this.expect(types._while), node.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(types.semi) : this.semicolon(), this.finishNode(node, "DoWhileStatement");
      }, pp$1.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(loopLabel), this.enterScope(0), this.expect(types.parenL), this.type === types.semi)
          return awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, null);
        var isLet = this.isLet();
        if (this.type === types._var || this.type === types._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          return this.next(), this.parseVar(init$1, true, kind), this.finishNode(init$1, "VariableDeclaration"), (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === types._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), this.parseForIn(node, init$1)) : (awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init$1));
        }
        var refDestructuringErrors = new DestructuringErrors(), init2 = this.parseExpression(true, refDestructuringErrors);
        return this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === types._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), this.toAssignable(init2, false, refDestructuringErrors), this.checkLVal(init2), this.parseForIn(node, init2)) : (this.checkExpressionErrors(refDestructuringErrors, true), awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init2));
      }, pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        return this.next(), this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      }, pp$1.parseIfStatement = function(node) {
        return this.next(), node.test = this.parseParenExpression(), node.consequent = this.parseStatement("if"), node.alternate = this.eat(types._else) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
      }, pp$1.parseReturnStatement = function(node) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(types.semi) || this.insertSemicolon() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
      }, pp$1.parseSwitchStatement = function(node) {
        this.next(), node.discriminant = this.parseParenExpression(), node.cases = [], this.expect(types.braceL), this.labels.push(switchLabel), this.enterScope(0);
        for (var cur, sawDefault = false; this.type !== types.braceR; )
          if (this.type === types._case || this.type === types._default) {
            var isCase = this.type === types._case;
            cur && this.finishNode(cur, "SwitchCase"), node.cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), sawDefault = true, cur.test = null), this.expect(types.colon);
          } else
            cur || this.unexpected(), cur.consequent.push(this.parseStatement(null));
        return this.exitScope(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(node, "SwitchStatement");
      }, pp$1.parseThrowStatement = function(node) {
        return this.next(), lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
      };
      var empty = [];
      pp$1.parseTryStatement = function(node) {
        if (this.next(), node.block = this.parseBlock(), node.handler = null, this.type === types._catch) {
          var clause = this.startNode();
          if (this.next(), this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple2 = clause.param.type === "Identifier";
            this.enterScope(simple2 ? SCOPE_SIMPLE_CATCH : 0), this.checkLVal(clause.param, simple2 ? BIND_SIMPLE_CATCH : BIND_LEXICAL), this.expect(types.parenR);
          } else
            this.options.ecmaVersion < 10 && this.unexpected(), clause.param = null, this.enterScope(0);
          clause.body = this.parseBlock(false), this.exitScope(), node.handler = this.finishNode(clause, "CatchClause");
        }
        return node.finalizer = this.eat(types._finally) ? this.parseBlock() : null, !node.handler && !node.finalizer && this.raise(node.start, "Missing catch or finally clause"), this.finishNode(node, "TryStatement");
      }, pp$1.parseVarStatement = function(node, kind) {
        return this.next(), this.parseVar(node, false, kind), this.semicolon(), this.finishNode(node, "VariableDeclaration");
      }, pp$1.parseWhileStatement = function(node) {
        return this.next(), node.test = this.parseParenExpression(), this.labels.push(loopLabel), node.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(node, "WhileStatement");
      }, pp$1.parseWithStatement = function(node) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), node.object = this.parseParenExpression(), node.body = this.parseStatement("with"), this.finishNode(node, "WithStatement");
      }, pp$1.parseEmptyStatement = function(node) {
        return this.next(), this.finishNode(node, "EmptyStatement");
      }, pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
          var label = list[i$1];
          label.name === maybeName && this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
        for (var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null, i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start)
            label$1.statementStart = this.start, label$1.kind = kind;
          else
            break;
        }
        return this.labels.push({ name: maybeName, kind, statementStart: this.start }), node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label"), this.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
      }, pp$1.parseExpressionStatement = function(node, expr) {
        return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
      }, pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        for (createNewLexicalScope === void 0 && (createNewLexicalScope = true), node === void 0 && (node = this.startNode()), node.body = [], this.expect(types.braceL), createNewLexicalScope && this.enterScope(0); this.type !== types.braceR; ) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        return exitStrict && (this.strict = false), this.next(), createNewLexicalScope && this.exitScope(), this.finishNode(node, "BlockStatement");
      }, pp$1.parseFor = function(node, init2) {
        return node.init = init2, this.expect(types.semi), node.test = this.type === types.semi ? null : this.parseExpression(), this.expect(types.semi), node.update = this.type === types.parenR ? null : this.parseExpression(), this.expect(types.parenR), node.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(node, "ForStatement");
      }, pp$1.parseForIn = function(node, init2) {
        var isForIn = this.type === types._in;
        return this.next(), init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier") ? this.raise(
          init2.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ) : init2.type === "AssignmentPattern" && this.raise(init2.start, "Invalid left-hand side in for-loop"), node.left = init2, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign(), this.expect(types.parenR), node.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }, pp$1.parseVar = function(node, isFor, kind) {
        for (node.declarations = [], node.kind = kind; ; ) {
          var decl = this.startNode();
          if (this.parseVarId(decl, kind), this.eat(types.eq) ? decl.init = this.parseMaybeAssign(isFor) : kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : decl.init = null, node.declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(types.comma))
            break;
        }
        return node;
      }, pp$1.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom(), this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
        this.initFunction(node), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) && (this.type === types.star && statement & FUNC_HANGING_STATEMENT && this.unexpected(), node.generator = this.eat(types.star)), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), statement & FUNC_STATEMENT && (node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent(), node.id && !(statement & FUNC_HANGING_STATEMENT) && this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION));
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(node.async, node.generator)), statement & FUNC_STATEMENT || (node.id = this.type === types.name ? this.parseIdent() : null), this.parseFunctionParams(node), this.parseFunctionBody(node, allowExpressionBody, false), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      }, pp$1.parseFunctionParams = function(node) {
        this.expect(types.parenL), node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, pp$1.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true, this.parseClassId(node, isStatement), this.parseClassSuper(node);
        var classBody = this.startNode(), hadConstructor = false;
        for (classBody.body = [], this.expect(types.braceL); this.type !== types.braceR; ) {
          var element = this.parseClassElement(node.superClass !== null);
          element && (classBody.body.push(element), element.type === "MethodDefinition" && element.kind === "constructor" && (hadConstructor && this.raise(element.start, "Duplicate constructor in the same class"), hadConstructor = true));
        }
        return this.strict = oldStrict, this.next(), node.body = this.finishNode(classBody, "ClassBody"), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }, pp$1.parseClassElement = function(constructorAllowsSuper) {
        var this$1$1 = this;
        if (this.eat(types.semi))
          return null;
        var method = this.startNode(), tryContextual = function(k2, noLineBreak) {
          noLineBreak === void 0 && (noLineBreak = false);
          var start = this$1$1.start, startLoc = this$1$1.startLoc;
          return this$1$1.eatContextual(k2) ? this$1$1.type !== types.parenL && (!noLineBreak || !this$1$1.canInsertSemicolon()) ? true : (method.key && this$1$1.unexpected(), method.computed = false, method.key = this$1$1.startNodeAt(start, startLoc), method.key.name = k2, this$1$1.finishNode(method.key, "Identifier"), false) : false;
        };
        method.kind = "method", method.static = tryContextual("static");
        var isGenerator = this.eat(types.star), isAsync = false;
        isGenerator || (this.options.ecmaVersion >= 8 && tryContextual("async", true) ? (isAsync = true, isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star)) : tryContextual("get") ? method.kind = "get" : tryContextual("set") && (method.kind = "set")), method.key || this.parsePropertyName(method);
        var key = method.key, allowsDirectSuper = false;
        return !method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor") ? (method.kind !== "method" && this.raise(key.start, "Constructor can't have get/set modifier"), isGenerator && this.raise(key.start, "Constructor can't be a generator"), isAsync && this.raise(key.start, "Constructor can't be an async method"), method.kind = "constructor", allowsDirectSuper = constructorAllowsSuper) : method.static && key.type === "Identifier" && key.name === "prototype" && this.raise(key.start, "Classes may not have a static property named prototype"), this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper), method.kind === "get" && method.value.params.length !== 0 && this.raiseRecoverable(method.value.start, "getter should have no params"), method.kind === "set" && method.value.params.length !== 1 && this.raiseRecoverable(method.value.start, "setter should have exactly one param"), method.kind === "set" && method.value.params[0].type === "RestElement" && this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"), method;
      }, pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        return method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper), this.finishNode(method, "MethodDefinition");
      }, pp$1.parseClassId = function(node, isStatement) {
        this.type === types.name ? (node.id = this.parseIdent(), isStatement && this.checkLVal(node.id, BIND_LEXICAL, false)) : (isStatement === true && this.unexpected(), node.id = null);
      }, pp$1.parseClassSuper = function(node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
      }, pp$1.parseExport = function(node, exports3) {
        if (this.next(), this.eat(types.star))
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (node.exported = this.parseIdent(true), this.checkExport(exports3, node.exported.name, this.lastTokStart)) : node.exported = null), this.expectContextual("from"), this.type !== types.string && this.unexpected(), node.source = this.parseExprAtom(), this.semicolon(), this.finishNode(node, "ExportAllDeclaration");
        if (this.eat(types._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next(), isAsync && this.next(), node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else
            node.declaration = this.parseMaybeAssign(), this.semicolon();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement())
          node.declaration = this.parseStatement(null), node.declaration.type === "VariableDeclaration" ? this.checkVariableExport(exports3, node.declaration.declarations) : this.checkExport(exports3, node.declaration.id.name, node.declaration.id.start), node.specifiers = [], node.source = null;
        else {
          if (node.declaration = null, node.specifiers = this.parseExportSpecifiers(exports3), this.eatContextual("from"))
            this.type !== types.string && this.unexpected(), node.source = this.parseExprAtom();
          else {
            for (var i2 = 0, list = node.specifiers; i2 < list.length; i2 += 1) {
              var spec = list[i2];
              this.checkUnreserved(spec.local), this.checkLocalExport(spec.local);
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      }, pp$1.checkExport = function(exports3, name, pos) {
        exports3 && (has(exports3, name) && this.raiseRecoverable(pos, "Duplicate export '" + name + "'"), exports3[name] = true);
      }, pp$1.checkPatternExport = function(exports3, pat) {
        var type5 = pat.type;
        if (type5 === "Identifier")
          this.checkExport(exports3, pat.name, pat.start);
        else if (type5 === "ObjectPattern")
          for (var i2 = 0, list = pat.properties; i2 < list.length; i2 += 1) {
            var prop = list[i2];
            this.checkPatternExport(exports3, prop);
          }
        else if (type5 === "ArrayPattern")
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            elt && this.checkPatternExport(exports3, elt);
          }
        else type5 === "Property" ? this.checkPatternExport(exports3, pat.value) : type5 === "AssignmentPattern" ? this.checkPatternExport(exports3, pat.left) : type5 === "RestElement" ? this.checkPatternExport(exports3, pat.argument) : type5 === "ParenthesizedExpression" && this.checkPatternExport(exports3, pat.expression);
      }, pp$1.checkVariableExport = function(exports3, decls) {
        if (exports3)
          for (var i2 = 0, list = decls; i2 < list.length; i2 += 1) {
            var decl = list[i2];
            this.checkPatternExport(exports3, decl.id);
          }
      }, pp$1.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, pp$1.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        for (this.expect(types.braceL); !this.eat(types.braceR); ) {
          if (first)
            first = false;
          else if (this.expect(types.comma), this.afterTrailingComma(types.braceR))
            break;
          var node = this.startNode();
          node.local = this.parseIdent(true), node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local, this.checkExport(exports3, node.exported.name, node.exported.start), nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      }, pp$1.parseImport = function(node) {
        return this.next(), this.type === types.string ? (node.specifiers = empty, node.source = this.parseExprAtom()) : (node.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(node, "ImportDeclaration");
      }, pp$1.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types.name) {
          var node = this.startNode();
          if (node.local = this.parseIdent(), this.checkLVal(node.local, BIND_LEXICAL), nodes.push(this.finishNode(node, "ImportDefaultSpecifier")), !this.eat(types.comma))
            return nodes;
        }
        if (this.type === types.star) {
          var node$1 = this.startNode();
          return this.next(), this.expectContextual("as"), node$1.local = this.parseIdent(), this.checkLVal(node$1.local, BIND_LEXICAL), nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier")), nodes;
        }
        for (this.expect(types.braceL); !this.eat(types.braceR); ) {
          if (first)
            first = false;
          else if (this.expect(types.comma), this.afterTrailingComma(types.braceR))
            break;
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true), this.eatContextual("as") ? node$2.local = this.parseIdent() : (this.checkUnreserved(node$2.imported), node$2.local = node$2.imported), this.checkLVal(node$2.local, BIND_LEXICAL), nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      }, pp$1.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2)
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
      }, pp$1.isDirectiveCandidate = function(statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value == "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$2 = Parser2.prototype;
      pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node)
          switch (node.type) {
            case "Identifier":
              this.inAsync && node.name === "await" && this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true);
              for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
                var prop = list[i2];
                this.toAssignable(prop, isBinding), prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern") && this.raise(prop.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              node.kind !== "init" && this.raise(node.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true), this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement", this.toAssignable(node.argument, isBinding), node.argument.type === "AssignmentPattern" && this.raise(node.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              node.operator !== "=" && this.raise(node.left.end, "Only '=' operator can be used for specifying default value."), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isBinding);
            // falls through to AssignmentPattern
            case "AssignmentPattern":
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding)
                break;
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        else refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, true);
        return node;
      }, pp$2.toAssignableList = function(exprList, isBinding) {
        for (var end = exprList.length, i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          elt && this.toAssignable(elt, isBinding);
        }
        if (end) {
          var last = exprList[end - 1];
          this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier" && this.unexpected(last.argument.start);
        }
        return exprList;
      }, pp$2.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        return this.next(), node.argument = this.parseMaybeAssign(false, refDestructuringErrors), this.finishNode(node, "SpreadElement");
      }, pp$2.parseRestBinding = function() {
        var node = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== types.name && this.unexpected(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
      }, pp$2.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case types.bracketL:
              var node = this.startNode();
              return this.next(), node.elements = this.parseBindingList(types.bracketR, true, true), this.finishNode(node, "ArrayPattern");
            case types.braceL:
              return this.parseObj(true);
          }
        return this.parseIdent();
      }, pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        for (var elts = [], first = true; !this.eat(close); )
          if (first ? first = false : this.expect(types.comma), allowEmpty && this.type === types.comma)
            elts.push(null);
          else {
            if (allowTrailingComma && this.afterTrailingComma(close))
              break;
            if (this.type === types.ellipsis) {
              var rest = this.parseRestBinding();
              this.parseBindingListItem(rest), elts.push(rest), this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(close);
              break;
            } else {
              var elem = this.parseMaybeDefault(this.start, this.startLoc);
              this.parseBindingListItem(elem), elts.push(elem);
            }
          }
        return elts;
      }, pp$2.parseBindingListItem = function(param) {
        return param;
      }, pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
        if (left = left || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(types.eq))
          return left;
        var node = this.startNodeAt(startPos, startLoc);
        return node.left = left, node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentPattern");
      }, pp$2.checkLVal = function(expr, bindingType, checkClashes) {
        switch (bindingType === void 0 && (bindingType = BIND_NONE), expr.type) {
          case "Identifier":
            bindingType === BIND_LEXICAL && expr.name === "let" && this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(expr.name) && this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"), checkClashes && (has(checkClashes, expr.name) && this.raiseRecoverable(expr.start, "Argument name clash"), checkClashes[expr.name] = true), bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE && this.declareName(expr.name, bindingType, expr.start);
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            bindingType && this.raiseRecoverable(expr.start, "Binding member expression");
            break;
          case "ObjectPattern":
            for (var i2 = 0, list = expr.properties; i2 < list.length; i2 += 1) {
              var prop = list[i2];
              this.checkLVal(prop, bindingType, checkClashes);
            }
            break;
          case "Property":
            this.checkLVal(expr.value, bindingType, checkClashes);
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              elem && this.checkLVal(elem, bindingType, checkClashes);
            }
            break;
          case "AssignmentPattern":
            this.checkLVal(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLVal(expr.argument, bindingType, checkClashes);
            break;
          case "ParenthesizedExpression":
            this.checkLVal(expr.expression, bindingType, checkClashes);
            break;
          default:
            this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      var pp$3 = Parser2.prototype;
      pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (!(this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))) {
          var key = prop.key, name;
          switch (key.type) {
            case "Identifier":
              name = key.name;
              break;
            case "Literal":
              name = String(key.value);
              break;
            default:
              return;
          }
          var kind = prop.kind;
          if (this.options.ecmaVersion >= 6) {
            name === "__proto__" && kind === "init" && (propHash.proto && (refDestructuringErrors ? refDestructuringErrors.doubleProto < 0 && (refDestructuringErrors.doubleProto = key.start) : this.raiseRecoverable(key.start, "Redefinition of __proto__ property")), propHash.proto = true);
            return;
          }
          name = "$" + name;
          var other = propHash[name];
          if (other) {
            var redefinition;
            kind === "init" ? redefinition = this.strict && other.init || other.get || other.set : redefinition = other.init || other[kind], redefinition && this.raiseRecoverable(key.start, "Redefinition of property");
          } else
            other = propHash[name] = {
              init: false,
              get: false,
              set: false
            };
          other[kind] = true;
        }
      }, pp$3.parseExpression = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
        if (this.type === types.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          for (node.expressions = [expr]; this.eat(types.comma); )
            node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }, pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(noIn);
          this.exprAllowed = false;
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        refDestructuringErrors ? (oldParenAssign = refDestructuringErrors.parenthesizedAssign, oldTrailingComma = refDestructuringErrors.trailingComma, refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1) : (refDestructuringErrors = new DestructuringErrors(), ownDestructuringErrors = true);
        var startPos = this.start, startLoc = this.startLoc;
        (this.type === types.parenL || this.type === types.name) && (this.potentialArrowAt = this.start);
        var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
        if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          return node.operator = this.value, node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left, ownDestructuringErrors || (refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1), refDestructuringErrors.shorthandAssign >= node.left.start && (refDestructuringErrors.shorthandAssign = -1), this.checkLVal(left), this.next(), node.right = this.parseMaybeAssign(noIn), this.finishNode(node, "AssignmentExpression");
        } else
          ownDestructuringErrors && this.checkExpressionErrors(refDestructuringErrors, true);
        return oldParenAssign > -1 && (refDestructuringErrors.parenthesizedAssign = oldParenAssign), oldTrailingComma > -1 && (refDestructuringErrors.trailingComma = oldTrailingComma), left;
      }, pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors))
          return expr;
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          return node.test = expr, node.consequent = this.parseMaybeAssign(), this.expect(types.colon), node.alternate = this.parseMaybeAssign(noIn), this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }, pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeUnary(refDestructuringErrors, false);
        return this.checkExpressionErrors(refDestructuringErrors) || expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
      }, pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== types._in) && prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND, coalesce = this.type === types.coalesce;
          coalesce && (prec = types.logicalAND.binop);
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc, right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn), node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          return (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
        return left;
      }, pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        return node.left = left, node.operator = op, node.right = right, this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      }, pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
          expr = this.parseAwait(), sawUnary = true;
        else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types.incDec;
          node.operator = this.value, node.prefix = true, this.next(), node.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(refDestructuringErrors, true), update ? this.checkLVal(node.argument) : this.strict && node.operator === "delete" && node.argument.type === "Identifier" ? this.raiseRecoverable(node.start, "Deleting local variable in strict mode") : sawUnary = true, expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          if (expr = this.parseExprSubscripts(refDestructuringErrors), this.checkExpressionErrors(refDestructuringErrors))
            return expr;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value, node$1.prefix = false, node$1.argument = expr, this.checkLVal(expr), this.next(), expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        return !sawUnary && this.eat(types.starstar) ? this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) : expr;
      }, pp$3.parseExprSubscripts = function(refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprAtom(refDestructuringErrors);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return expr;
        var result = this.parseSubscripts(expr, startPos, startLoc);
        return refDestructuringErrors && result.type === "MemberExpression" && (refDestructuringErrors.parenthesizedAssign >= result.start && (refDestructuringErrors.parenthesizedAssign = -1), refDestructuringErrors.parenthesizedBind >= result.start && (refDestructuringErrors.parenthesizedBind = -1)), result;
      }, pp$3.parseSubscripts = function(base2, startPos, startLoc, noCalls) {
        for (var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start, optionalChained = false; ; ) {
          var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
          if (element.optional && (optionalChained = true), element === base2 || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element, element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base2 = element;
        }
      }, pp$3.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        var optionalSupported = this.options.ecmaVersion >= 11, optional = optionalSupported && this.eat(types.questionDot);
        noCalls && optional && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var computed = this.eat(types.bracketL);
        if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base2, node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), node.computed = !!computed, computed && this.expect(types.bracketR), optionalSupported && (node.optional = optional), base2 = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow))
            return this.checkPatternErrors(refDestructuringErrors, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
          this.checkExpressionErrors(refDestructuringErrors, true), this.yieldPos = oldYieldPos || this.yieldPos, this.awaitPos = oldAwaitPos || this.awaitPos, this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2, node$1.arguments = exprList, optionalSupported && (node$1.optional = optional), base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types.backQuote) {
          (optional || optionalChained) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2, node$2.quasi = this.parseTemplate({ isTagged: true }), base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      }, pp$3.parseExprAtom = function(refDestructuringErrors) {
        this.type === types.slash && this.readRegexp();
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), node = this.startNode(), this.next(), this.type === types.parenL && !this.allowDirectSuper && this.raise(node.start, "super() call outside constructor of a subclass"), this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL && this.unexpected(), this.finishNode(node, "Super");
          case types._this:
            return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
          case types.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc, id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types.arrow))
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc)
                return id = this.parseIdent(false), (this.canInsertSemicolon() || !this.eat(types.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
            }
            return id;
          case types.regexp:
            var value = this.value;
            return node = this.parseLiteral(value.value), node.regex = { pattern: value.pattern, flags: value.flags }, node;
          case types.num:
          case types.string:
            return this.parseLiteral(this.value);
          case types._null:
          case types._true:
          case types._false:
            return node = this.startNode(), node.value = this.type === types._null ? null : this.type === types._true, node.raw = this.type.keyword, this.next(), this.finishNode(node, "Literal");
          case types.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
            return refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr) && (refDestructuringErrors.parenthesizedAssign = start), refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = start)), expr;
          case types.bracketL:
            return node = this.startNode(), this.next(), node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors), this.finishNode(node, "ArrayExpression");
          case types.braceL:
            return this.parseObj(false, refDestructuringErrors);
          case types._function:
            return node = this.startNode(), this.next(), this.parseFunction(node, 0);
          case types._class:
            return this.parseClass(this.startNode(), false);
          case types._new:
            return this.parseNew();
          case types.backQuote:
            return this.parseTemplate();
          case types._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
          default:
            this.unexpected();
        }
      }, pp$3.parseExprImport = function() {
        var node = this.startNode();
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        var meta2 = this.parseIdent(true);
        switch (this.type) {
          case types.parenL:
            return this.parseDynamicImport(node);
          case types.dot:
            return node.meta = meta2, this.parseImportMeta(node);
          default:
            this.unexpected();
        }
      }, pp$3.parseDynamicImport = function(node) {
        if (this.next(), node.source = this.parseMaybeAssign(), !this.eat(types.parenR)) {
          var errorPos = this.start;
          this.eat(types.comma) && this.eat(types.parenR) ? this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()") : this.unexpected(errorPos);
        }
        return this.finishNode(node, "ImportExpression");
      }, pp$3.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        return node.property = this.parseIdent(true), node.property.name !== "meta" && this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"), containsEsc && this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"), this.finishNode(node, "MetaProperty");
      }, pp$3.parseLiteral = function(value) {
        var node = this.startNode();
        return node.value = value, node.raw = this.input.slice(this.start, this.end), node.raw.charCodeAt(node.raw.length - 1) === 110 && (node.bigint = node.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(node, "Literal");
      }, pp$3.parseParenExpression = function() {
        this.expect(types.parenL);
        var val = this.parseExpression();
        return this.expect(types.parenR), val;
      }, pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc, exprList = [], first = true, lastIsComma = false, refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== types.parenR; )
            if (first ? first = false : this.expect(types.comma), allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types.ellipsis) {
              spreadStart = this.start, exprList.push(this.parseParenItem(this.parseRestBinding())), this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element");
              break;
            } else
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          if (this.expect(types.parenR), canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow))
            return this.checkPatternErrors(refDestructuringErrors, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.parseParenArrowList(startPos, startLoc, exprList);
          (!exprList.length || lastIsComma) && this.unexpected(this.lastTokStart), spreadStart && this.unexpected(spreadStart), this.checkExpressionErrors(refDestructuringErrors, true), this.yieldPos = oldYieldPos || this.yieldPos, this.awaitPos = oldAwaitPos || this.awaitPos, exprList.length > 1 ? (val = this.startNodeAt(innerStartPos, innerStartLoc), val.expressions = exprList, this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)) : val = exprList[0];
        } else
          val = this.parseParenExpression();
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          return par.expression = val, this.finishNode(par, "ParenthesizedExpression");
        } else
          return val;
      }, pp$3.parseParenItem = function(item) {
        return item;
      }, pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
      };
      var empty$1 = [];
      pp$3.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var node = this.startNode(), meta2 = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
          node.meta = meta2;
          var containsEsc = this.containsEsc;
          return node.property = this.parseIdent(true), node.property.name !== "target" && this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"), containsEsc && this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"), this.inNonArrowFunction() || this.raiseRecoverable(node.start, "'new.target' can only be used in functions"), this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
        return node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true), isImport && node.callee.type === "ImportExpression" && this.raise(startPos, "Cannot use new with import()"), this.eat(types.parenL) ? node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false) : node.arguments = empty$1, this.finishNode(node, "NewExpression");
      }, pp$3.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged, elem = this.startNode();
        return this.type === types.invalidTemplate ? (isTagged || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), elem.value = {
          raw: this.value,
          cooked: null
        }) : elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), elem.tail = this.type === types.backQuote, this.finishNode(elem, "TemplateElement");
      }, pp$3.parseTemplate = function(ref2) {
        ref2 === void 0 && (ref2 = {});
        var isTagged = ref2.isTagged;
        isTagged === void 0 && (isTagged = false);
        var node = this.startNode();
        this.next(), node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        for (node.quasis = [curElt]; !curElt.tail; )
          this.type === types.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(types.dollarBraceL), node.expressions.push(this.parseExpression()), this.expect(types.braceR), node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        return this.next(), this.finishNode(node, "TemplateLiteral");
      }, pp$3.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }, pp$3.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        for (node.properties = [], this.next(); !this.eat(types.braceR); ) {
          if (first)
            first = false;
          else if (this.expect(types.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR))
            break;
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          isPattern || this.checkPropClash(prop, propHash, refDestructuringErrors), node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      }, pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis))
          return isPattern ? (prop.argument = this.parseIdent(false), this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(prop, "RestElement")) : (this.type === types.parenL && refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && (refDestructuringErrors.parenthesizedAssign = this.start), refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = this.start)), prop.argument = this.parseMaybeAssign(false, refDestructuringErrors), this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start), this.finishNode(prop, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (prop.method = false, prop.shorthand = false, (isPattern || refDestructuringErrors) && (startPos = this.start, startLoc = this.startLoc), isPattern || (isGenerator = this.eat(types.star)));
        var containsEsc = this.containsEsc;
        return this.parsePropertyName(prop), !isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop) ? (isAsync = true, isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star), this.parsePropertyName(prop, refDestructuringErrors)) : isAsync = false, this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc), this.finishNode(prop, "Property");
      }, pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types.colon && this.unexpected(), this.eat(types.colon))
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors), prop.kind = "init";
        else if (this.options.ecmaVersion >= 6 && this.type === types.parenL)
          isPattern && this.unexpected(), prop.kind = "init", prop.method = true, prop.value = this.parseMethod(isGenerator, isAsync);
        else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
          (isGenerator || isAsync) && this.unexpected(), prop.kind = prop.key.name, this.parsePropertyName(prop), prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            prop.kind === "get" ? this.raiseRecoverable(start, "getter should have no params") : this.raiseRecoverable(start, "setter should have exactly one param");
          } else
            prop.kind === "set" && prop.value.params[0].type === "RestElement" && this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        } else this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier" ? ((isGenerator || isAsync) && this.unexpected(), this.checkUnreserved(prop.key), prop.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = startPos), prop.kind = "init", isPattern ? prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key) : this.type === types.eq && refDestructuringErrors ? (refDestructuringErrors.shorthandAssign < 0 && (refDestructuringErrors.shorthandAssign = this.start), prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)) : prop.value = prop.key, prop.shorthand = true) : this.unexpected();
      }, pp$3.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types.bracketL))
            return prop.computed = true, prop.key = this.parseMaybeAssign(), this.expect(types.bracketR), prop.key;
          prop.computed = false;
        }
        return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, pp$3.initFunction = function(node) {
        node.id = null, this.options.ecmaVersion >= 6 && (node.generator = node.expression = false), this.options.ecmaVersion >= 8 && (node.async = false);
      }, pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        return this.initFunction(node), this.options.ecmaVersion >= 6 && (node.generator = isGenerator), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0)), this.expect(types.parenL), node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(node, false, true), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, "FunctionExpression");
      }, pp$3.parseArrowExpression = function(node, params, isAsync) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        return this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW), this.initFunction(node), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, node.params = this.toAssignableList(params, true), this.parseFunctionBody(node, true, false), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, "ArrowFunctionExpression");
      }, pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
        var isExpression = isArrowFunction && this.type !== types.braceL, oldStrict = this.strict, useStrict = false;
        if (isExpression)
          node.body = this.parseMaybeAssign(), node.expression = true, this.checkParams(node, false);
        else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          (!oldStrict || nonSimple) && (useStrict = this.strictDirective(this.end), useStrict && nonSimple && this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var oldLabels = this.labels;
          this.labels = [], useStrict && (this.strict = true), this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params)), this.strict && node.id && this.checkLVal(node.id, BIND_OUTSIDE), node.body = this.parseBlock(false, void 0, useStrict && !oldStrict), node.expression = false, this.adaptDirectivePrologue(node.body.body), this.labels = oldLabels;
        }
        this.exitScope();
      }, pp$3.isSimpleParamList = function(params) {
        for (var i2 = 0, list = params; i2 < list.length; i2 += 1) {
          var param = list[i2];
          if (param.type !== "Identifier")
            return false;
        }
        return true;
      }, pp$3.checkParams = function(node, allowDuplicates) {
        for (var nameHash = {}, i2 = 0, list = node.params; i2 < list.length; i2 += 1) {
          var param = list[i2];
          this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      }, pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        for (var elts = [], first = true; !this.eat(close); ) {
          if (first)
            first = false;
          else if (this.expect(types.comma), allowTrailingComma && this.afterTrailingComma(close))
            break;
          var elt = void 0;
          allowEmpty && this.type === types.comma ? elt = null : this.type === types.ellipsis ? (elt = this.parseSpread(refDestructuringErrors), refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start)) : elt = this.parseMaybeAssign(false, refDestructuringErrors), elts.push(elt);
        }
        return elts;
      }, pp$3.checkUnreserved = function(ref2) {
        var start = ref2.start, end = ref2.end, name = ref2.name;
        if (this.inGenerator && name === "yield" && this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && name === "await" && this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(name) && this.raise(start, "Unexpected keyword '" + name + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1)) {
          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
          re.test(name) && (!this.inAsync && name === "await" && this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(start, "The keyword '" + name + "' is reserved"));
        }
      }, pp$3.parseIdent = function(liberal, isBinding) {
        var node = this.startNode();
        return this.type === types.name ? node.name = this.value : this.type.keyword ? (node.name = this.type.keyword, (node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!liberal), this.finishNode(node, "Identifier"), liberal || (this.checkUnreserved(node), node.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = node.start)), node;
      }, pp$3.parseYield = function(noIn) {
        this.yieldPos || (this.yieldPos = this.start);
        var node = this.startNode();
        return this.next(), this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr ? (node.delegate = false, node.argument = null) : (node.delegate = this.eat(types.star), node.argument = this.parseMaybeAssign(noIn)), this.finishNode(node, "YieldExpression");
      }, pp$3.parseAwait = function() {
        this.awaitPos || (this.awaitPos = this.start);
        var node = this.startNode();
        return this.next(), node.argument = this.parseMaybeUnary(null, false), this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser2.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        throw err.pos = pos, err.loc = loc, err.raisedAt = this.pos, err;
      }, pp$4.raiseRecoverable = pp$4.raise, pp$4.curPosition = function() {
        if (this.options.locations)
          return new Position(this.curLine, this.pos - this.lineStart);
      };
      var pp$5 = Parser2.prototype, Scope = function(flags) {
        this.flags = flags, this.var = [], this.lexical = [], this.functions = [];
      };
      pp$5.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      }, pp$5.exitScope = function() {
        this.scopeStack.pop();
      }, pp$5.treatFunctionsAsVarInScope = function(scope2) {
        return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
      }, pp$5.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope2 = this.currentScope();
          redeclared = scope2.lexical.indexOf(name) > -1 || scope2.functions.indexOf(name) > -1 || scope2.var.indexOf(name) > -1, scope2.lexical.push(name), this.inModule && scope2.flags & SCOPE_TOP && delete this.undefinedExports[name];
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          this.treatFunctionsAsVar ? redeclared = scope$2.lexical.indexOf(name) > -1 : redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1, scope$2.functions.push(name);
        } else
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            if (scope$3.var.push(name), this.inModule && scope$3.flags & SCOPE_TOP && delete this.undefinedExports[name], scope$3.flags & SCOPE_VAR)
              break;
          }
        redeclared && this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }, pp$5.checkLocalExport = function(id) {
        this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && (this.undefinedExports[id.name] = id);
      }, pp$5.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, pp$5.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope2 = this.scopeStack[i2];
          if (scope2.flags & SCOPE_VAR)
            return scope2;
        }
      }, pp$5.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope2 = this.scopeStack[i2];
          if (scope2.flags & SCOPE_VAR && !(scope2.flags & SCOPE_ARROW))
            return scope2;
        }
      };
      var Node2 = function(parser, pos, loc) {
        this.type = "", this.start = pos, this.end = 0, parser.options.locations && (this.loc = new SourceLocation(parser, loc)), parser.options.directSourceFile && (this.sourceFile = parser.options.directSourceFile), parser.options.ranges && (this.range = [pos, 0]);
      }, pp$6 = Parser2.prototype;
      pp$6.startNode = function() {
        return new Node2(this, this.start, this.startLoc);
      }, pp$6.startNodeAt = function(pos, loc) {
        return new Node2(this, pos, loc);
      };
      function finishNodeAt(node, type5, pos, loc) {
        return node.type = type5, node.end = pos, this.options.locations && (node.loc.end = loc), this.options.ranges && (node.range[1] = pos), node;
      }
      pp$6.finishNode = function(node, type5) {
        return finishNodeAt.call(this, node, type5, this.lastTokEnd, this.lastTokEndLoc);
      }, pp$6.finishNodeAt = function(node, type5, pos, loc) {
        return finishNodeAt.call(this, node, type5, pos, loc);
      };
      var TokContext = function(token, isExpr, preserveSpace, override, generator) {
        this.token = token, this.isExpr = !!isExpr, this.preserveSpace = !!preserveSpace, this.override = override, this.generator = !!generator;
      }, types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p2) {
          return p2.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      }, pp$7 = Parser2.prototype;
      pp$7.initialContext = function() {
        return [types$1.b_stat];
      }, pp$7.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        return parent === types$1.f_expr || parent === types$1.f_stat ? true : prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr) ? !parent.isExpr : prevType === types._return || prevType === types.name && this.exprAllowed ? lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) : prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow ? true : prevType === types.braceL ? parent === types$1.b_stat : prevType === types._var || prevType === types._const || prevType === types.name ? false : !this.exprAllowed;
      }, pp$7.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function")
            return context.generator;
        }
        return false;
      }, pp$7.updateContext = function(prevType) {
        var update, type5 = this.type;
        type5.keyword && prevType === types.dot ? this.exprAllowed = false : (update = type5.updateContext) ? update.call(this, prevType) : this.exprAllowed = type5.beforeExpr;
      }, types.parenR.updateContext = types.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        out === types$1.b_stat && this.curContext().token === "function" && (out = this.context.pop()), this.exprAllowed = !out.isExpr;
      }, types.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr), this.exprAllowed = true;
      }, types.dollarBraceL.updateContext = function() {
        this.context.push(types$1.b_tmpl), this.exprAllowed = true;
      }, types.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr), this.exprAllowed = true;
      }, types.incDec.updateContext = function() {
      }, types._function.updateContext = types._class.updateContext = function(prevType) {
        prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat) ? this.context.push(types$1.f_expr) : this.context.push(types$1.f_stat), this.exprAllowed = false;
      }, types.backQuote.updateContext = function() {
        this.curContext() === types$1.q_tmpl ? this.context.pop() : this.context.push(types$1.q_tmpl), this.exprAllowed = false;
      }, types.star.updateContext = function(prevType) {
        if (prevType === types._function) {
          var index2 = this.context.length - 1;
          this.context[index2] === types$1.f_expr ? this.context[index2] = types$1.f_expr_gen : this.context[index2] = types$1.f_gen;
        }
        this.exprAllowed = true;
      }, types.name.updateContext = function(prevType) {
        var allowed = false;
        this.options.ecmaVersion >= 6 && prevType !== types.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (allowed = true), this.exprAllowed = allowed;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic", ecma11BinaryProperties = ecma10BinaryProperties, unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties
      }, unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues
      }, data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script, d.nonBinary.gc = d.nonBinary.General_Category, d.nonBinary.sc = d.nonBinary.Script, d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9), buildUnicodeData(10), buildUnicodeData(11);
      var pp$8 = Parser2.prototype, RegExpValidationState = function(parser) {
        this.parser = parser, this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0, this.source = pattern + "", this.flags = flags, this.switchU = unicode && this.parser.options.ecmaVersion >= 6, this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      }, RegExpValidationState.prototype.raise = function(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      }, RegExpValidationState.prototype.at = function(i2, forceU) {
        forceU === void 0 && (forceU = false);
        var s3 = this.source, l2 = s3.length;
        if (i2 >= l2)
          return -1;
        var c2 = s3.charCodeAt(i2);
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2)
          return c2;
        var next = s3.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
      }, RegExpValidationState.prototype.nextIndex = function(i2, forceU) {
        forceU === void 0 && (forceU = false);
        var s3 = this.source, l2 = s3.length;
        if (i2 >= l2)
          return l2;
        var c2 = s3.charCodeAt(i2), next;
        return !(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2 || (next = s3.charCodeAt(i2 + 1)) < 56320 || next > 57343 ? i2 + 1 : i2 + 2;
      }, RegExpValidationState.prototype.current = function(forceU) {
        return forceU === void 0 && (forceU = false), this.at(this.pos, forceU);
      }, RegExpValidationState.prototype.lookahead = function(forceU) {
        return forceU === void 0 && (forceU = false), this.at(this.nextIndex(this.pos, forceU), forceU);
      }, RegExpValidationState.prototype.advance = function(forceU) {
        forceU === void 0 && (forceU = false), this.pos = this.nextIndex(this.pos, forceU);
      }, RegExpValidationState.prototype.eat = function(ch, forceU) {
        return forceU === void 0 && (forceU = false), this.current(forceU) === ch ? (this.advance(forceU), true) : false;
      };
      function codePointToString(ch) {
        return ch <= 65535 ? String.fromCharCode(ch) : (ch -= 65536, String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320));
      }
      pp$8.validateRegExpFlags = function(state3) {
        for (var validFlags = state3.validFlags, flags = state3.flags, i2 = 0; i2 < flags.length; i2++) {
          var flag3 = flags.charAt(i2);
          validFlags.indexOf(flag3) === -1 && this.raise(state3.start, "Invalid regular expression flag"), flags.indexOf(flag3, i2 + 1) > -1 && this.raise(state3.start, "Duplicate regular expression flag");
        }
      }, pp$8.validateRegExpPattern = function(state3) {
        this.regexp_pattern(state3), !state3.switchN && this.options.ecmaVersion >= 9 && state3.groupNames.length > 0 && (state3.switchN = true, this.regexp_pattern(state3));
      }, pp$8.regexp_pattern = function(state3) {
        state3.pos = 0, state3.lastIntValue = 0, state3.lastStringValue = "", state3.lastAssertionIsQuantifiable = false, state3.numCapturingParens = 0, state3.maxBackReference = 0, state3.groupNames.length = 0, state3.backReferenceNames.length = 0, this.regexp_disjunction(state3), state3.pos !== state3.source.length && (state3.eat(
          41
          /* ) */
        ) && state3.raise("Unmatched ')'"), (state3.eat(
          93
          /* ] */
        ) || state3.eat(
          125
          /* } */
        )) && state3.raise("Lone quantifier brackets")), state3.maxBackReference > state3.numCapturingParens && state3.raise("Invalid escape");
        for (var i2 = 0, list = state3.backReferenceNames; i2 < list.length; i2 += 1) {
          var name = list[i2];
          state3.groupNames.indexOf(name) === -1 && state3.raise("Invalid named capture referenced");
        }
      }, pp$8.regexp_disjunction = function(state3) {
        for (this.regexp_alternative(state3); state3.eat(
          124
          /* | */
        ); )
          this.regexp_alternative(state3);
        this.regexp_eatQuantifier(state3, true) && state3.raise("Nothing to repeat"), state3.eat(
          123
          /* { */
        ) && state3.raise("Lone quantifier brackets");
      }, pp$8.regexp_alternative = function(state3) {
        for (; state3.pos < state3.source.length && this.regexp_eatTerm(state3); )
          ;
      }, pp$8.regexp_eatTerm = function(state3) {
        return this.regexp_eatAssertion(state3) ? (state3.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state3) && state3.switchU && state3.raise("Invalid quantifier"), true) : (state3.switchU ? this.regexp_eatAtom(state3) : this.regexp_eatExtendedAtom(state3)) ? (this.regexp_eatQuantifier(state3), true) : false;
      }, pp$8.regexp_eatAssertion = function(state3) {
        var start = state3.pos;
        if (state3.lastAssertionIsQuantifiable = false, state3.eat(
          94
          /* ^ */
        ) || state3.eat(
          36
          /* $ */
        ))
          return true;
        if (state3.eat(
          92
          /* \ */
        )) {
          if (state3.eat(
            66
            /* B */
          ) || state3.eat(
            98
            /* b */
          ))
            return true;
          state3.pos = start;
        }
        if (state3.eat(
          40
          /* ( */
        ) && state3.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9 && (lookbehind = state3.eat(
            60
            /* < */
          )), state3.eat(
            61
            /* = */
          ) || state3.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(state3), state3.eat(
              41
              /* ) */
            ) || state3.raise("Unterminated group"), state3.lastAssertionIsQuantifiable = !lookbehind, true;
        }
        return state3.pos = start, false;
      }, pp$8.regexp_eatQuantifier = function(state3, noError) {
        return noError === void 0 && (noError = false), this.regexp_eatQuantifierPrefix(state3, noError) ? (state3.eat(
          63
          /* ? */
        ), true) : false;
      }, pp$8.regexp_eatQuantifierPrefix = function(state3, noError) {
        return state3.eat(
          42
          /* * */
        ) || state3.eat(
          43
          /* + */
        ) || state3.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state3, noError);
      }, pp$8.regexp_eatBracedQuantifier = function(state3, noError) {
        var start = state3.pos;
        if (state3.eat(
          123
          /* { */
        )) {
          var min2 = 0, max2 = -1;
          if (this.regexp_eatDecimalDigits(state3) && (min2 = state3.lastIntValue, state3.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(state3) && (max2 = state3.lastIntValue), state3.eat(
            125
            /* } */
          )))
            return max2 !== -1 && max2 < min2 && !noError && state3.raise("numbers out of order in {} quantifier"), true;
          state3.switchU && !noError && state3.raise("Incomplete quantifier"), state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatAtom = function(state3) {
        return this.regexp_eatPatternCharacters(state3) || state3.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state3) || this.regexp_eatCharacterClass(state3) || this.regexp_eatUncapturingGroup(state3) || this.regexp_eatCapturingGroup(state3);
      }, pp$8.regexp_eatReverseSolidusAtomEscape = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state3))
            return true;
          state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatUncapturingGroup = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          40
          /* ( */
        )) {
          if (state3.eat(
            63
            /* ? */
          ) && state3.eat(
            58
            /* : */
          )) {
            if (this.regexp_disjunction(state3), state3.eat(
              41
              /* ) */
            ))
              return true;
            state3.raise("Unterminated group");
          }
          state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatCapturingGroup = function(state3) {
        if (state3.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(state3) : state3.current() === 63 && state3.raise("Invalid group"), this.regexp_disjunction(state3), state3.eat(
            41
            /* ) */
          ))
            return state3.numCapturingParens += 1, true;
          state3.raise("Unterminated group");
        }
        return false;
      }, pp$8.regexp_eatExtendedAtom = function(state3) {
        return state3.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state3) || this.regexp_eatCharacterClass(state3) || this.regexp_eatUncapturingGroup(state3) || this.regexp_eatCapturingGroup(state3) || this.regexp_eatInvalidBracedQuantifier(state3) || this.regexp_eatExtendedPatternCharacter(state3);
      }, pp$8.regexp_eatInvalidBracedQuantifier = function(state3) {
        return this.regexp_eatBracedQuantifier(state3, true) && state3.raise("Nothing to repeat"), false;
      }, pp$8.regexp_eatSyntaxCharacter = function(state3) {
        var ch = state3.current();
        return isSyntaxCharacter(ch) ? (state3.lastIntValue = ch, state3.advance(), true) : false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8.regexp_eatPatternCharacters = function(state3) {
        for (var start = state3.pos, ch = 0; (ch = state3.current()) !== -1 && !isSyntaxCharacter(ch); )
          state3.advance();
        return state3.pos !== start;
      }, pp$8.regexp_eatExtendedPatternCharacter = function(state3) {
        var ch = state3.current();
        return ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124 ? (state3.advance(), true) : false;
      }, pp$8.regexp_groupSpecifier = function(state3) {
        if (state3.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(state3)) {
            state3.groupNames.indexOf(state3.lastStringValue) !== -1 && state3.raise("Duplicate capture group name"), state3.groupNames.push(state3.lastStringValue);
            return;
          }
          state3.raise("Invalid group");
        }
      }, pp$8.regexp_eatGroupName = function(state3) {
        if (state3.lastStringValue = "", state3.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state3) && state3.eat(
            62
            /* > */
          ))
            return true;
          state3.raise("Invalid capture group name");
        }
        return false;
      }, pp$8.regexp_eatRegExpIdentifierName = function(state3) {
        if (state3.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(state3)) {
          for (state3.lastStringValue += codePointToString(state3.lastIntValue); this.regexp_eatRegExpIdentifierPart(state3); )
            state3.lastStringValue += codePointToString(state3.lastIntValue);
          return true;
        }
        return false;
      }, pp$8.regexp_eatRegExpIdentifierStart = function(state3) {
        var start = state3.pos, forceU = this.options.ecmaVersion >= 11, ch = state3.current(forceU);
        return state3.advance(forceU), ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state3, forceU) && (ch = state3.lastIntValue), isRegExpIdentifierStart(ch) ? (state3.lastIntValue = ch, true) : (state3.pos = start, false);
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$8.regexp_eatRegExpIdentifierPart = function(state3) {
        var start = state3.pos, forceU = this.options.ecmaVersion >= 11, ch = state3.current(forceU);
        return state3.advance(forceU), ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state3, forceU) && (ch = state3.lastIntValue), isRegExpIdentifierPart(ch) ? (state3.lastIntValue = ch, true) : (state3.pos = start, false);
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8.regexp_eatAtomEscape = function(state3) {
        return this.regexp_eatBackReference(state3) || this.regexp_eatCharacterClassEscape(state3) || this.regexp_eatCharacterEscape(state3) || state3.switchN && this.regexp_eatKGroupName(state3) ? true : (state3.switchU && (state3.current() === 99 && state3.raise("Invalid unicode escape"), state3.raise("Invalid escape")), false);
      }, pp$8.regexp_eatBackReference = function(state3) {
        var start = state3.pos;
        if (this.regexp_eatDecimalEscape(state3)) {
          var n2 = state3.lastIntValue;
          if (state3.switchU)
            return n2 > state3.maxBackReference && (state3.maxBackReference = n2), true;
          if (n2 <= state3.numCapturingParens)
            return true;
          state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatKGroupName = function(state3) {
        if (state3.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state3))
            return state3.backReferenceNames.push(state3.lastStringValue), true;
          state3.raise("Invalid named reference");
        }
        return false;
      }, pp$8.regexp_eatCharacterEscape = function(state3) {
        return this.regexp_eatControlEscape(state3) || this.regexp_eatCControlLetter(state3) || this.regexp_eatZero(state3) || this.regexp_eatHexEscapeSequence(state3) || this.regexp_eatRegExpUnicodeEscapeSequence(state3, false) || !state3.switchU && this.regexp_eatLegacyOctalEscapeSequence(state3) || this.regexp_eatIdentityEscape(state3);
      }, pp$8.regexp_eatCControlLetter = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state3))
            return true;
          state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatZero = function(state3) {
        return state3.current() === 48 && !isDecimalDigit(state3.lookahead()) ? (state3.lastIntValue = 0, state3.advance(), true) : false;
      }, pp$8.regexp_eatControlEscape = function(state3) {
        var ch = state3.current();
        return ch === 116 ? (state3.lastIntValue = 9, state3.advance(), true) : ch === 110 ? (state3.lastIntValue = 10, state3.advance(), true) : ch === 118 ? (state3.lastIntValue = 11, state3.advance(), true) : ch === 102 ? (state3.lastIntValue = 12, state3.advance(), true) : ch === 114 ? (state3.lastIntValue = 13, state3.advance(), true) : false;
      }, pp$8.regexp_eatControlLetter = function(state3) {
        var ch = state3.current();
        return isControlLetter(ch) ? (state3.lastIntValue = ch % 32, state3.advance(), true) : false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state3, forceU) {
        forceU === void 0 && (forceU = false);
        var start = state3.pos, switchU = forceU || state3.switchU;
        if (state3.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state3, 4)) {
            var lead = state3.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state3.pos;
              if (state3.eat(
                92
                /* \ */
              ) && state3.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state3, 4)) {
                var trail = state3.lastIntValue;
                if (trail >= 56320 && trail <= 57343)
                  return state3.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536, true;
              }
              state3.pos = leadSurrogateEnd, state3.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state3.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state3) && state3.eat(
            125
            /* } */
          ) && isValidUnicode(state3.lastIntValue))
            return true;
          switchU && state3.raise("Invalid unicode escape"), state3.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8.regexp_eatIdentityEscape = function(state3) {
        if (state3.switchU)
          return this.regexp_eatSyntaxCharacter(state3) ? true : state3.eat(
            47
            /* / */
          ) ? (state3.lastIntValue = 47, true) : false;
        var ch = state3.current();
        return ch !== 99 && (!state3.switchN || ch !== 107) ? (state3.lastIntValue = ch, state3.advance(), true) : false;
      }, pp$8.regexp_eatDecimalEscape = function(state3) {
        state3.lastIntValue = 0;
        var ch = state3.current();
        if (ch >= 49 && ch <= 57) {
          do
            state3.lastIntValue = 10 * state3.lastIntValue + (ch - 48), state3.advance();
          while ((ch = state3.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      }, pp$8.regexp_eatCharacterClassEscape = function(state3) {
        var ch = state3.current();
        if (isCharacterClassEscape(ch))
          return state3.lastIntValue = -1, state3.advance(), true;
        if (state3.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          if (state3.lastIntValue = -1, state3.advance(), state3.eat(
            123
            /* { */
          ) && this.regexp_eatUnicodePropertyValueExpression(state3) && state3.eat(
            125
            /* } */
          ))
            return true;
          state3.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8.regexp_eatUnicodePropertyValueExpression = function(state3) {
        var start = state3.pos;
        if (this.regexp_eatUnicodePropertyName(state3) && state3.eat(
          61
          /* = */
        )) {
          var name = state3.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state3)) {
            var value = state3.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(state3, name, value), true;
          }
        }
        if (state3.pos = start, this.regexp_eatLoneUnicodePropertyNameOrValue(state3)) {
          var nameOrValue = state3.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state3, nameOrValue), true;
        }
        return false;
      }, pp$8.regexp_validateUnicodePropertyNameAndValue = function(state3, name, value) {
        has(state3.unicodeProperties.nonBinary, name) || state3.raise("Invalid property name"), state3.unicodeProperties.nonBinary[name].test(value) || state3.raise("Invalid property value");
      }, pp$8.regexp_validateUnicodePropertyNameOrValue = function(state3, nameOrValue) {
        state3.unicodeProperties.binary.test(nameOrValue) || state3.raise("Invalid property name");
      }, pp$8.regexp_eatUnicodePropertyName = function(state3) {
        var ch = 0;
        for (state3.lastStringValue = ""; isUnicodePropertyNameCharacter(ch = state3.current()); )
          state3.lastStringValue += codePointToString(ch), state3.advance();
        return state3.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$8.regexp_eatUnicodePropertyValue = function(state3) {
        var ch = 0;
        for (state3.lastStringValue = ""; isUnicodePropertyValueCharacter(ch = state3.current()); )
          state3.lastStringValue += codePointToString(ch), state3.advance();
        return state3.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state3) {
        return this.regexp_eatUnicodePropertyValue(state3);
      }, pp$8.regexp_eatCharacterClass = function(state3) {
        if (state3.eat(
          91
          /* [ */
        )) {
          if (state3.eat(
            94
            /* ^ */
          ), this.regexp_classRanges(state3), state3.eat(
            93
            /* ] */
          ))
            return true;
          state3.raise("Unterminated character class");
        }
        return false;
      }, pp$8.regexp_classRanges = function(state3) {
        for (; this.regexp_eatClassAtom(state3); ) {
          var left = state3.lastIntValue;
          if (state3.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state3)) {
            var right = state3.lastIntValue;
            state3.switchU && (left === -1 || right === -1) && state3.raise("Invalid character class"), left !== -1 && right !== -1 && left > right && state3.raise("Range out of order in character class");
          }
        }
      }, pp$8.regexp_eatClassAtom = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state3))
            return true;
          if (state3.switchU) {
            var ch$1 = state3.current();
            (ch$1 === 99 || isOctalDigit(ch$1)) && state3.raise("Invalid class escape"), state3.raise("Invalid escape");
          }
          state3.pos = start;
        }
        var ch = state3.current();
        return ch !== 93 ? (state3.lastIntValue = ch, state3.advance(), true) : false;
      }, pp$8.regexp_eatClassEscape = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          98
          /* b */
        ))
          return state3.lastIntValue = 8, true;
        if (state3.switchU && state3.eat(
          45
          /* - */
        ))
          return state3.lastIntValue = 45, true;
        if (!state3.switchU && state3.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state3))
            return true;
          state3.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state3) || this.regexp_eatCharacterEscape(state3);
      }, pp$8.regexp_eatClassControlLetter = function(state3) {
        var ch = state3.current();
        return isDecimalDigit(ch) || ch === 95 ? (state3.lastIntValue = ch % 32, state3.advance(), true) : false;
      }, pp$8.regexp_eatHexEscapeSequence = function(state3) {
        var start = state3.pos;
        if (state3.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state3, 2))
            return true;
          state3.switchU && state3.raise("Invalid escape"), state3.pos = start;
        }
        return false;
      }, pp$8.regexp_eatDecimalDigits = function(state3) {
        var start = state3.pos, ch = 0;
        for (state3.lastIntValue = 0; isDecimalDigit(ch = state3.current()); )
          state3.lastIntValue = 10 * state3.lastIntValue + (ch - 48), state3.advance();
        return state3.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8.regexp_eatHexDigits = function(state3) {
        var start = state3.pos, ch = 0;
        for (state3.lastIntValue = 0; isHexDigit(ch = state3.current()); )
          state3.lastIntValue = 16 * state3.lastIntValue + hexToInt(ch), state3.advance();
        return state3.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        return ch >= 65 && ch <= 70 ? 10 + (ch - 65) : ch >= 97 && ch <= 102 ? 10 + (ch - 97) : ch - 48;
      }
      pp$8.regexp_eatLegacyOctalEscapeSequence = function(state3) {
        if (this.regexp_eatOctalDigit(state3)) {
          var n1 = state3.lastIntValue;
          if (this.regexp_eatOctalDigit(state3)) {
            var n2 = state3.lastIntValue;
            n1 <= 3 && this.regexp_eatOctalDigit(state3) ? state3.lastIntValue = n1 * 64 + n2 * 8 + state3.lastIntValue : state3.lastIntValue = n1 * 8 + n2;
          } else
            state3.lastIntValue = n1;
          return true;
        }
        return false;
      }, pp$8.regexp_eatOctalDigit = function(state3) {
        var ch = state3.current();
        return isOctalDigit(ch) ? (state3.lastIntValue = ch - 48, state3.advance(), true) : (state3.lastIntValue = 0, false);
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8.regexp_eatFixedHexDigits = function(state3, length) {
        var start = state3.pos;
        state3.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state3.current();
          if (!isHexDigit(ch))
            return state3.pos = start, false;
          state3.lastIntValue = 16 * state3.lastIntValue + hexToInt(ch), state3.advance();
        }
        return true;
      };
      var Token = function(p2) {
        this.type = p2.type, this.value = p2.value, this.start = p2.start, this.end = p2.end, p2.options.locations && (this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc)), p2.options.ranges && (this.range = [p2.start, p2.end]);
      }, pp$9 = Parser2.prototype;
      pp$9.next = function(ignoreEscapeSequenceInKeyword) {
        !ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Token(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, pp$9.getToken = function() {
        return this.next(), new Token(this);
      }, typeof Symbol < "u" && (pp$9[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            };
          }
        };
      }), pp$9.curContext = function() {
        return this.context[this.context.length - 1];
      }, pp$9.nextToken = function() {
        var curContext = this.curContext();
        if ((!curContext || !curContext.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(types.eof);
        if (curContext.override)
          return curContext.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, pp$9.readToken = function(code) {
        return isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 ? this.readWord() : this.getTokenFromCode(code);
      }, pp$9.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 57344)
          return code;
        var next = this.input.charCodeAt(this.pos + 1);
        return (code << 10) + next - 56613888;
      }, pp$9.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition(), start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = end + 2, this.options.locations) {
          lineBreakG.lastIndex = start;
          for (var match; (match = lineBreakG.exec(this.input)) && match.index < this.pos; )
            ++this.curLine, this.lineStart = match.index + match[0].length;
        }
        this.options.onComment && this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }, pp$9.skipLineComment = function(startSkip) {
        for (var start = this.pos, startLoc = this.options.onComment && this.curPosition(), ch = this.input.charCodeAt(this.pos += startSkip); this.pos < this.input.length && !isNewLine(ch); )
          ch = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }, pp$9.skipSpace = function() {
        loop: for (; this.pos < this.input.length; ) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))
                ++this.pos;
              else
                break loop;
          }
        }
      }, pp$9.finishToken = function(type5, val) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var prevType = this.type;
        this.type = type5, this.value = val, this.updateContext(prevType);
      }, pp$9.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57)
          return this.readNumber(true);
        var next2 = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && next === 46 && next2 === 46 ? (this.pos += 3, this.finishToken(types.ellipsis)) : (++this.pos, this.finishToken(types.dot));
      }, pp$9.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : next === 61 ? this.finishOp(types.assign, 2) : this.finishOp(types.slash, 1);
      }, pp$9.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1), size2 = 1, tokentype = code === 42 ? types.star : types.modulo;
        return this.options.ecmaVersion >= 7 && code === 42 && next === 42 && (++size2, tokentype = types.starstar, next = this.input.charCodeAt(this.pos + 2)), next === 61 ? this.finishOp(types.assign, size2 + 1) : this.finishOp(tokentype, size2);
      }, pp$9.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61)
              return this.finishOp(types.assign, 3);
          }
          return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }
        return next === 61 ? this.finishOp(types.assign, 2) : this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      }, pp$9.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        return next === 61 ? this.finishOp(types.assign, 2) : this.finishOp(types.bitwiseXOR, 1);
      }, pp$9.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        return next === code ? next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(types.incDec, 2) : next === 61 ? this.finishOp(types.assign, 2) : this.finishOp(types.plusMin, 1);
      }, pp$9.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1), size2 = 1;
        return next === code ? (size2 = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + size2) === 61 ? this.finishOp(types.assign, size2 + 1) : this.finishOp(types.bitShift, size2)) : next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (next === 61 && (size2 = 2), this.finishOp(types.relational, size2));
      }, pp$9.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        return next === 61 ? this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : code === 61 && next === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(types.arrow)) : this.finishOp(code === 61 ? types.eq : types.prefix, 1);
      }, pp$9.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57)
              return this.finishOp(types.questionDot, 2);
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61)
                return this.finishOp(types.assign, 3);
            }
            return this.finishOp(types.coalesce, 2);
          }
        }
        return this.finishOp(types.question, 1);
      }, pp$9.getTokenFromCode = function(code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            return ++this.pos, this.finishToken(types.parenL);
          case 41:
            return ++this.pos, this.finishToken(types.parenR);
          case 59:
            return ++this.pos, this.finishToken(types.semi);
          case 44:
            return ++this.pos, this.finishToken(types.comma);
          case 91:
            return ++this.pos, this.finishToken(types.bracketL);
          case 93:
            return ++this.pos, this.finishToken(types.bracketR);
          case 123:
            return ++this.pos, this.finishToken(types.braceL);
          case 125:
            return ++this.pos, this.finishToken(types.braceR);
          case 58:
            return ++this.pos, this.finishToken(types.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(types.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79)
                return this.readRadixNumber(8);
              if (next === 98 || next === 66)
                return this.readRadixNumber(2);
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types.prefix, 1);
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      }, pp$9.finishOp = function(type5, size2) {
        var str2 = this.input.slice(this.pos, this.pos + size2);
        return this.pos += size2, this.finishToken(type5, str2);
      }, pp$9.readRegexp = function() {
        for (var escaped, inClass, start = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(start, "Unterminated regular expression");
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch) && this.raise(start, "Unterminated regular expression"), escaped)
            escaped = false;
          else {
            if (ch === "[")
              inClass = true;
            else if (ch === "]" && inClass)
              inClass = false;
            else if (ch === "/" && !inClass)
              break;
            escaped = ch === "\\";
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos, flags = this.readWord1();
        this.containsEsc && this.unexpected(flagsStart);
        var state3 = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state3.reset(start, pattern, flags), this.validateRegExpFlags(state3), this.validateRegExpPattern(state3);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch {
        }
        return this.finishToken(types.regexp, { pattern, flags, value });
      }, pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        for (var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0, isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48, start = this.pos, total = 0, lastCode = 0, i2 = 0, e2 = len ?? 1 / 0; i2 < e2; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            isLegacyOctalNumericLiteral && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), lastCode === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), i2 === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), lastCode = code;
            continue;
          }
          if (code >= 97 ? val = code - 97 + 10 : code >= 65 ? val = code - 65 + 10 : code >= 48 && code <= 57 ? val = code - 48 : val = 1 / 0, val >= radix)
            break;
          lastCode = code, total = total * radix + val;
        }
        return allowSeparators && lastCode === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === start || len != null && this.pos - start !== len ? null : total;
      };
      function stringToNumber(str2, isLegacyOctalNumericLiteral) {
        return isLegacyOctalNumericLiteral ? parseInt(str2, 8) : parseFloat(str2.replace(/_/g, ""));
      }
      function stringToBigInt(str2) {
        return typeof BigInt != "function" ? null : BigInt(str2.replace(/_/g, ""));
      }
      pp$9.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        return val == null && this.raise(this.start + 2, "Expected number in radix " + radix), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (val = stringToBigInt(this.input.slice(start, this.pos)), ++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types.num, val);
      }, pp$9.readNumber = function(startsWithDot) {
        var start = this.pos;
        !startsWithDot && this.readInt(10, void 0, true) === null && this.raise(start, "Invalid number");
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        octal && this.strict && this.raise(start, "Invalid number");
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types.num, val$1);
        }
        octal && /[89]/.test(this.input.slice(start, this.pos)) && (octal = false), next === 46 && !octal && (++this.pos, this.readInt(10), next = this.input.charCodeAt(this.pos)), (next === 69 || next === 101) && !octal && (next = this.input.charCodeAt(++this.pos), (next === 43 || next === 45) && ++this.pos, this.readInt(10) === null && this.raise(start, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types.num, val);
      }, pp$9.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, code > 1114111 && this.invalidStringToken(codePos, "Code point out of bounds");
        } else
          code = this.readHexChar(4);
        return code;
      };
      function codePointToString$1(code) {
        return code <= 65535 ? String.fromCharCode(code) : (code -= 65536, String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320));
      }
      pp$9.readString = function(quote) {
        for (var out = "", chunkStart = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote)
            break;
          ch === 92 ? (out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(false), chunkStart = this.pos) : (isNewLine(ch, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return out += this.input.slice(chunkStart, this.pos++), this.finishToken(types.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp$9.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR)
            this.readInvalidTemplateToken();
          else
            throw err;
        }
        this.inTemplateElement = false;
      }, pp$9.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        this.raise(position, message);
      }, pp$9.readTmplToken = function() {
        for (var out = "", chunkStart = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate) ? ch === 36 ? (this.pos += 2, this.finishToken(types.dollarBraceL)) : (++this.pos, this.finishToken(types.backQuote)) : (out += this.input.slice(chunkStart, this.pos), this.finishToken(types.template, out));
          if (ch === 92)
            out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(true), chunkStart = this.pos;
          else if (isNewLine(ch)) {
            switch (out += this.input.slice(chunkStart, this.pos), ++this.pos, ch) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                out += `
`;
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), chunkStart = this.pos;
          } else
            ++this.pos;
        }
      }, pp$9.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            // falls through
            case "`":
              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        this.raise(this.start, "Unterminated template");
      }, pp$9.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        switch (++this.pos, ch) {
          case 110:
            return `
`;
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString$1(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          // '\r\n'
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (inTemplate) {
              var codePos = this.pos - 1;
              return this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              ), null;
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
              return octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), this.pos += octalStr.length - 1, ch = this.input.charCodeAt(this.pos), (octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate) && this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(octal);
            }
            return isNewLine(ch) ? "" : String.fromCharCode(ch);
        }
      }, pp$9.readHexChar = function(len) {
        var codePos = this.pos, n2 = this.readInt(16, len);
        return n2 === null && this.invalidStringToken(codePos, "Bad character escape sequence"), n2;
      }, pp$9.readWord1 = function() {
        this.containsEsc = false;
        for (var word = "", first = true, chunkStart = this.pos, astral = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral))
            this.pos += ch <= 65535 ? 1 : 2;
          else if (ch === 92) {
            this.containsEsc = true, word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var esc = this.readCodePoint();
            (first ? isIdentifierStart : isIdentifierChar)(esc, astral) || this.invalidStringToken(escStart, "Invalid Unicode escape"), word += codePointToString$1(esc), chunkStart = this.pos;
          } else
            break;
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      }, pp$9.readWord = function() {
        var word = this.readWord1(), type5 = types.name;
        return this.keywords.test(word) && (type5 = keywords$1[word]), this.finishToken(type5, word);
      };
      var version = "7.4.1";
      Parser2.acorn = {
        Parser: Parser2,
        version,
        defaultOptions: defaultOptions2,
        Position,
        SourceLocation,
        getLineInfo,
        Node: Node2,
        TokenType,
        tokTypes: types,
        keywordTypes: keywords$1,
        TokContext,
        tokContexts: types$1,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse22(input2, options) {
        return Parser2.parse(input2, options);
      }
      function parseExpressionAt(input2, pos, options) {
        return Parser2.parseExpressionAt(input2, pos, options);
      }
      function tokenizer(input2, options) {
        return Parser2.tokenizer(input2, options);
      }
      exports2.Node = Node2, exports2.Parser = Parser2, exports2.Position = Position, exports2.SourceLocation = SourceLocation, exports2.TokContext = TokContext, exports2.Token = Token, exports2.TokenType = TokenType, exports2.defaultOptions = defaultOptions2, exports2.getLineInfo = getLineInfo, exports2.isIdentifierChar = isIdentifierChar, exports2.isIdentifierStart = isIdentifierStart, exports2.isNewLine = isNewLine, exports2.keywordTypes = keywords$1, exports2.lineBreak = lineBreak, exports2.lineBreakG = lineBreakG, exports2.nonASCIIwhitespace = nonASCIIwhitespace, exports2.parse = parse22, exports2.parseExpressionAt = parseExpressionAt, exports2.tokContexts = types$1, exports2.tokTypes = types, exports2.tokenizer = tokenizer, exports2.version = version, Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
var require_xhtml = __commonJS$1({
  "../../node_modules/acorn-jsx/xhtml.js"(exports, module2) {
    module2.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "",
      iexcl: "",
      cent: "",
      pound: "",
      curren: "",
      yen: "",
      brvbar: "",
      sect: "",
      uml: "",
      copy: "",
      ordf: "",
      laquo: "",
      not: "",
      shy: "",
      reg: "",
      macr: "",
      deg: "",
      plusmn: "",
      sup2: "",
      sup3: "",
      acute: "",
      micro: "",
      para: "",
      middot: "",
      cedil: "",
      sup1: "",
      ordm: "",
      raquo: "",
      frac14: "",
      frac12: "",
      frac34: "",
      iquest: "",
      Agrave: "",
      Aacute: "",
      Acirc: "",
      Atilde: "",
      Auml: "",
      Aring: "",
      AElig: "",
      Ccedil: "",
      Egrave: "",
      Eacute: "",
      Ecirc: "",
      Euml: "",
      Igrave: "",
      Iacute: "",
      Icirc: "",
      Iuml: "",
      ETH: "",
      Ntilde: "",
      Ograve: "",
      Oacute: "",
      Ocirc: "",
      Otilde: "",
      Ouml: "",
      times: "",
      Oslash: "",
      Ugrave: "",
      Uacute: "",
      Ucirc: "",
      Uuml: "",
      Yacute: "",
      THORN: "",
      szlig: "",
      agrave: "",
      aacute: "",
      acirc: "",
      atilde: "",
      auml: "",
      aring: "",
      aelig: "",
      ccedil: "",
      egrave: "",
      eacute: "",
      ecirc: "",
      euml: "",
      igrave: "",
      iacute: "",
      icirc: "",
      iuml: "",
      eth: "",
      ntilde: "",
      ograve: "",
      oacute: "",
      ocirc: "",
      otilde: "",
      ouml: "",
      divide: "",
      oslash: "",
      ugrave: "",
      uacute: "",
      ucirc: "",
      uuml: "",
      yacute: "",
      thorn: "",
      yuml: "",
      OElig: "",
      oelig: "",
      Scaron: "",
      scaron: "",
      Yuml: "",
      fnof: "",
      circ: "",
      tilde: "",
      Alpha: "",
      Beta: "",
      Gamma: "",
      Delta: "",
      Epsilon: "",
      Zeta: "",
      Eta: "",
      Theta: "",
      Iota: "",
      Kappa: "",
      Lambda: "",
      Mu: "",
      Nu: "",
      Xi: "",
      Omicron: "",
      Pi: "",
      Rho: "",
      Sigma: "",
      Tau: "",
      Upsilon: "",
      Phi: "",
      Chi: "",
      Psi: "",
      Omega: "",
      alpha: "",
      beta: "",
      gamma: "",
      delta: "",
      epsilon: "",
      zeta: "",
      eta: "",
      theta: "",
      iota: "",
      kappa: "",
      lambda: "",
      mu: "",
      nu: "",
      xi: "",
      omicron: "",
      pi: "",
      rho: "",
      sigmaf: "",
      sigma: "",
      tau: "",
      upsilon: "",
      phi: "",
      chi: "",
      psi: "",
      omega: "",
      thetasym: "",
      upsih: "",
      piv: "",
      ensp: "",
      emsp: "",
      thinsp: "",
      zwnj: "",
      zwj: "",
      lrm: "",
      rlm: "",
      ndash: "",
      mdash: "",
      lsquo: "",
      rsquo: "",
      sbquo: "",
      ldquo: "",
      rdquo: "",
      bdquo: "",
      dagger: "",
      Dagger: "",
      bull: "",
      hellip: "",
      permil: "",
      prime: "",
      Prime: "",
      lsaquo: "",
      rsaquo: "",
      oline: "",
      frasl: "",
      euro: "",
      image: "",
      weierp: "",
      real: "",
      trade: "",
      alefsym: "",
      larr: "",
      uarr: "",
      rarr: "",
      darr: "",
      harr: "",
      crarr: "",
      lArr: "",
      uArr: "",
      rArr: "",
      dArr: "",
      hArr: "",
      forall: "",
      part: "",
      exist: "",
      empty: "",
      nabla: "",
      isin: "",
      notin: "",
      ni: "",
      prod: "",
      sum: "",
      minus: "",
      lowast: "",
      radic: "",
      prop: "",
      infin: "",
      ang: "",
      and: "",
      or: "",
      cap: "",
      cup: "",
      int: "",
      there4: "",
      sim: "",
      cong: "",
      asymp: "",
      ne: "",
      equiv: "",
      le: "",
      ge: "",
      sub: "",
      sup: "",
      nsub: "",
      sube: "",
      supe: "",
      oplus: "",
      otimes: "",
      perp: "",
      sdot: "",
      lceil: "",
      rceil: "",
      lfloor: "",
      rfloor: "",
      lang: "",
      rang: "",
      loz: "",
      spades: "",
      clubs: "",
      hearts: "",
      diams: ""
    };
  }
});
var require_acorn_jsx = __commonJS$1({
  "../../node_modules/acorn-jsx/index.js"(exports, module2) {
    var XHTMLEntities = require_xhtml(), hexNumber = /^[\da-fA-F]+$/, decimalNumber = /^\d+$/, acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx = acornJsxMap.get(acorn);
      if (!acornJsx) {
        let tt = acorn.tokTypes, TokContext = acorn.TokContext, TokenType = acorn.TokenType, tc_oTag = new TokContext("<tag", false), tc_cTag = new TokContext("</tag", false), tc_expr = new TokContext("<tag>...</tag>", true, true), tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        }, tokTypes = {
          jsxName: new TokenType("jsxName"),
          jsxText: new TokenType("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr), this.context.push(tc_oTag), this.exprAllowed = false;
        }, tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          out === tc_oTag && prevType === tt.slash || out === tc_cTag ? (this.context.pop(), this.exprAllowed = this.curContext() === tc_expr) : this.exprAllowed = true;
        }, acornJsx = { tokContexts, tokTypes }, acornJsxMap.set(acorn, acornJsx);
      }
      return acornJsx;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module2.exports = function(options) {
      return options = options || {}, function(Parser2) {
        return plugin2({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser2);
      };
    };
    Object.defineProperty(module2.exports, "tokTypes", {
      get: function() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin2(options, Parser2) {
      let acorn = Parser2.acorn || require_acorn(), acornJsx = getJsxTokens(acorn), tt = acorn.tokTypes, tok = acornJsx.tokTypes, tokContexts = acorn.tokContexts, tc_oTag = acornJsx.tokContexts.tc_oTag, tc_cTag = acornJsx.tokContexts.tc_cTag, tc_expr = acornJsx.tokContexts.tc_expr, isNewLine = acorn.isNewLine, isIdentifierStart = acorn.isIdentifierStart, isIdentifierChar = acorn.isIdentifierChar;
      return class extends Parser2 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              // '<'
              case 123:
                return this.pos === this.start ? ch === 60 && this.exprAllowed ? (++this.pos, this.finishToken(tok.jsxTagStart)) : this.getTokenFromCode(ch) : (out += this.input.slice(chunkStart, this.pos), this.finishToken(tok.jsxText, out));
              case 38:
                out += this.input.slice(chunkStart, this.pos), out += this.jsx_readEntity(), chunkStart = this.pos;
                break;
              case 62:
              // '>'
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                isNewLine(ch) ? (out += this.input.slice(chunkStart, this.pos), out += this.jsx_readNewLine(true), chunkStart = this.pos) : ++this.pos;
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos), out;
          return ++this.pos, ch === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, out = normalizeCRLF ? `
` : `\r
`) : out = String.fromCharCode(ch), this.options.locations && (++this.curLine, this.lineStart = this.pos), out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            ch === 38 ? (out += this.input.slice(chunkStart, this.pos), out += this.jsx_readEntity(), chunkStart = this.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.pos), out += this.jsx_readNewLine(false), chunkStart = this.pos) : ++this.pos;
          }
          return out += this.input.slice(chunkStart, this.pos++), this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str2 = "", count2 = 0, entity, ch = this.input[this.pos];
          ch !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          for (; this.pos < this.input.length && count2++ < 10; ) {
            if (ch = this.input[this.pos++], ch === ";") {
              str2[0] === "#" ? str2[1] === "x" ? (str2 = str2.substr(2), hexNumber.test(str2) && (entity = String.fromCharCode(parseInt(str2, 16)))) : (str2 = str2.substr(1), decimalNumber.test(str2) && (entity = String.fromCharCode(parseInt(str2, 10)))) : entity = XHTMLEntities[str2];
              break;
            }
            str2 += ch;
          }
          return entity || (this.pos = startPos, "&");
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start = this.pos;
          do
            ch = this.input.charCodeAt(++this.pos);
          while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node = this.startNode();
          return this.type === tok.jsxName ? node.name = this.value : this.type.keyword ? node.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(node, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc, name = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          return node.namespace = name, node.name = this.jsx_parseIdentifier(), this.finishNode(node, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc, node = this.jsx_parseNamespacedName();
          for (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects && this.unexpected(); this.eat(tt.dot); ) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node, newNode.property = this.jsx_parseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node = this.jsx_parseExpressionContainer();
              return node.expression.type === "JSXEmptyExpression" && this.raise(node.start, "JSX attributes must only be assigned a non-empty expression"), node;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node = this.startNode();
          return this.next(), node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(tt.braceR), this.finishNode(node, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node = this.startNode();
          return this.eat(tt.braceL) ? (this.expect(tt.ellipsis), node.argument = this.parseMaybeAssign(), this.expect(tt.braceR), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsx_parseNamespacedName(), node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          node.attributes = [];
          let nodeName = this.jsx_parseElementName();
          for (nodeName && (node.name = nodeName); this.type !== tt.slash && this.type !== tok.jsxTagEnd; )
            node.attributes.push(this.jsx_parseAttribute());
          return node.selfClosing = this.eat(tt.slash), this.expect(tok.jsxTagEnd), this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc), nodeName = this.jsx_parseElementName();
          return nodeName && (node.name = nodeName), this.expect(tok.jsxTagEnd), this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc), children = [], openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc), closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; )
              switch (this.type) {
                case tok.jsxTagStart:
                  if (startPos = this.start, startLoc = this.startLoc, this.next(), this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(
              closingElement.start,
              "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
            );
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          return node["opening" + fragmentOrElement] = openingElement, node["closing" + fragmentOrElement] = closingElement, node.children = children, this.type === tt.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(node, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node = this.parseLiteral(this.value);
          return node.type = "JSXText", node;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          return this.next(), this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          return this.type === tok.jsxText ? this.jsx_parseText() : this.type === tok.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart(code)) return this.jsx_readWord();
            if (code == 62)
              return ++this.pos, this.finishToken(tok.jsxTagEnd);
            if ((code === 34 || code === 39) && context == tc_oTag)
              return this.jsx_readString(code);
          }
          return code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(tok.jsxTagStart)) : super.readToken(code);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            curContext == tc_oTag ? this.context.push(tokContexts.b_expr) : curContext == tc_expr ? this.context.push(tokContexts.b_tmpl) : super.updateContext(prevType), this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart)
            this.context.length -= 2, this.context.push(tc_cTag), this.exprAllowed = false;
          else
            return super.updateContext(prevType);
        }
      };
    }
  }
});
var require_html_tags = __commonJS$1({
  "../../node_modules/html-tags/html-tags.json"(exports, module2) {
    module2.exports = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "math",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "script",
      "search",
      "section",
      "select",
      "slot",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ];
  }
});
var require_html_tags2 = __commonJS$1({
  "../../node_modules/html-tags/index.js"(exports, module2) {
    module2.exports = require_html_tags();
  }
});
var entry_preview_argtypes_exports = {};
__export$2(entry_preview_argtypes_exports, {
  argTypesEnhancers: () => argTypesEnhancers,
  parameters: () => parameters$2
});
var CUSTOM_CAPTION = "custom", OBJECT_CAPTION = "object", ARRAY_CAPTION = "array", CLASS_CAPTION = "class", FUNCTION_CAPTION = "func", ELEMENT_CAPTION = "element";
var import_escodegen = __toESM$1(require_escodegen(), 1);
function dedent(templ) {
  for (var values = [], _i = 1; _i < arguments.length; _i++)
    values[_i - 1] = arguments[_i];
  var strings = Array.from(typeof templ == "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str2) {
    var matches5 = str2.match(/\n([\t ]+|(?!\s).)/g);
    return matches5 ? arr.concat(matches5.map(function(match) {
      var _a3, _b;
      return (_b = (_a3 = match.match(/[\t ]/g)) === null || _a3 === void 0 ? void 0 : _a3.length) !== null && _b !== void 0 ? _b : 0;
    })) : arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str2) {
      return str2.replace(pattern_1, `
`);
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  return values.forEach(function(value, i2) {
    var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value;
    typeof value == "string" && value.includes(`
`) && (indentedValue = String(value).split(`
`).map(function(str2, i22) {
      return i22 === 0 ? str2 : "" + endentation + str2;
    }).join(`
`)), string += indentedValue + strings[i2 + 1];
  }), string;
}
var BASIC_OPTIONS = {
  format: {
    indent: {
      style: "  "
    },
    semicolons: false
  }
}, COMPACT_OPTIONS = {
  ...BASIC_OPTIONS,
  format: {
    newline: ""
  }
}, PRETTY_OPTIONS = {
  ...BASIC_OPTIONS
};
function generateCode(ast, compact = false) {
  return (0, import_escodegen.generate)(ast, compact ? COMPACT_OPTIONS : PRETTY_OPTIONS);
}
function generateObjectCode(ast, compact = false) {
  return compact ? generateCompactObjectCode(ast) : generateCode(ast);
}
function generateCompactObjectCode(ast) {
  let result = generateCode(ast, true);
  return result.endsWith(" }") || (result = `${result.slice(0, -1)} }`), result;
}
function generateArrayCode(ast, compact = false) {
  return compact ? generateCompactArrayCode(ast) : generateMultilineArrayCode(ast);
}
function generateMultilineArrayCode(ast) {
  let result = generateCode(ast);
  return result.endsWith("  }]") && (result = dedent(result)), result;
}
function generateCompactArrayCode(ast) {
  let result = generateCode(ast, true);
  return result.startsWith("[    ") && (result = result.replace("[    ", "[")), result;
}
var import_acorn = __toESM$1(require_acorn(), 1), import_acorn_jsx = __toESM$1(require_acorn_jsx(), 1);
function simple(node, visitors, baseVisitor, state3, override) {
  baseVisitor || (baseVisitor = base), function c2(node2, st, override2) {
    var type5 = override2 || node2.type, found = visitors[type5];
    baseVisitor[type5](node2, st, c2), found && found(node2, st);
  }(node, state3, override);
}
function ancestor(node, visitors, baseVisitor, state3, override) {
  var ancestors = [];
  baseVisitor || (baseVisitor = base), function c2(node2, st, override2) {
    var type5 = override2 || node2.type, found = visitors[type5], isNew = node2 !== ancestors[ancestors.length - 1];
    isNew && ancestors.push(node2), baseVisitor[type5](node2, st, c2), found && found(node2, st || ancestors, ancestors), isNew && ancestors.pop();
  }(node, state3, override);
}
function skipThrough(node, st, c2) {
  c2(node, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = function(node, st, c2) {
  for (var i2 = 0, list = node.body; i2 < list.length; i2 += 1) {
    var stmt = list[i2];
    c2(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c2) {
  return c2(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c2) {
  c2(node.test, st, "Expression"), c2(node.consequent, st, "Statement"), node.alternate && c2(node.alternate, st, "Statement");
};
base.LabeledStatement = function(node, st, c2) {
  return c2(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c2) {
  c2(node.object, st, "Expression"), c2(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c2) {
  c2(node.discriminant, st, "Expression");
  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
    var cs = list$1[i$1];
    cs.test && c2(cs.test, st, "Expression");
    for (var i2 = 0, list = cs.consequent; i2 < list.length; i2 += 1) {
      var cons = list[i2];
      c2(cons, st, "Statement");
    }
  }
};
base.SwitchCase = function(node, st, c2) {
  node.test && c2(node.test, st, "Expression");
  for (var i2 = 0, list = node.consequent; i2 < list.length; i2 += 1) {
    var cons = list[i2];
    c2(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c2) {
  node.argument && c2(node.argument, st, "Expression");
};
base.ThrowStatement = base.SpreadElement = function(node, st, c2) {
  return c2(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c2) {
  c2(node.block, st, "Statement"), node.handler && c2(node.handler, st), node.finalizer && c2(node.finalizer, st, "Statement");
};
base.CatchClause = function(node, st, c2) {
  node.param && c2(node.param, st, "Pattern"), c2(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c2) {
  c2(node.test, st, "Expression"), c2(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c2) {
  node.init && c2(node.init, st, "ForInit"), node.test && c2(node.test, st, "Expression"), node.update && c2(node.update, st, "Expression"), c2(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c2) {
  c2(node.left, st, "ForInit"), c2(node.right, st, "Expression"), c2(node.body, st, "Statement");
};
base.ForInit = function(node, st, c2) {
  node.type === "VariableDeclaration" ? c2(node, st) : c2(node, st, "Expression");
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c2) {
  return c2(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c2) {
  for (var i2 = 0, list = node.declarations; i2 < list.length; i2 += 1) {
    var decl = list[i2];
    c2(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c2) {
  c2(node.id, st, "Pattern"), node.init && c2(node.init, st, "Expression");
};
base.Function = function(node, st, c2) {
  node.id && c2(node.id, st, "Pattern");
  for (var i2 = 0, list = node.params; i2 < list.length; i2 += 1) {
    var param = list[i2];
    c2(param, st, "Pattern");
  }
  c2(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c2) {
  node.type === "Identifier" ? c2(node, st, "VariablePattern") : node.type === "MemberExpression" ? c2(node, st, "MemberPattern") : c2(node, st);
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c2) {
  return c2(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c2) {
  for (var i2 = 0, list = node.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    elt && c2(elt, st, "Pattern");
  }
};
base.ObjectPattern = function(node, st, c2) {
  for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    prop.type === "Property" ? (prop.computed && c2(prop.key, st, "Expression"), c2(prop.value, st, "Pattern")) : prop.type === "RestElement" && c2(prop.argument, st, "Pattern");
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    elt && c2(elt, st, "Expression");
  }
};
base.ObjectExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    c2(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.expressions; i2 < list.length; i2 += 1) {
    var expr = list[i2];
    c2(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c2) {
  for (var i2 = 0, list = node.quasis; i2 < list.length; i2 += 1) {
    var quasi = list[i2];
    c2(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c2(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c2) {
  c2(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c2) {
  c2(node.left, st, "Expression"), c2(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c2) {
  c2(node.left, st, "Pattern"), c2(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c2) {
  c2(node.test, st, "Expression"), c2(node.consequent, st, "Expression"), c2(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c2) {
  if (c2(node.callee, st, "Expression"), node.arguments)
    for (var i2 = 0, list = node.arguments; i2 < list.length; i2 += 1) {
      var arg = list[i2];
      c2(arg, st, "Expression");
    }
};
base.MemberExpression = function(node, st, c2) {
  c2(node.object, st, "Expression"), node.computed && c2(node.property, st, "Expression");
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c2) {
  node.declaration && c2(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"), node.source && c2(node.source, st, "Expression");
};
base.ExportAllDeclaration = function(node, st, c2) {
  node.exported && c2(node.exported, st), c2(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c2) {
  for (var i2 = 0, list = node.specifiers; i2 < list.length; i2 += 1) {
    var spec = list[i2];
    c2(spec, st);
  }
  c2(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c2) {
  c2(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c2) {
  c2(node.tag, st, "Expression"), c2(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c2) {
  return c2(node, st, "Class");
};
base.Class = function(node, st, c2) {
  node.id && c2(node.id, st, "Pattern"), node.superClass && c2(node.superClass, st, "Expression"), c2(node.body, st);
};
base.ClassBody = function(node, st, c2) {
  for (var i2 = 0, list = node.body; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    c2(elt, st);
  }
};
base.MethodDefinition = base.Property = function(node, st, c2) {
  node.computed && c2(node.key, st, "Expression"), c2(node.value, st, "Expression");
};
var ACORN_WALK_VISITORS = {
  // @ts-expect-error (Converted from ts-ignore)
  ...base,
  JSXElement: () => {
  }
}, acornParser = import_acorn.Parser.extend((0, import_acorn_jsx.default)());
function extractIdentifierName(identifierNode) {
  return identifierNode != null ? identifierNode.name : null;
}
function filterAncestors(ancestors) {
  return ancestors.filter((x2) => x2.type === "ObjectExpression" || x2.type === "ArrayExpression");
}
function calculateNodeDepth(node) {
  let depths = [];
  return ancestor(
    // @ts-expect-error (Converted from ts-ignore)
    node,
    {
      ObjectExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      },
      ArrayExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      }
    },
    ACORN_WALK_VISITORS
  ), Math.max(...depths);
}
function parseIdentifier(identifierNode) {
  return {
    inferredType: {
      type: "Identifier",
      identifier: extractIdentifierName(identifierNode)
    },
    ast: identifierNode
  };
}
function parseLiteral(literalNode) {
  return {
    inferredType: {
      type: "Literal"
      /* LITERAL */
    },
    ast: literalNode
  };
}
function parseFunction(funcNode) {
  let innerJsxElementNode;
  simple(
    // @ts-expect-error (Converted from ts-ignore)
    funcNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  let inferredType = {
    type: innerJsxElementNode != null ? "Element" : "Function",
    params: funcNode.params,
    hasParams: funcNode.params.length !== 0
  }, identifierName = extractIdentifierName(funcNode.id);
  return identifierName != null && (inferredType.identifier = identifierName), {
    inferredType,
    ast: funcNode
  };
}
function parseClass(classNode) {
  let innerJsxElementNode;
  return simple(
    // @ts-expect-error (Converted from ts-ignore)
    classNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  ), {
    inferredType: {
      type: innerJsxElementNode != null ? "Element" : "Class",
      identifier: extractIdentifierName(classNode.id)
    },
    ast: classNode
  };
}
function parseJsxElement(jsxElementNode) {
  let inferredType = {
    type: "Element"
    /* ELEMENT */
  }, identifierName = extractIdentifierName(jsxElementNode.openingElement.name);
  return identifierName != null && (inferredType.identifier = identifierName), {
    inferredType,
    ast: jsxElementNode
  };
}
function parseCall(callNode) {
  let identifierNode = callNode.callee.type === "MemberExpression" ? callNode.callee.property : callNode.callee;
  return extractIdentifierName(identifierNode) === "shape" ? parseObject(callNode.arguments[0]) : null;
}
function parseObject(objectNode) {
  return {
    inferredType: { type: "Object", depth: calculateNodeDepth(objectNode) },
    ast: objectNode
  };
}
function parseArray(arrayNode) {
  return {
    inferredType: { type: "Array", depth: calculateNodeDepth(arrayNode) },
    ast: arrayNode
  };
}
function parseExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return parseIdentifier(expression);
    case "Literal":
      return parseLiteral(expression);
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return parseFunction(expression);
    case "ClassExpression":
      return parseClass(expression);
    case "JSXElement":
      return parseJsxElement(expression);
    case "CallExpression":
      return parseCall(expression);
    case "ObjectExpression":
      return parseObject(expression);
    case "ArrayExpression":
      return parseArray(expression);
    default:
      return null;
  }
}
function parse(value) {
  let ast = acornParser.parse(`(${value})`, { ecmaVersion: 2020 }), parsingResult = {
    inferredType: {
      type: "Unknown"
      /* UNKNOWN */
    },
    ast
  };
  if (ast.body[0] != null) {
    let rootNode = ast.body[0];
    switch (rootNode.type) {
      case "ExpressionStatement": {
        let expressionResult = parseExpression(rootNode.expression);
        expressionResult != null && (parsingResult = expressionResult);
        break;
      }
    }
  }
  return parsingResult;
}
function inspectValue(value) {
  try {
    return { ...parse(value) };
  } catch {
  }
  return { inferredType: {
    type: "Unknown"
    /* UNKNOWN */
  } };
}
var import_html_tags = __toESM$1(require_html_tags2(), 1);
function isHtmlTag(tagName) {
  return import_html_tags.default.includes(tagName.toLowerCase());
}
function generateArray({ inferredType, ast }) {
  let { depth } = inferredType;
  if (depth <= 2) {
    let compactArray = generateArrayCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactArray))
      return createSummaryValue(compactArray);
  }
  return createSummaryValue(ARRAY_CAPTION, generateArrayCode(ast));
}
function generateObject({ inferredType, ast }) {
  let { depth } = inferredType;
  if (depth === 1) {
    let compactObject = generateObjectCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactObject))
      return createSummaryValue(compactObject);
  }
  return createSummaryValue(OBJECT_CAPTION, generateObjectCode(ast));
}
function getPrettyFuncIdentifier(identifier, hasArguments) {
  return hasArguments ? `${identifier}( ... )` : `${identifier}()`;
}
function getPrettyElementIdentifier(identifier) {
  return `<${identifier} />`;
}
function getPrettyIdentifier(inferredType) {
  let { type: type5, identifier } = inferredType;
  switch (type5) {
    case "Function":
      return getPrettyFuncIdentifier(identifier, inferredType.hasParams);
    case "Element":
      return getPrettyElementIdentifier(identifier);
    default:
      return identifier;
  }
}
function generateFunc({ inferredType, ast }) {
  let { identifier } = inferredType;
  if (identifier != null)
    return createSummaryValue(
      getPrettyIdentifier(inferredType),
      generateCode(ast)
    );
  let prettyCaption = generateCode(ast, true);
  return isTooLongForDefaultValueSummary(prettyCaption) ? createSummaryValue(FUNCTION_CAPTION, generateCode(ast)) : createSummaryValue(prettyCaption);
}
function generateElement(defaultValue, inspectionResult) {
  let { inferredType } = inspectionResult, { identifier } = inferredType;
  if (identifier != null && !isHtmlTag(identifier)) {
    let prettyIdentifier = getPrettyIdentifier(
      inferredType
    );
    return createSummaryValue(prettyIdentifier, defaultValue);
  }
  return isTooLongForDefaultValueSummary(defaultValue) ? createSummaryValue(ELEMENT_CAPTION, defaultValue) : createSummaryValue(defaultValue);
}
function createDefaultValue(defaultValue) {
  try {
    let inspectionResult = inspectValue(defaultValue);
    switch (inspectionResult.inferredType.type) {
      case "Object":
        return generateObject(inspectionResult);
      case "Function":
        return generateFunc(inspectionResult);
      case "Element":
        return generateElement(defaultValue, inspectionResult);
      case "Array":
        return generateArray(inspectionResult);
      default:
        return null;
    }
  } catch (e2) {
    console.error(e2);
  }
  return null;
}
function isPlainObject(value) {
  if (!value || typeof value != "object")
    return false;
  let proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value) === "[object Object]" : false;
}
function isFunction(value) {
  return typeof value == "function";
}
function isString(value) {
  return typeof value == "string";
}
var reactElementToJSXString$1 = reactElementToJsxString;
function isReactElement(element) {
  return element.$$typeof != null;
}
function extractFunctionName(func, propName) {
  let { name } = func;
  return name !== "" && name !== "anonymous" && name !== propName ? name : null;
}
var stringResolver = (rawDefaultProp) => createSummaryValue(JSON.stringify(rawDefaultProp));
function generateReactObject(rawDefaultProp) {
  let { type: type5 } = rawDefaultProp, { displayName } = type5, jsx2 = reactElementToJSXString$1(rawDefaultProp, {});
  if (displayName != null) {
    let prettyIdentifier = getPrettyElementIdentifier(displayName);
    return createSummaryValue(prettyIdentifier, jsx2);
  }
  if (isString(type5) && isHtmlTag(type5)) {
    let jsxSummary = reactElementToJSXString$1(rawDefaultProp, { tabStop: 0 }).replace(/\r?\n|\r/g, "");
    if (!isTooLongForDefaultValueSummary(jsxSummary))
      return createSummaryValue(jsxSummary);
  }
  return createSummaryValue(ELEMENT_CAPTION, jsx2);
}
var objectResolver = (rawDefaultProp) => {
  if (isReactElement(rawDefaultProp) && rawDefaultProp.type != null)
    return generateReactObject(rawDefaultProp);
  if (isPlainObject(rawDefaultProp)) {
    let inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateObject(inspectionResult);
  }
  if (Array.isArray(rawDefaultProp)) {
    let inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateArray(inspectionResult);
  }
  return createSummaryValue(OBJECT_CAPTION);
}, functionResolver = (rawDefaultProp, propDef) => {
  let isElement5 = false, inspectionResult;
  if (isFunction(rawDefaultProp.render))
    isElement5 = true;
  else if (rawDefaultProp.prototype != null && isFunction(rawDefaultProp.prototype.render))
    isElement5 = true;
  else {
    let innerElement;
    try {
      inspectionResult = inspectValue(rawDefaultProp.toString());
      let { hasParams, params } = inspectionResult.inferredType;
      hasParams ? params.length === 1 && params[0].type === "ObjectPattern" && (innerElement = rawDefaultProp({})) : innerElement = rawDefaultProp(), innerElement != null && isReactElement(innerElement) && (isElement5 = true);
    } catch {
    }
  }
  let funcName = extractFunctionName(rawDefaultProp, propDef.name);
  if (funcName != null) {
    if (isElement5)
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    inspectionResult != null && (inspectionResult = inspectValue(rawDefaultProp.toString()));
    let { hasParams } = inspectionResult.inferredType;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue(isElement5 ? ELEMENT_CAPTION : FUNCTION_CAPTION);
}, defaultResolver = (rawDefaultProp) => createSummaryValue(rawDefaultProp.toString()), DEFAULT_TYPE_RESOLVERS = {
  string: stringResolver,
  object: objectResolver,
  function: functionResolver,
  default: defaultResolver
};
function createTypeResolvers(customResolvers = {}) {
  return {
    ...DEFAULT_TYPE_RESOLVERS,
    ...customResolvers
  };
}
function createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, typeResolvers = DEFAULT_TYPE_RESOLVERS) {
  try {
    switch (typeof rawDefaultProp) {
      case "string":
        return typeResolvers.string(rawDefaultProp, propDef);
      case "object":
        return typeResolvers.object(rawDefaultProp, propDef);
      case "function":
        return typeResolvers.function(rawDefaultProp, propDef);
      default:
        return typeResolvers.default(rawDefaultProp, propDef);
    }
  } catch (e2) {
    console.error(e2);
  }
  return null;
}
function generateFuncSignature(params, returns) {
  let hasParams = params != null, hasReturns = returns != null;
  if (!hasParams && !hasReturns)
    return "";
  let funcParts = [];
  if (hasParams) {
    let funcParams = params.map((x2) => {
      let prettyName = x2.getPrettyName(), typeName = x2.getTypeName();
      return typeName != null ? `${prettyName}: ${typeName}` : prettyName;
    });
    funcParts.push(`(${funcParams.join(", ")})`);
  } else
    funcParts.push("()");
  return hasReturns && funcParts.push(`=> ${returns.getTypeName()}`), funcParts.join(" ");
}
function generateShortFuncSignature(params, returns) {
  let hasParams = params != null, hasReturns = returns != null;
  if (!hasParams && !hasReturns)
    return "";
  let funcParts = [];
  return hasParams ? funcParts.push("( ... )") : funcParts.push("()"), hasReturns && funcParts.push(`=> ${returns.getTypeName()}`), funcParts.join(" ");
}
function toMultilineSignature(signature) {
  return signature.replace(/,/g, `,\r
`);
}
var MAX_FUNC_LENGTH = 150;
function createTypeDef({
  name,
  short,
  compact,
  full,
  inferredType
}) {
  return {
    name,
    short,
    compact,
    full: full ?? short,
    inferredType
  };
}
function cleanPropTypes(value) {
  return value.replace(/PropTypes./g, "").replace(/.isRequired/g, "");
}
function splitIntoLines(value) {
  return value.split(/\r?\n/);
}
function prettyObject(ast, compact = false) {
  return cleanPropTypes(generateObjectCode(ast, compact));
}
function prettyArray(ast, compact = false) {
  return cleanPropTypes(generateCode(ast, compact));
}
function getCaptionForInspectionType(type5) {
  switch (type5) {
    case "Object":
      return OBJECT_CAPTION;
    case "Array":
      return ARRAY_CAPTION;
    case "Class":
      return CLASS_CAPTION;
    case "Function":
      return FUNCTION_CAPTION;
    case "Element":
      return ELEMENT_CAPTION;
    default:
      return CUSTOM_CAPTION;
  }
}
function generateTypeFromString(value, originalTypeName) {
  let { inferredType, ast } = inspectValue(value), { type: type5 } = inferredType, short, compact, full;
  switch (type5) {
    case "Identifier":
    case "Literal":
      short = value, compact = value;
      break;
    case "Object": {
      let { depth } = inferredType;
      short = OBJECT_CAPTION, compact = depth === 1 ? prettyObject(ast, true) : null, full = prettyObject(ast);
      break;
    }
    case "Element": {
      let { identifier } = inferredType;
      short = identifier != null && !isHtmlTag(identifier) ? identifier : ELEMENT_CAPTION, compact = splitIntoLines(value).length === 1 ? value : null, full = value;
      break;
    }
    case "Array": {
      let { depth } = inferredType;
      short = ARRAY_CAPTION, compact = depth <= 2 ? prettyArray(ast, true) : null, full = prettyArray(ast);
      break;
    }
    default:
      short = getCaptionForInspectionType(type5), compact = splitIntoLines(value).length === 1 ? value : null, full = value;
      break;
  }
  return createTypeDef({
    name: originalTypeName,
    short,
    compact,
    full,
    inferredType: type5
  });
}
function generateCustom({ raw }) {
  return raw != null ? generateTypeFromString(
    raw,
    "custom"
    /* CUSTOM */
  ) : createTypeDef({
    name: "custom",
    short: CUSTOM_CAPTION,
    compact: CUSTOM_CAPTION
  });
}
function generateFunc2(extractedProp) {
  let { jsDocTags } = extractedProp;
  return jsDocTags != null && (jsDocTags.params != null || jsDocTags.returns != null) ? createTypeDef({
    name: "func",
    // @ts-expect-error (Converted from ts-ignore)
    short: generateShortFuncSignature(jsDocTags.params, jsDocTags.returns),
    compact: null,
    // @ts-expect-error (Converted from ts-ignore)
    full: generateFuncSignature(jsDocTags.params, jsDocTags.returns)
  }) : createTypeDef({
    name: "func",
    short: FUNCTION_CAPTION,
    compact: FUNCTION_CAPTION
  });
}
function generateShape(type5, extractedProp) {
  let fields = Object.keys(type5.value).map((key) => `${key}: ${generateType(type5.value[key], extractedProp).full}`).join(", "), { inferredType, ast } = inspectValue(`{ ${fields} }`), { depth } = inferredType;
  return createTypeDef({
    name: "shape",
    short: OBJECT_CAPTION,
    compact: depth === 1 && ast ? prettyObject(ast, true) : null,
    full: ast ? prettyObject(ast) : null
  });
}
function objectOf(of) {
  return `objectOf(${of})`;
}
function generateObjectOf(type5, extractedProp) {
  let { short, compact, full } = generateType(type5.value, extractedProp);
  return createTypeDef({
    name: "objectOf",
    short: objectOf(short),
    compact: compact != null ? objectOf(compact) : null,
    full: full && objectOf(full)
  });
}
function generateUnion(type5, extractedProp) {
  if (Array.isArray(type5.value)) {
    let values = type5.value.reduce(
      (acc, v2) => {
        let { short, compact, full } = generateType(v2, extractedProp);
        return acc.short.push(short), acc.compact.push(compact), acc.full.push(full), acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "union",
      short: values.short.join(" | "),
      compact: values.compact.every((x2) => x2 != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "union", short: type5.value, compact: null });
}
function generateEnumValue({ value, computed }) {
  return computed ? generateTypeFromString(value, "enumvalue") : createTypeDef({ name: "enumvalue", short: value, compact: value });
}
function generateEnum(type5) {
  if (Array.isArray(type5.value)) {
    let values = type5.value.reduce(
      (acc, v2) => {
        let { short, compact, full } = generateEnumValue(v2);
        return acc.short.push(short), acc.compact.push(compact), acc.full.push(full), acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "enum",
      short: values.short.join(" | "),
      compact: values.compact.every((x2) => x2 != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "enum", short: type5.value, compact: type5.value });
}
function braceAfter(of) {
  return `${of}[]`;
}
function braceAround(of) {
  return `[${of}]`;
}
function createArrayOfObjectTypeDef(short, compact, full) {
  return createTypeDef({
    name: "arrayOf",
    short: braceAfter(short),
    compact: compact != null ? braceAround(compact) : null,
    full: full && braceAround(full)
  });
}
function generateArray2(type5, extractedProp) {
  let { name, short, compact, full, inferredType } = generateType(type5.value, extractedProp);
  if (name === "custom") {
    if (inferredType === "Object")
      return createArrayOfObjectTypeDef(short, compact, full);
  } else if (name === "shape")
    return createArrayOfObjectTypeDef(short, compact, full);
  return createTypeDef({
    name: "arrayOf",
    short: braceAfter(short),
    compact: braceAfter(short)
  });
}
function generateType(type5, extractedProp) {
  try {
    switch (type5.name) {
      case "custom":
        return generateCustom(type5);
      case "func":
        return generateFunc2(extractedProp);
      case "shape":
        return generateShape(type5, extractedProp);
      case "instanceOf":
        return createTypeDef({
          name: "instanceOf",
          short: type5.value,
          compact: type5.value
        });
      case "objectOf":
        return generateObjectOf(type5, extractedProp);
      case "union":
        return generateUnion(type5, extractedProp);
      case "enum":
        return generateEnum(type5);
      case "arrayOf":
        return generateArray2(type5, extractedProp);
      default:
        return createTypeDef({ name: type5.name, short: type5.name, compact: type5.name });
    }
  } catch (e2) {
    console.error(e2);
  }
  return createTypeDef({ name: "unknown", short: "unknown", compact: "unknown" });
}
function createType(extractedProp) {
  let { type: type5 } = extractedProp.docgenInfo;
  if (type5 == null)
    return null;
  try {
    switch (type5.name) {
      case "custom":
      case "shape":
      case "instanceOf":
      case "objectOf":
      case "union":
      case "enum":
      case "arrayOf": {
        let { short, compact, full } = generateType(type5, extractedProp);
        return compact != null && !isTooLongForTypeSummary(compact) ? createSummaryValue(compact) : full ? createSummaryValue(short, full) : createSummaryValue(short);
      }
      case "func": {
        let { short, full } = generateType(type5, extractedProp), summary = short, detail;
        return full && full.length < MAX_FUNC_LENGTH ? summary = full : full && (detail = toMultilineSignature(full)), createSummaryValue(summary, detail);
      }
      default:
        return null;
    }
  } catch (e2) {
    console.error(e2);
  }
  return null;
}
var funcResolver = (rawDefaultProp, { name, type: type5 }) => {
  let isElement5 = type5?.summary === "element" || type5?.summary === "elementType", funcName = extractFunctionName(rawDefaultProp, name);
  if (funcName != null) {
    if (isElement5)
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    let { hasParams } = inspectValue(rawDefaultProp.toString()).inferredType;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue(isElement5 ? ELEMENT_CAPTION : FUNCTION_CAPTION);
}, rawDefaultPropTypeResolvers = createTypeResolvers({
  function: funcResolver
});
function keepOriginalDefinitionOrder(extractedProps, component) {
  let { propTypes } = component;
  return propTypes != null ? Object.keys(propTypes).map((x2) => extractedProps.find((y2) => y2.name === x2)).filter(Boolean) : extractedProps;
}
function enhancePropTypesProp(extractedProp, rawDefaultProp) {
  let { propDef } = extractedProp, newtype = createType(extractedProp);
  newtype != null && (propDef.type = newtype);
  let { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    let newDefaultValue = createDefaultValue(defaultValue.value);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  } else if (rawDefaultProp != null) {
    let newDefaultValue = createDefaultValueFromRawDefaultProp(
      rawDefaultProp,
      propDef,
      rawDefaultPropTypeResolvers
    );
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  }
  return propDef;
}
function enhancePropTypesProps(extractedProps, component) {
  let rawDefaultProps = component.defaultProps != null ? component.defaultProps : {}, enhancedProps = extractedProps.map(
    (x2) => enhancePropTypesProp(x2, rawDefaultProps[x2.propDef.name])
  );
  return keepOriginalDefinitionOrder(enhancedProps, component);
}
function enhanceTypeScriptProp(extractedProp, rawDefaultProp) {
  let { propDef } = extractedProp, { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    let newDefaultValue = createDefaultValue(defaultValue.value);
    newDefaultValue != null && (propDef.defaultValue = newDefaultValue);
  }
  return propDef;
}
function enhanceTypeScriptProps(extractedProps) {
  return extractedProps.map((prop) => enhanceTypeScriptProp(prop));
}
function getPropDefs(component, section) {
  let processedComponent = component;
  !hasDocgen(component) && !component.propTypes && isMemo(component) && (processedComponent = component.type);
  let extractedProps = extractComponentProps(processedComponent, section);
  if (extractedProps.length === 0)
    return [];
  switch (extractedProps[0].typeSystem) {
    case TypeSystem.JAVASCRIPT:
      return enhancePropTypesProps(extractedProps, component);
    case TypeSystem.TYPESCRIPT:
      return enhanceTypeScriptProps(extractedProps);
    default:
      return extractedProps.map((x2) => x2.propDef);
  }
}
var extractProps = (component) => ({
  rows: getPropDefs(component, "props")
});
var extractArgTypes = (component) => {
  if (component) {
    let { rows } = extractProps(component);
    if (rows)
      return rows.reduce((acc, row) => {
        let {
          name,
          description,
          type: type5,
          sbType,
          defaultValue: defaultSummary,
          jsDocTags,
          required
        } = row;
        return acc[name] = {
          name,
          description,
          type: { required, ...sbType },
          table: {
            type: type5 ?? void 0,
            jsDocTags,
            defaultValue: defaultSummary ?? void 0
          }
        }, acc;
      }, {});
  }
  return null;
};
var parameters$2 = {
  docs: {
    extractArgTypes,
    extractComponentDescription
  }
}, argTypesEnhancers = [enhanceArgTypes];
const entry_preview_argtypes_20364 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  argTypesEnhancers,
  parameters: parameters$2
}, Symbol.toStringTag, { value: "Module" }));
var entry_preview_docs_exports = {};
__export$2(entry_preview_docs_exports, {
  applyDecorators: () => applyDecorators2,
  decorators: () => decorators$1,
  parameters: () => parameters$1
});
const { logger } = __STORYBOOK_MODULE_CLIENT_LOGGER__;
const { emitTransformCode, useEffect, useRef } = __STORYBOOK_MODULE_PREVIEW_API__;
var reactElementToJSXString = reactElementToJsxString, toPascalCase = (str2) => str2.charAt(0).toUpperCase() + str2.slice(1), getReactSymbolName = (elementType) => (elementType.$$typeof || elementType).toString().replace(/^Symbol\((.*)\)$/, "$1").split(".").map((segment) => segment.split("_").map(toPascalCase).join("")).join(".");
function simplifyNodeForStringify(node) {
  if (reactExports.isValidElement(node)) {
    let props = Object.keys(node.props).reduce((acc, cur) => (acc[cur] = simplifyNodeForStringify(node.props[cur]), acc), {});
    return {
      ...node,
      props,
      // @ts-expect-error (this is an internal or removed api)
      _owner: null
    };
  }
  return Array.isArray(node) ? node.map(simplifyNodeForStringify) : node;
}
var renderJsx$1 = (code, options) => {
  if (typeof code > "u")
    return logger.warn("Too many skip or undefined component"), null;
  let renderedJSX = code, Type = renderedJSX.type;
  for (let i2 = 0; i2 < options?.skip; i2 += 1) {
    if (typeof renderedJSX > "u")
      return logger.warn("Cannot skip undefined element"), null;
    if (React.Children.count(renderedJSX) > 1)
      return logger.warn("Trying to skip an array of elements"), null;
    typeof renderedJSX.props.children > "u" ? (logger.warn("Not enough children to skip elements."), typeof renderedJSX.type == "function" && renderedJSX.type.name === "" && (renderedJSX = React.createElement(Type, { ...renderedJSX.props }))) : typeof renderedJSX.props.children == "function" ? renderedJSX = renderedJSX.props.children() : renderedJSX = renderedJSX.props.children;
  }
  let displayNameDefaults;
  typeof options?.displayName == "string" ? displayNameDefaults = { showFunctions: true, displayName: () => options.displayName } : displayNameDefaults = {
    // To get exotic component names resolving properly
    displayName: (el) => el.type.displayName ? el.type.displayName : getDocgenSection(el.type, "displayName") ? getDocgenSection(el.type, "displayName") : el.type.render?.displayName ? el.type.render.displayName : typeof el.type == "symbol" || el.type.$$typeof && typeof el.type.$$typeof == "symbol" ? getReactSymbolName(el.type) : el.type.name && el.type.name !== "_default" ? el.type.name : typeof el.type == "function" ? "No Display Name" : isForwardRef(el.type) ? el.type.render.name : isMemo(el.type) ? el.type.type.name : el.type
  };
  let opts = {
    ...displayNameDefaults,
    ...{
      filterProps: (value, key) => value !== void 0
    },
    ...options
  };
  return React.Children.map(code, (c2) => {
    let child = typeof c2 == "number" ? c2.toString() : c2, string = (typeof reactElementToJSXString == "function" ? reactElementToJSXString : (
      // @ts-expect-error (Converted from ts-ignore)
      reactElementToJSXString.default
    ))(simplifyNodeForStringify(child), opts);
    if (string.indexOf("&quot;") > -1) {
      let matches5 = string.match(/\S+=\\"([^"]*)\\"/g);
      matches5 && matches5.forEach((match) => {
        string = string.replace(match, match.replace(/&quot;/g, "'"));
      });
    }
    return string;
  }).join(`
`).replace(/function\s+noRefCheck\(\)\s*\{\}/g, "() => {}");
}, defaultOpts = {
  skip: 0,
  showFunctions: false,
  enableBeautify: true,
  showDefaultProps: false
}, skipJsxRender = (context) => {
  let sourceParams = context?.parameters.docs?.source, isArgsStory = context?.parameters.__isArgsStory;
  return sourceParams?.type === SourceType.DYNAMIC ? false : !isArgsStory || sourceParams?.code || sourceParams?.type === SourceType.CODE;
}, isMdx = (node) => node.type?.displayName === "MDXCreateElement" && !!node.props?.mdxType, mdxToJsx = (node) => {
  if (!isMdx(node))
    return node;
  let { mdxType, originalType, children, ...rest } = node.props, jsxChildren = [];
  return children && (jsxChildren = (Array.isArray(children) ? children : [children]).map(mdxToJsx)), reactExports.createElement(originalType, rest, ...jsxChildren);
}, jsxDecorator = (storyFn, context) => {
  let jsx = useRef(void 0), story = storyFn(), skip = skipJsxRender(context), options = {
    ...defaultOpts,
    ...context?.parameters.jsx || {}
  }, storyJsx = context.originalStoryFn(context.args, context);
  return useEffect(() => {
    if (skip)
      return;
    let sourceJsx = mdxToJsx(storyJsx), rendered = renderJsx$1(sourceJsx, options);
    rendered && jsx.current !== rendered && (emitTransformCode(rendered, context), jsx.current = rendered);
  }), story;
};
var applyDecorators2 = (storyFn, decorators22) => {
  let jsxIndex = decorators22.findIndex((d) => d.originalFn === jsxDecorator), reorderedDecorators = jsxIndex === -1 ? decorators22 : [...decorators22.splice(jsxIndex, 1), ...decorators22];
  return applyDecorators(storyFn, reorderedDecorators);
};
var decorators$1 = "FEATURES" in globalThis && globalThis?.FEATURES?.experimentalCodeExamples ? [] : [jsxDecorator], parameters$1 = {
  docs: {
    story: { inline: true }
  }
};
const entry_preview_docs_19910 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyDecorators: applyDecorators2,
  decorators: decorators$1,
  parameters: parameters$1
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$2 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$2(target, name, { get: all[name], enumerable: true });
};
var PARAM_KEY = "links";
const { SELECT_STORY, STORY_CHANGED } = __STORYBOOK_MODULE_CORE_EVENTS__;
const { global: global$1 } = __STORYBOOK_MODULE_GLOBAL__;
const { addons, makeDecorator } = __STORYBOOK_MODULE_PREVIEW_API__;
var { document: document$1, HTMLElement: HTMLElement$1 } = global$1;
var navigate = (params) => addons.getChannel().emit(SELECT_STORY, params), linksListener = (e2) => {
  let { target } = e2;
  if (!(target instanceof HTMLElement$1))
    return;
  let element = target, { sbKind: kind, sbStory: story } = element.dataset;
  (kind || story) && (e2.preventDefault(), navigate({ kind, story }));
}, hasListener = false, on = () => {
  hasListener || (hasListener = true, document$1.addEventListener("click", linksListener));
}, off = () => {
  hasListener && (hasListener = false, document$1.removeEventListener("click", linksListener));
}, withLinks = makeDecorator({
  name: "withLinks",
  parameterName: PARAM_KEY,
  wrapper: (getStory, context) => (on(), addons.getChannel().once(STORY_CHANGED, off), getStory(context))
});
var preview_exports$1 = {};
__export$1(preview_exports$1, {
  decorators: () => decorators
});
var decorators = [withLinks];
const preview_19623 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decorators
}, Symbol.toStringTag, { value: "Module" }));
var __create = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require < "u" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp$1.call(to, key) && key !== except && __defProp$1(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp$1(target, "default", { value: mod, enumerable: true }),
  mod
));
var preview_exports = {};
__export(preview_exports, {
  parameters: () => parameters
});
var excludeTags = Object.entries(globalThis.TAGS_OPTIONS ?? {}).reduce(
  (acc, entry) => {
    let [tag, option] = entry;
    return option.excludeFromDocsStories && (acc[tag] = true), acc;
  },
  {}
), parameters = {
  docs: {
    renderer: async () => {
      let { DocsRenderer } = await __vitePreload(async () => {
        const { DocsRenderer: DocsRenderer2 } = await import("./DocsRenderer-GHJI37HO-BKB2fj9D.js");
        return { DocsRenderer: DocsRenderer2 };
      }, true ? __vite__mapDeps([133,2,132,8,3,4]) : void 0, import.meta.url);
      return new DocsRenderer();
    },
    stories: {
      filter: (story) => (story.tags || []).filter((tag) => excludeTags[tag]).length === 0 && !story.parameters.docs?.disable
    }
  }
};
const preview_19787 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parameters
}, Symbol.toStringTag, { value: "Module" }));
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type5, config4, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config4.key && (key = "" + config4.key);
    if ("key" in config4) {
      maybeKey = {};
      for (var propName in config4)
        "key" !== propName && (maybeKey[propName] = config4[propName]);
    } else maybeKey = config4;
    config4 = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type5,
      key,
      ref: void 0 !== config4 ? config4 : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
const getDemoIModel = (name) => {
  if (name === "blank") {
    return "blank";
  }
  const model = remoteIModels.find((model2) => model2.name === name);
  return model;
};
const DemoIModelContext = React.createContext(
  void 0
);
const withDemoIModel = (Story, context) => {
  const demoIModel = getDemoIModel(context.globals.iModel);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DemoIModelContext.Provider, { value: demoIModel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Story, {}) });
};
function useDemoIModel() {
  return React.useContext(DemoIModelContext);
}
const remoteIModels = [
  {
    name: "metrostation",
    label: "Metrostation",
    iTwinId: "402f1a92-c7b1-4012-b787-7fa45e2e7fe4",
    iModelId: "b55dec38-d9b7-4029-9b9c-6b899151328f"
  },
  {
    name: "coffsHarborDemo",
    label: "Coffs Harbor Road",
    iTwinId: "c5d4dd3a-597a-4c88-918c-f1aa3588312f",
    iModelId: "11977591-6a15-4f0e-aa10-1c6afb066bc7"
  },
  {
    name: "retailBuilding",
    label: "Retail Building",
    iTwinId: "998b4696-a672-4f85-bea1-8e35e0852452",
    iModelId: "97a67f36-8efa-499c-a6ed-a8e07f38a410"
  },
  {
    name: "bayTownProcessPlant",
    label: "Bay Town Process Plant",
    iTwinId: "b27dc251-0e53-4a36-9a38-182fc309be07",
    iModelId: "f30566da-8fdf-4cba-b09a-fd39f5397ae6"
  },
  {
    name: "house",
    label: "House",
    iTwinId: "6b9d3c0b-1217-4cf8-a1c0-afcade43e66a",
    iModelId: "6be3a56d-b93b-4a3c-a41e-06398083905d"
  },
  {
    name: "philadelphia",
    label: "Philadelphia",
    iTwinId: "402f1a92-c7b1-4012-b787-7fa45e2e7fe4",
    iModelId: "f815bddf-c448-47c6-84d1-94762d85b645"
  },
  {
    name: "stadium",
    label: "Stadium",
    iTwinId: "656dd74d-8798-4aa4-8d13-6e6458789639",
    iModelId: "881c9ca0-34ff-4875-ae63-2dd8ac015c27"
  },
  {
    name: "transformedStadium",
    label: "Transformed Stadium",
    iTwinId: "58262a3d-bbc8-45d0-adbc-13a4623c180f",
    iModelId: "67cf8408-8f3f-4a3a-bde1-a991a422e909"
  },
  {
    name: "extonCampus",
    label: "Exton Campus",
    iTwinId: "5b4ebd22-d94b-456b-8bd8-d59563de9acd",
    iModelId: "d992e912-7f6f-4bd6-9781-4ecf2891b17a"
  },
  {
    name: "villa",
    label: "Villa",
    iTwinId: "532629d2-d25e-4a00-9fb7-c401b6cacf84",
    iModelId: "62d521ca-0b45-4a65-9f48-9fc9b5e87100"
  }
];
const demoIModelGlobalType = {
  description: "Global iModel for components",
  defaultValue: void 0,
  toolbar: {
    title: "Demo iModel",
    icon: "doclist",
    items: [
      {
        title: "Reset",
        type: "reset"
      },
      {
        title: "Blank iModel",
        value: "blank"
      },
      ...remoteIModels.map((model) => ({
        title: model.label,
        value: model.name
      }))
    ],
    dynamicTitle: true
  }
};
withDemoIModel.__docgenInfo = { "description": "", "methods": [], "displayName": "withDemoIModel" };
const withResizer = (Story, context) => {
  const resizer = !!context.globals.resizer;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: resizer ? {
        resize: "both",
        overflow: "auto",
        padding: "10px",
        border: "2px solid black"
      } : void 0,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Story, {})
    }
  );
};
const resizerGlobalType = {
  description: "Story resizer",
  defaultValue: void 0,
  toolbar: {
    title: "Resizer",
    icon: "tablet",
    items: [
      { title: "Enable", value: "true" },
      { title: "Disable", type: "reset" }
    ]
  }
};
withResizer.__docgenInfo = { "description": "", "methods": [], "displayName": "withResizer" };
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames$1.exports;
  hasRequiredClassnames = 1;
  (function(module2) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes2 = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes2 = appendClass(classes2, parseValue(arg));
          }
        }
        return classes2;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes2 = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes2 = appendClass(classes2, key);
          }
        }
        return classes2;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module2.exports) {
        classNames.default = classNames;
        module2.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  })(classnames$1);
  return classnames$1.exports;
}
var classnamesExports = requireClassnames();
const classnames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const getWindow$2 = () => "undefined" == typeof window ? void 0 : window;
const mergeEventHandlers = (...callbacks) => (event) => {
  for (let cb of callbacks) {
    cb?.(event);
    if (event?.defaultPrevented) return;
  }
};
const getTranslateValuesFromElement = (element) => {
  if (!element) return [];
  let transformValue = getComputedStyle(element).getPropertyValue("transform");
  return getTranslateValues(transformValue);
};
const getTranslateValues = (transformValue) => {
  let matrix = new DOMMatrix(transformValue);
  return [matrix.m41, matrix.m42];
};
const getBoundedValue = (val, min2, max2) => Math.min(max2, Math.max(min2, val));
const getRandomValue = (length = 21) => {
  let alphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let id = "";
  for (let i2 = 0; i2 < length; i2++) id += alphabet[64 * Math.random() | 0];
  return id;
};
const mergeRefs = (...refs) => (instance) => {
  refs.forEach((ref) => {
    if ("function" == typeof ref) ref(instance);
    else if (ref) ref.current = instance;
  });
};
const useMergedRefs$1 = (...refs) => reactExports.useCallback(mergeRefs(...refs), [...refs]);
const useResizeObserver = (onResize) => {
  let resizeObserver = reactExports.useRef(void 0);
  let elementRef = reactExports.useCallback(
    (element) => {
      if (!getWindow$2()?.ResizeObserver) return;
      resizeObserver.current?.disconnect?.();
      if (element) {
        resizeObserver.current = new ResizeObserver((entries) => {
          window.requestAnimationFrame(() => {
            if (!Array.isArray(entries) || !entries.length) return;
            let [{ contentRect }] = entries;
            return onResize(contentRect);
          });
        });
        resizeObserver.current?.observe?.(element);
      }
    },
    [onResize]
  );
  return [elementRef, resizeObserver.current];
};
const ThemeContext = reactExports.createContext(void 0);
let isJest = "undefined" != typeof jest;
let isCypress = void 0 !== globalThis.Cypress;
let isMocha = void 0 !== globalThis.beforeEach && "function(name,fn){suites[0].beforeEach(name,fn);}" === `${globalThis.beforeEach}`.replace(/\s/g, "") && !isCypress;
let isVitest = void 0 !== globalThis.__vitest_index__;
let isUnitTest = isJest || isVitest || isMocha;
const useGlobals = () => {
  let themeContext = reactExports.useContext(ThemeContext);
  useThemeProviderWarning(themeContext);
  useRootFontSizeWarning();
  return themeContext;
};
const useThemeProviderWarning = (themeContext) => {
  reactExports.useEffect(() => {
  }, [themeContext]);
};
let useRootFontSizeWarning = () => {
  reactExports.useEffect(() => {
  }, []);
};
let _React$3 = React8;
const useSyncExternalStore = _React$3.useSyncExternalStore || useSyncExternalStoreShim;
function useSyncExternalStoreShim(subscribe, getSnapshot) {
  let value = getSnapshot();
  let [{ instance }, forceUpdate] = reactExports.useState({
    instance: {
      value,
      getSnapshot
    }
  });
  reactExports.useLayoutEffect(() => {
    instance.value = value;
    instance.getSnapshot = getSnapshot;
    if (!Object.is(value, getSnapshot()))
      forceUpdate({
        instance
      });
  }, [subscribe, value, getSnapshot]);
  reactExports.useEffect(() => {
    let synchronize = () => {
      if (!Object.is(instance.value, instance.getSnapshot()))
        forceUpdate({
          instance
        });
    };
    synchronize();
    return subscribe(synchronize);
  }, [subscribe]);
  return value;
}
const useMediaQuery$1 = (queryString) => {
  let getSnapshot = reactExports.useCallback(
    () => "undefined" != typeof window ? window.matchMedia?.(queryString).matches : void 0,
    [queryString]
  );
  let subscribe = reactExports.useCallback(
    (onChange) => {
      let mediaQueryList = window.matchMedia?.(queryString);
      mediaQueryList?.addEventListener?.("change", onChange);
      return () => mediaQueryList?.removeEventListener?.("change", onChange);
    },
    [queryString]
  );
  return useSyncExternalStore(subscribe, getSnapshot, () => void 0);
};
const useSafeContext$1 = (context) => {
  let value = reactExports.useContext(context);
  if (!value)
    throw new Error(`${context.displayName || "Context"} is undefined`);
  return value;
};
const useLatestRef$3 = (value) => {
  let valueRef = reactExports.useRef(value);
  reactExports.useEffect(() => {
    valueRef.current = value;
  }, [value]);
  return valueRef;
};
let useIsomorphicLayoutEffect = "undefined" != typeof window ? reactExports.useLayoutEffect : reactExports.useEffect;
const useIsClient$1 = () => {
  let [isClient2, setIsClient] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setIsClient(true);
  }, []);
  return isClient2;
};
const useId$1 = () => {
  let uniqueValue = useUniqueValue();
  return reactExports.useMemo(() => `iui-${uniqueValue}`, [uniqueValue]);
};
let _React$2 = React8;
let useUniqueValue = _React$2.useId ?? (() => reactExports.useMemo(() => getRandomValue(10), []));
const useControlledState = (initialValue2, controlledState, setControlledState) => {
  let [uncontrolledState, setUncontrolledState] = reactExports.useState(initialValue2);
  let state3 = reactExports.useMemo(
    () => void 0 !== controlledState ? controlledState : uncontrolledState,
    [controlledState, uncontrolledState]
  );
  let oldState = useLatestRef$3(state3);
  let setState2 = reactExports.useCallback(
    (value) => {
      if (value === oldState.current) return;
      oldState.current = value;
      setUncontrolledState(value);
      setControlledState?.(value);
    },
    [oldState, setControlledState]
  );
  return [state3, setState2];
};
var reactDom = { exports: {} };
var reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React2 = requireReact();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop4() {
  }
  var Internals = {
    d: {
      f: noop4,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop4,
      C: noop4,
      L: noop4,
      m: noop4,
      X: noop4,
      S: noop4,
      M: noop4
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input2) {
    if ("font" === as) return "";
    if ("string" === typeof input2)
      return "use-credentials" === input2 ? input2 : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn3) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn3) return fn3();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn3, a2) {
    return fn3(a2);
  };
  reactDom_production.useFormState = function(action2, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action2, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.2.1";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
var reactDomExports = requireReactDom();
const ReactDOM2 = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const t2 = "3.20.1";
const u = new Proxy(
  {},
  {
    get(e2, i2) {
      if (typeof i2 == "string" && i2.startsWith("iui-"))
        return i2.replace("iui-", `_iui${t2.replace(/\./g, "")}-`);
    },
    has(e2, i2) {
      return typeof i2 == "string" && i2.startsWith("iui-");
    }
  }
);
let _base = (defaultElement) => (className, attrs) => {
  let Comp = reactExports.forwardRef(({ as = defaultElement, ...props }, ref) => {
    props = {
      ...attrs,
      ...props,
      className: getScopedClassName(
        classnames(className, attrs?.className, props.className)
      )
    };
    let Element2 = as || "div";
    if ("button" === Element2 || "a" === Element2 || "input" === Element2 && "checkbox" === props.type) {
      var _props;
      (_props = props).tabIndex ?? (_props.tabIndex = 0);
    }
    useGlobals();
    return reactExports.createElement(Element2, {
      ref,
      ...props
    });
  });
  return Comp;
};
const polymorphic = new Proxy(
  {},
  {
    get: (target, prop) => {
      if ("string" == typeof prop) return _base(prop);
      return Reflect.get(target, prop);
    }
  }
);
let getScopedClassName = (className = "") => className.split(" ").map((c2) => c2 in u ? u[c2] : c2).join(" ") || null;
const importCss = async (url) => {
  try {
    return await new Function(
      `return import("${url}", { with: { type: "css" } })`
    )();
  } catch {
    try {
      return await new Function(
        `return import("${url}", { assert: { type: "css" } })`
      )();
    } catch {
      return await fetch(url).then((res) => res.text()).then((cssText) => {
        let stylesheet = new CSSStyleSheet();
        stylesheet.replaceSync(cssText);
        return {
          default: stylesheet
        };
      });
    }
  }
};
let _React$1 = React8;
const isReact17or18 = (() => {
  let version = _React$1.version?.split(".")?.[0];
  return ["17", "18"].includes(version);
})();
const cloneElementWithRef = (children, getProps) => {
  if (!children) return null;
  if (!reactExports.isValidElement(children)) return children;
  let childrenRef = isReact17or18 ? children?.ref : children.props?.ref;
  let props = getProps(children);
  let ref = mergeRefs(
    ...[childrenRef, "ref" in props ? props.ref : null].filter(Boolean)
  );
  return reactExports.cloneElement(children, {
    ...props,
    ref
  });
};
const Box = polymorphic.div("");
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display: display2
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display2);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements2, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements2);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements2.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden3(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements2 = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements2) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements2
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
const FOCUSABLE_ATTRIBUTE$1 = "data-floating-ui-focusable";
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
const ARROW_LEFT$1 = "ArrowLeft";
const ARROW_RIGHT$1 = "ArrowRight";
const ARROW_UP$1 = "ArrowUp";
const ARROW_DOWN$1 = "ArrowDown";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains$1(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget$1(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const e2 = event;
  return e2.target != null && node.contains(e2.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument$1(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function isTypeableCombobox(element) {
  if (!element) return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}
function matchesFocusVisible(element) {
  if (!element || isJSDOM()) return true;
  try {
    return element.matches(":focus-visible");
  } catch (_e) {
    return true;
  }
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE$1) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE$1 + "]") || floatingElement;
}
function getNodeChildren$1(nodes, id, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  const directChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));
  });
  return directChildren.flatMap((child) => [child, ...getNodeChildren$1(nodes, child.id, onlyOpenChildren)]);
}
function getDeepestNode(nodes, id) {
  let deepestNodeId;
  let maxDepth = -1;
  function findDeepest(nodeId, depth) {
    if (depth > maxDepth) {
      deepestNodeId = nodeId;
      maxDepth = depth;
    }
    const children = getNodeChildren$1(nodes, nodeId);
    children.forEach((child) => {
      findDeepest(child.id, depth + 1);
    });
  }
  findDeepest(id, 0);
  return nodes.find((node) => node.id === deepestNodeId);
}
function getNodeAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM()) return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
var isClient$1 = typeof document !== "undefined";
var noop$1 = function noop22() {
};
var index$1 = isClient$1 ? reactExports.useLayoutEffect : noop$1;
const SafeReact$1 = {
  ...React8
};
function useLatestRef$2(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
const useInsertionEffect = SafeReact$1.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn3) => fn3());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isDifferentGridRow(index2, cols, prevRow) {
  return Math.floor(index2 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index2) {
  return index2 < 0 || index2 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledListIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  let index2 = startingIndex;
  do {
    index2 += decrement ? -amount : amount;
  } while (index2 >= 0 && index2 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index2, disabledIndices));
  return index2;
}
function getGridNavigatedIndex(listRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP$1) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset2 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset2 : offset2 - cols;
        }
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN$1) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT$1 : ARROW_RIGHT$1)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT$1 : ARROW_LEFT$1)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT$1 : ARROW_LEFT$1) ? maxIndex : findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function createGridCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index2) => {
    let {
      width,
      height
    } = _ref2;
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i2 = 0; i2 < width; i2++) {
        for (let j2 = 0; j2 < height; j2++) {
          targetCells.push(startIndex + i2 + j2 * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index2;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getGridCellIndexOfCorner(index2, sizes, cellMap, cols, corner) {
  if (index2 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index2);
  const sizeItem = sizes[index2];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index2);
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index2, cellIndex) => indices.includes(index2) ? [cellIndex] : []);
}
function isListIndexDisabled(listRef, index2, disabledIndices) {
  if (typeof disabledIndices === "function") {
    return disabledIndices(index2);
  } else if (disabledIndices) {
    return disabledIndices.includes(index2);
  }
  const element = listRef.current[index2];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, dir) {
  const list = tabbable(container, getTabbableOptions());
  const len = list.length;
  if (len === 0) return;
  const active = activeElement(getDocument$1(container));
  const index2 = list.indexOf(active);
  const nextIndex = index2 === -1 ? dir === 1 ? 0 : len - 1 : index2 + dir;
  return list[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument$1(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument$1(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains$1(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements2 = container.querySelectorAll("[data-tabindex]");
  elements2.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config4) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config4;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn3
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn3({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state3, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements: elements2,
    strategy
  } = state3;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state3);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements2[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements2.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements2.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: elements2,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state3) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements: elements2
      } = state3;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state3);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state3, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v2) => v2 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state3) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements: elements2
      } = state3;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state3);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state3, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state3) {
      const {
        rects
      } = state3;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state3);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state3, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state3, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y);
  const groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state3) {
      const {
        placement,
        elements: elements2,
        rects,
        platform: platform2,
        strategy
      } = state3;
      const {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state3);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements2.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements2.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state3, options) {
  const {
    placement,
    platform: platform2,
    elements: elements2
  } = state3;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state3);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state3) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state3;
      const diffCoords = await convertValueToCoords(state3, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state3) {
      const {
        x: x2,
        y: y2,
        placement
      } = state3;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state3);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state3, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state3,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state3) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements: elements2
      } = state3;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state3);
      const overflow = await detectOverflow(state3, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state3.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state3.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state3.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state3,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements2.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements: elements2,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements2 ? isTopLayer(elements2.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor2) => ancestor2 !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow$1(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor2) => {
    ancestorScroll && ancestor2.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor2.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor2) => {
      ancestorScroll && ancestor2.removeEventListener("scroll", update);
      ancestorResize && ancestor2.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const autoPlacement$1 = autoPlacement$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const inline$1 = inline$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop3() {
};
var index = isClient ? reactExports.useLayoutEffect : noop;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys2;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const openRef = useLatestRef$1(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config4 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config4.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config4).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements2 = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements2.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements2.floating, data.x);
    const y2 = roundByDPR(elements2.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements2.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements2.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements: elements2,
    floatingStyles
  }), [data, update, refs, elements2, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const autoPlacement = (options, deps) => ({
  ...autoPlacement$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
});
function useMergeRefs$1(refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance) => {
    const cleanups2 = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups2.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function sortByDocumentPosition(a2, b2) {
  const position = a2.compareDocumentPosition(b2);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
const FloatingListContext = /* @__PURE__ */ reactExports.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [nodes, setNodes] = reactExports.useState(() => /* @__PURE__ */ new Set());
  const register = reactExports.useCallback((node) => {
    setNodes((prevSet) => new Set(prevSet).add(node));
  }, []);
  const unregister = reactExports.useCallback((node) => {
    setNodes((prevSet) => {
      const set = new Set(prevSet);
      set.delete(node);
      return set;
    });
  }, []);
  const map2 = reactExports.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);
    sortedNodes.forEach((node, index2) => {
      newMap.set(node, index2);
    });
    return newMap;
  }, [nodes]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingListContext.Provider, {
    value: reactExports.useMemo(() => ({
      register,
      unregister,
      map: map2,
      elementsRef,
      labelsRef
    }), [register, unregister, map2, elementsRef, labelsRef]),
    children
  });
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map: map2,
    elementsRef,
    labelsRef
  } = reactExports.useContext(FloatingListContext);
  const [index2, setIndex] = reactExports.useState(null);
  const componentRef = reactExports.useRef(null);
  const ref = reactExports.useCallback((node) => {
    componentRef.current = node;
    if (index2 !== null) {
      elementsRef.current[index2] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index2] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index2, elementsRef, labelsRef, label]);
  index$1(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index$1(() => {
    const index22 = componentRef.current ? map2.get(componentRef.current) : null;
    if (index22 != null) {
      setIndex(index22);
    }
  }, [map2]);
  return reactExports.useMemo(() => ({
    ref,
    index: index2 == null ? -1 : index2
  }), [index2, ref]);
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
const ARROW_LEFT = "ArrowLeft";
const ARROW_RIGHT = "ArrowRight";
const ARROW_UP = "ArrowUp";
const ARROW_DOWN = "ArrowDown";
function renderJsx(render2, computedProps) {
  if (typeof render2 === "function") {
    return render2(computedProps);
  }
  if (render2) {
    return /* @__PURE__ */ reactExports.cloneElement(render2, computedProps);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    ...computedProps
  });
}
const CompositeContext = /* @__PURE__ */ reactExports.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
const verticalKeys = [ARROW_UP, ARROW_DOWN];
const allKeys = [...horizontalKeys, ...verticalKeys];
const Composite = /* @__PURE__ */ reactExports.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render: render2,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = reactExports.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = reactExports.useRef([]);
  const renderElementProps = render2 && typeof render2 !== "function" ? render2.props : {};
  const contextValue = reactExports.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinListIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;
    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index2) => index2 != null && !isListIndexDisabled(elementsRef, index2, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index2, cellIndex) => index2 != null && !isListIndexDisabled(elementsRef, index2, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || elementsRef.current.map((_, index2) => isListIndexDisabled(elementsRef, index2, disabledIndices) ? index2 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN],
      both: [horizontalEndKey, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP],
      both: [horizontalStartKey, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e2) {
      domProps.onKeyDown == null || domProps.onKeyDown(e2);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e2);
      handleKeyDown(e2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CompositeContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingList, {
      elementsRef,
      children: renderJsx(render2, computedProps)
    })
  });
});
const CompositeItem = /* @__PURE__ */ reactExports.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render: render2,
    ...domProps
  } = props;
  const renderElementProps = render2 && typeof render2 !== "function" ? render2.props : {};
  const {
    activeIndex,
    onNavigate
  } = reactExports.useContext(CompositeContext);
  const {
    ref,
    index: index2
  } = useListItem();
  const mergedRef = useMergeRefs$1([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index2;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e2) {
      domProps.onFocus == null || domProps.onFocus(e2);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e2);
      onNavigate(index2);
    }
  };
  return renderJsx(render2, computedProps);
});
const SafeReact = {
  ...React8
};
let serverHandoffComplete = false;
let count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index$1(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
function createEventEmitter() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map2.has(event)) {
        map2.set(event, /* @__PURE__ */ new Set());
      }
      map2.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map2.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function useFloatingNodeId(customParentId) {
  const id = useId();
  const tree = useFloatingTree();
  const reactParentId = useFloatingParentNodeId();
  const parentId = reactParentId;
  index$1(() => {
    if (!id) return;
    const node = {
      id,
      parentId
    };
    tree == null || tree.addNode(node);
    return () => {
      tree == null || tree.removeNode(node);
    };
  }, [tree, id, parentId]);
  return id;
}
function FloatingNode(props) {
  const {
    children,
    id
  } = props;
  const parentId = useFloatingParentNodeId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingNodeContext.Provider, {
    value: reactExports.useMemo(() => ({
      id,
      parentId
    }), [id, parentId]),
    children
  });
}
function FloatingTree(props) {
  const {
    children
  } = props;
  const nodesRef = reactExports.useRef([]);
  const addNode = reactExports.useCallback((node) => {
    nodesRef.current = [...nodesRef.current, node];
  }, []);
  const removeNode = reactExports.useCallback((node) => {
    nodesRef.current = nodesRef.current.filter((n2) => n2 !== node);
  }, []);
  const [events2] = reactExports.useState(() => createEventEmitter());
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingTreeContext.Provider, {
    value: reactExports.useMemo(() => ({
      nodesRef,
      addNode,
      removeNode,
      events: events2
    }), [addNode, removeNode, events2]),
    children
  });
}
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  if (timeoutRef.current !== -1) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = -1;
  }
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "function") {
    const result = value();
    if (typeof result === "number") {
      return result;
    }
    return result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  if (typeof value === "function") {
    return value();
  }
  return value;
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events: events2,
    elements: elements2
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef$2(handleClose);
  const delayRef = useLatestRef$2(delay);
  const openRef = useLatestRef$2(open);
  const restMsRef = useLatestRef$2(restMs);
  const pointerTypeRef = reactExports.useRef();
  const timeoutRef = reactExports.useRef(-1);
  const handlerRef = reactExports.useRef();
  const restTimeoutRef = reactExports.useRef(-1);
  const blockMouseMoveRef = reactExports.useRef(true);
  const performedPointerEventsMutationRef = reactExports.useRef(false);
  const unbindMouseMoveRef = reactExports.useRef(() => {
  });
  const restTimeoutPendingRef = reactExports.useRef(false);
  const isHoverOpen = useEffectEvent(() => {
    var _dataRef$current$open;
    const type5 = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type5 == null ? void 0 : type5.includes("mouse")) && type5 !== "mousedown";
  });
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events2.on("openchange", onOpenChange2);
    return () => {
      events2.off("openchange", onOpenChange2);
    };
  }, [enabled, events2]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    if (!handleCloseRef.current) return;
    if (!open) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument$1(elements2.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements2.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = reactExports.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeoutIfSet(timeoutRef);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeoutIfSet(timeoutRef);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument$1(elements2.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      clearTimeoutIfSet(timeoutRef);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument$1(elements2.floating);
      clearTimeoutIfSet(restTimeoutRef);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeoutIfSet(timeoutRef);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains$1(elements2.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    if (isElement(elements2.domReference)) {
      const reference2 = elements2.domReference;
      const floating = elements2.floating;
      if (open) {
        reference2.addEventListener("mouseleave", onScrollMouseLeave);
      }
      if (move) {
        reference2.addEventListener("mousemove", onReferenceMouseEnter, {
          once: true
        });
      }
      reference2.addEventListener("mouseenter", onReferenceMouseEnter);
      reference2.addEventListener("mouseleave", onReferenceMouseLeave);
      if (floating) {
        floating.addEventListener("mouseleave", onScrollMouseLeave);
        floating.addEventListener("mouseenter", onFloatingMouseEnter);
        floating.addEventListener("mouseleave", onFloatingMouseLeave);
      }
      return () => {
        if (open) {
          reference2.removeEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.removeEventListener("mousemove", onReferenceMouseEnter);
        }
        reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
        reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.removeEventListener("mouseleave", onScrollMouseLeave);
          floating.removeEventListener("mouseenter", onFloatingMouseEnter);
          floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        }
      };
    }
  }, [elements2, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
  index$1(() => {
    var _handleCloseRef$curre;
    if (!enabled) return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements2.floating;
      if (isElement(elements2.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument$1(elements2.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements2.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements2, tree, handleCloseRef, isHoverOpen]);
  index$1(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  reactExports.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeoutIfSet(timeoutRef);
      clearTimeoutIfSet(restTimeoutRef);
      clearPointerEvents();
    };
  }, [enabled, elements2.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = reactExports.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeoutIfSet(restTimeoutRef);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return reactExports.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const NOOP = () => {
};
const FloatingDelayGroupContext = /* @__PURE__ */ reactExports.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
const useDelayGroupContext = () => reactExports.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props;
  const [state3, setState2] = reactExports.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: false
  });
  const initialCurrentIdRef = reactExports.useRef(null);
  const setCurrentId = reactExports.useCallback((currentId) => {
    setState2({
      currentId
    });
  }, []);
  index$1(() => {
    if (state3.currentId) {
      if (initialCurrentIdRef.current === null) {
        initialCurrentIdRef.current = state3.currentId;
      } else if (!state3.isInstantPhase) {
        setState2({
          isInstantPhase: true
        });
      }
    } else {
      if (state3.isInstantPhase) {
        setState2({
          isInstantPhase: false
        });
      }
      initialCurrentIdRef.current = null;
    }
  }, [state3.currentId, state3.isInstantPhase]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingDelayGroupContext.Provider, {
    value: reactExports.useMemo(() => ({
      ...state3,
      setState: setState2,
      setCurrentId
    }), [state3, setCurrentId]),
    children
  });
}
function useDelayGroup(context, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open,
    onOpenChange,
    floatingId
  } = context;
  const {
    id: optionId,
    enabled = true
  } = options;
  const id = optionId != null ? optionId : floatingId;
  const groupContext = useDelayGroupContext();
  const {
    currentId,
    setCurrentId,
    initialDelay,
    setState: setState2,
    timeoutMs
  } = groupContext;
  index$1(() => {
    if (!enabled) return;
    if (!currentId) return;
    setState2({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    });
    if (currentId !== id) {
      onOpenChange(false);
    }
  }, [enabled, id, onOpenChange, setState2, currentId, initialDelay]);
  index$1(() => {
    function unset() {
      onOpenChange(false);
      setState2({
        delay: initialDelay,
        currentId: null
      });
    }
    if (!enabled) return;
    if (!currentId) return;
    if (!open && currentId === id) {
      if (timeoutMs) {
        const timeout = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout);
        };
      }
      unset();
    }
  }, [enabled, open, setState2, currentId, id, onOpenChange, initialDelay, timeoutMs]);
  index$1(() => {
    if (!enabled) return;
    if (setCurrentId === NOOP || !open) return;
    setCurrentId(id);
  }, [enabled, open, setCurrentId, id]);
  return groupContext;
}
let rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
const counters = {
  inert: /* @__PURE__ */ new WeakMap(),
  "aria-hidden": /* @__PURE__ */ new WeakMap(),
  none: /* @__PURE__ */ new WeakMap()
};
function getCounterMap(control) {
  if (control === "inert") return counters.inert;
  if (control === "aria-hidden") return counters["aria-hidden"];
  return counters.none;
}
let uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
let markerMap = {};
let lockCount$1 = 0;
const supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
const unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
const correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x2) => x2 != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script") return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterMap = getCounterMap(controlAttribute);
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
        }
      }
    });
  }
  lockCount$1++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterMap = getCounterMap(controlAttribute);
      const currentCounterValue = counterMap.get(element) || 0;
      const counterValue = currentCounterValue - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counters.inert = /* @__PURE__ */ new WeakMap();
      counters["aria-hidden"] = /* @__PURE__ */ new WeakMap();
      counters.none = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live],[role="status"],output'))), body, ariaHidden, inert);
}
const HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
const FocusGuard = /* @__PURE__ */ reactExports.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = reactExports.useState();
  index$1(() => {
    if (isSafari()) {
      setRole("button");
    }
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    ...props,
    ...restProps
  });
});
const PortalContext$1 = /* @__PURE__ */ reactExports.createContext(null);
const attr = /* @__PURE__ */ createAttribute("portal");
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id,
    root: root2
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = reactExports.useState(null);
  const portalNodeRef = reactExports.useRef(null);
  index$1(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index$1(() => {
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    const existingIdRoot = id ? document.getElementById(id) : null;
    if (!existingIdRoot) return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, uniqueId]);
  index$1(() => {
    if (root2 === null) return;
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    let container = root2 || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container && !isNode(container)) container = container.current;
    container = container || document.body;
    let idWrapper = null;
    if (id) {
      idWrapper = document.createElement("div");
      idWrapper.id = id;
      container.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container = idWrapper || container;
    container.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id, root2, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id,
    root: root2,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id,
    root: root2
  });
  const [focusManagerState, setFocusManagerState] = reactExports.useState(null);
  const beforeOutsideRef = reactExports.useRef(null);
  const afterOutsideRef = reactExports.useRef(null);
  const beforeInsideRef = reactExports.useRef(null);
  const afterInsideRef = reactExports.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root2 || portalNode)
  );
  reactExports.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  reactExports.useEffect(() => {
    if (!portalNode) return;
    if (open) return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PortalContext$1.Provider, {
    value: reactExports.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode]),
    children: [shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "outside",
      ref: beforeOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _beforeInsideRef$curr;
          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const prevTabbable = getPreviousTabbable(domReference);
          prevTabbable == null || prevTabbable.focus();
        }
      }
    }), shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      "aria-owns": portalNode.id,
      style: HIDDEN_STYLES
    }), portalNode && /* @__PURE__ */ reactDomExports.createPortal(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "outside",
      ref: afterOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _afterInsideRef$curre;
          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const nextTabbable = getNextTabbable(domReference);
          nextTabbable == null || nextTabbable.focus();
          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
const usePortalContext = () => reactExports.useContext(PortalContext$1);
function useLiteMergeRefs(refs) {
  return reactExports.useMemo(() => {
    return (value) => {
      refs.forEach((ref) => {
        if (ref) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
const LIST_LIMIT = 20;
let previouslyFocusedElements = [];
function clearDisconnectedPreviouslyFocusedElements() {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
}
function addPreviouslyFocusedElement(element) {
  clearDisconnectedPreviouslyFocusedElements();
  if (element && getNodeName(element) !== "body") {
    previouslyFocusedElements.push(element);
    if (previouslyFocusedElements.length > LIST_LIMIT) {
      previouslyFocusedElements = previouslyFocusedElements.slice(-20);
    }
  }
}
function getPreviouslyFocusedElement() {
  clearDisconnectedPreviouslyFocusedElements();
  return previouslyFocusedElements[previouslyFocusedElements.length - 1];
}
function getFirstTabbableElement(container) {
  const tabbableOptions = getTabbableOptions();
  if (isTabbable(container, tabbableOptions)) {
    return container;
  }
  return tabbable(container, tabbableOptions)[0] || container;
}
function handleTabIndex(floatingFocusElement, orderRef) {
  var _floatingFocusElement;
  if (!orderRef.current.includes("floating") && !((_floatingFocusElement = floatingFocusElement.getAttribute("role")) != null && _floatingFocusElement.includes("dialog"))) {
    return;
  }
  const options = getTabbableOptions();
  const focusableElements = focusable(floatingFocusElement, options);
  const tabbableContent = focusableElements.filter((element) => {
    const dataTabIndex = element.getAttribute("data-tabindex") || "";
    return isTabbable(element, options) || element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-");
  });
  const tabIndex = floatingFocusElement.getAttribute("tabindex");
  if (orderRef.current.includes("floating") || tabbableContent.length === 0) {
    if (tabIndex !== "0") {
      floatingFocusElement.setAttribute("tabindex", "0");
    }
  } else if (tabIndex !== "-1" || floatingFocusElement.hasAttribute("data-tabindex") && floatingFocusElement.getAttribute("data-tabindex") !== "-1") {
    floatingFocusElement.setAttribute("tabindex", "-1");
    floatingFocusElement.setAttribute("data-tabindex", "-1");
  }
}
const VisuallyHiddenDismiss = /* @__PURE__ */ reactExports.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
    ...props,
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  });
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true,
    outsideElementsInert = false,
    getInsideElements: _getInsideElements = () => []
  } = props;
  const {
    open,
    onOpenChange,
    events: events2,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const getNodeId = useEffectEvent(() => {
    var _dataRef$current$floa;
    return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
  });
  const getInsideElements = useEffectEvent(_getInsideElements);
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const inertSupported = supportsInert();
  const guards = inertSupported ? _guards : true;
  const useInert = !guards || inertSupported && outsideElementsInert;
  const orderRef = useLatestRef$2(order);
  const initialFocusRef = useLatestRef$2(initialFocus);
  const returnFocusRef = useLatestRef$2(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = reactExports.useRef(null);
  const endDismissButtonRef = reactExports.useRef(null);
  const preventReturnFocusRef = reactExports.useRef(false);
  const isPointerDownRef = reactExports.useRef(false);
  const tabbableIndexRef = reactExports.useRef(-1);
  const blurTimeoutRef = reactExports.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type5) => {
      if (domReference && type5 === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type5 === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  reactExports.useEffect(() => {
    if (disabled) return;
    if (!modal) return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains$1(floatingFocusElement, activeElement(getDocument$1(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget$1(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument$1(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  reactExports.useEffect(() => {
    if (disabled) return;
    if (!floating) return;
    function handleFocusIn(event) {
      const target = getTarget$1(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  reactExports.useEffect(() => {
    if (disabled) return;
    if (!closeOnFocusOut) return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      const currentTarget = event.currentTarget;
      const target = getTarget$1(event);
      queueMicrotask(() => {
        const nodeId = getNodeId();
        const movedToUnrelatedNode = !(contains$1(domReference, relatedTarget) || contains$1(floating, relatedTarget) || contains$1(relatedTarget, floating) || contains$1(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getNodeChildren$1(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains$1((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains$1((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getNodeAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4, _node$context5;
          return [(_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating, getFloatingFocusElement((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.floating)].includes(relatedTarget) || ((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;
        })));
        if (currentTarget === domReference && floatingFocusElement) {
          handleTabIndex(floatingFocusElement, orderRef);
        }
        if (restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && activeElement(getDocument$1(floatingFocusElement)) === getDocument$1(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if (dataRef.current.insideReactTree) {
          dataRef.current.insideReactTree = false;
          return;
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    const shouldHandleBlurCapture = Boolean(!tree && portalContext);
    function markInsideReactTree() {
      clearTimeoutIfSet(blurTimeoutRef);
      dataRef.current.insideReactTree = true;
      blurTimeoutRef.current = window.setTimeout(() => {
        dataRef.current.insideReactTree = false;
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      if (shouldHandleBlurCapture) {
        floating.addEventListener("focusout", markInsideReactTree, true);
      }
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
        if (shouldHandleBlurCapture) {
          floating.removeEventListener("focusout", markInsideReactTree, true);
        }
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef]);
  const beforeGuardRef = reactExports.useRef(null);
  const afterGuardRef = reactExports.useRef(null);
  const mergedBeforeGuardRef = useLiteMergeRefs([beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef]);
  const mergedAfterGuardRef = useLiteMergeRefs([afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef]);
  reactExports.useEffect(() => {
    var _portalContext$portal, _ancestors$find;
    if (disabled) return;
    if (!floating) return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];
    const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find((node) => {
      var _node$context6;
      return isTypeableCombobox(((_node$context6 = node.context) == null ? void 0 : _node$context6.elements.domReference) || null);
    })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;
    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x2) => x2 != null);
    const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);
    return () => {
      cleanup2();
    };
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards, useInert, tree, getNodeId, getInsideElements]);
  index$1(() => {
    if (disabled || !isHTMLElement(floatingFocusElement)) return;
    const doc = getDocument$1(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains$1(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index$1(() => {
    if (disabled || !floatingFocusElement) return;
    const doc = getDocument$1(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        reason,
        event,
        nested
      } = _ref;
      if (["hover", "safe-polygon"].includes(reason) && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press") return;
      if (nested) {
        preventReturnFocusRef.current = false;
      } else if (isVirtualClick(event) || isVirtualPointerEvent(event)) {
        preventReturnFocusRef.current = false;
      } else {
        let isPreventScrollSupported = false;
        document.createElement("div").focus({
          get preventScroll() {
            isPreventScrollSupported = true;
            return false;
          }
        });
        if (isPreventScrollSupported) {
          preventReturnFocusRef.current = false;
        } else {
          preventReturnFocusRef.current = true;
        }
      }
    }
    events2.on("openchange", onOpenChange2);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, HIDDEN_STYLES);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    function getReturnElement() {
      if (typeof returnFocusRef.current === "boolean") {
        const el = domReference || getPreviouslyFocusedElement();
        return el && el.isConnected ? el : fallbackEl;
      }
      return returnFocusRef.current.current || fallbackEl;
    }
    return () => {
      events2.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains$1(floating, activeEl) || tree && getNodeChildren$1(tree.nodesRef.current, getNodeId(), false).some((node) => {
        var _node$context7;
        return contains$1((_node$context7 = node.context) == null ? void 0 : _node$context7.elements.floating, activeEl);
      });
      const returnElement = getReturnElement();
      queueMicrotask(() => {
        const tabbableReturnElement = getFirstTabbableElement(returnElement);
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          tabbableReturnElement.focus({
            preventScroll: true
          });
        }
        fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events2, tree, isInsidePortal, domReference, getNodeId]);
  reactExports.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = false;
    });
    return () => {
      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);
    };
  }, [disabled]);
  index$1(() => {
    if (disabled) return;
    if (!portalContext) return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      domReference
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]);
  index$1(() => {
    if (disabled) return;
    if (!floatingFocusElement) return;
    handleTabIndex(floatingFocusElement, orderRef);
  }, [disabled, floatingFocusElement, orderRef]);
  function renderDismissButton(location2) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenDismiss, {
      ref: location2 === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent),
      children: typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss"
    });
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [shouldRenderGuards && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "inside",
      ref: mergedBeforeGuardRef,
      onFocus: (event) => {
        if (modal) {
          const els = getTabbableElements();
          enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          preventReturnFocusRef.current = false;
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const nextTabbable = getNextTabbable(domReference);
            nextTabbable == null || nextTabbable.focus();
          } else {
            var _portalContext$before;
            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
          }
        }
      }
    }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusGuard, {
      "data-type": "inside",
      ref: mergedAfterGuardRef,
      onFocus: (event) => {
        if (modal) {
          enqueueFocus(getTabbableElements()[0]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          if (closeOnFocusOut) {
            preventReturnFocusRef.current = true;
          }
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const prevTabbable = getPreviousTabbable(domReference);
            prevTabbable == null || prevTabbable.focus();
          } else {
            var _portalContext$afterO;
            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
          }
        }
      }
    })]
  });
}
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
function isAnchorTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "A";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true,
    stickIfOpen = true
  } = props;
  const pointerTypeRef = reactExports.useRef();
  const didKeyDownRef = reactExports.useRef(false);
  const reference = reactExports.useMemo(() => ({
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onMouseDown(event) {
      const pointerType = pointerTypeRef.current;
      if (event.button !== 0) return;
      if (eventOption === "click") return;
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "mousedown" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        event.preventDefault();
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onClick(event) {
      const pointerType = pointerTypeRef.current;
      if (eventOption === "mousedown" && pointerTypeRef.current) {
        pointerTypeRef.current = void 0;
        return;
      }
      if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "click" : true)) {
        onOpenChange(false, event.nativeEvent, "click");
      } else {
        onOpenChange(true, event.nativeEvent, "click");
      }
    },
    onKeyDown(event) {
      pointerTypeRef.current = void 0;
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
        return;
      }
      if (event.key === " " && !isSpaceIgnored(domReference)) {
        event.preventDefault();
        didKeyDownRef.current = true;
      }
      if (isAnchorTarget(event)) {
        return;
      }
      if (event.key === "Enter") {
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    },
    onKeyUp(event) {
      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
        return;
      }
      if (event.key === " " && didKeyDownRef.current) {
        didKeyDownRef.current = false;
        if (open && toggle) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      }
    }
  }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, stickIfOpen, toggle]);
  return reactExports.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
const captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
const normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements: elements2,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const endedOrStartedInsideRef = reactExports.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const isComposingRef = reactExports.useRef(false);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getNodeChildren$1(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget$1(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget$1(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget$1(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument$1(elements2.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains$1(target, elements2.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains$1(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const lastTraversableNode = isLastTraversableNode(target);
      const style = getComputedStyle$1(target);
      const scrollRe = /auto|scroll/;
      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);
      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);
      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      const isRTL2 = style.direction === "rtl";
      const pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);
      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getNodeChildren$1(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements2.floating) || isEventTargetWithin(event, elements2.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getNodeChildren$1(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget$1(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget$1(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  reactExports.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout);
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = false;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument$1(elements2.floating);
    if (escapeKey) {
      doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      doc.addEventListener("compositionstart", handleCompositionStart);
      doc.addEventListener("compositionend", handleCompositionEnd);
    }
    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements2.domReference)) {
        ancestors = getOverflowAncestors(elements2.domReference);
      }
      if (isElement(elements2.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements2.floating));
      }
      if (!isElement(elements2.reference) && elements2.reference && elements2.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements2.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor2) => {
      var _doc$defaultView;
      return ancestor2 !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor2) => {
      ancestor2.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      if (escapeKey) {
        doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc.removeEventListener("compositionstart", handleCompositionStart);
        doc.removeEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor2) => {
        ancestor2.removeEventListener("scroll", onScroll);
      });
      window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements2, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  reactExports.useEffect(() => {
    dataRef.current.insideReactTree = false;
  }, [dataRef, outsidePress, outsidePressEvent]);
  const reference = reactExports.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(false, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "click" && {
        onClick(event) {
          onOpenChange(false, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = reactExports.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      dataRef.current.insideReactTree = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);
  return reactExports.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = reactExports.useRef({});
  const [events2] = reactExports.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = reactExports.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events2.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = reactExports.useMemo(() => ({
    setPositionReference
  }), []);
  const elements2 = reactExports.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return reactExports.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements: elements2,
    events: events2,
    floatingId,
    refs
  }), [open, onOpenChange, elements2, events2, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const [positionReference, _setPositionReference] = reactExports.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree();
  index$1(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = reactExports.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements2 = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = reactExports.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements: elements2,
    nodeId
  }), [position, refs, elements2, nodeId, rootContext]);
  index$1(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context,
    refs,
    elements: elements2
  }), [position, refs, elements2, context]);
}
function isMacSafari() {
  return isMac() && isSafari();
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events: events2,
    dataRef,
    elements: elements2
  } = context;
  const {
    enabled = true,
    visibleOnly = true
  } = props;
  const blockFocusRef = reactExports.useRef(false);
  const timeoutRef = reactExports.useRef(-1);
  const keyboardModalityRef = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (!enabled) return;
    const win = getWindow$1(elements2.domReference);
    function onBlur() {
      if (!open && isHTMLElement(elements2.domReference) && elements2.domReference === activeElement(getDocument$1(elements2.domReference))) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    function onPointerDown() {
      keyboardModalityRef.current = false;
    }
    win.addEventListener("blur", onBlur);
    if (isMacSafari()) {
      win.addEventListener("keydown", onKeyDown, true);
      win.addEventListener("pointerdown", onPointerDown, true);
    }
    return () => {
      win.removeEventListener("blur", onBlur);
      if (isMacSafari()) {
        win.removeEventListener("keydown", onKeyDown, true);
        win.removeEventListener("pointerdown", onPointerDown, true);
      }
    };
  }, [elements2.domReference, open, enabled]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      if (reason === "reference-press" || reason === "escape-key") {
        blockFocusRef.current = true;
      }
    }
    events2.on("openchange", onOpenChange2);
    return () => {
      events2.off("openchange", onOpenChange2);
    };
  }, [events2, enabled]);
  reactExports.useEffect(() => {
    return () => {
      clearTimeoutIfSet(timeoutRef);
    };
  }, []);
  const reference = reactExports.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = false;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget$1(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari() && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target)) {
            return;
          }
        } else if (!matchesFocusVisible(target)) {
          return;
        }
      }
      onOpenChange(true, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = false;
      const relatedTarget = event.relatedTarget;
      const nativeEvent = event.nativeEvent;
      const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements2.domReference ? elements2.domReference.ownerDocument : document);
        if (!relatedTarget && activeEl === elements2.domReference) return;
        if (contains$1((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains$1(elements2.domReference, activeEl) || movedToFocusGuard) {
          return;
        }
        onOpenChange(false, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements2.domReference, onOpenChange, visibleOnly]);
  return reactExports.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function mergeProps$1(userProps, propsList, elementKey) {
  const map2 = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map2.has(key)) {
            map2.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map2.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.map((fn3) => fn3(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const ESCAPE = "Escape";
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl, cols) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  if (orientation === "both" || orientation === "horizontal" && cols && cols > 1) {
    return key === ESCAPE;
  }
  return doSwitch(orientation, vertical, horizontal);
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    elements: elements2,
    floatingId
  } = context;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    parentOrientation,
    cols = 1,
    scrollItemIntoView = true,
    virtualItemRef,
    itemSizes,
    dense = false
  } = props;
  const floatingFocusElement = getFloatingFocusElement(elements2.floating);
  const floatingFocusElementRef = useLatestRef$2(floatingFocusElement);
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  index$1(() => {
    context.dataRef.current.orientation = orientation;
  }, [context, orientation]);
  const onNavigate = useEffectEvent(() => {
    unstable_onNavigate(indexRef.current === -1 ? null : indexRef.current);
  });
  const typeableComboboxReference = isTypeableCombobox(elements2.domReference);
  const focusItemOnOpenRef = reactExports.useRef(focusItemOnOpen);
  const indexRef = reactExports.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = reactExports.useRef(null);
  const isPointerModalityRef = reactExports.useRef(true);
  const previousOnNavigateRef = reactExports.useRef(onNavigate);
  const previousMountedRef = reactExports.useRef(!!elements2.floating);
  const previousOpenRef = reactExports.useRef(open);
  const forceSyncFocusRef = reactExports.useRef(false);
  const forceScrollIntoViewRef = reactExports.useRef(false);
  const disabledIndicesRef = useLatestRef$2(disabledIndices);
  const latestOpenRef = useLatestRef$2(open);
  const scrollItemIntoViewRef = useLatestRef$2(scrollItemIntoView);
  const selectedIndexRef = useLatestRef$2(selectedIndex);
  const [activeId, setActiveId] = reactExports.useState();
  const [virtualId, setVirtualId] = reactExports.useState();
  const focusItem = useEffectEvent(() => {
    function runFocus(item2) {
      if (virtual) {
        var _item$id;
        if ((_item$id = item2.id) != null && _item$id.endsWith("-fui-option")) {
          item2.id = floatingId + "-" + Math.random().toString(16).slice(2, 10);
        }
        setActiveId(item2.id);
        tree == null || tree.events.emit("virtualfocus", item2);
        if (virtualItemRef) {
          virtualItemRef.current = item2;
        }
      } else {
        enqueueFocus(item2, {
          sync: forceSyncFocusRef.current,
          preventScroll: true
        });
      }
    }
    const initialItem = listRef.current[indexRef.current];
    const forceScrollIntoView = forceScrollIntoViewRef.current;
    if (initialItem) {
      runFocus(initialItem);
    }
    const scheduler = forceSyncFocusRef.current ? (v2) => v2() : requestAnimationFrame;
    scheduler(() => {
      const waitedItem = listRef.current[indexRef.current] || initialItem;
      if (!waitedItem) return;
      if (!initialItem) {
        runFocus(waitedItem);
      }
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index$1(() => {
    if (!enabled) return;
    if (open && elements2.floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        indexRef.current = selectedIndex;
        onNavigate();
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current();
    }
  }, [enabled, open, elements2.floating, selectedIndex, onNavigate]);
  index$1(() => {
    if (!enabled) return;
    if (!open) return;
    if (!elements2.floating) return;
    if (activeIndex == null) {
      forceSyncFocusRef.current = false;
      if (selectedIndexRef.current != null) {
        return;
      }
      if (previousMountedRef.current) {
        indexRef.current = -1;
        focusItem();
      }
      if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
        let runs = 0;
        const waitForListPopulated = () => {
          if (listRef.current[0] == null) {
            if (runs < 2) {
              const scheduler = runs ? requestAnimationFrame : queueMicrotask;
              scheduler(waitForListPopulated);
            }
            runs++;
          } else {
            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current);
            keyRef.current = null;
            onNavigate();
          }
        };
        waitForListPopulated();
      }
    } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {
      indexRef.current = activeIndex;
      focusItem();
      forceScrollIntoViewRef.current = false;
    }
  }, [enabled, open, elements2.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index$1(() => {
    var _nodes$find;
    if (!enabled || elements2.floating || !tree || virtual || !previousMountedRef.current) {
      return;
    }
    const nodes = tree.nodesRef.current;
    const parent = (_nodes$find = nodes.find((node) => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
    const activeEl = activeElement(getDocument$1(elements2.floating));
    const treeContainsActiveEl = nodes.some((node) => node.context && contains$1(node.context.elements.floating, activeEl));
    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
      parent.focus({
        preventScroll: true
      });
    }
  }, [enabled, elements2.floating, tree, parentId, virtual]);
  index$1(() => {
    if (!enabled) return;
    if (!tree) return;
    if (!virtual) return;
    if (parentId) return;
    function handleVirtualFocus(item2) {
      setVirtualId(item2.id);
      if (virtualItemRef) {
        virtualItemRef.current = item2;
      }
    }
    tree.events.on("virtualfocus", handleVirtualFocus);
    return () => {
      tree.events.off("virtualfocus", handleVirtualFocus);
    };
  }, [enabled, tree, virtual, parentId, virtualItemRef]);
  index$1(() => {
    previousOnNavigateRef.current = onNavigate;
    previousOpenRef.current = open;
    previousMountedRef.current = !!elements2.floating;
  });
  index$1(() => {
    if (!open) {
      keyRef.current = null;
      focusItemOnOpenRef.current = focusItemOnOpen;
    }
  }, [open, focusItemOnOpen]);
  const hasActiveIndex = activeIndex != null;
  const item = reactExports.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!latestOpenRef.current) return;
      const index2 = listRef.current.indexOf(currentTarget);
      if (index2 !== -1 && indexRef.current !== index2) {
        indexRef.current = index2;
        onNavigate();
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        forceSyncFocusRef.current = true;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      onMouseMove(_ref3) {
        let {
          currentTarget
        } = _ref3;
        forceSyncFocusRef.current = true;
        forceScrollIntoViewRef.current = false;
        if (focusItemOnHover) {
          syncCurrentTarget(currentTarget);
        }
      },
      onPointerLeave(_ref4) {
        let {
          pointerType
        } = _ref4;
        if (!isPointerModalityRef.current || pointerType === "touch") {
          return;
        }
        forceSyncFocusRef.current = true;
        if (!focusItemOnHover) {
          return;
        }
        indexRef.current = -1;
        onNavigate();
        if (!virtual) {
          var _floatingFocusElement;
          (_floatingFocusElement = floatingFocusElementRef.current) == null || _floatingFocusElement.focus({
            preventScroll: true
          });
        }
      }
    };
    return props2;
  }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);
  const getParentOrientation = reactExports.useCallback(() => {
    var _tree$nodesRef$curren;
    return parentOrientation != null ? parentOrientation : tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.dataRef) == null ? void 0 : _tree$nodesRef$curren.current.orientation;
  }, [parentId, tree, parentOrientation]);
  const commonOnKeyDown = useEffectEvent((event) => {
    isPointerModalityRef.current = false;
    forceSyncFocusRef.current = true;
    if (event.which === 229) {
      return;
    }
    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
      return;
    }
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {
      if (!isMainOrientationKey(event.key, getParentOrientation())) {
        stopEvent(event);
      }
      onOpenChange(false, event.nativeEvent, "list-navigation");
      if (isHTMLElement(elements2.domReference)) {
        if (virtual) {
          tree == null || tree.events.emit("virtualfocus", elements2.domReference);
        } else {
          elements2.domReference.focus();
        }
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinListIndex(listRef, disabledIndices);
    const maxIndex = getMaxListIndex(listRef, disabledIndices);
    if (!typeableComboboxReference) {
      if (event.key === "Home") {
        stopEvent(event);
        indexRef.current = minIndex;
        onNavigate();
      }
      if (event.key === "End") {
        stopEvent(event);
        indexRef.current = maxIndex;
        onNavigate();
      }
    }
    if (cols > 1) {
      const sizes = itemSizes || Array.from({
        length: listRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index22) => index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index22, cellIndex) => index22 != null && !isListIndexDisabled(listRef, index22, disabledIndices) ? cellIndex : foundIndex, -1);
      const index2 = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || listRef.current.map((_, index22) => isListIndexDisabled(listRef, index22, disabledIndices) ? index22 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          indexRef.current > maxIndex ? minIndex : indexRef.current,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction
          // we're moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? "tr" : "tl"
        ),
        stopEvent: true
      })];
      if (index2 != null) {
        indexRef.current = index2;
        onNavigate();
      }
      if (orientation === "both") {
        return;
      }
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate();
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          }));
        }
      }
      if (isIndexOutOfListBounds(listRef, indexRef.current)) {
        indexRef.current = -1;
      }
      onNavigate();
    }
  });
  const ariaActiveDescendantProp = reactExports.useMemo(() => {
    return virtual && open && hasActiveIndex && {
      "aria-activedescendant": virtualId || activeId
    };
  }, [virtual, open, hasActiveIndex, virtualId, activeId]);
  const floating = reactExports.useMemo(() => {
    return {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...!typeableComboboxReference ? ariaActiveDescendantProp : {},
      onKeyDown: commonOnKeyDown,
      onPointerMove() {
        isPointerModalityRef.current = true;
      }
    };
  }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference]);
  const reference = reactExports.useMemo(() => {
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    return {
      ...ariaActiveDescendantProp,
      onKeyDown(event) {
        isPointerModalityRef.current = false;
        const isArrowKey = event.key.startsWith("Arrow");
        const isHomeOrEndKey = ["Home", "End"].includes(event.key);
        const isMoveKey = isArrowKey || isHomeOrEndKey;
        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl, cols);
        const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);
        const isMainKey = isMainOrientationKey(event.key, orientation);
        const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
        if (virtual && open) {
          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node) => node.parentId == null);
          const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
          if (isMoveKey && deepestNode && virtualItemRef) {
            const eventObject = new KeyboardEvent("keydown", {
              key: event.key,
              bubbles: true
            });
            if (isCrossOpenKey || isCrossCloseKey) {
              var _deepestNode$context, _deepestNode$context2;
              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId) : null;
              if (dispatchItem) {
                stopEvent(event);
                dispatchItem.dispatchEvent(eventObject);
                setVirtualId(void 0);
              }
            }
            if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {
              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                var _deepestNode$context$;
                stopEvent(event);
                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                return;
              }
            }
          }
          return commonOnKeyDown(event);
        }
        if (!open && !openOnArrowKeyDown && isArrowKey) {
          return;
        }
        if (isNavigationKey) {
          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());
          keyRef.current = nested && isParentMainKey ? null : event.key;
        }
        if (nested) {
          if (isParentCrossOpenKey) {
            stopEvent(event);
            if (open) {
              indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);
              onNavigate();
            } else {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            }
          }
          return;
        }
        if (isMainKey) {
          if (selectedIndex != null) {
            indexRef.current = selectedIndex;
          }
          stopEvent(event);
          if (!open && openOnArrowKeyDown) {
            onOpenChange(true, event.nativeEvent, "list-navigation");
          } else {
            commonOnKeyDown(event);
          }
          if (open) {
            onNavigate();
          }
        }
      },
      onFocus() {
        if (open && !virtual) {
          indexRef.current = -1;
          onNavigate();
        }
      },
      onPointerDown: checkVirtualPointer,
      onPointerEnter: checkVirtualPointer,
      onMouseDown: checkVirtualMouse,
      onClick: checkVirtualMouse
    };
  }, [activeId, ariaActiveDescendantProp, cols, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);
  return reactExports.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements: elements2,
    floatingId: defaultFloatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const defaultReferenceId = useId();
  const referenceId = ((_elements$domReferenc = elements2.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;
  const floatingId = reactExports.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements2.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements2.floating, defaultFloatingId]);
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = reactExports.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = reactExports.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = reactExports.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role) {
      case "select":
      case "combobox":
        return {
          ...commonProps,
          "aria-selected": selected
        };
    }
    return {};
  }, [floatingId, role]);
  return reactExports.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
function getNodeChildren(nodes, id, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  const directChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));
  });
  return directChildren.flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function isPointInPolygon(point, polygon) {
  const [x2, y2] = point;
  let isInside2 = false;
  const length = polygon.length;
  for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
    const [xi, yi] = polygon[i2] || [0, 0];
    const [xj, yj] = polygon[j2] || [0, 0];
    const intersect = yi >= y2 !== yj >= y2 && x2 <= (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  const timeoutRef = {
    current: -1
  };
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = typeof performance !== "undefined" ? performance.now() : 0;
  function getCursorSpeed(x2, y2) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x2;
      lastY = y2;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x2 - lastX;
    const deltaY = y2 - lastY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance / elapsedTime;
    lastX = x2;
    lastY = y2;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn3 = (_ref) => {
    let {
      x: x2,
      y: y2,
      placement,
      elements: elements2,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeoutIfSet(timeoutRef);
        onClose();
      }
      clearTimeoutIfSet(timeoutRef);
      if (!elements2.domReference || !elements2.floating || placement == null || x2 == null || y2 == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains(elements2.floating, target);
      const isOverReferenceEl = contains(elements2.domReference, target);
      const refRect = elements2.domReference.getBoundingClientRect();
      const rect = elements2.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x2 > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y2 > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement(event.relatedTarget) && contains(elements2.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getNodeChildren(tree.nodesRef.current, nodeId).length) {
        return;
      }
      if (side === "top" && y2 >= refRect.bottom - 1 || side === "bottom" && y2 <= refRect.top + 1 || side === "left" && x2 >= refRect.right - 1 || side === "right" && x2 <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
          break;
      }
      function getPolygon(_ref2) {
        let [x22, y22] = _ref2;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x22 + buffer / 2 : cursorLeaveFromRight ? x22 + buffer * 4 : x22 - buffer * 4, y22 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x22 - buffer / 2 : cursorLeaveFromRight ? x22 + buffer * 4 : x22 - buffer * 4, y22 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x22 + buffer / 2 : cursorLeaveFromRight ? x22 + buffer * 4 : x22 - buffer * 4, y22 - buffer];
            const cursorPointTwo = [isFloatingWider ? x22 - buffer / 2 : cursorLeaveFromRight ? x22 + buffer * 4 : x22 - buffer * 4, y22 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x22 + buffer + 1, isFloatingTaller ? y22 + buffer / 2 : cursorLeaveFromBottom ? y22 + buffer * 4 : y22 - buffer * 4];
            const cursorPointTwo = [x22 + buffer + 1, isFloatingTaller ? y22 - buffer / 2 : cursorLeaveFromBottom ? y22 + buffer * 4 : y22 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x22 - buffer, isFloatingTaller ? y22 + buffer / 2 : cursorLeaveFromBottom ? y22 + buffer * 4 : y22 - buffer * 4];
            const cursorPointTwo = [x22 - buffer, isFloatingTaller ? y22 - buffer / 2 : cursorLeaveFromBottom ? y22 + buffer * 4 : y22 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x2, y2]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutRef.current = window.setTimeout(close, 40);
      }
    };
  };
  fn3.__options = {
    blockPointerEvents
  };
  return fn3;
}
const defaultTooltipDelay = {
  open: 200,
  close: 200
};
let useTooltip = (options = {}) => {
  let uniqueId = useId$1();
  let {
    placement = "top",
    visible,
    onVisibleChange,
    middleware = {
      flip: true,
      shift: true
    },
    autoUpdateOptions = {},
    reference,
    ariaStrategy = "description",
    id = uniqueId,
    ...props
  } = options;
  let [open, onOpenChange] = useControlledState(
    false,
    visible,
    onVisibleChange
  );
  let syncWithControlledState = reactExports.useCallback(
    (element) => {
      queueMicrotask(() => {
        try {
          element?.togglePopover?.(open);
        } catch {
        }
      });
    },
    [open]
  );
  let floating = useFloating({
    placement,
    open,
    onOpenChange,
    strategy: "fixed",
    whileElementsMounted: reactExports.useMemo(
      () => open ? (...args) => autoUpdate(...args, autoUpdateOptions) : void 0,
      [autoUpdateOptions, open]
    ),
    middleware: reactExports.useMemo(
      () => [
        void 0 !== middleware.offset ? offset(middleware.offset) : offset(4),
        middleware.flip && flip({
          padding: 4
        }),
        middleware.shift && shift({
          padding: 4
        }),
        middleware.size && size({
          padding: 4
        }),
        middleware.autoPlacement && autoPlacement({
          padding: 4
        }),
        middleware.inline && inline(),
        middleware.hide && hide({
          padding: 4
        })
      ].filter(Boolean),
      [middleware]
    ),
    ...reference && {
      elements: {
        reference
      }
    }
  });
  let ariaProps = reactExports.useMemo(
    () => "description" === ariaStrategy ? {
      "aria-describedby": id
    } : "label" === ariaStrategy ? {
      "aria-labelledby": id
    } : {},
    [ariaStrategy, id]
  );
  let { delay } = useDelayGroup(floating.context, {
    id: useId$1()
  });
  let interactions = useInteractions([
    useHover(floating.context, {
      delay: 0 !== delay ? delay : defaultTooltipDelay,
      handleClose: safePolygon({
        buffer: -1 / 0
      }),
      move: false
    }),
    useFocus(floating.context),
    useDismiss(floating.context, {
      referencePress: true,
      referencePressEvent: "click"
    })
  ]);
  reactExports.useEffect(() => {
    if (!reference) return;
    let domEventName = (e2) => e2.toLowerCase().substring(2);
    let cleanupValues = {};
    Object.entries({
      ...ariaProps,
      ...interactions.getReferenceProps()
    }).forEach(([key, value]) => {
      if ("function" == typeof value) {
        let patchedHandler = (event) => {
          value({
            ...event,
            nativeEvent: event
          });
        };
        reference.addEventListener(domEventName(key), patchedHandler);
        cleanupValues[key] = patchedHandler;
      } else if (value) {
        cleanupValues[key] = reference.getAttribute(key);
        reference.setAttribute(key, value);
      }
    });
    return () => {
      Object.entries(cleanupValues).forEach(([key, value]) => {
        if ("function" == typeof value)
          reference.removeEventListener(domEventName(key), value);
        else if (value) reference.setAttribute(key, value);
        else reference.removeAttribute(key);
      });
    };
  }, [ariaProps, reference, interactions]);
  let getReferenceProps = reactExports.useCallback(
    (userProps) => interactions.getReferenceProps({
      ...userProps,
      ...ariaProps
    }),
    [interactions, ariaProps]
  );
  let floatingProps = reactExports.useMemo(
    () => ({
      ...interactions.getFloatingProps({
        hidden: !open,
        "aria-hidden": "true",
        ...props,
        id
      }),
      popover: "manual"
    }),
    [interactions, props, id, open]
  );
  return reactExports.useMemo(
    () => ({
      getReferenceProps,
      floatingProps,
      ...floating,
      refs: {
        ...floating.refs,
        setFloating: (element) => {
          floating.refs.setFloating(element);
          syncWithControlledState(element);
        }
      },
      floatingStyles: floating.context.open ? floating.floatingStyles : {}
    }),
    [getReferenceProps, floatingProps, floating, syncWithControlledState]
  );
};
const Tooltip = reactExports.forwardRef((props, forwardedRef) => {
  let { content, children, portal = true, className, style, ...rest } = props;
  let tooltip = useTooltip(rest);
  let refs = useMergedRefs$1(tooltip.refs.setFloating, forwardedRef);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    cloneElementWithRef(children, (children2) => ({
      ...tooltip.getReferenceProps(children2.props),
      ref: tooltip.refs.setReference
    })),
    "none" !== props.ariaStrategy || tooltip.context.open ? reactExports.createElement(
      Portal,
      {
        portal
      },
      reactExports.createElement(
        Box,
        {
          className: classnames("iui-tooltip", className),
          ref: refs,
          style: {
            ...tooltip.floatingStyles,
            ...style
          },
          ...tooltip.floatingProps
        },
        content
      )
    ) : null
  );
});
const VisuallyHidden = reactExports.forwardRef((props, ref) => {
  let {
    as: asProp = "span",
    className,
    unhideOnFocus = true,
    children: childrenProp,
    ...rest
  } = props;
  let isHydrated = "hydrated" === useHydration();
  let children = ["div", "span", "p"].includes(asProp) ? reactExports.createElement(
    reactExports.Fragment,
    null,
    reactExports.createElement(
      ShadowRoot$1,
      {
        css: css$1
      },
      reactExports.createElement("slot", null)
    ),
    isHydrated && childrenProp
  ) : childrenProp;
  return reactExports.createElement(
    Box,
    {
      as: asProp,
      className: classnames("iui-visually-hidden", className),
      "data-iui-unhide-on-focus": unhideOnFocus ? true : void 0,
      ref,
      ...rest
    },
    children
  );
});
let css$1 = `
  :host(:where(:not([data-iui-unhide-on-focus]:is(:focus-within, :active)))) {
    clip-path: inset(50%) !important;
    overflow: hidden !important;
    position: absolute !important;
    white-space: nowrap !important;
    block-size: 1px !important;
    inline-size: 1px !important;
  }
`;
const ButtonGroupContext = reactExports.createContext(void 0);
const ButtonGroup = reactExports.forwardRef((props, forwardedRef) => {
  let {
    children: childrenProp,
    overflowButton,
    overflowPlacement = "end",
    orientation = "horizontal",
    ...rest
  } = props;
  let children = reactExports.useMemo(() => {
    if ("toolbar" !== props.role) return childrenProp;
    return reactExports.Children.map(
      childrenProp,
      (child, index2) => reactExports.isValidElement(child) ? reactExports.createElement(CompositeItem, {
        key: index2,
        render: child
      }) : child
    );
  }, [childrenProp, props.role]);
  let node = overflowButton ? reactExports.createElement(
    OverflowGroup,
    {
      orientation,
      overflowButton,
      overflowPlacement,
      ref: forwardedRef,
      ...rest
    },
    children
  ) : reactExports.createElement(
    BaseGroup,
    {
      orientation,
      ref: forwardedRef,
      ...rest
    },
    children
  );
  return reactExports.createElement(
    FloatingDelayGroup,
    {
      delay: defaultTooltipDelay
    },
    reactExports.createElement(
      ButtonGroupContext.Provider,
      {
        value: orientation
      },
      "toolbar" === props.role ? reactExports.createElement(Composite, {
        orientation,
        render: node,
        disabledIndices: []
      }) : node
    )
  );
});
let BaseGroup = reactExports.forwardRef((props, forwardedRef) => {
  let { orientation, className, ...rest } = props;
  return reactExports.createElement(Box, {
    className: classnames("iui-button-group", className),
    "data-iui-orientation": "vertical" === orientation ? orientation : void 0,
    ref: forwardedRef,
    ...rest
  });
});
let OverflowGroup = reactExports.forwardRef((props, forwardedRef) => {
  let {
    children: childrenProp,
    orientation,
    overflowButton,
    overflowPlacement,
    ...rest
  } = props;
  let items = reactExports.useMemo(
    () => reactExports.Children.toArray(childrenProp).filter(Boolean),
    [childrenProp]
  );
  return reactExports.createElement(
    OverflowContainer,
    {
      as: BaseGroup,
      itemsCount: items.length,
      overflowOrientation: orientation,
      orientation,
      ...rest,
      className: classnames(
        {
          "iui-button-group-overflow-x": !!overflowButton && "horizontal" === orientation
        },
        props.className
      ),
      ref: forwardedRef
    },
    reactExports.createElement(OverflowGroupContent, {
      overflowButton,
      overflowPlacement,
      items
    })
  );
});
let OverflowGroupContent = (props) => {
  let { overflowButton, overflowPlacement, items } = props;
  let { visibleCount } = OverflowContainer.useContext();
  let overflowStart = "start" === overflowPlacement ? items.length - visibleCount : visibleCount - 1;
  if (!(visibleCount < items.length)) return items;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    overflowButton && "start" === overflowPlacement && overflowButton(overflowStart),
    "start" === overflowPlacement ? items.slice(overflowStart + 1) : items.slice(0, Math.max(0, overflowStart)),
    overflowButton && "end" === overflowPlacement && overflowButton(overflowStart)
  );
};
const PortalContainerContext = reactExports.createContext(null);
const Portal = (props) => {
  let { portal = true, children } = props;
  let isClient2 = useIsClient$1();
  let portalTo = usePortalTo(portal);
  if (!isClient2) return null;
  return portalTo ? reactDomExports.createPortal(children, portalTo) : children;
};
const usePortalTo = (portal) => {
  let portalContainer = reactExports.useContext(PortalContainerContext);
  if ("boolean" == typeof portal) return portal ? portalContainer : null;
  let portalTo = "function" == typeof portal.to ? portal.to() : portal.to;
  return portalTo ?? portalContainer;
};
const Toast = (props) => {
  let {
    content,
    category,
    type: type5 = "temporary",
    isVisible: isVisibleProp,
    link,
    duration = 7e3,
    hasCloseButton,
    onRemove,
    animateOutTo,
    domProps
  } = props;
  let closeTimeout = reactExports.useRef(0);
  let { placement } = useSafeContext$1(ToasterStateContext).settings;
  let placementPosition = placement.startsWith("top") ? "top" : "bottom";
  let [visible, setVisible] = reactExports.useState(isVisibleProp ?? true);
  let isVisible2 = isVisibleProp ?? visible;
  let [height, setHeight] = reactExports.useState(0);
  let thisElement = reactExports.useRef(null);
  let [margin, setMargin] = reactExports.useState(0);
  let marginStyle = () => {
    if ("top" === placementPosition)
      return {
        marginBlockEnd: margin
      };
    return {
      marginBlockStart: margin
    };
  };
  reactExports.useEffect(() => {
    if ("temporary" === type5) setCloseTimeout(duration);
    return () => {
      clearCloseTimeout();
    };
  }, [duration, type5]);
  reactExports.useEffect(() => {
    if (!isVisible2 && !animateOutTo) setMargin(-height);
  }, [isVisible2, animateOutTo, setMargin, height]);
  let close = () => {
    clearCloseTimeout();
    setMargin(-height);
    setVisible(false);
  };
  let setCloseTimeout = (timeout) => {
    let definedWindow = getWindow$2();
    if (!definedWindow) return;
    closeTimeout.current = definedWindow.setTimeout(() => {
      close();
    }, timeout);
  };
  let clearCloseTimeout = () => {
    getWindow$2()?.clearTimeout(closeTimeout.current);
  };
  let onRef = (ref) => {
    if (ref) {
      let { height: height2 } = ref.getBoundingClientRect();
      setHeight(height2);
    }
  };
  let shouldBeMounted = useAnimateToastBasedOnVisibility(isVisible2, {
    thisElement,
    animateOutTo,
    onRemove
  });
  return shouldBeMounted ? reactExports.createElement(
    Box,
    {
      ref: thisElement,
      className: "iui-toast-all",
      style: {
        height,
        ...marginStyle()
      }
    },
    reactExports.createElement(
      "div",
      {
        ref: onRef
      },
      reactExports.createElement(ToastPresentation, {
        as: "div",
        category,
        content,
        link,
        type: type5,
        hasCloseButton,
        onClose: close,
        ...domProps?.toastProps,
        contentProps: domProps?.contentProps
      })
    )
  ) : null;
};
const ToastPresentation = reactExports.forwardRef((props, forwardedRef) => {
  let {
    content,
    category,
    type: type5 = "temporary",
    link,
    hasCloseButton,
    onClose,
    className,
    contentProps,
    ...rest
  } = props;
  let StatusIcon = StatusIconMap[category];
  return reactExports.createElement(
    Box,
    {
      className: classnames(`iui-toast iui-${category}`, className),
      ref: forwardedRef,
      ...rest
    },
    reactExports.createElement(
      Box,
      {
        className: "iui-status-area"
      },
      reactExports.createElement(StatusIcon, {
        className: "iui-icon"
      })
    ),
    reactExports.createElement(
      Box,
      {
        as: "div",
        ...contentProps,
        className: classnames("iui-message", contentProps?.className)
      },
      content
    ),
    link && reactExports.createElement(
      ButtonBase,
      {
        ...link,
        className: classnames("iui-anchor", "iui-toast-anchor", link.className),
        title: void 0,
        "data-iui-status": category,
        "data-iui-underline": true
      },
      link.title
    ),
    ("persisting" === type5 || hasCloseButton) && reactExports.createElement(
      IconButton,
      {
        size: "small",
        styleType: "borderless",
        onClick: onClose,
        "aria-label": "Close"
      },
      reactExports.createElement(SvgCloseSmall, null)
    )
  );
});
let useAnimateToastBasedOnVisibility = (isVisible2, args) => {
  let { thisElement, animateOutTo, onRemove } = args;
  let [shouldBeMounted, setShouldBeMounted] = reactExports.useState(isVisible2);
  let motionOk = useMediaQuery$1("(prefers-reduced-motion: no-preference)");
  let onRemoveRef = useLatestRef$3(onRemove);
  let [prevIsVisible, setPrevIsVisible] = reactExports.useState(void 0);
  reactExports.useEffect(() => {
    if (prevIsVisible !== isVisible2) {
      setPrevIsVisible(isVisible2);
      if (isVisible2) safeAnimateIn();
      else safeAnimateOut();
    }
    function calculateOutAnimation(node) {
      let translateX = 0;
      let translateY = 0;
      if (animateOutTo && node) {
        let { x: startX, y: startY } = node.getBoundingClientRect();
        let { x: endX, y: endY } = animateOutTo.getBoundingClientRect();
        translateX = endX - startX;
        translateY = endY - startY;
      }
      return {
        translateX,
        translateY
      };
    }
    function safeAnimateIn() {
      setShouldBeMounted(true);
      queueMicrotask(() => {
        animateIn();
      });
    }
    function safeAnimateOut() {
      if (motionOk) {
        let animation = animateOut();
        animation?.addEventListener("finish", () => {
          setShouldBeMounted(false);
          onRemoveRef.current?.();
        });
      } else {
        setShouldBeMounted(false);
        onRemoveRef.current?.();
      }
    }
    function animateIn() {
      if (!motionOk) return;
      thisElement.current?.animate?.(
        [
          {
            transform: "translateY(15%)"
          },
          {
            transform: "translateY(0)"
          }
        ],
        {
          duration: 240,
          fill: "forwards"
        }
      );
    }
    function animateOut() {
      if (null == thisElement.current || !motionOk) return;
      let { translateX, translateY } = calculateOutAnimation(
        thisElement.current
      );
      let animationDuration = animateOutTo ? 400 : 120;
      let animation = thisElement.current?.animate?.(
        [
          {
            transform: animateOutTo ? `scale(0.9) translate(${translateX}px,${translateY}px)` : "scale(0.9)",
            opacity: 0,
            transitionDuration: `${animationDuration}ms`,
            transitionTimingFunction: "cubic-bezier(0.4, 0, 1, 1)"
          }
        ],
        {
          duration: animationDuration,
          iterations: 1,
          fill: "forwards"
        }
      );
      return animation;
    }
  }, [
    isVisible2,
    prevIsVisible,
    animateOutTo,
    motionOk,
    thisElement,
    setShouldBeMounted,
    onRemoveRef
  ]);
  return shouldBeMounted;
};
const useToaster = () => {
  let dispatch = useSafeContext$1(ToasterDispatchContext);
  return reactExports.useMemo(() => {
    let showToast = (category) => (content, options) => {
      let id = nextId();
      dispatch({
        type: "add",
        toast: {
          ...options,
          id,
          content,
          category
        }
      });
      return {
        close: () => dispatch({
          type: "remove",
          id
        })
      };
    };
    return {
      positive: showToast("positive"),
      informational: showToast("informational"),
      negative: showToast("negative"),
      warning: showToast("warning"),
      closeAll: () => {
        dispatch({
          type: "close-all"
        });
      },
      setSettings: (settings) => {
        dispatch({
          type: "settings",
          settings
        });
      }
    };
  }, [dispatch]);
};
const Toaster = () => {
  let { toasts, settings } = useSafeContext$1(ToasterStateContext);
  return reactExports.createElement(
    Box,
    {
      className: classnames("iui-toast-wrapper", `iui-placement-${settings.placement}`)
    },
    toasts.map(
      (toastProps) => reactExports.createElement(Toast, {
        key: toastProps.id,
        ...toastProps
      })
    )
  );
};
const ToastProvider = ({ children, inherit = false }) => {
  let [toasterState, dispatch] = reactExports.useReducer(toastReducer, {
    toasts: [],
    settings: {
      order: "auto",
      placement: "top"
    }
  });
  let toasterDispatchContext = reactExports.useContext(ToasterDispatchContext);
  let toasterStateContext = reactExports.useContext(ToasterStateContext);
  let shouldReuse = toasterStateContext && inherit;
  let toasterDispatchContextValue = shouldReuse ? toasterDispatchContext : dispatch;
  let toasterStateContextValue = shouldReuse ? toasterStateContext : toasterState;
  return reactExports.createElement(
    ToasterDispatchContext.Provider,
    {
      value: toasterDispatchContextValue
    },
    reactExports.createElement(
      ToasterStateContext.Provider,
      {
        value: toasterStateContextValue
      },
      children
    )
  );
};
let toastReducer = (state3, action2) => {
  if ("add" === action2.type) {
    let order = state3.settings.order;
    if ("auto" === order)
      order = state3.settings.placement.startsWith("top") ? "descending" : "ascending";
    return {
      ...state3,
      toasts: [
        ..."ascending" === order ? state3.toasts : [],
        action2.toast,
        ..."descending" === order ? state3.toasts : []
      ]
    };
  }
  if ("remove" === action2.type)
    return {
      ...state3,
      toasts: state3.toasts.filter((toast) => toast.id !== action2.id)
    };
  if ("close-all" === action2.type)
    return {
      ...state3,
      toasts: state3.toasts.map((toast) => ({
        ...toast,
        isVisible: false
      }))
    };
  if ("settings" === action2.type)
    return {
      ...state3,
      settings: {
        ...state3.settings,
        ...action2.settings
      }
    };
  return state3;
};
const ToasterStateContext = reactExports.createContext(void 0);
let ToasterDispatchContext = reactExports.createContext(void 0);
let nextId = /* @__PURE__ */ (() => {
  let count2 = 0;
  return () => ++count2;
})();
let _moduleType = "ESM";
const meta = {
  version: t2,
  module: _moduleType
};
let versionWithoutDots = meta.version.replace(/\./g, "");
let OwnerDocumentContext = reactExports.createContext(void 0);
const ThemeProvider = reactExports.forwardRef((props, forwardedRef) => {
  var _themeOptions, _themeOptions1;
  let {
    theme: themeProp = "inherit",
    children,
    themeOptions = {},
    portalContainer: portalContainerProp,
    includeCss = "inherit" === themeProp,
    future: futureProp = {},
    ...rest
  } = props;
  useInertPolyfill();
  let [rootElement, setRootElement] = reactExports.useState(null);
  let parent = useParentThemeAndContext(rootElement);
  let theme = "inherit" === themeProp ? parent.theme || "light" : themeProp;
  (_themeOptions = themeOptions).applyBackground ?? (_themeOptions.applyBackground = !parent.theme);
  (_themeOptions1 = themeOptions).highContrast ?? (_themeOptions1.highContrast = "inherit" === themeProp ? parent.highContrast : void 0);
  let portalContainerFromParent = reactExports.useContext(PortalContainerContext);
  let themeContextValue = reactExports.useMemo(
    () => ({
      theme,
      themeOptions
    }),
    [theme, JSON.stringify(themeOptions)]
  );
  let [portalContainer, setPortalContainer] = reactExports.useState(
    portalContainerProp || null
  );
  return reactExports.createElement(
    FutureFlagsProvider,
    {
      value: futureProp
    },
    reactExports.createElement(
      PortalContainerContext.Provider,
      {
        value: portalContainer
      },
      reactExports.createElement(
        HydrationProvider,
        null,
        reactExports.createElement(
          ThemeContext.Provider,
          {
            value: themeContextValue
          },
          reactExports.createElement(
            ToastProvider,
            {
              inherit: "inherit" === themeProp && !portalContainerProp
            },
            includeCss && rootElement ? reactExports.createElement(FallbackStyles, {
              root: rootElement
            }) : null,
            reactExports.createElement(
              MainRoot,
              {
                theme,
                themeOptions,
                ref: useMergedRefs$1(
                  forwardedRef,
                  setRootElement,
                  useIuiDebugRef
                ),
                ...rest
              },
              children,
              reactExports.createElement(PortalContainer$1, {
                theme,
                themeOptions,
                portalContainerProp,
                portalContainerFromParent,
                setPortalContainer,
                isInheritingTheme: "inherit" === themeProp
              })
            )
          )
        )
      )
    )
  );
});
let MainRoot = reactExports.forwardRef((props, forwardedRef) => {
  let [ownerDocument, setOwnerDocument] = reactExports.useState(void 0);
  let findOwnerDocumentFromRef = reactExports.useCallback(
    (el) => {
      if (el && el.ownerDocument !== ownerDocument)
        setOwnerDocument(el.ownerDocument);
    },
    [ownerDocument, setOwnerDocument]
  );
  return reactExports.createElement(
    OwnerDocumentContext.Provider,
    {
      value: ownerDocument
    },
    reactExports.createElement(Root$1, {
      ...props,
      ref: useMergedRefs$1(findOwnerDocumentFromRef, forwardedRef)
    })
  );
});
let Root$1 = reactExports.forwardRef((props, forwardedRef) => {
  let { theme, children, themeOptions, className, ...rest } = props;
  let prefersDark = useMediaQuery$1("(prefers-color-scheme: dark)");
  let prefersHighContrast = useMediaQuery$1("(prefers-contrast: more)");
  let shouldApplyDark = "dark" === theme || "os" === theme && prefersDark;
  let shouldApplyHC = themeOptions?.highContrast ?? prefersHighContrast;
  let shouldApplyBackground = themeOptions?.applyBackground;
  let themeBridge = useFutureFlag("themeBridge");
  return reactExports.createElement(
    Box,
    {
      className: classnames(
        "iui-root",
        {
          "iui-root-background": shouldApplyBackground
        },
        className
      ),
      "data-iui-theme": shouldApplyDark ? "dark" : "light",
      "data-iui-contrast": shouldApplyHC ? "high" : "default",
      "data-iui-bridge": themeBridge ? "true" : void 0,
      ref: forwardedRef,
      ...rest
    },
    children
  );
});
let useParentThemeAndContext = (rootElement) => {
  let parentContext = reactExports.useContext(ThemeContext);
  let [parentThemeState, setParentTheme] = reactExports.useState(parentContext?.theme);
  let [parentHighContrastState, setParentHighContrastState] = reactExports.useState(
    parentContext?.themeOptions?.highContrast
  );
  let parentThemeRef = useLatestRef$3(parentContext?.theme);
  useIsomorphicLayoutEffect(() => {
    if (parentThemeRef.current) return;
    let closestRoot = rootElement?.parentElement?.closest("[data-iui-theme]");
    if (!closestRoot) return;
    let synchronizeTheme = () => {
      setParentTheme(closestRoot?.getAttribute("data-iui-theme"));
      setParentHighContrastState(
        closestRoot?.getAttribute("data-iui-contrast") === "high"
      );
    };
    synchronizeTheme();
    let observer = new MutationObserver(() => synchronizeTheme());
    observer.observe(closestRoot, {
      attributes: true,
      attributeFilter: ["data-iui-theme", "data-iui-contrast"]
    });
    return () => {
      observer.disconnect();
    };
  }, [rootElement, parentThemeRef]);
  return {
    theme: parentContext?.theme ?? parentThemeState,
    highContrast: parentContext?.themeOptions?.highContrast ?? parentHighContrastState,
    context: parentContext
  };
};
let PortalContainer$1 = reactExports.memo(
  ({
    portalContainerProp,
    portalContainerFromParent,
    setPortalContainer,
    isInheritingTheme,
    theme,
    themeOptions
  }) => {
    let ownerDocument = reactExports.useContext(OwnerDocumentContext);
    let shouldSetupPortalContainer = !portalContainerProp && (!isInheritingTheme || !portalContainerFromParent || !!ownerDocument && portalContainerFromParent.ownerDocument !== ownerDocument);
    let id = useId$1();
    reactExports.useEffect(() => {
      if (shouldSetupPortalContainer) return;
      let portalTarget = portalContainerProp || portalContainerFromParent;
      if (portalTarget) setPortalContainer(portalTarget);
    }, [
      portalContainerProp,
      portalContainerFromParent,
      shouldSetupPortalContainer,
      setPortalContainer
    ]);
    let isHydrated = "hydrated" === useHydration();
    if (!isHydrated) return null;
    if (shouldSetupPortalContainer && ownerDocument)
      return reactDomExports.createPortal(
        reactExports.createElement(
          Root$1,
          {
            theme,
            themeOptions: {
              ...themeOptions,
              applyBackground: false
            },
            "data-iui-portal": true,
            style: {
              display: "contents"
            },
            ref: setPortalContainer,
            id
          },
          reactExports.createElement(Toaster, null)
        ),
        ownerDocument.body
      );
    if (portalContainerProp)
      return reactDomExports.createPortal(
        reactExports.createElement(Toaster, null),
        portalContainerProp
      );
    return null;
  }
);
let FallbackStyles = ({ root: root2 }) => {
  useIsomorphicLayoutEffect(() => {
    if ("yes" === getComputedStyle(root2).getPropertyValue(`--_iui-v${versionWithoutDots}`))
      return;
    if (isUnitTest) return;
    (async () => {
      try {
        await __vitePreload(() => Promise.resolve({}), true ? __vite__mapDeps([134]) : void 0, import.meta.url);
      } catch (error) {
        console.log("Error loading styles.css locally", error);
        let css2 = await importCss(
          `https://cdn.jsdelivr.net/npm/@itwin/itwinui-react@${meta.version}/styles.css`
        );
        document.adoptedStyleSheets = [
          ...document.adoptedStyleSheets,
          css2.default
        ];
      }
    })();
  }, [root2]);
  return reactExports.createElement(reactExports.Fragment, null);
};
let useIuiDebugRef = () => {
  var _globalThis;
  let _globalThis1 = globalThis;
  (_globalThis = _globalThis1).__iui || (_globalThis.__iui = {
    versions: /* @__PURE__ */ new Set()
  });
  _globalThis1.__iui.versions.add(JSON.stringify(meta));
};
let useInertPolyfill = () => {
  let loaded = reactExports.useRef(false);
  let modulePath = "https://cdn.jsdelivr.net/npm/wicg-inert@3.1.2/dist/inert.min.js";
  reactExports.useEffect(() => {
    (async () => {
      if (!HTMLElement.prototype.hasOwnProperty("inert") && !loaded.current && !isUnitTest) {
        await new Function("url", "return import(url)")(modulePath);
        loaded.current = true;
      }
    })();
  }, []);
};
const PopoverOpenContext = reactExports.createContext(void 0);
const PopoverInitialFocusContext = reactExports.createContext(void 0);
const usePopover = (options) => {
  let {
    placement = "bottom-start",
    visible,
    onVisibleChange,
    closeOnOutsideClick,
    autoUpdateOptions,
    matchWidth,
    interactions: interactionsProp,
    role,
    ...rest
  } = options;
  let mergedInteractions = reactExports.useMemo(
    () => ({
      ...interactionsProp,
      ...{
        click: interactionsProp?.click ?? true,
        dismiss: interactionsProp?.dismiss ?? true,
        hover: interactionsProp?.hover ?? false,
        focus: interactionsProp?.focus ?? false
      }
    }),
    [interactionsProp]
  );
  let tree = useFloatingTree();
  let middleware = reactExports.useMemo(
    () => ({
      ...options.middleware,
      flip: options.middleware?.flip ?? true,
      shift: options.middleware?.shift ?? true,
      size: options.middleware?.size ?? true,
      hide: options.middleware?.hide || !isUnitTest
    }),
    [options.middleware]
  );
  let maxHeight = "boolean" == typeof middleware.size ? "400px" : middleware.size?.maxHeight;
  let [open, onOpenChange] = useControlledState(
    false,
    visible,
    onVisibleChange
  );
  let floating = useFloating({
    placement,
    open,
    onOpenChange,
    strategy: "fixed",
    whileElementsMounted: reactExports.useMemo(
      () => open ? (...args) => autoUpdate(...args, autoUpdateOptions) : void 0,
      [autoUpdateOptions, open]
    ),
    ...rest,
    middleware: reactExports.useMemo(
      () => [
        void 0 !== middleware.offset && offset(middleware.offset),
        middleware.flip && flip({
          padding: 5
        }),
        middleware.shift && shift({
          padding: 4
        }),
        (matchWidth || middleware.size) && size({
          padding: 4,
          apply: ({ rects, availableHeight: availableHeight2 }) => {
            if (middleware.size)
              setAvailableHeight(Math.round(availableHeight2));
            if (matchWidth) setReferenceWidth(rects.reference.width);
          }
        }),
        middleware.autoPlacement && autoPlacement({
          padding: 4
        }),
        middleware.inline && inline(),
        middleware.hide && hide({
          padding: 4
        })
      ].filter(Boolean),
      [matchWidth, middleware]
    )
  });
  let interactions = useInteractions([
    useClick(floating.context, {
      enabled: !!mergedInteractions.click,
      ...mergedInteractions.click
    }),
    useDismiss(floating.context, {
      enabled: !!mergedInteractions.dismiss,
      outsidePress: closeOnOutsideClick,
      bubbles: null != tree,
      ...mergedInteractions.dismiss
    }),
    useHover(floating.context, {
      enabled: !!mergedInteractions.hover,
      delay: 100,
      handleClose: safePolygon({
        buffer: 1,
        blockPointerEvents: true
      }),
      move: false,
      ...mergedInteractions.hover
    }),
    useFocus(floating.context, {
      enabled: !!mergedInteractions.focus,
      ...mergedInteractions.focus
    }),
    useRole(floating.context, {
      role: "dialog",
      enabled: !!role
    })
  ]);
  let [referenceWidth, setReferenceWidth] = reactExports.useState();
  let [availableHeight, setAvailableHeight] = reactExports.useState();
  let getFloatingProps = reactExports.useCallback(
    (userProps) => interactions.getFloatingProps({
      ...userProps,
      style: {
        ...floating.floatingStyles,
        ...middleware.size && availableHeight && {
          maxBlockSize: `min(${availableHeight}px, ${maxHeight})`
        },
        zIndex: 999,
        ...matchWidth && referenceWidth ? {
          minInlineSize: `${referenceWidth}px`,
          maxInlineSize: `min(${2 * referenceWidth}px, 90vw)`
        } : {},
        ...middleware.hide && floating.middlewareData.hide?.referenceHidden && {
          visibility: "hidden"
        },
        ...userProps?.style
      }
    }),
    [
      interactions,
      floating.floatingStyles,
      floating.middlewareData.hide?.referenceHidden,
      middleware.size,
      middleware.hide,
      availableHeight,
      maxHeight,
      matchWidth,
      referenceWidth
    ]
  );
  let getReferenceProps = reactExports.useCallback(
    (userProps) => interactions.getReferenceProps({
      ...userProps,
      onClick: mergeEventHandlers(userProps?.onClick, () => {
        if (!!mergedInteractions.click && visible) onOpenChange(false);
      })
    }),
    [interactions, mergedInteractions.click, visible, onOpenChange]
  );
  return reactExports.useMemo(
    () => ({
      open,
      onOpenChange,
      getReferenceProps,
      getFloatingProps,
      ...floating
    }),
    [open, onOpenChange, getFloatingProps, floating, getReferenceProps]
  );
};
const Popover = reactExports.forwardRef((props, forwardedRef) => {
  let {
    portal = true,
    visible,
    placement = "bottom-start",
    onVisibleChange,
    closeOnOutsideClick = true,
    middleware,
    positionReference,
    className,
    children,
    content,
    applyBackground = false,
    ...rest
  } = props;
  let popover = usePopover({
    visible,
    placement,
    onVisibleChange,
    closeOnOutsideClick,
    role: "dialog",
    middleware,
    transform: false
  });
  let [popoverElement, setPopoverElement] = reactExports.useState(null);
  let popoverRef = useMergedRefs$1(
    popover.refs.setFloating,
    forwardedRef,
    setPopoverElement
  );
  let triggerId = `${useId$1()}-trigger`;
  let hasAriaLabel = !!props["aria-labelledby"] || !!props["aria-label"];
  useIsomorphicLayoutEffect(() => {
    if (!positionReference) return;
    popover.refs.setPositionReference(positionReference);
    return () => void popover.refs.setPositionReference(null);
  }, [popover.refs, positionReference]);
  let [initialFocus, setInitialFocus] = reactExports.useState();
  let initialFocusContextValue = reactExports.useMemo(
    () => ({
      setInitialFocus
    }),
    []
  );
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    reactExports.createElement(
      PopoverOpenContext.Provider,
      {
        value: popover.open
      },
      cloneElementWithRef(children, (children2) => ({
        id: children2.props.id || triggerId,
        ...popover.getReferenceProps(children2.props),
        ref: popover.refs.setReference
      }))
    ),
    popover.open ? reactExports.createElement(
      PopoverInitialFocusContext.Provider,
      {
        value: initialFocusContextValue
      },
      reactExports.createElement(
        PopoverPortal,
        {
          portal
        },
        reactExports.createElement(
          ThemeProvider,
          null,
          reactExports.createElement(
            PortalContainerContext.Provider,
            {
              value: popoverElement
            },
            reactExports.createElement(DisplayContents, null),
            reactExports.createElement(
              FloatingFocusManager,
              {
                context: popover.context,
                modal: false,
                initialFocus
              },
              reactExports.createElement(
                Box,
                {
                  className: classnames(
                    "iui-popover",
                    {
                      "iui-popover-surface": applyBackground
                    },
                    className
                  ),
                  "aria-labelledby": hasAriaLabel ? void 0 : popover.refs.domReference.current?.id,
                  ...popover.getFloatingProps(rest),
                  ref: popoverRef
                },
                content
              )
            )
          )
        )
      )
    ) : null
  );
});
let PopoverPortal = ({ children, portal = true }) => {
  let portalTo = usePortalTo(portal);
  return reactExports.createElement(
    FloatingPortal,
    {
      key: portalTo?.id,
      root: portalTo ?? void 0
    },
    reactExports.createElement(DisplayContents, null),
    children
  );
};
let DisplayContents = reactExports.memo(
  () => reactExports.createElement(
    ShadowRoot$1,
    {
      css: `
        :host {
          display: contents;
        }
      `
    },
    reactExports.createElement("slot", null)
  )
);
const IconButton = reactExports.forwardRef((props, ref) => {
  let {
    isActive,
    children,
    styleType = "default",
    size: size2,
    className,
    title,
    label = title,
    iconProps,
    labelProps,
    ...rest
  } = props;
  let buttonGroupOrientation = reactExports.useContext(ButtonGroupContext);
  let hasPopoverOpen = reactExports.useContext(PopoverOpenContext);
  let button = reactExports.createElement(
    ButtonBase,
    {
      ref,
      className: classnames("iui-button", "iui-field", className),
      "data-iui-variant": "default" !== styleType ? styleType : void 0,
      "data-iui-size": size2,
      "data-iui-active": isActive,
      "data-iui-has-popover": hasPopoverOpen ? "open" : void 0,
      "aria-pressed": isActive,
      ...rest
    },
    reactExports.createElement(
      Box,
      {
        as: "span",
        "aria-hidden": true,
        ...iconProps,
        className: classnames("iui-button-icon", iconProps?.className)
      },
      children
    ),
    label ? reactExports.createElement(VisuallyHidden, null, label) : null
  );
  return label ? reactExports.createElement(
    Tooltip,
    {
      placement: "vertical" === buttonGroupOrientation ? "right" : "top",
      ...labelProps,
      content: label,
      ariaStrategy: "none"
    },
    button
  ) : button;
});
let OverflowContainerMain = React.forwardRef((props, forwardedRef) => {
  let { itemsCount, children, overflowOrientation, ...rest } = props;
  let [containerRef, visibleCount] = useOverflow(
    itemsCount,
    overflowOrientation
  );
  let overflowContainerContextValue = React.useMemo(
    () => ({
      visibleCount,
      itemsCount
    }),
    [itemsCount, visibleCount]
  );
  return React.createElement(
    OverflowContainerContext.Provider,
    {
      value: overflowContainerContextValue
    },
    React.createElement(
      Box,
      {
        ref: useMergedRefs$1(forwardedRef, containerRef),
        ...rest
      },
      children
    )
  );
});
let OverflowContainerOverflowNode = (props) => {
  let { children } = props;
  let { visibleCount, itemsCount } = useOverflowContainerContext();
  let isOverflowing = visibleCount < itemsCount;
  return isOverflowing ? children : null;
};
let OverflowContainerComponent = React.forwardRef((props, forwardedRef) => {
  let { itemsCount, overflowOrientation = "horizontal", ...rest } = props;
  let [size2, setSize] = React.useState(null);
  let [resizeRef] = useResizeObserver(setSize);
  let ref = useMergedRefs$1(resizeRef, forwardedRef);
  let key = `${itemsCount}${"vertical" === overflowOrientation ? size2?.height : size2?.width}`;
  return React.createElement(OverflowContainerMain, {
    ...rest,
    key,
    ref,
    itemsCount,
    overflowOrientation
  });
});
const OverflowContainer = Object.assign(OverflowContainerComponent, {
  OverflowNode: OverflowContainerOverflowNode,
  useContext: useOverflowContainerContext
});
let OverflowContainerContext = React.createContext(void 0);
let useOverflow = (itemsCount, orientation = "horizontal") => {
  let [guessState, dispatch] = React.useReducer(
    overflowGuessReducer,
    {
      itemsCount
    },
    overflowGuessReducerInitialState
  );
  let containerRef = React.useRef(null);
  let isGuessing = React.useRef(false);
  useIsomorphicLayoutEffect(() => {
    let { minGuess, maxGuess, isStabilized, visibleCount } = guessState;
    if (isStabilized) return;
    guessVisibleCount();
    function guessVisibleCount() {
      if (isStabilized || isGuessing.current || isUnitTest) return;
      try {
        isGuessing.current = true;
        if (null == containerRef.current) return;
        let dimension = "horizontal" === orientation ? "Width" : "Height";
        let availableSize = containerRef.current[`offset${dimension}`];
        let requiredSize = containerRef.current[`scroll${dimension}`];
        let isOverflowing = availableSize < requiredSize;
        if (0 === itemsCount || 1 === visibleCount && isOverflowing || visibleCount === itemsCount && !isOverflowing || maxGuess - minGuess === 1 && visibleCount === minGuess)
          return void dispatch({
            type: "stabilize"
          });
        if (maxGuess === visibleCount && !isOverflowing)
          return void dispatch({
            type: "shiftGuessRangeForward"
          });
        isOverflowing ? dispatch({
          type: "decreaseMaxGuess",
          currentState: guessState
        }) : dispatch({
          type: "increaseMinGuess",
          currentState: guessState
        });
      } finally {
        isGuessing.current = false;
      }
    }
  }, [guessState, itemsCount, orientation]);
  return [containerRef, guessState.visibleCount];
};
let STARTING_MAX_ITEMS_COUNT = 32;
let overflowGuessReducerInitialState = ({ itemsCount }) => {
  let initialVisibleCount = Math.min(itemsCount, STARTING_MAX_ITEMS_COUNT);
  return isUnitTest ? {
    isStabilized: true,
    minGuess: null,
    maxGuess: null,
    itemsCount,
    visibleCount: itemsCount
  } : {
    isStabilized: false,
    minGuess: 0,
    maxGuess: initialVisibleCount,
    itemsCount,
    visibleCount: initialVisibleCount
  };
};
let overflowGuessReducer = (state3, action2) => {
  let getSafeVisibleCount = ({ visibleCount, itemsCount }) => Math.min(itemsCount, visibleCount);
  switch (action2.type) {
    case "decreaseMaxGuess":
    case "increaseMinGuess":
      if (state3.isStabilized) return state3;
      let newMinGuess = state3.minGuess;
      let newMaxGuess = state3.maxGuess;
      if ("decreaseMaxGuess" === action2.type)
        newMaxGuess = action2.currentState.visibleCount;
      else newMinGuess = action2.currentState.visibleCount;
      let newVisibleCount = Math.floor((newMinGuess + newMaxGuess) / 2);
      return {
        ...state3,
        isStabilized: false,
        minGuess: newMinGuess,
        maxGuess: newMaxGuess,
        visibleCount: getSafeVisibleCount({
          visibleCount: newVisibleCount,
          itemsCount: state3.itemsCount
        })
      };
    case "shiftGuessRangeForward":
      if (state3.isStabilized) return state3;
      let doubleOfMaxGuess = 2 * state3.maxGuess;
      return {
        ...state3,
        isStabilized: false,
        minGuess: state3.maxGuess,
        maxGuess: doubleOfMaxGuess,
        visibleCount: getSafeVisibleCount({
          visibleCount: doubleOfMaxGuess,
          itemsCount: state3.itemsCount
        })
      };
    case "stabilize":
      return {
        ...state3,
        isStabilized: true,
        minGuess: null,
        maxGuess: null
      };
    default:
      return state3;
  }
};
function useOverflowContainerContext() {
  let overflowContainerContext = useSafeContext$1(OverflowContainerContext);
  return overflowContainerContext;
}
let FutureFlagsContext = reactExports.createContext({});
function useFutureFlag(key) {
  let context = useSafeContext$1(FutureFlagsContext);
  return context[key];
}
const FutureFlagsProvider = ({ children, value }) => {
  if (true === value)
    value = {
      themeBridge: true
    };
  let context = reactExports.useContext(FutureFlagsContext);
  let combinedValue = {
    ...context,
    ...value
  };
  return reactExports.createElement(
    FutureFlagsContext.Provider,
    {
      value: reactExports.useMemo(
        () => combinedValue,
        [JSON.stringify(combinedValue)]
      )
    },
    children
  );
};
let HydrationContext = reactExports.createContext(false);
let noopSubscribe = () => () => {
};
let isServer = "undefined" == typeof window;
const useHydration = () => {
  let hydrating = useSyncExternalStore(
    noopSubscribe,
    () => false,
    () => !isServer
  );
  let hydrated = reactExports.useContext(HydrationContext);
  let hydratedFallback = useIsClient$1();
  if (hydrated || hydratedFallback) return "hydrated";
  if (hydrating) return "hydrating";
};
const HydrationProvider = ({ children }) => {
  let [isHydrated, setIsHydrated] = reactExports.useState(
    reactExports.useContext(HydrationContext)
  );
  let onHydrate = reactExports.useCallback(() => setIsHydrated(true), []);
  return reactExports.createElement(
    HydrationContext.Provider,
    {
      value: isHydrated
    },
    isHydrated ? null : reactExports.createElement(HydrationCheck, {
      onHydrate
    }),
    children
  );
};
let HydrationCheck = ({ onHydrate }) => {
  reactExports.useEffect(() => void onHydrate(), [onHydrate]);
  return null;
};
let isBrowser$1 = "undefined" != typeof document;
let supportsDSD = isBrowser$1 && "shadowRootMode" in HTMLTemplateElement.prototype;
let supportsAdoptedStylesheets$1 = isBrowser$1 && "adoptedStyleSheets" in Document.prototype;
const ShadowRoot$1 = ({ children, css: css2, flush = true }) => {
  let isHydrating = "hydrating" === useHydration();
  if (!isBrowser$1)
    return reactExports.createElement(
      "template",
      {
        shadowrootmode: "open"
      },
      css2 && reactExports.createElement("style", null, css2),
      children
    );
  if (supportsDSD && isHydrating) return null;
  return reactExports.createElement(
    ClientShadowRoot,
    {
      css: css2,
      flush
    },
    children
  );
};
let ClientShadowRoot = ({ children, css: css2, flush = true }) => {
  let templateRef = reactExports.useRef(null);
  let shadowRoot = useShadowRoot(templateRef, {
    css: css2,
    flush
  });
  let fallbackCss = !supportsAdoptedStylesheets$1 && css2 ? reactExports.createElement("style", null, css2) : null;
  return shadowRoot ? reactDomExports.createPortal(
    reactExports.createElement(reactExports.Fragment, null, fallbackCss, children),
    shadowRoot
  ) : reactExports.createElement("template", {
    ref: templateRef
  });
};
function useShadowRoot(templateRef, { css: css2 = "", flush = true }) {
  let [shadowRoot, setShadowRoot] = reactExports.useState(null);
  let styleSheet = reactExports.useRef(void 0);
  let latestCss = useLatestRef$3(css2);
  let latestShadowRoot = useLatestRef$3(shadowRoot);
  let createStyleSheet = reactExports.useCallback(
    (shadow) => {
      if (shadow && supportsAdoptedStylesheets$1) {
        let currentWindow = shadow.ownerDocument.defaultView || globalThis;
        if (styleSheet.current instanceof currentWindow.CSSStyleSheet) return;
        styleSheet.current = new currentWindow.CSSStyleSheet();
        shadow.adoptedStyleSheets.push(styleSheet.current);
        if (latestCss.current)
          styleSheet.current.replaceSync(latestCss.current);
      }
    },
    [latestCss]
  );
  useIsomorphicLayoutEffect(() => {
    let parent = templateRef.current?.parentElement;
    if (!parent) return;
    let setupOrReuseShadowRoot = () => {
      if (parent.shadowRoot && null === latestShadowRoot.current)
        parent.shadowRoot.replaceChildren();
      let shadow = parent.shadowRoot || parent.attachShadow({
        mode: "open"
      });
      createStyleSheet(shadow);
      if (flush) reactDomExports.flushSync(() => setShadowRoot(shadow));
      else setShadowRoot(shadow);
    };
    if (flush) queueMicrotask(() => setupOrReuseShadowRoot());
    else setupOrReuseShadowRoot();
    return () => void setShadowRoot(null);
  }, [templateRef, createStyleSheet, latestShadowRoot, flush]);
  useIsomorphicLayoutEffect(() => {
    if (css2 && supportsAdoptedStylesheets$1) styleSheet.current?.replaceSync(css2);
  }, [css2]);
  reactExports.useEffect(() => {
    let listener = () => createStyleSheet(latestShadowRoot.current);
    window.addEventListener("appui:reparent", listener);
    return () => {
      window.removeEventListener("appui:reparent", listener);
    };
  }, [createStyleSheet, latestShadowRoot]);
  return shadowRoot;
}
const ButtonBase = reactExports.forwardRef((props, forwardedRef) => {
  let {
    as: asProp = "button",
    disabled: disabledProp,
    htmlDisabled,
    type: typeProp = "button" === asProp ? "button" : void 0,
    ...rest
  } = props;
  let isClient2 = useIsClient$1();
  let ariaDisabled = disabledProp && !htmlDisabled && isClient2 && "button" === asProp;
  let handleIfEnabled = (handler) => (e2) => {
    if (disabledProp) return;
    handler?.(e2);
  };
  let type5 = "button" === asProp && disabledProp ? "button" : typeProp;
  return reactExports.createElement(Box, {
    as: asProp,
    type: type5,
    ref: forwardedRef,
    "aria-disabled": ariaDisabled ? "true" : void 0,
    "data-iui-disabled": disabledProp ? "true" : void 0,
    disabled: htmlDisabled ?? (!isClient2 && disabledProp) ? true : void 0,
    ...rest,
    className: classnames("iui-button-base", props.className),
    onClick: handleIfEnabled(props.onClick),
    onPointerDown: handleIfEnabled(props.onPointerDown),
    onPointerUp: handleIfEnabled(props.onPointerUp)
  });
});
const Svg = polymorphic.svg("", {
  viewBox: "0 0 16 16",
  width: 16,
  height: 16
});
const SvgInfoCircular = (props) => reactExports.createElement(
  Svg,
  props,
  reactExports.createElement("path", {
    d: "M8 0a8 8 0 1 0 8 8 8 8 0 0 0-8-8zm1.2 3.2a.923.923 0 0 1 .997.843l.003.057a1.31 1.31 0 0 1-1.3 1.2.945.945 0 0 1-1-1 1.228 1.228 0 0 1 1.3-1.1zm-2 9.6c-.5 0-.9-.3-.5-1.7l.6-2.4c.1-.4.1-.5 0-.5-.2-.1-.9.2-1.3.5l-.2-.5a6.497 6.497 0 0 1 3.3-1.6c.5 0 .6.6.3 1.6l-.7 2.6c-.1.5-.1.6.1.6a2.003 2.003 0 0 0 1.1-.6l.3.4a5.769 5.769 0 0 1-3 1.6z"
  })
);
const SvgStatusError = (props) => reactExports.createElement(
  Svg,
  props,
  reactExports.createElement("path", {
    d: "M9 12H7v-2h2v2Zm0-3H7V4h2v5Zm2.314-9H4.686L0 4.686v6.628L4.686 16h6.628L16 11.314V4.686L11.314 0Z"
  })
);
const SvgStatusSuccess = (props) => reactExports.createElement(
  Svg,
  props,
  reactExports.createElement("path", {
    d: "m8 0a8 8 0 1 0 8 8 8 8 0 0 0 -8-8zm-1.35 12-3.65-3.41 1.4-1.3 2.36 2.2 4.83-4.49 1.41 1.29z"
  })
);
const SvgStatusWarning = (props) => reactExports.createElement(
  Svg,
  props,
  reactExports.createElement("path", {
    d: "m15.86807 13.26721-6.77-11.62a1.15 1.15 0 0 0 -1.1-.67 1.17 1.17 0 0 0 -1.1.69l-6.77 11.59a1.2 1.2 0 0 0 1.1 1.72h13.45a1.19 1.19 0 0 0 1.19-1.71zm-6.87-.29h-2v-2h2zm0-3h-2v-5h2z"
  })
);
const StatusIconMap = {
  negative: (args) => reactExports.createElement(SvgStatusError, {
    "aria-hidden": true,
    ...args
  }),
  positive: (args) => reactExports.createElement(SvgStatusSuccess, {
    "aria-hidden": true,
    ...args
  }),
  warning: (args) => reactExports.createElement(SvgStatusWarning, {
    "aria-hidden": true,
    ...args
  }),
  informational: (args) => reactExports.createElement(SvgInfoCircular, {
    "aria-hidden": true,
    ...args
  })
};
const SvgCloseSmall = (props) => reactExports.createElement(
  Svg,
  props,
  reactExports.createElement("path", {
    d: "m12.5 2-4.5 4.5-4.5-4.5-1.5 1.5 4.5 4.5-4.5 4.5 1.5 1.5 4.5-4.5 4.5 4.5 1.5-1.5-4.5-4.5 4.5-4.5z"
  })
);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function hasOwnProperty(object, prop) {
  if (typeof Object.hasOwn === "function") {
    return Object.hasOwn(object, prop);
  }
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function isValidElementWithRef(element) {
  if (!element) return false;
  if (!reactExports.isValidElement(element)) return false;
  if ("ref" in element.props) return true;
  if ("ref" in element) return true;
  return false;
}
function getRefProperty(element) {
  if (!isValidElementWithRef(element)) return null;
  const props = __spreadValues({}, element.props);
  return props.ref || element.ref;
}
function mergeProps(base2, overrides) {
  const props = __spreadValues({}, base2);
  for (const key in overrides) {
    if (!hasOwnProperty(overrides, key)) continue;
    if (key === "className") {
      const prop = "className";
      props[prop] = base2[prop] ? `${base2[prop]} ${overrides[prop]}` : overrides[prop];
      continue;
    }
    if (key === "style") {
      const prop = "style";
      props[prop] = base2[prop] ? __spreadValues(__spreadValues({}, base2[prop]), overrides[prop]) : overrides[prop];
      continue;
    }
    const overrideValue = overrides[key];
    if (typeof overrideValue === "function" && key.startsWith("on")) {
      const baseValue = base2[key];
      if (typeof baseValue === "function") {
        props[key] = (...args) => {
          overrideValue(...args);
          baseValue(...args);
        };
        continue;
      }
    }
    props[key] = overrideValue;
  }
  return props;
}
var _React = __spreadValues({}, React8);
_React.useId;
_React.useDeferredValue;
_React.useInsertionEffect;
function useMergeRefs(...refs) {
  return reactExports.useMemo(() => {
    if (!refs.some(Boolean)) return;
    return (value) => {
      for (const ref of refs) {
        setRef(ref, value);
      }
    };
  }, refs);
}
function forwardRef2(render2) {
  const Role3 = reactExports.forwardRef((props, ref) => render2(__spreadProps(__spreadValues({}, props), { ref })));
  Role3.displayName = render2.displayName || render2.name;
  return Role3;
}
function createElement(Type, props) {
  const _a3 = props, { wrapElement, render: render2 } = _a3, rest = __objRest(_a3, ["wrapElement", "render"]);
  const mergedRef = useMergeRefs(props.ref, getRefProperty(render2));
  let element;
  if (reactExports.isValidElement(render2)) {
    const renderProps = __spreadProps(__spreadValues({}, render2.props), { ref: mergedRef });
    element = reactExports.cloneElement(render2, mergeProps(rest, renderProps));
  } else if (render2) {
    element = render2(rest);
  } else {
    element = /* @__PURE__ */ jsxRuntimeExports.jsx(Type, __spreadValues({}, rest));
  }
  if (wrapElement) {
    return wrapElement(element);
  }
  return element;
}
var TagName = "div";
var elements = [
  "a",
  "button",
  "details",
  "dialog",
  "div",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "section",
  "select",
  "span",
  "summary",
  "textarea",
  "ul",
  "svg"
];
var Role = forwardRef2(
  // @ts-expect-error
  function Role2(props) {
    return createElement(TagName, props);
  }
);
Object.assign(
  Role,
  elements.reduce((acc, element) => {
    acc[element] = forwardRef2(function Role3(props) {
      return createElement(element, props);
    });
    return acc;
  }, {})
);
const isBrowser = typeof document !== "undefined";
function isDocument(node) {
  return node?.nodeType === Node.DOCUMENT_NODE;
}
function getOwnerDocument(node) {
  if (!node) return null;
  return (isDocument(node) ? node : node.ownerDocument) || null;
}
function getWindow(node) {
  const ownerDocument = getOwnerDocument(node);
  return ownerDocument?.defaultView || null;
}
function parseDOM(htmlString, { ownerDocument }) {
  const template = ownerDocument.createElement("template");
  template.innerHTML = htmlString;
  return template.content;
}
const forwardRef = reactExports.forwardRef;
const identity = (value) => value;
const useLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
function useLatestRef(value) {
  const valueRef = reactExports.useRef(value);
  reactExports.useInsertionEffect(() => {
    valueRef.current = value;
  });
  return valueRef;
}
function useMergedRefs(...refs) {
  return reactExports.useCallback(
    (instance) => {
      for (const ref of refs) {
        if (typeof ref === "function") {
          ref(instance);
        } else if (ref) {
          ref.current = instance;
        }
      }
    },
    [...refs]
  );
}
function useSafeContext(context) {
  const value = reactExports.useContext(context);
  if (value === void 0) {
    throw new Error(`${context.displayName || "Context"} is undefined`);
  }
  return value;
}
function useIsClient() {
  return reactExports.useSyncExternalStore(
    reactExports.useCallback(() => () => {
    }, []),
    () => true,
    () => false
  );
}
const RootNodeContext = reactExports.createContext(null);
function useRootNode() {
  const maybeRootNode = reactExports.useContext(RootNodeContext);
  const isClient2 = useIsClient();
  if (!isClient2) return void 0;
  return maybeRootNode;
}
const spriteSheetId = "-inline-sprites";
const HtmlSanitizerContext = reactExports.createContext(void 0);
var PortalContext = reactExports.createContext(null);
var components_default = String.raw`@layer itwinui.components{@layer base{.VisuallyHidden:where(:not(:active,:focus-within)){clip-path:inset(50%)!important;white-space:nowrap!important;-webkit-user-select:none!important;user-select:none!important;block-size:1px!important;inline-size:1px!important;position:absolute!important;overflow:hidden!important}}@layer base{.Dot{inline-size:var(--Dot-size,4px);block-size:var(--Dot-size,4px);background-color:var(--stratakit-color-bg-accent-base);border:1px solid var(--stratakit-color-border-glow-strong-default);border-radius:9999px;display:inline-block}}@media (forced-colors:active){.Dot{background-color:canvastext}}@layer base{.GhostAligner:where([data-_sk-ghost-align=inline]){margin-inline:calc(-1*var(--GhostAligner-inline-offset))}.GhostAligner:where([data-_sk-ghost-align=inline-start]){margin-inline-start:calc(-1*var(--GhostAligner-inline-offset))}.GhostAligner:where([data-_sk-ghost-align=inline-end]){margin-inline-end:calc(-1*var(--GhostAligner-inline-offset))}.GhostAligner:where([data-_sk-ghost-align=block]){margin-block:calc(-1*var(--GhostAligner-block-offset))}.GhostAligner:where([data-_sk-ghost-align=block-start]){margin-block-start:calc(-1*var(--GhostAligner-block-offset))}.GhostAligner:where([data-_sk-ghost-align=block-end]){margin-block-end:calc(-1*var(--GhostAligner-block-offset))}}@layer base{.Anchor{cursor:pointer;font-size:var(--stratakit-font-size-12);text-underline-offset:var(--Anchor-state--default,var(--stratakit-space-x05))var(--Anchor-state--hover,var(--stratakit-space-x1))var(--Anchor-state--pressed,var(--stratakit-space-x1));-webkit-text-decoration-color:var(--Anchor-state--default,currentColor)var(--Anchor-state--hover,currentColor)var(--Anchor-state--pressed,transparent);text-decoration-color:var(--Anchor-state--default,currentColor)var(--Anchor-state--hover,currentColor)var(--Anchor-state--pressed,transparent);font-weight:500;text-decoration-line:underline}.Anchor:where(:has(.AnchorText)){text-decoration-line:none}.Anchor{color:var(--Anchor-color,var(--stratakit-color-text-neutral-primary));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-neutral-pressed);border-radius:4px;transition:color .15s ease-out,text-decoration-color .15s ease-out,text-underline-offset .15s ease-out}}@layer modifiers{.Anchor:where([data-_sk-tone=accent]){--Anchor-color:var(--Anchor-state--default,var(--stratakit-color-text-accent-strong))var(--Anchor-state--hover,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-hover-\%)))var(--Anchor-state--pressed,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-pressed-\%)));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-accent-pressed)}.Anchor:where([data-_sk-tone=critical]){--Anchor-color:var(--Anchor-state--default,var(--stratakit-color-text-critical-base))var(--Anchor-state--hover,color-mix(in oklch,var(--stratakit-color-text-critical-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-hover-\%)))var(--Anchor-state--pressed,color-mix(in oklch,var(--stratakit-color-text-critical-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-pressed-\%)));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-critical-pressed)}}@layer states{@media (any-hover:hover){.Anchor:where(:hover){--Anchor-state:var(--Anchor-state--hover)}}.Anchor:where(:active){--Anchor-state:var(--Anchor-state--pressed)}.Anchor:where(:focus-visible){--focus-outline-offset:var(--stratakit-space-x05)}.Anchor:where(:disabled,[aria-disabled=true]){--Anchor-color:var(--stratakit-color-text-neutral-disabled);cursor:not-allowed;text-decoration:none}}@layer base.{.Anchor{--Anchor-state:var(--Anchor-state--default);--Anchor-state--default:var(--Anchor-state, );--Anchor-state--hover:var(--Anchor-state, );--Anchor-state--pressed:var(--Anchor-state, )}}@layer base{.AnchorText{unicode-bidi:bidi-override;text-decoration-line:underline}}@layer base{.AnchorExternalMarker{-webkit-user-select:none;user-select:none}}@media (forced-colors:active){.Anchor:where(button){color:linktext}}@layer base{.Avatar{--Avatar-background-color:var(--stratakit-color-bg-mono-base);--Icon-color:var(--stratakit-color-icon-neutral-emphasis);block-size:var(--Avatar-size);inline-size:var(--Avatar-size);background-color:var(--Avatar-background-color);color:var(--stratakit-color-text-neutral-emphasis);-webkit-user-select:none;user-select:none;border-radius:50%;place-items:center;display:inline-grid;position:relative;overflow:hidden}.Avatar:after{content:"";border-radius:inherit;box-shadow:0px 0px 0px 1px var(--stratakit-color-border-glow-strong-default)inset;position:absolute;inset:0}.Avatar>img{background-color:inherit;block-size:inherit;inline-size:inherit;object-fit:cover;object-position:center}}@layer modifiers{.Avatar:where([data-_sk-size=small]){--Avatar-size:1rem;--Avatar-font-size:var(--stratakit-font-size-8);--Icon-size:.75rem}.Avatar:where([data-_sk-size=medium]){--Avatar-size:1.5rem;--Avatar-font-size:var(--stratakit-font-size-10);--Icon-size:1rem}.Avatar:where([data-_sk-size=large]){--Avatar-size:2rem;--Avatar-font-size:var(--stratakit-font-size-12);--Icon-size:1rem}.Avatar:where([data-_sk-size=xlarge]){--Avatar-size:3rem;--Avatar-font-size:var(--stratakit-font-size-16);--Icon-size:1.5rem}}@layer base{.AvatarInitials{font-size:var(--Avatar-font-size);text-align:center;text-transform:uppercase;font-weight:600}}@media (forced-colors:active){.Avatar{border:1px solid}}@layer base{.Badge{font-size:var(--stratakit-font-size-12);line-height:1.3333}.Badge{white-space:nowrap;box-shadow:0px 0px 0px 1px var(--Badge-border-color)inset;background-color:var(--Badge-background-color);color:var(--Badge-text-color);block-size:1.25rem;padding-inline:var(--stratakit-space-x2);border-radius:9999px;flex-shrink:0;justify-content:center;align-items:center;font-weight:500;display:inline-flex}}@layer modifiers{.Badge:where([data-_sk-variant=solid]){--Badge-border-color:var(--stratakit-color-border-glow-strong-default);--Badge-text-color:var(--stratakit-color-text-neutral-emphasis)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=neutral]){--Badge-background-color:var(--stratakit-color-bg-mono-base)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=info]){--Badge-background-color:var(--stratakit-color-bg-info-base)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=positive]){--Badge-background-color:var(--stratakit-color-bg-positive-base)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=attention]){--Badge-background-color:var(--stratakit-color-bg-attention-base)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=critical]){--Badge-background-color:var(--stratakit-color-bg-critical-base)}.Badge:where([data-_sk-variant=solid]):where([data-_sk-tone=accent]){--Badge-background-color:var(--stratakit-color-bg-accent-base)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=neutral]){--Badge-background-color:var(--stratakit-color-bg-mono-muted);--Badge-border-color:var(--stratakit-color-border-mono-muted);--Badge-text-color:var(--stratakit-color-text-mono-faded)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=info]){--Badge-background-color:var(--stratakit-color-bg-info-muted);--Badge-border-color:var(--stratakit-color-border-info-muted);--Badge-text-color:var(--stratakit-color-text-info-faded)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=positive]){--Badge-background-color:var(--stratakit-color-bg-positive-muted);--Badge-border-color:var(--stratakit-color-border-positive-muted);--Badge-text-color:var(--stratakit-color-text-positive-faded)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=attention]){--Badge-background-color:var(--stratakit-color-bg-attention-muted);--Badge-border-color:var(--stratakit-color-border-attention-muted);--Badge-text-color:var(--stratakit-color-text-attention-faded)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=critical]){--Badge-background-color:var(--stratakit-color-bg-critical-muted);--Badge-border-color:var(--stratakit-color-border-critical-muted);--Badge-text-color:var(--stratakit-color-text-critical-faded)}.Badge:where([data-_sk-variant=muted]):where([data-_sk-tone=accent]){--Badge-background-color:var(--stratakit-color-bg-accent-muted);--Badge-border-color:var(--stratakit-color-border-accent-muted);--Badge-text-color:var(--stratakit-color-text-accent-faded)}.Badge:where([data-_sk-variant=outline]){--Badge-background-color:transparent}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=neutral]){--Badge-text-color:var(--stratakit-color-text-mono-base);--Badge-border-color:var(--stratakit-color-border-mono-base)}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=info]){--Badge-text-color:var(--stratakit-color-text-info-base);--Badge-border-color:var(--stratakit-color-border-info-base)}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=positive]){--Badge-text-color:var(--stratakit-color-text-positive-base);--Badge-border-color:var(--stratakit-color-border-positive-base)}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=attention]){--Badge-text-color:var(--stratakit-color-text-attention-base);--Badge-border-color:var(--stratakit-color-border-attention-base)}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=critical]){--Badge-text-color:var(--stratakit-color-text-critical-base);--Badge-border-color:var(--stratakit-color-border-critical-base)}.Badge:where([data-_sk-variant=outline]):where([data-_sk-tone=accent]){--Badge-text-color:var(--stratakit-color-text-accent-base);--Badge-border-color:var(--stratakit-color-border-accent-base)}}@media (forced-colors:active){.Badge{border:1px solid}}@layer base{.Button{-webkit-user-select:none;user-select:none;cursor:pointer;line-height:1.2;font-size:var(--stratakit-font-size-12);justify-content:center;align-items:center;gap:var(--stratakit-space-x1);min-block-size:1.5rem;padding-inline:var(--Button-padding-inline,var(--stratakit-space-x3));padding-block:var(--stratakit-space-x1);--GhostAligner-inline-offset:var(--stratakit-space-x3);--GhostAligner-block-offset:var(--stratakit-space-x1);background-color:var(--Button-background-color);box-shadow:0px 0px 0px 1px var(--Button-border-color)inset;color:var(--Button-color,var(--stratakit-color-text-neutral-primary));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-neutral-pressed);--Icon-color:var(--Button-state--default,var(--stratakit-color-icon-neutral-base))var(--Button-state--hover,var(--stratakit-color-icon-neutral-hover))var(--Button-state--pressed,var(--stratakit-color-icon-neutral-hover))var(--Button-state--active,var(--stratakit-color-icon-accent-strong));border:none;border-radius:4px;flex-shrink:0;font-weight:500;text-decoration:none;transition:background-color .15s ease-out;display:inline-flex;position:relative}}@layer modifiers{.Button:where([data-_sk-variant=solid]){--Button-background-color:var(--Button-state--default,var(--Button-bg--solid-default))var(--Button-state--hover,color-mix(in oklch,var(--Button-bg--solid-default)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--Button-bg--solid-default)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-pressed-\%)))var(--Button-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--disabled,var(--stratakit-color-bg-glow-on-surface-disabled));box-shadow:var(--Button-state--default,var(--stratakit-shadow-button-base-inset),0px 0px 0px 1px var(--Button-border-color)inset,var(--stratakit-shadow-button-base-drop))var(--Button-state--hover,var(--stratakit-shadow-button-base-inset),0px 0px 0px 1px var(--Button-border-color)inset,var(--stratakit-shadow-button-base-drop))var(--Button-state--pressed,0px 0px 0px 1px var(--Button-border-color)inset)var(--Button-state--active,0px 0px 0px 1px var(--Button-border-color)inset)var(--Button-state--disabled,none)}.Button:where([data-_sk-variant=solid]):where([data-_sk-tone=neutral]){--Button-bg--solid-default:var(--stratakit-color-bg-neutral-base);--Button-border-color:var(--Button-state--default,var(--stratakit-color-border-shadow-base))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-border-shadow-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-border-shadow-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-pressed-\%)))var(--Button-state--active,var(--stratakit-color-border-accent-strong))var(--Button-state--disabled,transparent)}.Button:where([data-_sk-variant=solid]):where([data-_sk-tone=accent]){--Button-bg--solid-default:var(--stratakit-color-bg-accent-base);--Button-border-color:var(--Button-state--default,var(--stratakit-color-border-shadow-strong))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-border-shadow-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-border-shadow-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-pressed-\%)))var(--Button-state--active,var(--stratakit-color-border-accent-strong))var(--Button-state--disabled,transparent);--Button-color:var(--stratakit-color-text-neutral-emphasis);--Icon-color:var(--stratakit-color-icon-neutral-emphasis);-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-accent-pressed)}.Button:where([data-_sk-variant=outline]):where([data-_sk-tone=neutral]){--Button-background-color:var(--Button-state--default,transparent)var(--Button-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--Button-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed))var(--Button-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--disabled,transparent);--Button-border-color:var(--Button-state--default,var(--stratakit-color-border-neutral-base))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-border-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-border-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-pressed-\%)))var(--Button-state--active,var(--stratakit-color-border-accent-strong))var(--Button-state--disabled,var(--stratakit-color-border-glow-on-surface-disabled))}.Button:where([data-_sk-variant=outline]):where([data-_sk-tone=accent]){--Button-background-color:var(--Button-state--default,transparent)var(--Button-state--hover,var(--stratakit-color-bg-glow-on-surface-accent-hover))var(--Button-state--pressed,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--disabled,transparent);--Button-border-color:var(--Button-state--default,var(--stratakit-color-border-accent-base))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-border-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-border-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-pressed-\%)))var(--Button-state--active,var(--stratakit-color-border-accent-strong))var(--Button-state--disabled,var(--stratakit-color-border-glow-on-surface-disabled));--Button-color:var(--Button-state--default,var(--stratakit-color-text-accent-strong))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-pressed-\%)));--Icon-color:var(--Button-state--default,var(--stratakit-color-icon-accent-strong))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-icon-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-icon-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-icon-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-icon-glow-strong-pressed-\%)))}.Button:where([data-_sk-variant=ghost]){--Button-border-color:var(--Button-state--default,transparent)var(--Button-state--hover,transparent)var(--Button-state--pressed,transparent)var(--Button-state--active,var(--stratakit-color-border-accent-strong))var(--Button-state--disabled,transparent)}.Button:where([data-_sk-variant=ghost]):where([data-_sk-tone=neutral]){--Button-background-color:var(--Button-state--default,transparent)var(--Button-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--Button-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed))var(--Button-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--disabled,transparent)}.Button:where([data-_sk-variant=ghost]):where([data-_sk-tone=accent]){--Button-background-color:var(--Button-state--default,transparent)var(--Button-state--hover,var(--stratakit-color-bg-glow-on-surface-accent-hover))var(--Button-state--pressed,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--Button-state--disabled,transparent);--Button-color:var(--Button-state--default,var(--stratakit-color-text-accent-strong))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-text-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-text-glow-strong-pressed-\%)));--Icon-color:var(--Button-state--default,var(--stratakit-color-icon-accent-strong))var(--Button-state--hover,color-mix(in oklch,var(--stratakit-color-icon-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-icon-glow-strong-hover-\%)))var(--Button-state--pressed,color-mix(in oklch,var(--stratakit-color-icon-accent-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-icon-glow-strong-pressed-\%)))}}@layer states{@media (any-hover:hover){.Button:where(:hover){--Button-state:var(--Button-state--hover)}}.Button:where([data-has-popover-open]){--Button-state:var(--Button-state--hover)}.Button:where(:active){--Button-state:var(--Button-state--pressed)}.Button:where([aria-pressed=true]){--Button-state:var(--Button-state--active)}.Button:where(:disabled,[aria-disabled=true]){--Button-state:var(--Button-state--disabled);color:var(--stratakit-color-text-neutral-disabled);cursor:not-allowed;-webkit-tap-highlight-color:transparent;--Icon-color:var(--stratakit-color-icon-neutral-disabled)}}@layer base.{.Button{--Button-state:var(--Button-state--default);--Button-state--default:var(--Button-state, );--Button-state--hover:var(--Button-state, );--Button-state--pressed:var(--Button-state, );--Button-state--active:var(--Button-state, );--Button-state--disabled:var(--Button-state, )}}@media (forced-colors:active){.Button{color:buttontext;background-color:buttonface;border:1px solid buttonborder}.Button:where([aria-pressed=true]){color:selecteditemtext;background-color:selecteditem}.Button:where(:disabled,[aria-disabled=true]){color:graytext;border-color:graytext}}@layer base{.Checkbox{--Checkbox-color-svg:var(--stratakit-color-icon-neutral-emphasis);--Checkbox-border-radius:4px;--Checkbox-unchecked-svg:url("data:image/svg+xml;utf8,<svg viewBox=\"0 0 16 16\"></svg>");--Checkbox-checkmark-svg:url("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 16 16\"><path fill=\"currentColor\" d=\"M11.73 5.47a.75.75 0 0 1 0 1.06l-4.4 4.4a.75.75 0 0 1-1.06 0l-2-2a.75.75 0 0 1 1.06-1.06L6.8 9.34l3.87-3.87a.75.75 0 0 1 1.06 0Z\"/></svg>");--Checkbox-indeterminate-svg:url("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 16 16\"><path fill=\"currentColor\" d=\"M4.25 8A.75.75 0 0 1 5 7.25h6.5a.75.75 0 0 1 0 1.5H5A.75.75 0 0 1 4.25 8Z\"/></svg>");appearance:none;cursor:pointer;background-color:var(--Checkbox-visual-state--default,var(--stratakit-color-bg-neutral-base))var(--Checkbox-visual-state--hover,color-mix(in oklch,var(--stratakit-color-bg-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--Checkbox-visual-state--checked,var(--stratakit-color-bg-accent-base))var(--Checkbox-visual-state--checked-hover,color-mix(in oklch,var(--stratakit-color-bg-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-pressed-\%)))var(--Checkbox-visual-state--disabled,var(--stratakit-color-bg-glow-on-surface-disabled));border-radius:var(--Checkbox-border-radius);block-size:1rem;inline-size:1rem;color:var(--Checkbox-aria-state--unchecked,transparent)var(--Checkbox-aria-state--checked,var(--Checkbox-color-svg))var(--Checkbox-aria-state--indeterminate,var(--Checkbox-color-svg));box-shadow:var(--stratakit-shadow-button-base-inset),0px 0px 0px 1px var(--Checkbox-border-color)inset,var(--stratakit-shadow-button-base-drop);-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-accent-pressed);--Checkbox-border-color:var(--Checkbox-visual-state--default,var(--stratakit-color-border-shadow-base))var(--Checkbox-visual-state--hover,color-mix(in oklch,var(--stratakit-color-border-shadow-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%)))var(--Checkbox-visual-state--checked,var(--stratakit-color-border-shadow-strong))var(--Checkbox-visual-state--checked-hover,color-mix(in oklch,var(--stratakit-color-border-shadow-strong)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-pressed-\%)))var(--Checkbox-visual-state--disabled,transparent);--Checkbox-mask-image:var(--Checkbox-aria-state--unchecked,var(--Checkbox-unchecked-svg))var(--Checkbox-aria-state--checked,var(--Checkbox-checkmark-svg))var(--Checkbox-aria-state--indeterminate,var(--Checkbox-indeterminate-svg));transition:background-color .15s ease-out,border-color .15s ease-out,box-shadow .15s ease-out,--Checkbox-border-color .15s ease-out;position:relative}.Checkbox:before,.Checkbox:after{content:"";position:absolute;inset:0}.Checkbox:before{inset:calc((1rem - var(--stratakit-space-x6))/2)}.Checkbox:after{-webkit-mask-image:var(--Checkbox-mask-image,initial);mask-image:var(--Checkbox-mask-image,initial);background-color:currentColor;-webkit-mask-position:50%;mask-position:50%;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}}@layer states{@media (any-hover:hover){.Checkbox:where(:hover){--Checkbox-visual-state:var(--Checkbox-visual-state--hover)}}.Checkbox:where(:checked,[aria-checked=true]){--Checkbox-visual-state:var(--Checkbox-visual-state--checked);--Checkbox-aria-state:var(--Checkbox-aria-state--checked)}@media (any-hover:hover){.Checkbox:where(:checked,[aria-checked=true]):where(:hover){--Checkbox-visual-state:var(--Checkbox-visual-state--checked-hover)}}.Checkbox:where(:indeterminate,[aria-checked=mixed]){--Checkbox-visual-state:var(--Checkbox-visual-state--checked);--Checkbox-aria-state:var(--Checkbox-aria-state--indeterminate)}.Checkbox:where(:disabled,[aria-disabled=true]){--Checkbox-visual-state:var(--Checkbox-visual-state--disabled);--Checkbox-color-svg:var(--stratakit-color-icon-neutral-disabled);cursor:not-allowed;box-shadow:none;-webkit-tap-highlight-color:transparent}}@layer base.{.Checkbox{--Checkbox-visual-state:var(--Checkbox-visual-state--default);--Checkbox-visual-state--default:var(--Checkbox-visual-state, );--Checkbox-visual-state--hover:var(--Checkbox-visual-state, );--Checkbox-visual-state--checked:var(--Checkbox-visual-state, );--Checkbox-visual-state--checked-hover:var(--Checkbox-visual-state, );--Checkbox-visual-state--disabled:var(--Checkbox-visual-state, );--Checkbox-aria-state:var(--Checkbox-aria-state--unchecked);--Checkbox-aria-state--unchecked:var(--Checkbox-aria-state, );--Checkbox-aria-state--checked:var(--Checkbox-aria-state, );--Checkbox-aria-state--indeterminate:var(--Checkbox-aria-state, )}}@media (forced-colors:active){.Checkbox{border:1px solid canvastext}.Checkbox:where(:checked,[type=checkbox]:indeterminate,[aria-checked=true],[aria-checked=mixed]){background-color:selecteditem}.Checkbox:where(:checked,[type=checkbox]:indeterminate,[aria-checked=true],[aria-checked=mixed]):after{background-color:selecteditemtext}.Checkbox:where(:disabled,[aria-disabled=true]){background-color:canvas;border-color:graytext}.Checkbox:where(:disabled,[aria-disabled=true]):after{background-color:graytext}}@layer modifiers{.Description.Text:where([data-_sk-tone=neutral]){color:var(--stratakit-color-text-neutral-tertiary)}.Description.Text:where([data-_sk-tone=critical]){color:var(--stratakit-color-text-critical-base)}}@layer base{.Divider{background-color:var(--stratakit-color-border-page-base);flex:none;align-self:stretch}.Divider:where(hr){border:none;margin:0}}@layer modifiers{.Divider:where(:not([aria-orientation=vertical],[data-_sk-orientation=vertical])){block-size:1px;margin-inline:var(--Divider-main-axis-margin);margin-block:var(--Divider-cross-axis-margin)}.Divider:where([aria-orientation=vertical],[data-_sk-orientation=vertical]){min-block-size:100%;inline-size:1px;margin-inline:var(--Divider-cross-axis-margin);margin-block:var(--Divider-main-axis-margin)}}@media (forced-colors:active){.Divider{background-color:canvastext}}@layer base{.IconButton.Button{aspect-ratio:1;--Button-padding-inline:var(--stratakit-space-x1);--GhostAligner-inline-offset:var(--stratakit-space-x1)}}@layer base{.IconButtonDot.Dot{position:absolute;inset-block-start:var(--stratakit-space-x05);inset-inline-end:var(--stratakit-space-x05)}}@media (forced-colors:active){.IconButton:where([inert]){border:none}:where(.IconButton[aria-pressed=true]) .IconButtonDot.Dot{background-color:selecteditemtext}}@layer base{.Kbd{font-size:var(--stratakit-font-size-12);line-height:1.3333}.Kbd{color:var(--stratakit-color-text-neutral-secondary);column-gap:var(--stratakit-space-x1);min-block-size:var(--stratakit-space-x4);flex-shrink:0;justify-content:center;align-items:center;font-family:inherit;font-weight:500;display:inline-flex}}@layer modifiers{.Kbd:where([data-_sk-variant=solid],[data-_sk-variant=muted]){background-color:var(--stratakit-color-bg-neutral-base);padding-inline:var(--stratakit-space-x1);border-radius:4px}.Kbd:where([data-_sk-variant=solid]){box-shadow:var(--stratakit-shadow-button-base-inset),0px 0px 0px 1px var(--stratakit-color-border-shadow-base)inset,var(--stratakit-shadow-button-base-drop)}.Kbd:where([data-_sk-variant=ghost]){color:var(--stratakit-color-text-neutral-tertiary)}}@media (forced-colors:active){.Kbd:where([data-_sk-variant=solid]){border:1px solid}}@layer base{.Label{color:var(--stratakit-color-text-neutral-secondary);cursor:default;font-size:var(--stratakit-font-size-12)}.Label:is(label){cursor:pointer;-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-neutral-pressed)}}@layer states{.Label:has(+:where(:disabled,[aria-disabled=true])){color:var(--stratakit-color-text-neutral-disabled)}.Label:has(+:where(:disabled,[aria-disabled=true])):is(label){cursor:not-allowed;-webkit-tap-highlight-color:transparent}}@layer base{.ProgressBar{block-size:var(--ProgressBar-size);contain:strict;background-color:var(--ProgressBar-track-color);border-radius:9999px;inline-size:100%;display:grid}.ProgressBar:before{content:"";block-size:inherit;inline-size:var(--ProgressBar-fill-size);transform:translateX(calc(-100% + var(--ProgressBar-fill-portion-shown)));border-radius:inherit;background-color:var(--ProgressBar-fill-color);animation:var(--ProgressBar-animation)}@media (prefers-reduced-motion:no-preference){.ProgressBar:where([data-_sk-variant=determinate]):before{transition:transform .15s ease-in-out}}}@layer modifiers{.ProgressBar:where([data-_sk-tone=neutral]){--ProgressBar-fill-color:var(--stratakit-color-icon-neutral-base);--ProgressBar-track-color:var(--stratakit-color-border-page-base)}.ProgressBar:where([data-_sk-tone=accent]){--ProgressBar-fill-color:var(--stratakit-color-icon-accent-strong);--ProgressBar-track-color:var(--stratakit-color-bg-accent-muted)}.ProgressBar:where([data-_sk-size=medium]){--ProgressBar-size:.125rem}.ProgressBar:where([data-_sk-size=large]){--ProgressBar-size:.25rem}.ProgressBar:where([data-_sk-variant=indeterminate]){--ProgressBar-animation:calc(4*1.5s*2)--ProgressBar-animation-indeterminate steps(4,end)infinite;--ProgressBar-fill-size:25%;--ProgressBar-fill-start-point:0%}@media (prefers-reduced-motion:no-preference){.ProgressBar:where([data-_sk-variant=indeterminate]){--ProgressBar-animation:1.5s --ProgressBar-animation-indeterminate cubic-bezier(.5,0,.5,1)4,calc(1.5s*2)--ProgressBar-animation-indeterminate-slow cubic-bezier(.5,0,.5,1)calc(4*1.5s)infinite;--ProgressBar-fill-start-point:-100%}}.ProgressBar:where([data-_sk-variant=determinate]){--ProgressBar-fill-size:100%}}@keyframes --ProgressBar-animation-indeterminate{0%{transform:translateX(var(--ProgressBar-fill-start-point))}to{transform:translate(400%)}}@keyframes --ProgressBar-animation-indeterminate-slow{0%{transform:translate(-100%)}50%{transform:translate(-95%)}to{transform:translate(400%)}}@media (forced-colors:active){.ProgressBar{--ProgressBar-fill-color:CanvasText;--ProgressBar-track-color:Canvas;outline:1px solid;outline-color:oklch(from CanvasText l c h/50%);forced-color-adjust:none}}.Radio.Checkbox{--Checkbox-border-radius:9999px;--Checkbox-checkmark-svg:url("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" ><circle cx=\"8\" cy=\"8\" r=\"4\" /></svg>");--Checkbox-indeterminate-svg:var(--Checkbox-unchecked-svg)}@layer states{.Radio.Checkbox:where(:indeterminate){--Checkbox-visual-state:var(--Checkbox-visual-state--default)}}@layer base{.Spinner{block-size:var(--Spinner-size);inline-size:var(--Spinner-size);display:inline-block}}@layer modifiers{.Spinner:where([data-_sk-tone=neutral]){--Spinner-fill-color:var(--stratakit-color-icon-neutral-base);--Spinner-track-color:var(--stratakit-color-border-page-base)}.Spinner:where([data-_sk-tone=accent]){--Spinner-fill-color:var(--stratakit-color-icon-accent-strong);--Spinner-track-color:var(--stratakit-color-bg-accent-muted)}.Spinner:where([data-_sk-size=small]){--Spinner-size:1rem}.Spinner:where([data-_sk-size=medium]){--Spinner-size:1.5rem}.Spinner:where([data-_sk-size=large]){--Spinner-size:2rem}.Spinner:where([data-_sk-size=xlarge]){--Spinner-size:3rem}.Spinner:where([data-_sk-variant=indeterminate]){--Spinner-animation:--Spinner-animation-indeterminate linear infinite;--Spinner-animation-duration:1s;--Spinner-dash-array:25 75}@media (prefers-reduced-motion){.Spinner:where([data-_sk-variant=indeterminate]){--Spinner-animation-duration:2s}}}@layer base{.SpinnerSvg{block-size:inherit;inline-size:inherit;fill:none}}.SpinnerSvgTrack{stroke:var(--Spinner-track-color)}.SpinnerSvgFill{animation:var(--Spinner-animation);animation-duration:var(--Spinner-animation-duration);stroke:var(--Spinner-fill-color);stroke-dasharray:var(--Spinner-dash-array);stroke-dashoffset:25px;stroke-linecap:round;transform-box:fill-box;transform-origin:50%}@keyframes --Spinner-animation-indeterminate{to{rotate:360deg}}@media (forced-colors:active){.Spinner{--Spinner-fill-color:Canvas;--Spinner-track-color:CanvasText}.Spinner:where([data-_sk-variant=indeterminate]){--Spinner-dash-array:75 25}.SpinnerSvgTrack{stroke-width:2px}.SpinnerSvgFill{stroke-dashoffset:0}}@layer base{.SelectRoot:where(:has(select.Select),[data-_sk-has-select=true]){isolation:isolate;align-items:center;display:inline-grid}.SelectRoot:where(:has(select.Select),[data-_sk-has-select=true])>*{grid-area:1/1/-1/-1}}@layer base{.Select.Button{min-inline-size:calc(var(--stratakit-space-x2) + 1ch + calc(var(--stratakit-space-x1) + var(--stratakit-space-x4) + var(--stratakit-space-x1)));text-overflow:ellipsis}.Select.Button:where(select:not([multiple])){appearance:none;--Button-padding-inline:var(--stratakit-space-x2)calc(var(--stratakit-space-x1) + var(--stratakit-space-x4) + var(--stratakit-space-x1));--GhostAligner-inline-offset:var(--stratakit-space-x2)}.Select.Button:where(select:not([multiple]))>option{background-color:var(--stratakit-color-bg-neutral-base)}}@layer base{.SelectArrow.DisclosureArrow{pointer-events:none;z-index:1;--Icon-color:var(--SelectArrow-state--default,var(--stratakit-color-icon-neutral-base))var(--SelectArrow-state--hover,var(--stratakit-color-icon-neutral-hover))var(--SelectArrow-state--disabled,var(--stratakit-color-icon-neutral-disabled));justify-self:end;margin-inline-end:var(--stratakit-space-x1)}}@layer states{@media (any-hover:hover){:where(.Select:hover)+.SelectArrow.DisclosureArrow{--SelectArrow-state:var(--SelectArrow-state--hover)}}:where(.Select:disabled)+.SelectArrow.DisclosureArrow{--SelectArrow-state:var(--SelectArrow-state--disabled)}}@layer base.{.SelectArrow.DisclosureArrow{--SelectArrow-state:var(--SelectArrow-state--default);--SelectArrow-state--default:var(--SelectArrow-state, );--SelectArrow-state--hover:var(--SelectArrow-state, );--SelectArrow-state--disabled:var(--SelectArrow-state, )}}@layer base{.Skeleton{background-color:var(--stratakit-color-bg-glow-on-surface-disabled);border-radius:var(--Skeleton-border-radius);block-size:var(--Skeleton-height);inline-size:var(--Skeleton-width)}@media (prefers-reduced-motion:no-preference){.Skeleton{background:linear-gradient(to right,oklch(from var(--stratakit-color-glow-hue)l c h/.04)40.0%,oklch(from var(--stratakit-color-glow-hue)l c h/.08)50.0%,oklch(from var(--stratakit-color-glow-hue)l c h/.04)60%);background-position-x:100%;background-size:300%;background-attachment:fixed;animation:1.6s cubic-bezier(.32,1,.64,1) infinite --Skeleton-shimmer}}}@layer modifiers{.Skeleton:where([data-_sk-variant=text]){--Skeleton-width:100%;--Skeleton-border-radius:2px}.Skeleton:where([data-_sk-variant=text]):where([data-_sk-size=xsmall]){--Skeleton-height:.75rem}.Skeleton:where([data-_sk-variant=text]):where([data-_sk-size=small]){--Skeleton-height:.875rem}.Skeleton:where([data-_sk-variant=text]):where([data-_sk-size=medium]){--Skeleton-height:1rem}.Skeleton:where([data-_sk-variant=text]):where([data-_sk-size=large]){--Skeleton-height:1.25rem}.Skeleton:where([data-_sk-variant=text]):where([data-_sk-size=xlarge]){--Skeleton-height:1.5rem}.Skeleton:where([data-_sk-variant=object]):where([data-_sk-size=xsmall]){--Skeleton-border-radius:2px;--Skeleton-height:.75rem;--Skeleton-width:.75rem}.Skeleton:where([data-_sk-variant=object]):where([data-_sk-size=small]){--Skeleton-border-radius:2px;--Skeleton-height:1rem;--Skeleton-width:1rem}.Skeleton:where([data-_sk-variant=object]):where([data-_sk-size=medium]){--Skeleton-border-radius:4px;--Skeleton-height:1.5rem;--Skeleton-width:1.5rem}.Skeleton:where([data-_sk-variant=object]):where([data-_sk-size=large]){--Skeleton-border-radius:4px;--Skeleton-height:2rem;--Skeleton-width:2rem}.Skeleton:where([data-_sk-variant=object]):where([data-_sk-size=xlarge]){--Skeleton-border-radius:4px;--Skeleton-height:3rem;--Skeleton-width:3rem}}@keyframes --Skeleton-shimmer{to{background-position-x:0%}}@media (forced-colors:active){.Skeleton{background-color:#0000;border:1px solid}}@layer base{.Switch{appearance:none;cursor:pointer;background-color:var(--Switch-state--default,var(--stratakit-color-bg-page-base))var(--Switch-state--hover,color-mix(in oklch,var(--stratakit-color-bg-page-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--Switch-state--pressed,color-mix(in oklch,var(--stratakit-color-bg-page-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--Switch-state--checked,var(--stratakit-color-bg-accent-base))var(--Switch-state--checked-hover,color-mix(in oklch,var(--stratakit-color-bg-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-strong-hover-\%)))var(--Switch-state--disabled,var(--stratakit-color-bg-page-base));border:1px solid #0000;border-color:var(--Switch-state--default,var(--stratakit-color-border-neutral-base))var(--Switch-state--hover,color-mix(in oklch,var(--stratakit-color-border-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%)))var(--Switch-state--pressed,color-mix(in oklch,var(--stratakit-color-border-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-pressed-\%)))var(--Switch-state--checked,color-mix(in oklch,var(--stratakit-color-bg-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-hover-\%)))var(--Switch-state--checked-hover,color-mix(in oklch,var(--stratakit-color-bg-accent-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-strong-hover-\%)))var(--Switch-state--disabled,var(--stratakit-color-border-glow-on-surface-disabled));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-accent-pressed);border-radius:9999px;align-items:center;block-size:auto;inline-size:2rem;transition:background-color .15s ease-out,border-color .15s ease-out;display:inline-grid;position:relative}.Switch:before,.Switch:after{content:"";grid-area:1/1/-1/-1;display:block}.Switch:before{inline-size:2rem;block-size:var(--stratakit-space-x6);margin:-1px;position:absolute}.Switch:after{background-color:var(--Switch-thumb-color);block-size:1rem;inline-size:1rem;box-shadow:var(--stratakit-shadow-button-base-inset),0px 0px 0px 1px var(--stratakit-color-border-shadow-base)inset,var(--stratakit-shadow-button-base-drop);border-radius:var(--Switch-thumb-radius,9999px);transform-origin:0;transform:var(--Switch-thumb-transform);margin:calc(.125rem - 1px)}@media (prefers-reduced-motion:no-preference){.Switch:after{will-change:transform,border-radius;transition:transform .15s ease-out,border-radius .15s ease-out}}}@layer states{.Switch{--Switch-thumb-color:var(--stratakit-color-bg-neutral-inverse)}@media (any-hover:hover){.Switch:where(:hover){--Switch-state:var(--Switch-state--hover)}}.Switch:where(:checked,[aria-checked=true]){--Switch-state:var(--Switch-state--checked);--Switch-thumb-transform:translateX(75.0%)}@media (any-hover:hover){.Switch:where(:checked,[aria-checked=true]):where(:hover){--Switch-state:var(--Switch-state--checked-hover)}}.Switch:where(:active){--Switch-state:var(--Switch-state--pressed);--Switch-thumb-transform:scaleX(1.75);--Switch-thumb-radius:calc(9999px/1.75)/9999px}.Switch:where(:disabled,[aria-disabled=true]){--Switch-state:var(--Switch-state--disabled);--Switch-thumb-color:var(--stratakit-color-icon-neutral-disabled);cursor:not-allowed;-webkit-tap-highlight-color:transparent}.Switch:where(:disabled,[aria-disabled=true]):after{box-shadow:none}}@layer base.{.Switch{--Switch-state:var(--Switch-state--default);--Switch-state--default:var(--Switch-state, );--Switch-state--hover:var(--Switch-state, );--Switch-state--pressed:var(--Switch-state, );--Switch-state--checked:var(--Switch-state, );--Switch-state--checked-hover:var(--Switch-state, );--Switch-state--disabled:var(--Switch-state, )}}@media (forced-colors:active){.Switch{--Switch-thumb-color:CanvasText;border-color:canvastext}.Switch:where(:checked,[aria-checked=true]){--Switch-thumb-color:SelectedItemText;background-color:selecteditem}.Switch:where(:disabled,[aria-disabled=true]){--Switch-thumb-color:GrayText;background-color:canvas;border-color:graytext}}@layer modifiers{.Text:where([data-_sk-text-variant=display-lg]){font-size:var(--stratakit-font-size-48);line-height:1.1667}.Text:where([data-_sk-text-variant=display-md]){font-size:var(--stratakit-font-size-40);line-height:1.2}.Text:where([data-_sk-text-variant=display-sm]){font-size:var(--stratakit-font-size-32);line-height:1.25}.Text:where([data-_sk-text-variant=headline-lg]){font-size:var(--stratakit-font-size-28);line-height:1.2857}.Text:where([data-_sk-text-variant=headline-md]){font-size:var(--stratakit-font-size-24);line-height:1.3333}.Text:where([data-_sk-text-variant=headline-sm]){font-size:var(--stratakit-font-size-20);line-height:1.4}.Text:where([data-_sk-text-variant=body-lg]){font-size:var(--stratakit-font-size-16);line-height:1.5}.Text:where([data-_sk-text-variant=body-md]){font-size:var(--stratakit-font-size-14);line-height:1.4286}.Text:where([data-_sk-text-variant=body-sm]){font-size:var(--stratakit-font-size-12);line-height:1.3333}.Text:where([data-_sk-text-variant=caption-lg]){font-size:var(--stratakit-font-size-11);line-height:1.4545}.Text:where([data-_sk-text-variant=caption-md]){font-size:var(--stratakit-font-size-10);line-height:1.2}.Text:where([data-_sk-text-variant=caption-sm]){font-size:var(--stratakit-font-size-8);line-height:1.5}.Text:where([data-_sk-text-variant=mono-sm]){font-family:var(--stratakit-font-family-mono);font-size:var(--stratakit-font-size-12);line-height:1.3333}}@layer base{.TextBox{cursor:var(--TextBox-cursor);font-size:var(--stratakit-font-size-12);min-block-size:1.5rem;min-inline-size:0;padding-inline:var(--stratakit-space-x2);background-color:var(--TextBox-background-color);color:var(--stratakit-color-text-neutral-primary);-webkit-tap-highlight-color:transparent;--TextBox-cursor:text;--TextBox-background-color:var(--TextBox-state--default,var(--stratakit-color-bg-page-base))var(--TextBox-state--hover,color-mix(in oklch,var(--stratakit-color-bg-page-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--TextBox-state--disabled,var(--stratakit-color-bg-control-textbox));--TextBox-border-color:var(--TextBox-state--default,var(--stratakit-color-border-neutral-base))var(--TextBox-state--hover,color-mix(in oklch,var(--stratakit-color-border-neutral-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%)))var(--TextBox-state--disabled,var(--stratakit-color-border-glow-on-surface-disabled));--TextBox-box-shadow:var(--TextBox-state--default,var(--stratakit-shadow-input-base))var(--TextBox-state--hover,var(--stratakit-shadow-input-base))var(--TextBox-state--disabled,none);border-radius:4px;transition:background-color .15s ease-out,border-color .15s ease-out}.TextBox:where(:not(input,textarea)){align-items:center;gap:var(--stratakit-space-x1);display:inline-flex;position:relative}.TextBox:where(:not(input,textarea)):before{content:"";border-radius:inherit;pointer-events:none;border:1px solid var(--TextBox-border-color);box-shadow:var(--TextBox-box-shadow);transition:border-color .15s ease-out;position:absolute;inset:0}.TextBox:where(:not(input,textarea)):where(:not(:has(.TextBoxDecoration~:is(input,textarea)))){padding-inline-start:0}.TextBox:where(:not(input,textarea)):where(:not(:has(.TextBoxDecoration~:is(input,textarea)))) :where(input,textarea){padding-inline-start:var(--stratakit-space-x2)}.TextBox:where(:not(input,textarea)):where(:not(:has(:is(input,textarea)~.TextBoxDecoration))){padding-inline-end:0}.TextBox:where(:not(input,textarea)):where(:not(:has(:is(input,textarea)~.TextBoxDecoration))) :where(input,textarea){padding-inline-end:var(--stratakit-space-x2)}.TextBox:where(input,textarea){box-shadow:var(--TextBox-box-shadow)}.TextBox:where(input,textarea),.TextBox :where(input,textarea){appearance:none;border:1px solid var(--TextBox-border-color);min-inline-size:0;cursor:var(--TextBox-cursor);padding-block:max(0px,(1.5rem - var(--stratakit-space-x05) - 1lh)/2);line-height:1.3}:is(.TextBox:where(input,textarea),.TextBox :where(input,textarea))::placeholder{color:var(--stratakit-color-text-neutral-secondary);opacity:1;-webkit-user-select:none;user-select:none}.TextBox:where(textarea),.TextBox :where(textarea){resize:vertical;resize:block}.TextBox :where(input,textarea){background-color:var(--TextBox-background-color);border-radius:inherit;outline:unset;min-height:inherit;border:none;flex:999;align-self:stretch;transition:background-color .15s ease-out}}@layer states{@media (any-hover:hover){.TextBox:where(:hover){--TextBox-state:var(--TextBox-state--hover)}}.TextBox:where(:has(:is(input,textarea):focus-visible),:is(input,textarea):focus-visible){outline:var(--focus-outline);outline-offset:var(--focus-outline-offset);--TextBox-border-color:var(--stratakit-color-border-accent-strong);--Icon-color:var(--stratakit-color-icon-accent-strong)}@supports not selector(:has(+ *)){.TextBox:where(:not(input,textarea):focus-within){outline:var(--focus-outline);outline-offset:var(--focus-outline-offset);--TextBox-border-color:var(--stratakit-color-border-accent-strong);--Icon-color:var(--stratakit-color-icon-accent-strong)}}.TextBox:where(:disabled,[aria-disabled=true],[data-_sk-disabled=true],:has(:is(input,textarea):is(:disabled,[aria-disabled=true]))){--TextBox-state:var(--TextBox-state--disabled);color:var(--stratakit-color-text-neutral-disabled);--TextBox-cursor:not-allowed}}@layer base.{.TextBox{--TextBox-state:var(--TextBox-state--default);--TextBox-state--default:var(--TextBox-state, );--TextBox-state--hover:var(--TextBox-state, );--TextBox-state--disabled:var(--TextBox-state, )}}@layer base{.TextBoxDecoration{flex-shrink:0}}@media (forced-colors:active){.TextBox{--TextBox-background-color:Field;--TextBox-border-color:CanvasText;color:fieldtext}.TextBox:where(:disabled,[aria-disabled=true],[data-_sk-disabled=true],:has(:is(input,textarea):is(:disabled,[aria-disabled=true]))){--TextBox-border-color:GrayText;color:graytext}}@layer base{.Tooltip{font-size:var(--stratakit-font-size-12);line-height:1.3333}.Tooltip{background-color:var(--stratakit-color-bg-elevation-emphasis);box-shadow:var(--stratakit-shadow-tooltip-base);color:var(--stratakit-color-text-neutral-emphasis);justify-content:center;gap:var(--stratakit-space-x1);border:1px solid var(--stratakit-color-border-elevation-base);padding-block:calc(var(--stratakit-space-x1) - 1px);padding-inline:calc(var(--stratakit-space-x2) - 1px);border-radius:4px;min-block-size:1rem;max-inline-size:12.25rem;display:flex}}@layer base{.Field{gap:var(--stratakit-space-x1);--FieldDescription-column:label-start/label-end;grid-template-columns:[label-start]auto[label-end control-start]auto[control-end];justify-content:start;align-items:center;display:grid}.Field:where([data-_sk-control-type=checkable][data-_sk-label-placement=after]){grid-template-columns:[control-start]auto[control-end label-start]auto[label-end]}.Field:where([data-_sk-control-type=textlike]){--FieldDescription-column:control-start/control-end;align-items:baseline}.Field:where([data-_sk-control-type=textlike]):where(:not([data-_sk-layout=inline])){grid-template-columns:[label-start control-start]auto[label-end control-end];justify-content:stretch}.Field :where(.Description){grid-column:var(--FieldDescription-column)}}@layer base{.ListItem{cursor:pointer;line-height:1.2;font-size:var(--stratakit-font-size-12);min-block-size:var(--ListItem-height,1.75rem);padding-inline:var(--stratakit-space-x2);background-color:var(--ListItem-background-color);--ListItem-background-color:var(--ListItem-state--default,transparent)var(--ListItem-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--ListItem-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed))var(--ListItem-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--ListItem-state--active-hover,color-mix(in oklch,var(--stratakit-color-bg-glow-on-surface-accent-pressed)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-strong-hover-\%)))var(--ListItem-state--disabled,transparent);color:var(--ListItem-color,var(--ListItem-state--default,var(--stratakit-color-text-neutral-primary))var(--ListItem-state--hover,var(--stratakit-color-text-neutral-primary))var(--ListItem-state--pressed,var(--stratakit-color-text-neutral-primary))var(--ListItem-state--active,var(--stratakit-color-text-accent-strong))var(--ListItem-state--active-hover,var(--stratakit-color-text-accent-strong))var(--ListItem-state--disabled,var(--stratakit-color-text-neutral-disabled)));--Icon-color:var(--ListItem-state--default,var(--stratakit-color-icon-neutral-base))var(--ListItem-state--hover,var(--stratakit-color-icon-neutral-hover))var(--ListItem-state--pressed,var(--stratakit-color-icon-neutral-hover))var(--ListItem-state--active,var(--stratakit-color-icon-accent-strong))var(--ListItem-state--active-hover,var(--stratakit-color-icon-accent-strong))var(--ListItem-state--disabled,var(--stratakit-color-icon-neutral-disabled));grid-template-columns:[decoration-before-start]auto[decoration-before-end content-start]minmax(0,1fr)[content-end decoration-after-start]auto[decoration-after-end];align-content:center;align-items:center;display:grid}}@layer states{@media (any-hover:hover){.ListItem:where(:hover){--ListItem-state:var(--ListItem-state--hover)}}.ListItem:where(:active){--ListItem-state:var(--ListItem-state--pressed)}.ListItem:where(:disabled,[aria-disabled=true]){--ListItem-state:var(--ListItem-state--disabled);cursor:not-allowed}}@layer modifiers{.ListItem:where(:has(>:nth-child(2 of .ListItemContent))){--ListItem-height:2.75rem;grid-template-rows:repeat(auto-fit,minmax(0,auto))}}@layer base.{.ListItem{--ListItem-state:var(--ListItem-state--default);--ListItem-state--default:var(--ListItem-state, );--ListItem-state--hover:var(--ListItem-state, );--ListItem-state--pressed:var(--ListItem-state, );--ListItem-state--active:var(--ListItem-state, );--ListItem-state--active-hover:var(--ListItem-state, );--ListItem-state--disabled:var(--ListItem-state, )}}@layer base{.ListItemContent{grid-column:content}}@layer base{.ListItemDecoration{grid-area:1/decoration-before/-1;align-self:start;align-items:center;margin-inline-end:var(--stratakit-space-x1);display:flex}:where(.ListItemContent)~.ListItemDecoration{margin-inline:var(--stratakit-space-x1)0;grid-column:decoration-after}}@media (forced-colors:active){.ListItem:where(:disabled,[aria-disabled=true]){color:graytext}}.AccordionItem{--AccordionItem-gap:var(--stratakit-space-x3);--AccordionItem-padding:var(--stratakit-space-x3)}@layer base{.AccordionItem{contain:paint;border-block-end:1px solid var(--stratakit-color-border-neutral-muted);grid-template-rows:[header-start]auto[header-end content-start]auto[content-end];grid-template-columns:[marker-before-start]auto[marker-before-end decoration-before-start]auto[decoration-before-end header-content-start body-content-start]minmax(0,1fr)[header-content-end decoration-after-start]auto[decoration-after-end marker-after-start]auto[marker-after-end body-content-end];display:grid}}@layer states{.AccordionItem:where([data-_sk-open=true]){--ChevronDown-rotate:-.5turn}}@layer base{.AccordionItemHeader{background-color:var(--AccordionItemHeader-background-color);padding:var(--AccordionItem-padding);--AccordionItemHeader-background-color:var(--AccordionItemHeader-state--default,transparent)var(--AccordionItemHeader-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--AccordionItemHeader-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed));grid-area:header/marker-before-start/header/marker-after-end;grid-template-columns:inherit;align-items:center;transition:background-color .15s ease-out;display:grid;position:relative}@supports (grid-template-columns:subgrid){.AccordionItemHeader{grid-template-columns:subgrid}}}@layer states{@media (any-hover:hover){.AccordionItemHeader:where(:hover){--AccordionItemHeader-state:var(--AccordionItemHeader-state--hover)}}.AccordionItemHeader:where(:active){--AccordionItemHeader-state:var(--AccordionItemHeader-state--pressed)}}@layer base.{.AccordionItemHeader{--AccordionItemHeader-state:var(--AccordionItemHeader-state--default);--AccordionItemHeader-state--default:var(--AccordionItemHeader-state, );--AccordionItemHeader-state--hover:var(--AccordionItemHeader-state, );--AccordionItemHeader-state--pressed:var(--AccordionItemHeader-state, )}}@layer base{.AccordionItemMarker{pointer-events:none;grid-area:1/marker-before;margin-inline-start:calc(-1*var(--GhostAligner-inline-offset));margin-inline-end:var(--AccordionItem-gap)}:where(.AccordionItemHeading,.AccordionItemButton)~.AccordionItemMarker{grid-column:marker-after;margin-inline-start:var(--AccordionItem-gap);margin-inline-end:calc(-1*var(--GhostAligner-inline-offset))}}@layer base{.AccordionItemLabel.Text{-webkit-hyphens:auto;hyphens:auto;overflow-wrap:break-word;text-box:cap alphabetic;font-weight:500;display:inline-block}}@layer base{.AccordionItemButton{cursor:pointer;border-radius:var(--stratakit-space-x3);--focus-outline-offset:calc(var(--stratakit-space-x1)*-1);grid-column:header-content}.AccordionItemButton:after{content:"";border-radius:inherit;position:absolute;inset:0}}@layer states{.AccordionItemButton:focus-visible{outline:0}.AccordionItemButton:focus-visible:after{outline:var(--focus-outline);outline-offset:var(--focus-outline-offset)}}@layer base{.AccordionItemContent{padding-block:var(--AccordionItem-padding);text-box:cap alphabetic;color:var(--stratakit-color-text-neutral-secondary);grid-area:content/body-content}}@layer base{.AccordionItemDecoration{align-items:center;gap:var(--stratakit-space-x1);grid-column:decoration-before;margin-inline-end:var(--AccordionItem-gap);display:flex}:where(.AccordionItemHeading,.AccordionItemButton)~.AccordionItemDecoration{grid-column:decoration-after;margin-inline-start:var(--AccordionItem-gap);margin-inline-end:0}}@layer base{.AccordionItemHeading{text-box:cap alphabetic;grid-column:header-content;margin-block:0}}@layer base{.Banner{background-color:var(--Banner-color-background);border:1px solid var(--Banner-color-border);padding:var(--stratakit-space-x3);border-radius:8px;grid-template-columns:[start]auto[content]minmax(0,1fr)[end]auto;align-items:center;inline-size:100%;display:grid}}@layer modifiers{.Banner:where([data-_sk-variant=outline]){--Banner-color-background:var(--stratakit-color-bg-elevation-base)}.Banner:where([data-_sk-variant=outline]):where([data-_sk-tone=neutral]){--Banner-color-border:var(--stratakit-color-border-neutral-base)}.Banner:where([data-_sk-tone=info]){--Banner-color-border:var(--stratakit-color-border-info-base);--Icon-color:var(--stratakit-color-icon-info-base)}.Banner:where([data-_sk-tone=positive]){--Banner-color-border:var(--stratakit-color-border-positive-base);--Icon-color:var(--stratakit-color-icon-positive-base)}.Banner:where([data-_sk-tone=attention]){--Banner-color-border:var(--stratakit-color-border-attention-base);--Icon-color:var(--stratakit-color-icon-attention-base)}.Banner:where([data-_sk-tone=critical]){--Banner-color-border:var(--stratakit-color-border-critical-base);--Icon-color:var(--stratakit-color-icon-critical-base)}}@layer base{.BannerIcon{grid-area:1/start;align-self:start;margin-inline-end:var(--stratakit-space-x2)}}@layer base{.BannerLabel{grid-column:content;align-self:start;margin-block-end:var(--stratakit-space-x1);font-weight:500}}@layer base{.BannerMessage{overflow-wrap:break-word;-webkit-hyphens:auto;hyphens:auto;grid-column:content;overflow:hidden}}@layer base{.BannerActions{justify-self:start;align-items:baseline;gap:var(--stratakit-space-x2);flex-wrap:wrap;grid-column:content;margin-block-start:var(--stratakit-space-x3);display:flex}}@layer base{.BannerDismissButton{grid-area:1/end;align-self:start;margin-inline-start:var(--stratakit-space-x3)}}@media (forced-colors:active){.Banner{--Icon-color:CanvasText}}@layer base{.Chip{isolation:isolate;--Chip-padding-inline:var(--stratakit-space-x2);padding-inline:var(--Chip-padding-inline);border:none;border-radius:9999px;align-items:center;min-block-size:1.5rem;display:inline-flex;position:relative}}.Chip:before{z-index:-1;content:"";border-radius:inherit;border:1px solid var(--stratakit-color-border-neutral-base);pointer-events:none;position:absolute;inset:0}@layer modifiers{.Chip:where([data-_sk-variant=solid]){background-color:var(--stratakit-color-bg-neutral-base)}.Chip:where([data-_sk-variant=outline]){background-color:var(--stratakit-color-bg-page-base)}}@layer base{.ChipLabel:where(button){border-radius:inherit}.ChipLabel:where(button):after{content:"";border-radius:inherit;position:absolute;inset:0}}@layer base{.ChipDismissButton.IconButton{border-radius:inherit;margin-inline-end:calc(-1*var(--Chip-padding-inline));position:relative}}@layer base{.DialogWrapper{block-size:100%;inline-size:100%;display:grid;position:fixed;inset:0}}@layer base{.Dialog{min-block-size:min(100%,var(--Dialog-min-block-size,94px));background-color:var(--stratakit-color-bg-elevation-base);max-block-size:calc(100% - 64px);min-inline-size:min(100%,296px);max-inline-size:calc(100% - 64px);box-shadow:var(--stratakit-shadow-dialog-base);border-radius:12px;flex-direction:column;place-self:center;padding:1px;display:flex;position:relative;overflow:auto}.Dialog:where(:has(.DialogFooter)){--Dialog-min-block-size:156px}.Dialog:where(dialog:modal){inset:0}.Dialog:where(dialog:modal)::backdrop{background-color:#0000}}@layer base{.DialogHeader{padding-block:var(--stratakit-space-x4);padding-inline:var(--stratakit-space-x5);align-items:center;display:flex}}@layer base{.DialogHeading{margin-inline-end:auto}}@layer base{.DialogContent{font-size:var(--stratakit-font-size-12);line-height:1.3333}.DialogContent{color:var(--stratakit-color-text-neutral-primary);padding-block-end:var(--stratakit-space-x5);padding-inline:var(--stratakit-space-x5)}}@layer modifiers{@media (height>=15em){.DialogContent{overflow-block:auto;overflow-y:auto}}}@layer base{.DialogFooter{border-block-start:1px solid var(--stratakit-color-border-page-base);background-color:var(--stratakit-color-bg-page-base);padding-inline:var(--stratakit-space-x5);padding-block:var(--stratakit-space-x5);border-end-end-radius:12px;border-end-start-radius:12px;align-items:center;display:flex}}@layer base{.DialogActionList{gap:var(--stratakit-space-x3);margin-inline-start:auto;display:flex}}@layer base{.DialogBackdrop{opacity:.8;background:var(--stratakit-color-bg-elevation-overlay)}}@media (forced-colors:active){.Dialog{border:1px solid}}@layer base{.DropdownMenu{background-color:var(--stratakit-color-bg-elevation-level-1);min-inline-size:min(95vi,164px);padding:var(--stratakit-space-x1);box-shadow:var(--stratakit-shadow-dropdown-base);border-radius:8px;flex-direction:column;display:flex}}@layer states{.DropdownMenuButton:where([aria-expanded=true]){--DisclosureArrow-rotate:.5turn}}@layer base{.DropdownMenuItem.ListItem{border-radius:4px}}@layer states{.DropdownMenuItem.ListItem:where([role=menuitemcheckbox]:not([aria-checked=true])){--DropdownMenuCheckmark-visibility:hidden}}@layer base{.DropdownMenuItemDot.Dot{align-self:center}}@layer base{.DropdownMenuCheckmark{visibility:var(--DropdownMenuCheckmark-visibility)}}@layer base{.DropdownMenuItemShortcuts{margin-inline-start:var(--stratakit-space-x2)}}@media (forced-colors:active){.DropdownMenu{border:1px solid}}@layer base{.ErrorRegion{z-index:1;position:relative}}@layer states{.ErrorRegion:where([data-_sk-expanded=true]){--ChevronDown-rotate:-.5turn;--ErrorRegionHeader-border-end-radius:0}.ErrorRegion:where([data-_sk-visible=true]){padding-inline:var(--stratakit-space-x1);padding-block:var(--stratakit-space-x1);block-size:2.625rem}.ErrorRegion:where([data-_sk-visible=false]){--ErrorRegionContainer-display:none}}@layer base{.ErrorRegionContainer{isolation:isolate;display:var(--ErrorRegionContainer-display,flex);border:1px solid var(--stratakit-color-border-attention-base);background-color:var(--stratakit-color-bg-elevation-base);box-shadow:var(--stratakit-shadow-surface-sm);border-radius:8px;flex-direction:column;position:relative}@media (prefers-reduced-motion:no-preference){.ErrorRegionContainer:before{content:"";border-radius:inherit;z-index:-1;position:absolute;inset:0}}}@layer base{.ErrorRegionHeader{min-block-size:2rem;border-start-start-radius:7px;border-start-end-radius:7px;border-end-end-radius:var(--ErrorRegionHeader-border-end-radius,calc(8px - 1px));border-end-start-radius:var(--ErrorRegionHeader-border-end-radius,calc(8px - 1px));flex-wrap:wrap;padding-inline-start:var(--stratakit-space-x2);padding-inline-end:var(--stratakit-space-x1);font-weight:400;transition:border-radius 0s linear .15s}}@layer base{.ErrorRegionIcon{--Icon-color:var(--stratakit-color-icon-attention-base)}}@layer base{.ErrorRegionLabel{text-align:start;overflow-wrap:break-word;flex:1;max-inline-size:100%}}@layer base{.ErrorRegionDialog{transition:max-block-size .15s linear,opacity .15s linear;overflow:hidden}}@layer states{.ErrorRegionDialog:where(:not([data-enter])){opacity:0}@media (prefers-reduced-motion:no-preference){.ErrorRegionDialog:where(:not([data-enter])){max-block-size:0}}.ErrorRegionDialog:where([data-enter]){opacity:1}@media (prefers-reduced-motion:no-preference){.ErrorRegionDialog:where([data-enter]){max-block-size:calc(348px - 2rem)}@supports (interpolate-size:allow-keywords){.ErrorRegionDialog:where([data-enter]){max-block-size:max-content}}}}@layer base{.ErrorRegionItems{border-block-start:1px solid var(--stratakit-color-border-page-base);max-block-size:calc(348px - 2rem);overflow:auto}}@layer base{.ErrorRegionItem{padding-block:calc(var(--stratakit-space-x1) + var(--stratakit-space-x2));flex-direction:column;padding-inline-start:calc(var(--stratakit-space-x2) + 1rem + var(--stratakit-space-x1));padding-inline-end:var(--stratakit-space-x1);display:flex}.ErrorRegionItem:where(:not(:nth-child(1 of .ErrorRegionItem))){border-block-start:1px solid var(--stratakit-color-border-page-base)}}@layer base{.ErrorRegionItemActions{margin-block-start:var(--stratakit-space-x2)}}@layer base{.NavigationRail{gap:var(--stratakit-space-x1);block-size:100%;min-inline-size:calc(1.5rem + 4*var(--stratakit-space-x2));inline-size:var(--NavigationRail-inline-size);background-color:var(--stratakit-color-bg-page-depth);border-inline-end:1px solid var(--stratakit-color-border-neutral-muted);--Divider-cross-axis-margin:var(--stratakit-space-x1);flex-direction:column;display:inline-flex}}@layer modifiers{.NavigationRail:where([data-_sk-expanded=true]){--NavigationRail-inline-size:256px}}@layer base{.NavigationRailHeader{padding-block:var(--stratakit-space-x2);padding-inline:var(--stratakit-space-x4);align-items:center;min-block-size:56px;display:flex;position:relative}}@layer base{.NavigationRailToggleButton{border:1px solid var(--stratakit-color-border-neutral-muted);background-color:var(--stratakit-color-bg-page-base);block-size:1rem;inline-size:1rem;color:var(--stratakit-color-icon-neutral-base);border-radius:9999px;place-items:center;margin-inline-start:auto;transition:rotate .15s ease-out;display:grid}.NavigationRailToggleButton:before{content:"";border-radius:inherit;block-size:24px;inline-size:24px;position:absolute}}@layer states{@media (any-hover:hover){.NavigationRailToggleButton:where(:hover){border-color:color-mix(in oklch,var(--stratakit-color-border-neutral-muted)100%,var(--stratakit-color-glow-hue)var(--stratakit-color-border-glow-base-hover-\%))}}:where(.NavigationRailHeader[data-_sk-collapsed=true]) .NavigationRailToggleButton{position:absolute;inset-inline-end:0;translate:50%}.NavigationRailToggleButton:where([aria-expanded=true]){rotate:180deg}}@layer base{.NavigationRailContent{padding-block:var(--stratakit-space-x1);padding-inline:var(--stratakit-space-x2);flex-direction:column;flex:999;display:flex;overflow:auto}}@layer base{.NavigationRailList{flex-direction:column;display:flex}}@layer base{.NavigationRailListItem{flex-shrink:0}}@layer base{.NavigationRailItemAction{font-size:var(--stratakit-font-size-14);line-height:1.4286}.NavigationRailItemAction{align-items:center;gap:var(--stratakit-space-x3);inline-size:-webkit-fill-available;inline-size:-moz-available;inline-size:stretch;min-block-size:calc(1.5rem + 2*var(--stratakit-space-x2));padding:var(--stratakit-space-x2);--Icon-size:1.5rem;background-color:var(--NavigationRailItemAction-state--default,transparent)var(--NavigationRailItemAction-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--NavigationRailItemAction-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed))var(--NavigationRailItemAction-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--NavigationRailItemAction-state--disabled,transparent);color:var(--NavigationRailItemAction-state--default,var(--stratakit-color-text-neutral-primary))var(--NavigationRailItemAction-state--hover,var(--stratakit-color-text-neutral-primary))var(--NavigationRailItemAction-state--pressed,var(--stratakit-color-text-neutral-primary))var(--NavigationRailItemAction-state--active,var(--stratakit-color-text-accent-strong))var(--NavigationRailItemAction-state--disabled,var(--stratakit-color-text-neutral-disabled));--Icon-color:var(--NavigationRailItemAction-state--default,var(--stratakit-color-icon-neutral-base))var(--NavigationRailItemAction-state--hover,var(--stratakit-color-icon-neutral-hover))var(--NavigationRailItemAction-state--pressed,var(--stratakit-color-icon-neutral-hover))var(--NavigationRailItemAction-state--active,var(--stratakit-color-icon-accent-strong))var(--NavigationRailItemAction-state--disabled,var(--stratakit-color-icon-neutral-disabled));border:1px solid;border-color:var(--NavigationRailItemAction-state--default,transparent)var(--NavigationRailItemAction-state--hover,transparent)var(--NavigationRailItemAction-state--pressed,transparent)var(--NavigationRailItemAction-state--active,var(--stratakit-color-border-accent-base))var(--NavigationRailItemAction-state--disabled,transparent);-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-neutral-pressed);border-radius:4px;text-decoration:none;transition:background-color .15s ease-out;display:inline-flex}}@layer states{@media (any-hover:hover){.NavigationRailItemAction:where(:hover){--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--hover)}}.NavigationRailItemAction:where([data-has-popover-open]){--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--hover)}.NavigationRailItemAction:where(:active){--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--pressed)}.NavigationRailItemAction:where([aria-pressed=true],[aria-current]:not([aria-current=false])){--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--active)}.NavigationRailItemAction:where(:disabled,[aria-disabled=true]){--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--disabled);cursor:not-allowed;-webkit-tap-highlight-color:transparent}}@layer base.{.NavigationRailItemAction{--NavigationRailItemAction-state:var(--NavigationRailItemAction-state--default);--NavigationRailItemAction-state--default:var(--NavigationRailItemAction-state, );--NavigationRailItemAction-state--hover:var(--NavigationRailItemAction-state, );--NavigationRailItemAction-state--pressed:var(--NavigationRailItemAction-state, );--NavigationRailItemAction-state--active:var(--NavigationRailItemAction-state, );--NavigationRailItemAction-state--disabled:var(--NavigationRailItemAction-state, )}}@layer base{.NavigationRailItemActionLabel{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}}@layer base{.NavigationRailFooter{margin-block-start:auto}}@layer base{.Table:where(table){table-layout:fixed;border-collapse:separate;border-spacing:0;inline-size:100%}}@layer base{.TableHeader{color:var(--stratakit-color-text-neutral-secondary)}}@layer base{.TableRow:where([role=row]){display:flex}}@layer base{.TableCaption,.TableCell{min-block-size:3rem;padding-block:var(--stratakit-space-x2);overflow-wrap:anywhere;-webkit-hyphens:auto;hyphens:auto;align-content:center;padding-inline-start:var(--stratakit-space-x4);padding-inline-end:var(--stratakit-space-x3)}:is(.TableCaption,.TableCell):where(th,td){block-size:3rem}}@layer base{.TableCell{background-color:var(--TableCell-state--default,var(--stratakit-color-bg-page-base))var(--TableCell-state--hover,color-mix(in oklch,var(--stratakit-color-bg-page-base)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-base-hover-\%)))var(--TableCell-state--active,var(--stratakit-color-bg-glow-on-surface-accent-pressed))var(--TableCell-state--active-hover,color-mix(in oklch,var(--stratakit-color-bg-glow-on-surface-accent-pressed)100.0%,var(--stratakit-color-glow-hue)var(--stratakit-color-bg-glow-strong-hover-\%)));--TableCell-border-color--active:var(--stratakit-color-border-accent-strong);border-block-end:1px solid var(--TableCell-state--default,var(--stratakit-color-border-neutral-muted))var(--TableCell-state--hover,var(--stratakit-color-border-neutral-muted))var(--TableCell-state--active,var(--TableCell-border-color--active))var(--TableCell-state--active-hover,var(--TableCell-border-color--active));min-inline-size:4rem;position:relative}.TableCell:where(:not(th,td)){column-gap:var(--stratakit-space-x2);flex-grow:1;flex-basis:4rem}.TableCell:where(th){font-weight:inherit}.TableCell:before{content:"";pointer-events:none;border-block-start:1px solid var(--TableCell-state--default,transparent)var(--TableCell-state--hover,transparent)var(--TableCell-state--active,var(--TableCell-border-color--active))var(--TableCell-state--active-hover,var(--TableCell-border-color--active));position:absolute;inset:-1px 0 0}}@layer states{@media (any-hover:hover){.TableCell:where(:hover){--TableCell-state:var(--TableCell-state--hover)}:where(.TableRow:hover) .TableCell:where([role=cell],td){--TableCell-state:var(--TableCell-state--hover)}}:where(.TableRow:has(input[type=checkbox]:checked,[role=checkbox][aria-checked=true])) .TableCell:where([role=cell],td){--TableCell-state:var(--TableCell-state--active)}@media (any-hover:hover){:where(.TableRow:hover:has(input[type=checkbox]:checked,[role=checkbox][aria-checked=true])) .TableCell:where([role=cell],td){--TableCell-state:var(--TableCell-state--active-hover)}}}@layer base.{.TableCell{--TableCell-state:var(--TableCell-state--default);--TableCell-state--default:var(--TableCell-state, );--TableCell-state--hover:var(--TableCell-state, );--TableCell-state--active:var(--TableCell-state, );--TableCell-state--active-hover:var(--TableCell-state, )}}@layer base{.TabList{--Tab-active-stripe-gap:var(--stratakit-space-x2);--Tab-active-stripe-size:var(--stratakit-space-x05);--Tab-padding-inline:var(--stratakit-space-x1);gap:var(--stratakit-space-x2);display:flex;position:relative}@supports (position-anchor:--foo){.TabList:after{content:"";position-anchor:--Tab-active-tab;inline-size:calc(anchor-size(inline) - 2*var(--Tab-padding-inline));block-size:var(--Tab-active-stripe-size);background-color:var(--Tab-active-stripe-color);will-change:transform;position:absolute;inset-block-end:calc(anchor(end) - var(--Tab-active-stripe-gap));inset-inline-start:calc(anchor(start) + var(--Tab-padding-inline))}}}@layer modifiers{.TabList[aria-orientation=horizontal]{padding-block-end:var(--Tab-active-stripe-gap)}.TabList:where([data-_sk-tone=neutral]){--Tab-active-stripe-color:var(--stratakit-color-border-neutral-inverse)}.TabList:where([data-_sk-tone=accent]){--Tab-active-stripe-color:var(--stratakit-color-border-accent-strong)}}@layer base{.Tab{font-size:var(--stratakit-font-size-12);color:var(--Tab-color);background-color:var(--Tab-background-color);block-size:1.25rem;padding-inline:var(--Tab-padding-inline);-webkit-user-select:none;user-select:none;white-space:nowrap;cursor:pointer;align-items:center;gap:var(--stratakit-space-x1);border:none;border-radius:4px;transition:background-color .15s ease-out,color .15s ease-out;display:inline-flex;position:relative}.Tab:before{content:"";inset-inline:0;inset-block:0 calc(var(--Tab-active-stripe-gap)*-1);position:absolute}}@layer modifiers{:where(.TabList[data-_sk-tone=neutral]) .Tab{--Tab-background-color:var(--Tab-state--default,transparent)var(--Tab-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--Tab-state--selected,transparent)var(--Tab-state--disabled,transparent);--Tab-color:var(--Tab-state--default,var(--stratakit-color-text-neutral-tertiary))var(--Tab-state--hover,var(--stratakit-color-text-neutral-primary))var(--Tab-state--selected,var(--stratakit-color-text-neutral-primary))var(--Tab-state--disabled,var(--stratakit-color-text-neutral-disabled));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-neutral-pressed)}:where(.TabList[data-_sk-tone=accent]) .Tab{--Tab-background-color:var(--Tab-state--default,transparent)var(--Tab-state--hover,var(--stratakit-color-bg-glow-on-surface-accent-hover))var(--Tab-state--selected,transparent)var(--Tab-state--disabled,transparent);--Tab-color:var(--Tab-state--default,var(--stratakit-color-text-neutral-tertiary))var(--Tab-state--hover,var(--stratakit-color-text-accent-strong))var(--Tab-state--selected,var(--stratakit-color-text-accent-strong))var(--Tab-state--disabled,var(--stratakit-color-text-neutral-disabled));-webkit-tap-highlight-color:var(--stratakit-color-bg-glow-on-surface-accent-pressed)}}@layer states{.Tab:where([aria-selected=true]){--Tab-state:var(--Tab-state--selected);anchor-name:--Tab-active-tab}@supports not (anchor-name:--foo){.Tab:where([aria-selected=true]):after{content:"";background-color:var(--Tab-active-stripe-color);block-size:var(--Tab-active-stripe-size);inset-inline:var(--Tab-padding-inline);inset-block:auto calc(var(--Tab-active-stripe-gap)*-1);position:absolute}}@media (any-hover:hover){.Tab:where(:hover){--Tab-state:var(--Tab-state--hover)}}.Tab:where(:disabled,[aria-disabled=true]){--Tab-state:var(--Tab-state--disabled);--Tab-active-stripe-color:var(--stratakit-color-border-neutral-disabled);cursor:not-allowed;-webkit-tap-highlight-color:transparent}}@layer base.{.Tab{--Tab-state:var(--Tab-state--default);--Tab-state--default:var(--Tab-state, );--Tab-state--hover:var(--Tab-state, );--Tab-state--selected:var(--Tab-state, );--Tab-state--disabled:var(--Tab-state, )}}@layer base{.TabPanel{--focus-outline-offset:calc(var(--stratakit-space-x05)*-1)}.TabPanel:not([data-open]){display:none!important}}@media (forced-colors:active){.TabList,.Tab{--Tab-active-stripe-color:CanvasText}.Tab{--Tab-color:CanvasText}.Tab:where([aria-selected=true]){forced-color-adjust:none;--Tab-background-color:SelectedItem;--Tab-color:SelectedItemText}.Tab:where(:disabled,[aria-disabled=true]){--Tab-color:GrayText}}@layer base{.Toolbar{gap:var(--stratakit-space-x1);background-color:var(--stratakit-color-bg-page-base);box-shadow:var(--stratakit-shadow-toolbar-base);padding:var(--stratakit-space-x1);--Divider-main-axis-margin:var(--stratakit-space-x2);--Divider-cross-axis-margin:var(--stratakit-space-x1);border-radius:8px;align-items:center;display:inline-flex}}@layer modifiers{.Toolbar:where([aria-orientation=vertical]){flex-direction:column}}@layer modifiers{.ToolbarItem.IconButton:where([data-_sk-variant=ghost]){--Button-background-color:var(--Button-state--default,transparent)var(--Button-state--hover,var(--stratakit-color-bg-glow-on-surface-neutral-hover))var(--Button-state--pressed,var(--stratakit-color-bg-glow-on-surface-neutral-pressed))var(--Button-state--active,var(--stratakit-color-bg-accent-base))var(--Button-state--disabled,var(--stratakit-color-bg-glow-on-surface-disabled));--Icon-color:var(--Button-state--default,var(--stratakit-color-icon-neutral-base))var(--Button-state--hover,var(--stratakit-color-icon-neutral-hover))var(--Button-state--pressed,var(--stratakit-color-icon-neutral-hover))var(--Button-state--active,var(--stratakit-color-icon-neutral-emphasis));--Button-border-color:var(--Button-state--default,transparent)var(--Button-state--hover,transparent)var(--Button-state--pressed,transparent)var(--Button-state--active,var(--stratakit-color-border-accent-base))var(--Button-state--disabled,transparent)}}@media (forced-colors:active){.Toolbar{border:1px solid}}@layer base{.Tree{background-color:var(--stratakit-color-bg-page-base);align-content:start;display:grid;overflow:auto}}@layer base{.TreeItem{min-inline-size:max-content;position:relative}}@layer states{.TreeItem:focus-visible{isolation:isolate;outline:none}.TreeItem:focus-visible:before{content:"";z-index:1;pointer-events:none;outline:var(--focus-outline);outline-offset:-1px;position:absolute;inset:0}@media (any-hover:hover){.TreeItem:where(:not(:hover,:focus-visible,:has(:focus-visible),:has([data-has-popover-open]))){--TreeItem-action-visibility:hidden}@supports not selector(:has(+ *)){.TreeItem{--TreeItem-action-visibility:visible}}}}@layer base{.TreeItemNode.ListItem{isolation:isolate;--ListItem-color:var(--TreeItem-color);padding-inline-start:calc(var(--stratakit-space-x2) + calc(var(--stratakit-space-x1) + var(--stratakit-space-x05))*(var(--TreeItem-level) - 1));padding-inline-end:0;position:relative}}@layer modifiers{.TreeItemNode.ListItem:where([data-_sk-error=true]){--Icon-color:var(--stratakit-color-icon-attention-base);--TreeItem-color:var(--stratakit-color-text-attention-base)}}@layer states{.TreeItemNode.ListItem:where([data-_sk-selected=true]){--ListItem-state:var(--ListItem-state--active)}@media (any-hover:hover){.TreeItemNode.ListItem:where(:hover[data-_sk-selected=true]){--ListItem-state:var(--ListItem-state--active-hover)}}.TreeItemNode.ListItem:where([data-_sk-expanded=false]){--ChevronDown-rotate:-.25turn}.TreeItemNode.ListItem:where(:not([data-_sk-expanded])){--TreeItem-expander-visibility:hidden}}@layer base{.TreeItemContent.ListItemContent{white-space:nowrap}}@layer base{.TreeItemDescription.ListItemContent{color:var(--TreeItem-color,var(--ListItem-state--default,var(--stratakit-color-text-neutral-secondary)))}}@layer base{.TreeItemActionsContainer.ListItemDecoration{background-color:var(--stratakit-color-bg-page-base);visibility:var(--TreeItem-actions-container-visibility,var(--TreeItem-action-visibility));align-self:stretch;padding-inline-end:var(--stratakit-space-x1);display:inline-flex;position:sticky;inset-inline-end:0}.TreeItemActionsContainer.ListItemDecoration:before{content:"";background-color:var(--ListItem-background-color);z-index:-1;position:absolute;inset:0}}@layer modifiers{.TreeItemActionsContainer.ListItemDecoration:where(:has(.TreeItemAction[data-_sk-visible=true])){--TreeItem-actions-container-visibility:visible}}@layer base{.TreeItemAction.IconButton{visibility:var(--TreeItem-action-visibility);transition:visibility 16ms}}@layer modifiers{.TreeItemAction.IconButton:where([data-_sk-visible=false]){--TreeItem-action-visibility:hidden}.TreeItemAction.IconButton:where([data-_sk-visible=true]){--TreeItem-action-visibility:visible}}@layer base{.TreeItemExpander.IconButton{visibility:var(--TreeItem-expander-visibility);z-index:1}}@layer base{.TreeItemDecoration{align-items:center;gap:var(--stratakit-space-x1);display:flex}}@media (forced-colors:active){.TreeItemNode.ListItem{--ListItem-background-color:Canvas;--TreeItem-color:CanvasText}.TreeItemNode.ListItem:where([data-_sk-error=true],[data-_sk-selected=true]){forced-color-adjust:none}.TreeItemNode.ListItem:where([data-_sk-error=true]) .TreeItemContent,.TreeItemNode.ListItem:where([data-_sk-error=true]) .TreeItemDecoration{color:marktext;background-color:mark}.TreeItemNode.ListItem:where([data-_sk-selected=true]){--ListItem-background-color:SelectedItem;--TreeItem-color:SelectedItemText}}}`;
var components_css_default = components_default;
var styles_default = String.raw`@layer reset{*,:before,:after{box-sizing:border-box;margin:0;padding:0}:where([hidden]:not([hidden=until-found])){display:none!important}:where(html){-webkit-text-size-adjust:none;interpolate-size:allow-keywords}:where(html:has(dialog:modal[open])){overflow:clip}:where(button){appearance:none;background-color:unset;border:unset;cursor:pointer;text-align:unset}:where(input,button,textarea,select){font:inherit;color:inherit}:where(fieldset){border:none}:where(img,picture,svg,video){block-size:auto;max-inline-size:100%;display:block}:where(p,h1,h2,h3,h4,h5,h6){overflow-wrap:break-word;text-wrap:pretty;font-weight:unset;font-size:unset}:where(table){border-collapse:collapse}:where(table,th,caption){text-align:start}:where(dialog,[popover]){color:inherit;inset:unset;max-width:unset;max-height:unset;overflow:unset;background:0 0;border:none}:where(dialog:not([open],[popover]),[popover]:not(:popover-open)){display:none!important}}@layer itwinui.foundations{html,:host,.Root{--stratakit-space-x05:2px;--stratakit-space-x1:4px;--stratakit-space-x2:8px;--stratakit-space-x3:12px;--stratakit-space-x4:16px;--stratakit-space-x5:20px;--stratakit-space-x6:24px;--stratakit-space-x7:28px;--stratakit-space-x8:32px;--stratakit-space-x9:36px;--stratakit-space-x10:40px}:is(html:where([data-color-scheme=light]),:host([data-color-scheme=light]),.Root:where([data-_sk-theme=light])){--stratakit-color-bg-mono-base:oklch(55.22% .018 253.99);--stratakit-color-bg-mono-muted:oklch(87.77% .005 247.88);--stratakit-color-bg-mono-faded:oklch(34.4% .011 264.42);--stratakit-color-bg-mono-transparent:oklch(55.22% .018 253.99/.16);--stratakit-color-bg-accent-base:oklch(54% .1 170.26);--stratakit-color-bg-accent-muted:oklch(89.34% .027 178.99);--stratakit-color-bg-accent-faded:oklch(33.76% .059 170.74);--stratakit-color-bg-accent-transparent:oklch(54% .1 170.26/.16);--stratakit-color-bg-info-base:oklch(55.68% .187 255.82);--stratakit-color-bg-info-muted:oklch(89.45% .042 250.5);--stratakit-color-bg-info-faded:oklch(34.71% .108 254.29);--stratakit-color-bg-info-transparent:oklch(55.68% .187 255.82/.16);--stratakit-color-bg-positive-base:oklch(53.64% .173 140.57);--stratakit-color-bg-positive-muted:oklch(89.17% .046 138.13);--stratakit-color-bg-positive-faded:oklch(33.63% .106 139.87);--stratakit-color-bg-positive-transparent:oklch(53.64% .173 140.57/.16);--stratakit-color-bg-attention-base:oklch(55.63% .116 75.58);--stratakit-color-bg-attention-muted:oklch(89.65% .049 84.55);--stratakit-color-bg-attention-faded:oklch(34.69% .071 77.24);--stratakit-color-bg-attention-transparent:oklch(56.98% .174 41.22/.16);--stratakit-color-bg-critical-base:oklch(58.02% .221 19.39);--stratakit-color-bg-critical-muted:oklch(90.3% .042 5.14);--stratakit-color-bg-critical-faded:oklch(36.08% .133 17.52);--stratakit-color-bg-critical-transparent:oklch(58.02% .221 19.39/.16);--stratakit-color-bg-page-depth:oklch(97.87% .002 247.84);--stratakit-color-bg-page-base:oklch(99.06% .002 247.84);--stratakit-color-bg-page-zebra:oklch(0% none none/.04);--stratakit-color-bg-elevation-base:oklch(100% none none);--stratakit-color-bg-elevation-emphasis:oklch(18.15% .003 247.97);--stratakit-color-bg-elevation-level-1:oklch(100% none none);--stratakit-color-bg-elevation-overlay:oklch(99.06% .002 247.84);--stratakit-color-bg-elevation-level-2:oklch(100% none none);--stratakit-color-bg-neutral-base:oklch(100% none none);--stratakit-color-bg-neutral-muted:oklch(97.87% .002 247.84);--stratakit-color-bg-neutral-faded:oklch(94.86% .002 247.84);--stratakit-color-bg-neutral-inverse:oklch(100% none none);--stratakit-color-bg-glow-base-hover-\%:4.0%;--stratakit-color-bg-glow-base-pressed-\%:8.0%;--stratakit-color-bg-glow-on-surface-accent-hover:oklch(54% .1 170.26/.12);--stratakit-color-bg-glow-on-surface-accent-pressed:oklch(54% .1 170.26/.16);--stratakit-color-bg-glow-on-surface-neutral-hover:oklch(0% none none/.04);--stratakit-color-bg-glow-on-surface-neutral-pressed:oklch(0% none none/.08);--stratakit-color-bg-glow-on-surface-critical-pressed:oklch(58.02% .221 19.39/.16);--stratakit-color-bg-glow-on-surface-critical-hover:oklch(58.02% .221 19.39/.12);--stratakit-color-bg-glow-on-surface-disabled:oklch(0% none none/.04);--stratakit-color-bg-glow-on-surface-accent-active-hover:oklch(54% .1 170.26/.24);--stratakit-color-bg-glow-strong-pressed-\%:16.0%;--stratakit-color-bg-glow-strong-hover-\%:8.0%;--stratakit-color-bg-control-textbox:oklch(100% none none);--stratakit-color-bg-control-scrollbar-surface:oklch(0% none none/.48);--stratakit-color-bg-control-scrollbar-canvas:oklch(0% none none/.48);--stratakit-color-bg-control-switch:oklch(94.86% .002 247.84);--stratakit-color-bg-control-slider-track:oklch(87.77% .005 247.88);--stratakit-color-bg-control-select:oklch(100% none none);--stratakit-color-icon-neutral-hover:oklch(26.92% .008 268.32);--stratakit-color-icon-neutral-base:oklch(55.22% .018 253.99);--stratakit-color-icon-neutral-secondary:oklch(62.09% .017 257.22);--stratakit-color-icon-neutral-tertiary:oklch(69.04% .014 255.53);--stratakit-color-icon-neutral-disabled:oklch(75.82% .01 252.83);--stratakit-color-icon-neutral-emphasis:oklch(100% none none);--stratakit-color-icon-neutral-muted:oklch(79.56% .008 241.69);--stratakit-color-icon-accent-base:oklch(47.28% .087 169.96);--stratakit-color-icon-accent-strong:oklch(47.28% .087 169.96);--stratakit-color-icon-accent-faded:oklch(40.38% .071 171.73);--stratakit-color-icon-info-base:oklch(48.74% .162 255.58);--stratakit-color-icon-info-faded:oklch(41.55% .136 255.23);--stratakit-color-icon-positive-base:oklch(46.81% .151 140.37);--stratakit-color-icon-positive-faded:oklch(40.36% .129 140.08);--stratakit-color-icon-attention-base:oklch(48.69% .101 75.71);--stratakit-color-icon-attention-faded:oklch(41.7% .086 77.28);--stratakit-color-icon-critical-base:oklch(50.74% .193 19.05);--stratakit-color-icon-critical-faded:oklch(43.46% .163 18.38);--stratakit-color-icon-mono-base:oklch(48.26% .017 254.7);--stratakit-color-icon-mono-faded:oklch(41.45% .013 256.75);--stratakit-color-icon-glow-base-hover-\%:8.0%;--stratakit-color-icon-glow-base-pressed-\%:12.0%;--stratakit-color-icon-glow-strong-hover-\%:8.0%;--stratakit-color-icon-glow-strong-pressed-\%:16.0%;--stratakit-color-border-mono-base:oklch(55.22% .018 253.99);--stratakit-color-border-mono-faded:oklch(41.45% .013 256.75);--stratakit-color-border-mono-muted:oklch(79.56% .008 241.69);--stratakit-color-border-accent-base:oklch(54% .1 170.26);--stratakit-color-border-accent-faded:oklch(40.38% .071 171.73);--stratakit-color-border-accent-muted:oklch(82.26% .045 176.56);--stratakit-color-border-accent-strong:oklch(47.28% .087 169.96);--stratakit-color-border-info-base:oklch(55.68% .187 255.82);--stratakit-color-border-info-faded:oklch(41.55% .136 255.23);--stratakit-color-border-info-muted:oklch(82.51% .071 249.98);--stratakit-color-border-positive-base:oklch(53.64% .173 140.57);--stratakit-color-border-positive-muted:oklch(82.11% .078 138.1);--stratakit-color-border-positive-faded:oklch(40.36% .129 140.08);--stratakit-color-border-attention-base:oklch(55.63% .116 75.58);--stratakit-color-border-attention-muted:oklch(82.78% .08 84.58);--stratakit-color-border-attention-faded:oklch(41.7% .086 77.28);--stratakit-color-border-critical-base:oklch(58.02% .221 19.39);--stratakit-color-border-critical-muted:oklch(83.74% .075 6.15);--stratakit-color-border-critical-faded:oklch(43.46% .163 18.38);--stratakit-color-border-glow-base-hover-\%:8.0%;--stratakit-color-border-glow-base-pressed-\%:12.0%;--stratakit-color-border-glow-base-default:oklch(0% none none/.08);--stratakit-color-border-glow-on-surface-faded:oklch(0% none none/.04);--stratakit-color-border-glow-on-surface-disabled:oklch(0% none none/.08);--stratakit-color-border-glow-strong-hover-\%:8.0%;--stratakit-color-border-glow-strong-pressed-\%:16.0%;--stratakit-color-border-glow-strong-default:oklch(0% none none/.12);--stratakit-color-border-neutral-base:oklch(87.77% .005 247.88);--stratakit-color-border-neutral-muted:oklch(91.52% .005 258.33);--stratakit-color-border-neutral-faded:oklch(82.77% .007 247.91);--stratakit-color-border-neutral-inverse:oklch(14.4% .003 247.09);--stratakit-color-border-neutral-disabled:oklch(91.52% .005 258.33);--stratakit-color-border-elevation-base:oklch(0% none none/.64);--stratakit-color-border-page-base:oklch(0% none none/.08);--stratakit-color-border-page-depth:oklch(0% none none/.08);--stratakit-color-border-control-scrollbar-canvas:oklch(100% none none/.24);--stratakit-color-border-control-switch:oklch(85.95% .006 255.48);--stratakit-color-border-control-checkbox:oklch(79.56% .008 241.69);--stratakit-color-border-control-radio:oklch(79.56% .008 241.69);--stratakit-color-border-control-textbox:oklch(79.56% .008 241.69);--stratakit-color-border-control-select:oklch(79.56% .008 241.69);--stratakit-color-text-mono-base:oklch(48.26% .017 254.7);--stratakit-color-text-mono-faded:oklch(41.45% .013 256.75);--stratakit-color-text-accent-base:oklch(47.28% .087 169.96);--stratakit-color-text-accent-faded:oklch(40.38% .071 171.73);--stratakit-color-text-accent-strong:oklch(47.28% .087 169.96);--stratakit-color-text-info-base:oklch(48.74% .162 255.58);--stratakit-color-text-info-faded:oklch(41.55% .136 255.23);--stratakit-color-text-positive-base:oklch(46.81% .151 140.37);--stratakit-color-text-positive-faded:oklch(40.36% .129 140.08);--stratakit-color-text-attention-base:oklch(48.69% .101 75.71);--stratakit-color-text-attention-faded:oklch(41.7% .086 77.28);--stratakit-color-text-critical-base:oklch(50.74% .193 19.05);--stratakit-color-text-critical-faded:oklch(43.46% .163 18.38);--stratakit-color-text-neutral-emphasis:oklch(100% none none);--stratakit-color-text-neutral-primary:oklch(29.76% .011 268.32);--stratakit-color-text-neutral-secondary:oklch(41.45% .013 256.75);--stratakit-color-text-neutral-tertiary:oklch(55.22% .018 253.99);--stratakit-color-text-neutral-disabled:oklch(75.82% .01 252.83);--stratakit-color-text-glow-base-hover-\%:8.0%;--stratakit-color-text-glow-base-pressed-\%:12.0%;--stratakit-color-text-glow-strong-hover-\%:8.0%;--stratakit-color-text-glow-strong-pressed-\%:16.0%;--stratakit-color-static-black:oklch(0% none none);--stratakit-color-static-white:oklch(100% none none);--stratakit-color-static-accent:oklch(54% .1 170.26);--stratakit-color-glow-hue:oklch(0% none none);--stratakit-color-brand-logo:oklch(41.45% .013 256.75);--stratakit-shadow-surface-xs:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.08),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.04);--stratakit-shadow-surface-sm:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.08),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04);--stratakit-shadow-surface-md:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.08),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04),0px 6px 6px -3px oklch(0% none none/.04);--stratakit-shadow-surface-lg:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.08),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04),0px 6px 6px -3px oklch(0% none none/.04),0px 12px 12px -6px oklch(0% none none/.04);--stratakit-shadow-surface-xl:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.08),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04),0px 6px 6px -3px oklch(0% none none/.04),0px 12px 12px -6px oklch(0% none none/.04),0px 24px 24px -12px oklch(0% none none/.04);--stratakit-shadow-button-base-drop:0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04);--stratakit-shadow-button-base-inset:inset 0px -1px 0px 0px oklch(0% none none/.08);--stratakit-shadow-dialog-base:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.12),inset 0px 0px 0px 1px oklch(100% none none/.02),0px 1px 1px -.5px oklch(0% none none/.08),0px 3px 3px -1.5px oklch(0% none none/.08),0px 6px 6px -3px oklch(0% none none/.08),0px 12px 12px -6px oklch(0% none none/.08),0px 24px 24px -12px oklch(0% none none/.08);--stratakit-shadow-dropdown-base:0px 1px 0px 0px oklch(0% none none/.04),0px 0px 0px 1px oklch(0% none none/.12),inset 0px 0px 0px 1px oklch(100% none none/.02),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04),0px 6px 6px -3px oklch(0% none none/.04),0px 12px 12px -6px oklch(0% none none/.04),0px 24px 24px -12px oklch(0% none none/.04);--stratakit-shadow-input-base:inset 0px 1px 2px 0px oklch(0% none none/.04),inset 0px 2px 4px 0px oklch(0% none none/.04);--stratakit-shadow-table-strong:0px -1px 0px 0px oklch(54% .1 170.26);--stratakit-shadow-toolbar-base:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.24),inset 0px 0px 0px 1px oklch(100% none none/.8),0px 1px 1px -.5px oklch(0% none none/.08),0px 3px 3px -1.5px oklch(0% none none/.08),0px 6px 6px -3px oklch(0% none none/.08),0px 12px 12px -6px oklch(0% none none/.08),0px 24px 24px -12px oklch(0% none none/.08);--stratakit-shadow-tooltip-base:inset 0px 0px 0px 1px oklch(0% none none/.96),0px 1px 1px -.5px oklch(0% none none/.04),0px 3px 3px -1.5px oklch(0% none none/.04),0px 6px 6px -3px oklch(0% none none/.04),0px 12px 12px -6px oklch(0% none none/.04)}html:where([data-color-scheme=light]),:host([data-color-scheme=light]),.Root:where([data-_sk-theme=light]){color-scheme:light;--stratakit-color-border-shadow-base:var(--stratakit-color-border-neutral-base);--stratakit-color-border-shadow-strong:oklch(0% none none/.12)}@supports not (color:oklch(0% 0 0)){:is(html:where([data-color-scheme=light]),:host([data-color-scheme=light]),.Root:where([data-_sk-theme=light])){--stratakit-color-bg-mono-base:#6b737d;--stratakit-color-bg-mono-muted:#d4d7da;--stratakit-color-bg-mono-faded:#36393f;--stratakit-color-bg-mono-transparent:#6b737d29;--stratakit-color-bg-accent-base:#188166;--stratakit-color-bg-accent-muted:#cae2dc;--stratakit-color-bg-accent-faded:#0d4133;--stratakit-color-bg-accent-transparent:#18816629;--stratakit-color-bg-info-base:#0470dd;--stratakit-color-bg-info-muted:#c8dff8;--stratakit-color-bg-info-faded:#033970;--stratakit-color-bg-info-transparent:#0470dd29;--stratakit-color-bg-positive-base:#228404;--stratakit-color-bg-positive-muted:#cde3c6;--stratakit-color-bg-positive-faded:#114302;--stratakit-color-bg-positive-transparent:#22840429;--stratakit-color-bg-attention-base:#9a6804;--stratakit-color-bg-attention-muted:#ecdbb9;--stratakit-color-bg-attention-faded:#4e3402;--stratakit-color-bg-attention-transparent:#c7480129;--stratakit-color-bg-critical-base:#df1c41;--stratakit-color-bg-critical-muted:#f9d4db;--stratakit-color-bg-critical-faded:#730e22;--stratakit-color-bg-critical-transparent:#df1c4129;--stratakit-color-bg-page-depth:#f7f8f9;--stratakit-color-bg-page-base:#fbfcfd;--stratakit-color-bg-page-zebra:#0000000a;--stratakit-color-bg-elevation-base:#fff;--stratakit-color-bg-elevation-emphasis:#111213;--stratakit-color-bg-elevation-level-1:#fff;--stratakit-color-bg-elevation-overlay:#fbfcfd;--stratakit-color-bg-elevation-level-2:#fff;--stratakit-color-bg-neutral-base:#fff;--stratakit-color-bg-neutral-muted:#f7f8f9;--stratakit-color-bg-neutral-faded:#edeeef;--stratakit-color-bg-neutral-inverse:#fff;--stratakit-color-bg-glow-base-hover-\%:4.0%;--stratakit-color-bg-glow-base-pressed-\%:8.0%;--stratakit-color-bg-glow-on-surface-accent-hover:#1881661f;--stratakit-color-bg-glow-on-surface-accent-pressed:#18816629;--stratakit-color-bg-glow-on-surface-neutral-hover:#0000000a;--stratakit-color-bg-glow-on-surface-neutral-pressed:#00000014;--stratakit-color-bg-glow-on-surface-critical-pressed:#df1c4129;--stratakit-color-bg-glow-on-surface-critical-hover:#df1c411f;--stratakit-color-bg-glow-on-surface-disabled:#0000000a;--stratakit-color-bg-glow-on-surface-accent-active-hover:#1881663d;--stratakit-color-bg-glow-strong-pressed-\%:16.0%;--stratakit-color-bg-glow-strong-hover-\%:8.0%;--stratakit-color-bg-control-textbox:#fff;--stratakit-color-bg-control-scrollbar-surface:#0000007a;--stratakit-color-bg-control-scrollbar-canvas:#0000007a;--stratakit-color-bg-control-switch:#edeeef;--stratakit-color-bg-control-slider-track:#d4d7da;--stratakit-color-bg-control-select:#fff;--stratakit-color-icon-neutral-hover:#24262a;--stratakit-color-icon-neutral-base:#6b737d;--stratakit-color-icon-neutral-secondary:#808791;--stratakit-color-icon-neutral-tertiary:#969ca4;--stratakit-color-icon-neutral-disabled:#acb1b7;--stratakit-color-icon-neutral-emphasis:#fff;--stratakit-color-icon-neutral-muted:#b8bdc1;--stratakit-color-icon-accent-base:#146b54;--stratakit-color-icon-accent-strong:#146b54;--stratakit-color-icon-accent-faded:#125544;--stratakit-color-icon-info-base:#035db8;--stratakit-color-icon-info-faded:#024a93;--stratakit-color-icon-positive-base:#1c6d01;--stratakit-color-icon-positive-faded:#175801;--stratakit-color-icon-attention-base:#805604;--stratakit-color-icon-attention-faded:#664502;--stratakit-color-icon-critical-base:#ba1536;--stratakit-color-icon-critical-faded:#96122c;--stratakit-color-icon-mono-base:#585f68;--stratakit-color-icon-mono-faded:#474c53;--stratakit-color-icon-glow-base-hover-\%:8.0%;--stratakit-color-icon-glow-base-pressed-\%:12.0%;--stratakit-color-icon-glow-strong-hover-\%:8.0%;--stratakit-color-icon-glow-strong-pressed-\%:16.0%;--stratakit-color-border-mono-base:#6b737d;--stratakit-color-border-mono-faded:#474c53;--stratakit-color-border-mono-muted:#b8bdc1;--stratakit-color-border-accent-base:#188166;--stratakit-color-border-accent-faded:#125544;--stratakit-color-border-accent-muted:#a7cfc4;--stratakit-color-border-accent-strong:#146b54;--stratakit-color-border-info-base:#0470dd;--stratakit-color-border-info-faded:#024a93;--stratakit-color-border-info-muted:#a3caf3;--stratakit-color-border-positive-base:#228404;--stratakit-color-border-positive-muted:#acd1a0;--stratakit-color-border-positive-faded:#175801;--stratakit-color-border-attention-base:#9a6804;--stratakit-color-border-attention-muted:#dfc38a;--stratakit-color-border-attention-faded:#664502;--stratakit-color-border-critical-base:#df1c41;--stratakit-color-border-critical-muted:#f5b6c2;--stratakit-color-border-critical-faded:#96122c;--stratakit-color-border-glow-base-hover-\%:8.0%;--stratakit-color-border-glow-base-pressed-\%:12.0%;--stratakit-color-border-glow-base-default:#00000014;--stratakit-color-border-glow-on-surface-faded:#0000000a;--stratakit-color-border-glow-on-surface-disabled:#00000014;--stratakit-color-border-glow-strong-hover-\%:8.0%;--stratakit-color-border-glow-strong-pressed-\%:16.0%;--stratakit-color-border-glow-strong-default:#0000001f;--stratakit-color-border-neutral-base:#d4d7da;--stratakit-color-border-neutral-muted:#e1e3e6;--stratakit-color-border-neutral-faded:#c3c7cb;--stratakit-color-border-neutral-inverse:#090a0b;--stratakit-color-border-neutral-disabled:#e1e3e6;--stratakit-color-border-elevation-base:#000000a3;--stratakit-color-border-page-base:#00000014;--stratakit-color-border-page-depth:#00000014;--stratakit-color-border-control-scrollbar-canvas:#ffffff3d;--stratakit-color-border-control-switch:#ced1d5;--stratakit-color-border-control-checkbox:#b8bdc1;--stratakit-color-border-control-radio:#b8bdc1;--stratakit-color-border-control-textbox:#b8bdc1;--stratakit-color-border-control-select:#b8bdc1;--stratakit-color-text-mono-base:#585f68;--stratakit-color-text-mono-faded:#474c53;--stratakit-color-text-accent-base:#146b54;--stratakit-color-text-accent-faded:#125544;--stratakit-color-text-accent-strong:#146b54;--stratakit-color-text-info-base:#035db8;--stratakit-color-text-info-faded:#024a93;--stratakit-color-text-positive-base:#1c6d01;--stratakit-color-text-positive-faded:#175801;--stratakit-color-text-attention-base:#805604;--stratakit-color-text-attention-faded:#664502;--stratakit-color-text-critical-base:#ba1536;--stratakit-color-text-critical-faded:#96122c;--stratakit-color-text-neutral-emphasis:#fff;--stratakit-color-text-neutral-primary:#2b2d33;--stratakit-color-text-neutral-secondary:#474c53;--stratakit-color-text-neutral-tertiary:#6b737d;--stratakit-color-text-neutral-disabled:#acb1b7;--stratakit-color-text-glow-base-hover-\%:8.0%;--stratakit-color-text-glow-base-pressed-\%:12.0%;--stratakit-color-text-glow-strong-hover-\%:8.0%;--stratakit-color-text-glow-strong-pressed-\%:16.0%;--stratakit-color-static-black:#000;--stratakit-color-static-white:#fff;--stratakit-color-static-accent:#188166;--stratakit-color-glow-hue:#000;--stratakit-color-brand-logo:#474c53;--stratakit-shadow-surface-xs:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #00000014,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #0000000a;--stratakit-shadow-surface-sm:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #00000014,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a;--stratakit-shadow-surface-md:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #00000014,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a,0px 6px 6px -3px #0000000a;--stratakit-shadow-surface-lg:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #00000014,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a,0px 6px 6px -3px #0000000a,0px 12px 12px -6px #0000000a;--stratakit-shadow-surface-xl:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #00000014,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a,0px 6px 6px -3px #0000000a,0px 12px 12px -6px #0000000a,0px 24px 24px -12px #0000000a;--stratakit-shadow-button-base-drop:0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a;--stratakit-shadow-button-base-inset:inset 0px -1px 0px 0px #00000014;--stratakit-shadow-dialog-base:0px 1px 0px 0px #00000014,0px 0px 0px 1px #0000001f,inset 0px 0px 0px 1px #ffffff05,0px 1px 1px -.5px #00000014,0px 3px 3px -1.5px #00000014,0px 6px 6px -3px #00000014,0px 12px 12px -6px #00000014,0px 24px 24px -12px #00000014;--stratakit-shadow-dropdown-base:0px 1px 0px 0px #0000000a,0px 0px 0px 1px #0000001f,inset 0px 0px 0px 1px #ffffff05,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a,0px 6px 6px -3px #0000000a,0px 12px 12px -6px #0000000a,0px 24px 24px -12px #0000000a;--stratakit-shadow-input-base:inset 0px 1px 2px 0px #0000000a,inset 0px 2px 4px 0px #0000000a;--stratakit-shadow-table-strong:0px -1px 0px 0px #188166;--stratakit-shadow-toolbar-base:0px 1px 0px 0px #00000014,0px 0px 0px 1px #0000003d,inset 0px 0px 0px 1px #fffc,0px 1px 1px -.5px #00000014,0px 3px 3px -1.5px #00000014,0px 6px 6px -3px #00000014,0px 12px 12px -6px #00000014,0px 24px 24px -12px #00000014;--stratakit-shadow-tooltip-base:inset 0px 0px 0px 1px #000000f5,0px 1px 1px -.5px #0000000a,0px 3px 3px -1.5px #0000000a,0px 6px 6px -3px #0000000a,0px 12px 12px -6px #0000000a}}:is(html:where([data-color-scheme=dark]),:host([data-color-scheme=dark]),.Root:where([data-_sk-theme=dark])){--stratakit-color-bg-mono-base:oklch(55.22% .018 253.99);--stratakit-color-bg-mono-muted:oklch(34.4% .011 264.42);--stratakit-color-bg-mono-faded:oklch(69.04% .014 255.53);--stratakit-color-bg-mono-transparent:oklch(55.22% .018 253.99/.16);--stratakit-color-bg-accent-base:oklch(54% .1 170.26);--stratakit-color-bg-accent-muted:oklch(33.76% .059 170.74);--stratakit-color-bg-accent-faded:oklch(67.95% .077 175.72);--stratakit-color-bg-accent-transparent:oklch(54% .1 170.26/.16);--stratakit-color-bg-info-base:oklch(55.68% .187 255.82);--stratakit-color-bg-info-muted:oklch(34.71% .108 254.29);--stratakit-color-bg-info-faded:oklch(68.84% .131 251.14);--stratakit-color-bg-info-transparent:oklch(55.68% .187 255.82/.16);--stratakit-color-bg-positive-base:oklch(53.64% .173 140.57);--stratakit-color-bg-positive-muted:oklch(33.63% .106 139.87);--stratakit-color-bg-positive-faded:oklch(67.58% .14 138.68);--stratakit-color-bg-positive-transparent:oklch(53.64% .173 140.57/.16);--stratakit-color-bg-attention-base:oklch(55.63% .116 75.58);--stratakit-color-bg-attention-muted:oklch(34.69% .071 77.24);--stratakit-color-bg-attention-faded:oklch(69.31% .129 79.75);--stratakit-color-bg-attention-transparent:oklch(56.98% .174 41.22/.16);--stratakit-color-bg-critical-base:oklch(58.02% .221 19.39);--stratakit-color-bg-critical-muted:oklch(36.08% .133 17.52);--stratakit-color-bg-critical-faded:oklch(70.76% .147 9.28);--stratakit-color-bg-critical-transparent:oklch(58.02% .221 19.39/.16);--stratakit-color-bg-page-depth:oklch(22.52% .005 268.32);--stratakit-color-bg-page-base:oklch(24.37% .006 268.32);--stratakit-color-bg-page-zebra:oklch(0% none none/.08);--stratakit-color-bg-elevation-base:oklch(26.92% .008 268.32);--stratakit-color-bg-elevation-emphasis:oklch(14.4% .003 247.09);--stratakit-color-bg-elevation-level-1:oklch(29.76% .011 268.32);--stratakit-color-bg-elevation-overlay:oklch(18.15% .003 247.97);--stratakit-color-bg-elevation-level-2:oklch(32.63% .014 268.32);--stratakit-color-bg-neutral-base:oklch(34.4% .011 264.42);--stratakit-color-bg-neutral-muted:oklch(32.63% .014 268.32);--stratakit-color-bg-neutral-faded:oklch(48.26% .017 254.7);--stratakit-color-bg-neutral-inverse:oklch(99.06% .002 247.84);--stratakit-color-bg-glow-base-hover-\%:4.0%;--stratakit-color-bg-glow-base-pressed-\%:8.0%;--stratakit-color-bg-glow-on-surface-accent-hover:oklch(54% .1 170.26/.12);--stratakit-color-bg-glow-on-surface-accent-pressed:oklch(54% .1 170.26/.16);--stratakit-color-bg-glow-on-surface-neutral-hover:oklch(100% none none/.04);--stratakit-color-bg-glow-on-surface-neutral-pressed:oklch(100% none none/.08);--stratakit-color-bg-glow-on-surface-critical-pressed:oklch(58.02% .221 19.39/.16);--stratakit-color-bg-glow-on-surface-critical-hover:oklch(58.02% .221 19.39/.12);--stratakit-color-bg-glow-on-surface-disabled:oklch(100% none none/.04);--stratakit-color-bg-glow-on-surface-accent-active-hover:oklch(54% .1 170.26/.24);--stratakit-color-bg-glow-strong-pressed-\%:16.0%;--stratakit-color-bg-glow-strong-hover-\%:8.0%;--stratakit-color-bg-control-textbox:oklch(24.37% .006 268.32);--stratakit-color-bg-control-scrollbar-surface:oklch(100% none none/.4);--stratakit-color-bg-control-scrollbar-canvas:oklch(0% none none/.48);--stratakit-color-bg-control-switch:oklch(22.52% .005 268.32);--stratakit-color-bg-control-slider-track:oklch(34.4% .011 264.42);--stratakit-color-bg-control-select:oklch(24.37% .006 268.32);--stratakit-color-icon-neutral-hover:oklch(99.06% .002 247.84);--stratakit-color-icon-neutral-base:oklch(75.82% .01 252.83);--stratakit-color-icon-neutral-secondary:oklch(62.09% .017 257.22);--stratakit-color-icon-neutral-tertiary:oklch(55.22% .018 253.99);--stratakit-color-icon-neutral-disabled:oklch(48.26% .017 254.7);--stratakit-color-icon-neutral-emphasis:oklch(100% none none);--stratakit-color-icon-neutral-muted:oklch(48.26% .017 254.7);--stratakit-color-icon-accent-base:oklch(67.95% .077 175.72);--stratakit-color-icon-accent-strong:oklch(87.59% .175 168.9);--stratakit-color-icon-accent-faded:oklch(75.2% .062 176.03);--stratakit-color-icon-info-base:oklch(68.84% .131 251.14);--stratakit-color-icon-info-faded:oklch(75.7% .101 250.13);--stratakit-color-icon-positive-base:oklch(67.58% .14 138.68);--stratakit-color-icon-positive-faded:oklch(74.8% .109 138.51);--stratakit-color-icon-attention-base:oklch(69.31% .129 79.75);--stratakit-color-icon-attention-faded:oklch(76.1% .109 83.1);--stratakit-color-icon-critical-base:oklch(70.76% .147 9.28);--stratakit-color-icon-critical-faded:oklch(77.16% .109 6.79);--stratakit-color-icon-mono-base:oklch(69.04% .014 255.53);--stratakit-color-icon-mono-faded:oklch(75.82% .01 252.83);--stratakit-color-icon-glow-base-hover-\%:8.0%;--stratakit-color-icon-glow-base-pressed-\%:12.0%;--stratakit-color-icon-glow-strong-hover-\%:16.0%;--stratakit-color-icon-glow-strong-pressed-\%:24.0%;--stratakit-color-border-mono-base:oklch(62.09% .017 257.22);--stratakit-color-border-mono-faded:oklch(79.56% .008 241.69);--stratakit-color-border-mono-muted:oklch(41.45% .013 256.75);--stratakit-color-border-accent-base:oklch(60.98% .092 173.18);--stratakit-color-border-accent-faded:oklch(82.26% .045 176.56);--stratakit-color-border-accent-muted:oklch(40.38% .071 171.73);--stratakit-color-border-accent-strong:oklch(87.59% .175 168.9);--stratakit-color-border-info-base:oklch(62.11% .161 252.88);--stratakit-color-border-info-faded:oklch(82.51% .071 249.98);--stratakit-color-border-info-muted:oklch(41.55% .136 255.23);--stratakit-color-border-positive-base:oklch(60.59% .164 139.21);--stratakit-color-border-positive-muted:oklch(40.36% .129 140.08);--stratakit-color-border-positive-faded:oklch(82.11% .078 138.1);--stratakit-color-border-attention-base:oklch(62.6% .132 74.4);--stratakit-color-border-attention-muted:oklch(41.7% .086 77.28);--stratakit-color-border-attention-faded:oklch(82.78% .08 84.58);--stratakit-color-border-critical-base:oklch(64.49% .185 12.51);--stratakit-color-border-critical-muted:oklch(43.46% .163 18.38);--stratakit-color-border-critical-faded:oklch(83.74% .075 6.15);--stratakit-color-border-glow-base-hover-\%:8.0%;--stratakit-color-border-glow-base-pressed-\%:12.0%;--stratakit-color-border-glow-base-default:oklch(100% none none/.08);--stratakit-color-border-glow-on-surface-faded:oklch(100% none none/.04);--stratakit-color-border-glow-on-surface-disabled:oklch(100% none none/.08);--stratakit-color-border-glow-strong-hover-\%:16.0%;--stratakit-color-border-glow-strong-pressed-\%:24.0%;--stratakit-color-border-glow-strong-default:oklch(100% none none/.16);--stratakit-color-border-neutral-base:oklch(41.45% .013 256.75);--stratakit-color-border-neutral-muted:oklch(32.63% .014 268.32);--stratakit-color-border-neutral-faded:oklch(62.09% .017 257.22);--stratakit-color-border-neutral-inverse:oklch(99.06% .002 247.84);--stratakit-color-border-neutral-disabled:oklch(48.26% .017 254.7);--stratakit-color-border-elevation-base:oklch(0% none none/.64);--stratakit-color-border-page-base:oklch(100% none none/.08);--stratakit-color-border-page-depth:oklch(100% none none/.08);--stratakit-color-border-control-scrollbar-canvas:oklch(100% none none/.24);--stratakit-color-border-control-switch:oklch(41.45% .013 256.75);--stratakit-color-border-control-checkbox:oklch(48.26% .017 254.7);--stratakit-color-border-control-radio:oklch(48.26% .017 254.7);--stratakit-color-border-control-textbox:oklch(48.26% .017 254.7);--stratakit-color-border-control-select:oklch(48.26% .017 254.7);--stratakit-color-text-mono-base:oklch(69.04% .014 255.53);--stratakit-color-text-mono-faded:oklch(75.82% .01 252.83);--stratakit-color-text-accent-base:oklch(67.95% .077 175.72);--stratakit-color-text-accent-faded:oklch(75.2% .062 176.03);--stratakit-color-text-accent-strong:oklch(87.59% .175 168.9);--stratakit-color-text-info-base:oklch(68.84% .131 251.14);--stratakit-color-text-info-faded:oklch(75.7% .101 250.13);--stratakit-color-text-positive-base:oklch(67.58% .14 138.68);--stratakit-color-text-positive-faded:oklch(74.8% .109 138.51);--stratakit-color-text-attention-base:oklch(69.31% .129 79.75);--stratakit-color-text-attention-faded:oklch(76.1% .109 83.1);--stratakit-color-text-critical-base:oklch(70.76% .147 9.28);--stratakit-color-text-critical-faded:oklch(77.16% .109 6.79);--stratakit-color-text-neutral-emphasis:oklch(100% none none);--stratakit-color-text-neutral-primary:oklch(99.06% .002 247.84);--stratakit-color-text-neutral-secondary:oklch(79.56% .008 241.69);--stratakit-color-text-neutral-tertiary:oklch(69.04% .014 255.53);--stratakit-color-text-neutral-disabled:oklch(48.26% .017 254.7);--stratakit-color-text-glow-base-hover-\%:8.0%;--stratakit-color-text-glow-base-pressed-\%:12.0%;--stratakit-color-text-glow-strong-hover-\%:16.0%;--stratakit-color-text-glow-strong-pressed-\%:24.0%;--stratakit-color-static-black:oklch(0% none none);--stratakit-color-static-white:oklch(100% none none);--stratakit-color-static-accent:oklch(54% .1 170.26);--stratakit-color-glow-hue:oklch(100% none none);--stratakit-color-brand-logo:oklch(94.86% .002 247.84);--stratakit-shadow-surface-xs:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.16),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16);--stratakit-shadow-surface-sm:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.16),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16);--stratakit-shadow-surface-md:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.16),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16);--stratakit-shadow-surface-lg:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.16),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16),0px 12px 12px -6px oklch(0% none none/.16);--stratakit-shadow-surface-xl:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.16),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16),0px 12px 12px -6px oklch(0% none none/.16),0px 24px 24px -12px oklch(0% none none/.16);--stratakit-shadow-button-base-drop:0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16);--stratakit-shadow-button-base-inset:inset 0px -1px 0px 0px oklch(0% none none/.08);--stratakit-shadow-dialog-base:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.8),inset 0px 0px 0px 1px oklch(100% none none/.12),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16),0px 12px 12px -6px oklch(0% none none/.16),0px 24px 24px -12px oklch(0% none none/.16);--stratakit-shadow-dropdown-base:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.48),inset 0px 0px 0px 1px oklch(100% none none/.12),0px 1px 1px -.5px oklch(0% none none/.12),0px 3px 3px -1.5px oklch(0% none none/.12),0px 6px 6px -3px oklch(0% none none/.12),0px 12px 12px -6px oklch(0% none none/.12),0px 24px 24px -12px oklch(0% none none/.12);--stratakit-shadow-input-base:inset 0px 1px 2px 0px oklch(0% none none/.16),inset 0px 2px 4px 0px oklch(0% none none/.16);--stratakit-shadow-table-strong:0px -1px 0px 0px oklch(87.59% .175 168.9);--stratakit-shadow-toolbar-base:0px 1px 0px 0px oklch(0% none none/.08),0px 0px 0px 1px oklch(0% none none/.8),inset 0px 0px 0px 1px oklch(100% none none/.08),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16),0px 12px 12px -6px oklch(0% none none/.16),0px 24px 24px -12px oklch(0% none none/.16);--stratakit-shadow-tooltip-base:inset 0px 0px 0px 1px oklch(0% none none/.8),0px 1px 1px -.5px oklch(0% none none/.16),0px 3px 3px -1.5px oklch(0% none none/.16),0px 6px 6px -3px oklch(0% none none/.16),0px 12px 12px -6px oklch(0% none none/.16)}html:where([data-color-scheme=dark]),:host([data-color-scheme=dark]),.Root:where([data-_sk-theme=dark]){color-scheme:dark;--stratakit-color-border-shadow-base:oklch(100% none none/.08);--stratakit-color-border-shadow-strong:oklch(100% none none/.16)}@supports not (color:oklch(0% 0 0)){:is(html:where([data-color-scheme=dark]),:host([data-color-scheme=dark]),.Root:where([data-_sk-theme=dark])){--stratakit-color-bg-mono-base:#6b737d;--stratakit-color-bg-mono-muted:#36393f;--stratakit-color-bg-mono-faded:#969ca4;--stratakit-color-bg-mono-transparent:#6b737d29;--stratakit-color-bg-accent-base:#188166;--stratakit-color-bg-accent-muted:#0d4133;--stratakit-color-bg-accent-faded:#61a896;--stratakit-color-bg-accent-transparent:#18816629;--stratakit-color-bg-info-base:#0470dd;--stratakit-color-bg-info-muted:#033970;--stratakit-color-bg-info-faded:#589fe9;--stratakit-color-bg-info-transparent:#0470dd29;--stratakit-color-bg-positive-base:#228404;--stratakit-color-bg-positive-muted:#114302;--stratakit-color-bg-positive-faded:#68ab53;--stratakit-color-bg-positive-transparent:#22840429;--stratakit-color-bg-attention-base:#9a6804;--stratakit-color-bg-attention-muted:#4e3402;--stratakit-color-bg-attention-faded:#c6922c;--stratakit-color-bg-attention-transparent:#c7480129;--stratakit-color-bg-critical-base:#df1c41;--stratakit-color-bg-critical-muted:#730e22;--stratakit-color-bg-critical-faded:#ec768d;--stratakit-color-bg-critical-transparent:#df1c4129;--stratakit-color-bg-page-depth:#1b1c1e;--stratakit-color-bg-page-base:#1f2023;--stratakit-color-bg-page-zebra:#00000014;--stratakit-color-bg-elevation-base:#24262a;--stratakit-color-bg-elevation-emphasis:#090a0b;--stratakit-color-bg-elevation-level-1:#2b2d33;--stratakit-color-bg-elevation-overlay:#111213;--stratakit-color-bg-elevation-level-2:#31343c;--stratakit-color-bg-neutral-base:#36393f;--stratakit-color-bg-neutral-muted:#31343c;--stratakit-color-bg-neutral-faded:#585f68;--stratakit-color-bg-neutral-inverse:#fbfcfd;--stratakit-color-bg-glow-base-hover-\%:4.0%;--stratakit-color-bg-glow-base-pressed-\%:8.0%;--stratakit-color-bg-glow-on-surface-accent-hover:#1881661f;--stratakit-color-bg-glow-on-surface-accent-pressed:#18816629;--stratakit-color-bg-glow-on-surface-neutral-hover:#ffffff0a;--stratakit-color-bg-glow-on-surface-neutral-pressed:#ffffff14;--stratakit-color-bg-glow-on-surface-critical-pressed:#df1c4129;--stratakit-color-bg-glow-on-surface-critical-hover:#df1c411f;--stratakit-color-bg-glow-on-surface-disabled:#ffffff0a;--stratakit-color-bg-glow-on-surface-accent-active-hover:#1881663d;--stratakit-color-bg-glow-strong-pressed-\%:16.0%;--stratakit-color-bg-glow-strong-hover-\%:8.0%;--stratakit-color-bg-control-textbox:#1f2023;--stratakit-color-bg-control-scrollbar-surface:#fff6;--stratakit-color-bg-control-scrollbar-canvas:#0000007a;--stratakit-color-bg-control-switch:#1b1c1e;--stratakit-color-bg-control-slider-track:#36393f;--stratakit-color-bg-control-select:#1f2023;--stratakit-color-icon-neutral-hover:#fbfcfd;--stratakit-color-icon-neutral-base:#acb1b7;--stratakit-color-icon-neutral-secondary:#808791;--stratakit-color-icon-neutral-tertiary:#6b737d;--stratakit-color-icon-neutral-disabled:#585f68;--stratakit-color-icon-neutral-emphasis:#fff;--stratakit-color-icon-neutral-muted:#585f68;--stratakit-color-icon-accent-base:#61a896;--stratakit-color-icon-accent-strong:#06fac2;--stratakit-color-icon-accent-faded:#84bcad;--stratakit-color-icon-info-base:#589fe9;--stratakit-color-icon-info-faded:#7eb5ee;--stratakit-color-icon-positive-base:#68ab53;--stratakit-color-icon-positive-faded:#8abe7a;--stratakit-color-icon-attention-base:#c6922c;--stratakit-color-icon-attention-faded:#d3ab5b;--stratakit-color-icon-critical-base:#ec768d;--stratakit-color-icon-critical-faded:#f097a9;--stratakit-color-icon-mono-base:#969ca4;--stratakit-color-icon-mono-faded:#acb1b7;--stratakit-color-icon-glow-base-hover-\%:8.0%;--stratakit-color-icon-glow-base-pressed-\%:12.0%;--stratakit-color-icon-glow-strong-hover-\%:16.0%;--stratakit-color-icon-glow-strong-pressed-\%:24.0%;--stratakit-color-border-mono-base:#808791;--stratakit-color-border-mono-faded:#b8bdc1;--stratakit-color-border-mono-muted:#474c53;--stratakit-color-border-accent-base:#3d957e;--stratakit-color-border-accent-faded:#a7cfc4;--stratakit-color-border-accent-muted:#125544;--stratakit-color-border-accent-strong:#06fac2;--stratakit-color-border-info-base:#3088e4;--stratakit-color-border-info-faded:#a3caf3;--stratakit-color-border-info-muted:#024a93;--stratakit-color-border-positive-base:#46982c;--stratakit-color-border-positive-muted:#175801;--stratakit-color-border-positive-faded:#acd1a0;--stratakit-color-border-attention-base:#b67a02;--stratakit-color-border-attention-muted:#664502;--stratakit-color-border-attention-faded:#dfc38a;--stratakit-color-border-critical-base:#e7516e;--stratakit-color-border-critical-muted:#96122c;--stratakit-color-border-critical-faded:#f5b6c2;--stratakit-color-border-glow-base-hover-\%:8.0%;--stratakit-color-border-glow-base-pressed-\%:12.0%;--stratakit-color-border-glow-base-default:#ffffff14;--stratakit-color-border-glow-on-surface-faded:#ffffff0a;--stratakit-color-border-glow-on-surface-disabled:#ffffff14;--stratakit-color-border-glow-strong-hover-\%:16.0%;--stratakit-color-border-glow-strong-pressed-\%:24.0%;--stratakit-color-border-glow-strong-default:#ffffff29;--stratakit-color-border-neutral-base:#474c53;--stratakit-color-border-neutral-muted:#31343c;--stratakit-color-border-neutral-faded:#808791;--stratakit-color-border-neutral-inverse:#fbfcfd;--stratakit-color-border-neutral-disabled:#585f68;--stratakit-color-border-elevation-base:#000000a3;--stratakit-color-border-page-base:#ffffff14;--stratakit-color-border-page-depth:#ffffff14;--stratakit-color-border-control-scrollbar-canvas:#ffffff3d;--stratakit-color-border-control-switch:#474c53;--stratakit-color-border-control-checkbox:#585f68;--stratakit-color-border-control-radio:#585f68;--stratakit-color-border-control-textbox:#585f68;--stratakit-color-border-control-select:#585f68;--stratakit-color-text-mono-base:#969ca4;--stratakit-color-text-mono-faded:#acb1b7;--stratakit-color-text-accent-base:#61a896;--stratakit-color-text-accent-faded:#84bcad;--stratakit-color-text-accent-strong:#06fac2;--stratakit-color-text-info-base:#589fe9;--stratakit-color-text-info-faded:#7eb5ee;--stratakit-color-text-positive-base:#68ab53;--stratakit-color-text-positive-faded:#8abe7a;--stratakit-color-text-attention-base:#c6922c;--stratakit-color-text-attention-faded:#d3ab5b;--stratakit-color-text-critical-base:#ec768d;--stratakit-color-text-critical-faded:#f097a9;--stratakit-color-text-neutral-emphasis:#fff;--stratakit-color-text-neutral-primary:#fbfcfd;--stratakit-color-text-neutral-secondary:#b8bdc1;--stratakit-color-text-neutral-tertiary:#969ca4;--stratakit-color-text-neutral-disabled:#585f68;--stratakit-color-text-glow-base-hover-\%:8.0%;--stratakit-color-text-glow-base-pressed-\%:12.0%;--stratakit-color-text-glow-strong-hover-\%:16.0%;--stratakit-color-text-glow-strong-pressed-\%:24.0%;--stratakit-color-static-black:#000;--stratakit-color-static-white:#fff;--stratakit-color-static-accent:#188166;--stratakit-color-glow-hue:#fff;--stratakit-color-brand-logo:#edeeef;--stratakit-shadow-surface-xs:0px 1px 0px 0px #00000014,0px 0px 0px 1px #00000029,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029;--stratakit-shadow-surface-sm:0px 1px 0px 0px #00000014,0px 0px 0px 1px #00000029,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029;--stratakit-shadow-surface-md:0px 1px 0px 0px #00000014,0px 0px 0px 1px #00000029,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029;--stratakit-shadow-surface-lg:0px 1px 0px 0px #00000014,0px 0px 0px 1px #00000029,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029,0px 12px 12px -6px #00000029;--stratakit-shadow-surface-xl:0px 1px 0px 0px #00000014,0px 0px 0px 1px #00000029,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029,0px 12px 12px -6px #00000029,0px 24px 24px -12px #00000029;--stratakit-shadow-button-base-drop:0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029;--stratakit-shadow-button-base-inset:inset 0px -1px 0px 0px #00000014;--stratakit-shadow-dialog-base:0px 1px 0px 0px #00000014,0px 0px 0px 1px #000c,inset 0px 0px 0px 1px #ffffff1f,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029,0px 12px 12px -6px #00000029,0px 24px 24px -12px #00000029;--stratakit-shadow-dropdown-base:0px 1px 0px 0px #00000014,0px 0px 0px 1px #0000007a,inset 0px 0px 0px 1px #ffffff1f,0px 1px 1px -.5px #0000001f,0px 3px 3px -1.5px #0000001f,0px 6px 6px -3px #0000001f,0px 12px 12px -6px #0000001f,0px 24px 24px -12px #0000001f;--stratakit-shadow-input-base:inset 0px 1px 2px 0px #00000029,inset 0px 2px 4px 0px #00000029;--stratakit-shadow-table-strong:0px -1px 0px 0px #06fac2;--stratakit-shadow-toolbar-base:0px 1px 0px 0px #00000014,0px 0px 0px 1px #000c,inset 0px 0px 0px 1px #ffffff14,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029,0px 12px 12px -6px #00000029,0px 24px 24px -12px #00000029;--stratakit-shadow-tooltip-base:inset 0px 0px 0px 1px #000c,0px 1px 1px -.5px #00000029,0px 3px 3px -1.5px #00000029,0px 6px 6px -3px #00000029,0px 12px 12px -6px #00000029}}:root,:host{--stratakit-font-family-sans:"InterVariable","Noto Sans","Open Sans",sans-serif;--stratakit-font-family-mono:"Geist Mono","Noto Sans Mono",ui-monospace,"Segoe UI Mono",Consolas,monospace}:is(:root,:host){--stratakit-font-size-8:.5rem;--stratakit-font-size-10:.625rem;--stratakit-font-size-11:.6875rem;--stratakit-font-size-12:.75rem;--stratakit-font-size-14:.875rem;--stratakit-font-size-16:1rem;--stratakit-font-size-20:1.25rem;--stratakit-font-size-24:1.5rem;--stratakit-font-size-28:1.75rem;--stratakit-font-size-32:2rem;--stratakit-font-size-40:2.5rem;--stratakit-font-size-48:3rem}.Root:where([data-_sk-density=dense]){font-size:var(--stratakit-font-size-12);line-height:1.3333}@font-feature-values InterVariable{@character-variant{cv01:1;cv02:2;cv03:3;cv04:4;cv05:5;cv06:6;cv07:7;cv08:8;cv09:9;cv10:10;cv11:11;cv12:12;cv13:13;alt-1:1;alt-3:9;open-4:2;open-6:3;open-9:4;lc-l-with-tail:5;simplified-u:6;alt-double-s:7;uc-i-with-serif:8;uc-g-with-spur:10;single-story-a:11;compact-lc-f:12;compact-lc-t:13}@styleset{ss01:1;ss02:2;ss03:3;ss04:4;ss05:5;ss06:6;ss07:7;ss08:8;open-digits:1;disambiguation:2;disambiguation-except-zero:4;round-quotes-and-commas:3;square-punctuation:7;square-quotes:8;circled-characters:5;squared-characters:6}}html{background-color:var(--stratakit-color-bg-page-base);scrollbar-color:var(--stratakit-color-bg-control-scrollbar-surface)var(--stratakit-color-bg-page-base)}body{font-size:var(--stratakit-font-size-14);line-height:1.4286}:is(body,.Root){font-family:var(--stratakit-font-family-sans);font-variant-alternates:character-variant(alt-1,alt-3,lc-l-with-tail,uc-i-with-serif);color:var(--stratakit-color-text-neutral-primary);--focus-outline:2px solid var(--stratakit-color-border-accent-strong);--focus-outline-offset:1px;--selection-color-bg:var(--stratakit-color-bg-accent-base);--selection-color-text:var(--stratakit-color-text-neutral-emphasis)}@media (forced-colors:active){:is(body,.Root){--focus-outline:2px solid Highlight}}::selection{background-color:var(--selection-color-bg);color:var(--selection-color-text)}:focus-visible{outline:var(--focus-outline);outline-offset:var(--focus-outline-offset)}}@layer itwinui.components.base,itwinui.components.modifiers,itwinui.components.states;@layer itwinui.components{@layer base{.Icon{width:var(--Icon-size,1rem);height:var(--Icon-size,1rem);color:var(--Icon-color);flex-shrink:0;transition:color .15s ease-out}}@layer modifiers{.Icon:where([data-_sk-size=regular]){--Icon-size:1rem}.Icon:where([data-_sk-size=large]){--Icon-size:1.5rem}}@layer base{.DisclosureArrow{rotate:var(--DisclosureArrow-rotate);margin-inline-end:calc(var(--stratakit-space-x2)*-1)}@media (prefers-reduced-motion:no-preference){.DisclosureArrow{transition:rotate .15s ease-in-out}}}@layer base{.ChevronDown{rotate:var(--ChevronDown-rotate)}@media (prefers-reduced-motion:no-preference){.ChevronDown{transition:rotate .15s ease-in-out}}}@media (forced-colors:active){.Icon{--Icon-color:currentColor}}}`;
var styles_css_default = styles_default;
const styleSheets = new Map(
  Object.entries({ default: /* @__PURE__ */ new WeakMap() })
);
function loadStyles(rootNode, { css: css2, key = "default" }) {
  let cleanup = () => {
  };
  const loaded = (() => {
    if (!isBrowser) return false;
    const ownerDocument = getOwnerDocument(rootNode);
    const _window = getWindow(rootNode);
    if (!ownerDocument || !_window) return false;
    if (!supportsAdoptedStylesheets && !rootNode.querySelector(`style[data-_sk="${key}"]`)) {
      const styleElement = ownerDocument.createElement("style");
      styleElement.dataset._sk = key;
      styleElement.textContent = css2;
      (rootNode.head || rootNode).appendChild(styleElement);
      cleanup = () => styleElement.remove();
      return true;
    }
    const styleSheet = styleSheets.get(key)?.get(_window) || new _window.CSSStyleSheet();
    if (!styleSheets.get(key)?.has(_window)) {
      styleSheets.get(key)?.set(_window, styleSheet);
    }
    styleSheet.replaceSync(css2);
    if (!rootNode.adoptedStyleSheets.includes(styleSheet)) {
      rootNode.adoptedStyleSheets.push(styleSheet);
      cleanup = () => {
        rootNode.adoptedStyleSheets = rootNode.adoptedStyleSheets.filter(
          (sheet) => sheet !== styleSheet
        );
      };
    }
    return true;
  })();
  return { loaded, cleanup };
}
const supportsAdoptedStylesheets = isBrowser && "adoptedStyleSheets" in Document.prototype;
const css = styles_css_default + components_css_default;
const stack = new Error()?.stack?.split("Error")?.at(-1)?.trim() || "";
const Root = forwardRef((props, forwardedRef) => {
  throwIfNotSingleton();
  const {
    children,
    synchronizeColorScheme = false,
    unstable_htmlSanitizer = identity,
    portalContainer: portalContainerProp,
    ...rest
  } = props;
  const [portalContainer, setPortalContainer] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootInternal, { ...rest, ref: forwardedRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Styles, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Fonts, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InlineSpriteSheet, {}),
    synchronizeColorScheme ? /* @__PURE__ */ jsxRuntimeExports.jsx(SynchronizeColorScheme, { colorScheme: props.colorScheme }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PortalContainer,
      {
        colorScheme: props.colorScheme,
        density: props.density,
        ref: setPortalContainer,
        render: portalContainerProp
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PortalContext.Provider, { value: portalContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlSanitizerContext.Provider, { value: unstable_htmlSanitizer, children }) })
  ] });
});
Root.displayName = "Root";
const RootInternal = forwardRef(
  (props, forwardedRef) => {
    const { children, colorScheme, density, ...rest } = props;
    const [rootNode, setRootNode] = reactExports.useState(null);
    const findRootNodeFromRef = reactExports.useCallback((element) => {
      if (!element) return;
      const rootNode2 = element.getRootNode();
      if (!isDocument(rootNode2) && !isShadow(rootNode2)) return;
      setRootNode(rootNode2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Role,
      {
        ...rest,
        className: classnames("Root", props.className),
        "data-_sk-theme": colorScheme,
        "data-_sk-density": density,
        ref: useMergedRefs(forwardedRef, findRootNodeFromRef),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootNodeContext.Provider, { value: rootNode, children })
      }
    );
  }
);
function SynchronizeColorScheme({
  colorScheme
}) {
  const rootNode = useRootNode();
  useLayoutEffect(() => {
    if (!rootNode) return;
    if (isDocument(rootNode)) {
      rootNode.documentElement.dataset.colorScheme = colorScheme;
      const meta2 = rootNode.querySelector("meta[name='color-scheme']");
      if (meta2) meta2.content = colorScheme;
    } else if (isShadow(rootNode)) {
      rootNode.host.dataset.colorScheme = colorScheme;
    }
  }, [rootNode, colorScheme]);
  return null;
}
const PortalContainer = forwardRef(
  (props, forwardedRef) => {
    const rootNode = useRootNode();
    if (!rootNode) return null;
    const destination = isDocument(rootNode) ? rootNode.body : rootNode;
    if (!destination) return null;
    return reactDomExports.createPortal(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Role,
        {
          render: props.render,
          className: "Root",
          "data-_sk-theme": props.colorScheme,
          "data-_sk-density": props.density,
          style: { display: "contents" },
          ref: forwardedRef
        }
      ),
      destination
    );
  }
);
function Styles() {
  const rootNode = useRootNode();
  useLayoutEffect(
    /** Adds `@layer reset` _before_ all other styles to ensure correct layer order.  */
    function addResetLayer() {
      if (!rootNode) return;
      const styleElement = document.createElement("style");
      (rootNode.head || rootNode).prepend(styleElement);
      styleElement.textContent = "@layer reset;";
    },
    [rootNode]
  );
  useLayoutEffect(() => {
    if (!rootNode) return;
    const { cleanup } = loadStyles(rootNode, { css });
    return cleanup;
  }, [rootNode]);
  return null;
}
function Fonts() {
  const rootNode = useRootNode();
  useLayoutEffect(() => {
    if (!rootNode) return;
    loadFonts(rootNode);
  }, [rootNode]);
  return null;
}
function InlineSpriteSheet() {
  const rootNode = useRootNode();
  reactExports.useEffect(
    function maybeCreateSpriteSheet() {
      const ownerDocument = getOwnerDocument(rootNode);
      if (!ownerDocument) return;
      const spriteSheet = ownerDocument?.getElementById(spriteSheetId);
      if (spriteSheet) return;
      const svg = ownerDocument.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      svg.id = spriteSheetId;
      svg.style.display = "none";
      Object.defineProperty(svg, Symbol.for(""), {
        value: { icons: /* @__PURE__ */ new Map() }
        // Map of icon URLs that have already been inlined.
      });
      ownerDocument.body.appendChild(svg);
      return () => {
        if (svg.isConnected) {
          ownerDocument.body.removeChild(svg);
        }
      };
    },
    [rootNode]
  );
  return null;
}
function loadFonts(rootNode) {
  const ownerWindow = getWindow(rootNode);
  if (!ownerWindow?.document?.fonts || Array.from(ownerWindow.document.fonts).some(
    (font) => font.family === "InterVariable"
  )) {
    return;
  }
  const interStyles = {
    normal: "https://rsms.me/inter/font-files/InterVariable.woff2?v=4.1",
    italic: "https://rsms.me/inter/font-files/InterVariable-Italic.woff2?v=4.1"
  };
  for (const [style, url] of Object.entries(interStyles)) {
    const font = new ownerWindow.FontFace(
      "InterVariable",
      `url(${url}) format("woff2")`,
      {
        display: "swap",
        weight: "100 900",
        style
      }
    );
    ownerWindow.document.fonts.add(font);
  }
}
function throwIfNotSingleton() {
  const symbol = Symbol.for("@stratakit/foundations");
  const _globalThis = globalThis;
  _globalThis[symbol] ??= { versions: /* @__PURE__ */ new Set() };
  if (stack) _globalThis[symbol].versions?.add(stack);
  if ((_globalThis[symbol].versions?.size || 0) > 1) {
    console.table(
      Array.from(_globalThis[symbol].versions || []).map((stack2) => ({
        "@stratakit/foundations location": stack2
      }))
    );
    throw new Error(
      `Multiple instances of @stratakit/foundations detected. This can lead to unexpected behavior.`
    );
  }
}
function isShadow(node) {
  return node instanceof ShadowRoot || node?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !!node?.host;
}
const withThemeBridge = (Story, context) => {
  const themeBridge = !!context.globals.themeBridge;
  const prefersDark = useMediaQuery("(prefers-color-scheme: dark)");
  if (themeBridge) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root,
      {
        colorScheme: prefersDark ? "dark" : "light",
        density: "dense",
        synchronizeColorScheme: true,
        render: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { future: { themeBridge }, ...props }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Story, {})
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Story, {}) });
};
function useMediaQuery(query) {
  const getClientSnapshot = React.useCallback(() => {
    return window.matchMedia?.(query).matches;
  }, [query]);
  const subscribe = React.useCallback(
    (onChange) => {
      const mediaQueryList = window.matchMedia?.(query);
      mediaQueryList?.addEventListener?.("change", onChange);
      return () => mediaQueryList?.removeEventListener?.("change", onChange);
    },
    [query]
  );
  return React.useSyncExternalStore(subscribe, getClientSnapshot);
}
const themeBridgeGlobalType = {
  description: "iTwinUI v5 theme bridge",
  defaultValue: void 0,
  toolbar: {
    title: "Theme bridge",
    icon: "paintbrush",
    items: [
      { title: "Enable", value: "true" },
      { title: "Disable", type: "reset" }
    ]
  }
};
withThemeBridge.__docgenInfo = { "description": "", "methods": [], "displayName": "withThemeBridge" };
const preview = {
  parameters: {
    actions: {
      argTypesRegex: "^on[A-Z].*"
    },
    backgrounds: {
      options: {
        background: {
          name: "background",
          value: "white"
        },
        "background-backdrop": {
          name: "background-backdrop",
          value: "#eef0f1"
        }
      }
    },
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/
      }
    },
    options: {
      storySort: {
        order: ["Introduction", "Components", "Frontstage", "Widget", "Hooks", "PreviewFeatures", "Deprecated"]
      }
    }
  },
  globalTypes: {
    iModel: demoIModelGlobalType,
    resizer: resizerGlobalType,
    themeBridge: themeBridgeGlobalType
  },
  decorators: [withDemoIModel, withThemeBridge],
  initialGlobals: {
    backgrounds: {
      value: "background"
    }
  }
};
const preview_6577 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: preview
}, Symbol.toStringTag, { value: "Module" }));
setup();
const { composeConfigs, PreviewWeb: PreviewWeb2 } = __STORYBOOK_MODULE_PREVIEW_API__;
const getProjectAnnotations = (hmrPreviewAnnotationModules = []) => {
  const configs = [
    hmrPreviewAnnotationModules[0] ?? entry_preview_19440,
    hmrPreviewAnnotationModules[1] ?? entry_preview_argtypes_20364,
    hmrPreviewAnnotationModules[2] ?? entry_preview_docs_19910,
    hmrPreviewAnnotationModules[3] ?? preview_19623,
    hmrPreviewAnnotationModules[4] ?? preview_19787,
    hmrPreviewAnnotationModules[5] ?? preview_6577
  ];
  return composeConfigs(configs);
};
window.__STORYBOOK_PREVIEW__ = window.__STORYBOOK_PREVIEW__ || new PreviewWeb2(importFn, getProjectAnnotations);
window.__STORYBOOK_STORY_STORE__ = window.__STORYBOOK_STORY_STORE__ || window.__STORYBOOK_PREVIEW__.storyStore;
export {
  stringTag as $,
  ShadowRoot$1 as A,
  Box as B,
  PopoverOpenContext as C,
  ButtonBase as D,
  polymorphic as E,
  mergeEventHandlers as F,
  useMergedRefs$1 as G,
  HtmlSanitizerContext as H,
  IconButton as I,
  useResizeObserver as J,
  getWindow$2 as K,
  useIsomorphicLayoutEffect as L,
  Portal as M,
  PortalContainerContext as N,
  getTag as O,
  Popover as P,
  functionTag as Q,
  React as R,
  Svg as S,
  ThemeProvider as T,
  regexpTag as U,
  VisuallyHidden as V,
  symbolTag as W,
  dateTag as X,
  booleanTag as Y,
  numberTag as Z,
  __toESM as _,
  __commonJS as a,
  objectTag as a0,
  isPlainObject$2 as a1,
  getSymbols as a2,
  errorTag as a3,
  dataViewTag as a4,
  arrayBufferTag as a5,
  float64ArrayTag as a6,
  float32ArrayTag as a7,
  bigInt64ArrayTag as a8,
  int32ArrayTag as a9,
  useFloatingParentNodeId as aA,
  useControlledState as aB,
  usePopover as aC,
  useInteractions as aD,
  useListNavigation as aE,
  cloneElementWithRef as aF,
  mergeRefs as aG,
  FloatingNode as aH,
  FloatingTree as aI,
  FloatingDelayGroup as aJ,
  defaultTooltipDelay as aK,
  useId$1 as aL,
  SvgCloseSmall as aM,
  OverflowContainer as aN,
  useSafeContext$1 as aO,
  PopoverInitialFocusContext as aP,
  useIsClient$1 as aQ,
  isReact17or18 as aR,
  CompositeItem as aS,
  Composite as aT,
  useFutureFlag as aU,
  ButtonGroup as aV,
  useToaster as aW,
  int16ArrayTag as aa,
  int8ArrayTag as ab,
  bigUint64ArrayTag as ac,
  uint32ArrayTag as ad,
  uint16ArrayTag as ae,
  uint8ClampedArrayTag as af,
  uint8ArrayTag as ag,
  arrayTag as ah,
  setTag as ai,
  mapTag as aj,
  argumentsTag as ak,
  __require$1 as al,
  __export$3 as am,
  mergeWith as an,
  pick as ao,
  mapValues as ap,
  toMerged as aq,
  React8 as ar,
  SNIPPET_RENDERED as as,
  SourceType as at,
  __require as au,
  getAugmentedNamespace as av,
  useDemoIModel as aw,
  StatusIconMap as ax,
  useFloatingTree as ay,
  useFloatingNodeId as az,
  __toESM$2 as b,
  classnames as c,
  ReactDOM2 as d,
  reactDomExports as e,
  __commonJS$2 as f,
  Tooltip as g,
  commonjsGlobal as h,
  getDefaultExportFromCjs as i,
  jsxRuntimeExports as j,
  requireReact as k,
  forwardRef as l,
  Role as m,
  useSafeContext as n,
  useRootNode as o,
  getOwnerDocument as p,
  parseDOM as q,
  reactExports as r,
  spriteSheetId as s,
  requireReactDom as t,
  useLatestRef as u,
  useLatestRef$3 as v,
  withResizer as w,
  useSyncExternalStore as x,
  getTranslateValuesFromElement as y,
  getBoundedValue as z
};
