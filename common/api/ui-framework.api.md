## API Report File for "@bentley/ui-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as _ from 'lodash';
import { AccessToken } from '@bentley/imodeljs-clients';
import { ActivityMessageDetails } from '@bentley/imodeljs-frontend';
import { ActivityMessageEndReason } from '@bentley/imodeljs-frontend';
import { BackgroundMapType } from '@bentley/imodeljs-common';
import { BaseSolarDataProvider } from '@bentley/ui-components';
import { BaseTimelineDataProvider } from '@bentley/ui-components';
import { BeEvent } from '@bentley/bentleyjs-core';
import { CategorySelectorProps } from '@bentley/imodeljs-common';
import { CheckBoxInfo } from '@bentley/ui-core';
import { ColorDef } from '@bentley/imodeljs-common';
import { CommonDivProps } from '@bentley/ui-core';
import { CommonProps } from '@bentley/ui-core';
import * as CSS from 'csstype';
import { DelayLoadedTreeNodeItem } from '@bentley/ui-components';
import { DialogProps } from '@bentley/ui-core';
import { Direction } from '@bentley/ui-ninezone';
import { DisplayStyleProps } from '@bentley/imodeljs-common';
import { DndComponentClass } from 'react-dnd';
import { DraggedWidgetManagerProps } from '@bentley/ui-ninezone';
import { DragLayerProps } from '@bentley/ui-components';
import { DragSourceArguments } from '@bentley/ui-components';
import { EmphasizeElementsProps } from '@bentley/imodeljs-frontend';
import { Face } from '@bentley/ui-core';
import { HorizontalAnchor } from '@bentley/ui-ninezone';
import { I18N } from '@bentley/imodeljs-i18n';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelConnection } from '@bentley/imodeljs-frontend';
import { InteractiveTool } from '@bentley/imodeljs-frontend';
import { IOidcFrontendClient } from '@bentley/imodeljs-clients';
import { IPresentationTreeDataProvider } from '@bentley/presentation-components';
import { Matrix3d } from '@bentley/geometry-core';
import { MessageBoxIconType } from '@bentley/imodeljs-frontend';
import { MessageBoxType } from '@bentley/imodeljs-frontend';
import { MessageBoxValue } from '@bentley/imodeljs-frontend';
import { MessageSeverity } from '@bentley/ui-core';
import { ModelSelectorProps } from '@bentley/imodeljs-common';
import { NestedStagePanelKey } from '@bentley/ui-ninezone';
import { NestedStagePanelsManagerProps } from '@bentley/ui-ninezone';
import { NineZoneManager } from '@bentley/ui-ninezone';
import { NineZoneManagerProps } from '@bentley/ui-ninezone';
import { NineZoneStagePanelManagerProps } from '@bentley/ui-ninezone';
import { NoChildrenProps } from '@bentley/ui-core';
import { NodeKey } from '@bentley/presentation-common';
import { NodePathElement } from '@bentley/presentation-common';
import { NotificationManager } from '@bentley/imodeljs-frontend';
import { NotifyMessageDetails } from '@bentley/imodeljs-frontend';
import { OidcFrontendClientConfiguration } from '@bentley/imodeljs-clients';
import { OpenMode } from '@bentley/bentleyjs-core';
import { Orientation } from '@bentley/ui-core';
import { OutputMessagePriority } from '@bentley/imodeljs-frontend';
import { PageOptions } from '@bentley/ui-components';
import { PlaybackSettings } from '@bentley/ui-components';
import { Point } from '@bentley/ui-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { PointProps } from '@bentley/ui-core';
import { PresentationTreeDataProvider } from '@bentley/presentation-components';
import * as PropTypes from 'prop-types';
import * as React_2 from 'react';
import { RectangleProps } from '@bentley/ui-core';
import { RegisteredRuleset } from '@bentley/presentation-common';
import { RelativePosition } from '@bentley/imodeljs-frontend';
import { ResizeHandle } from '@bentley/ui-ninezone';
import { Ruleset } from '@bentley/presentation-common';
import { ScreenViewport } from '@bentley/imodeljs-frontend';
import { SelectionMode } from '@bentley/ui-components';
import { SheetProps } from '@bentley/imodeljs-common';
import { Size } from '@bentley/ui-core';
import { SizeProps } from '@bentley/ui-core';
import { SnapMode } from '@bentley/imodeljs-frontend';
import { StagePanelType } from '@bentley/ui-ninezone';
import { StandardViewId } from '@bentley/imodeljs-frontend';
import { Status } from '@bentley/ui-ninezone';
import { Store } from 'redux';
import { Tab } from '@bentley/ui-ninezone';
import { TabMode } from '@bentley/ui-ninezone';
import { Tool } from '@bentley/imodeljs-frontend';
import { ToolAssistanceInstruction } from '@bentley/imodeljs-frontend';
import { ToolAssistanceInstructions } from '@bentley/imodeljs-frontend';
import { ToolbarItemInsertSpec } from '@bentley/imodeljs-frontend';
import { ToolbarPanelAlignment } from '@bentley/ui-ninezone';
import { ToolSettingsPropertyRecord } from '@bentley/imodeljs-frontend';
import { ToolSettingsPropertySyncItem } from '@bentley/imodeljs-frontend';
import { ToolTipOptions } from '@bentley/imodeljs-frontend';
import { TranslationOptions } from '@bentley/imodeljs-i18n';
import { TreeDataChangesListener } from '@bentley/ui-components';
import { TreeNodeItem } from '@bentley/ui-components';
import { UiEvent } from '@bentley/ui-core';
import { UiItemNode } from '@bentley/imodeljs-frontend';
import { UiSettings } from '@bentley/ui-core';
import { Vector3d } from '@bentley/geometry-core';
import { VerticalAnchor } from '@bentley/ui-ninezone';
import { ViewDefinitionProps } from '@bentley/imodeljs-common';
import { ViewManager } from '@bentley/imodeljs-frontend';
import { Viewport } from '@bentley/imodeljs-frontend';
import { ViewState } from '@bentley/imodeljs-frontend';
import { WidgetManagerProps } from '@bentley/ui-ninezone';
import { WidgetZoneId } from '@bentley/ui-ninezone';
import { XAndY } from '@bentley/geometry-core';
import { ZoneManagerProps } from '@bentley/ui-ninezone';
import { ZonesManagerWidgetsProps } from '@bentley/ui-ninezone';
import { ZoneTargetType } from '@bentley/ui-ninezone';

// @public
export interface Action<T extends string> {
    // (undocumented)
    type: T;
}

// @public
export abstract class ActionButtonItemDef extends ItemDefBase {
    constructor(itemProps: ItemProps);
    // (undocumented)
    protected _commandHandler?: CommandHandler;
    // (undocumented)
    execute(): void;
    // (undocumented)
    getDimension(orientation: Orientation): number;
    // @internal (undocumented)
    getKey: (index?: number | undefined) => string;
    // @internal (undocumented)
    static getRandomId(): string;
    // (undocumented)
    handleSizeKnown: (size: SizeProps) => void;
    // (undocumented)
    parameters?: any;
    // (undocumented)
    size?: SizeProps;
    // (undocumented)
    toolbarReactNode(index?: number): React_2.ReactNode;
}

// @public
export type ActionCreatorsObject = {
    [actionCreatorName: string]: FunctionType;
};

// @public
export class ActionItemButton extends React_2.Component<ActionItemButtonProps, BaseItemState> {
    constructor(props: ActionItemButtonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: ActionItemButtonProps, state: BaseItemState): BaseItemState | null;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BaseItemState>;
}

// @public
export interface ActionItemButtonProps extends CommonProps {
    // (undocumented)
    actionItem: ActionButtonItemDef;
    // (undocumented)
    isEnabled?: boolean;
    // (undocumented)
    onSizeKnown?: (size: SizeProps) => void;
}

// @beta
export interface ActionItemSpec extends BackstageItemSpec {
    // (undocumented)
    execute: (args?: any) => void;
    // (undocumented)
    readonly itemType: BackstageItemType.ActionItem;
}

// @public
export type ActionsUnion<A extends ActionCreatorsObject> = ReturnType<A[keyof A]>;

// @public
export type ActionTypes<A extends Action<any>> = A["type"] extends infer X ? (X extends string ? X : never) : never;

// @public
export interface ActionWithPayload<T extends string, P> extends Action<T> {
    // (undocumented)
    payload: P;
}

// @public
export class ActiveContentChangedEvent extends UiEvent<ActiveContentChangedEventArgs> {
}

// @public
export interface ActiveContentChangedEventArgs {
    // (undocumented)
    activeContent?: React.ReactNode;
    // (undocumented)
    oldContent?: React.ReactNode;
}

// @public
export class ActivityCenterField extends React_2.Component<StatusFieldProps, ActivityCenterState> {
    constructor(p: StatusFieldProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export class ActivityMessageCancelledEvent extends UiEvent<{}> {
}

// @public
export interface ActivityMessageEventArgs {
    // (undocumented)
    details?: ActivityMessageDetails;
    // (undocumented)
    message: HTMLElement | string;
    // (undocumented)
    percentage: number;
    // (undocumented)
    restored?: boolean;
}

// @public
export class ActivityMessageUpdatedEvent extends UiEvent<ActivityMessageEventArgs> {
}

// @alpha
export class AnalysisAnimationTimelineDataProvider extends BaseTimelineDataProvider {
    constructor(viewState: ViewState, viewport?: ScreenViewport);
    // (undocumented)
    loadTimelineData(): Promise<boolean>;
    // (undocumented)
    onAnimationFractionChanged: (animationFraction: number) => void;
    // (undocumented)
    onPlaybackSettingChanged: (settings: PlaybackSettings) => void;
    }

// @public
export type AnyItemDef = GroupItemDef | CommandItemDef | ToolItemDef | ActionButtonItemDef;

// @beta
export type AnyItemProps = ItemProps | GroupItemProps | ToolItemProps | CommandItemProps | ConditionalItemProps | CustomItemProps;

// @public
export type AnyWidgetProps = WidgetProps | ToolWidgetProps | NavigationWidgetProps;

// @public
export class AppNotificationManager extends NotificationManager {
    clearToolTip(): void;
    closeInputFieldMessage(): void;
    closePointerMessage(): void;
    endActivityMessage(reason: ActivityMessageEndReason): boolean;
    readonly isToolTipOpen: boolean;
    readonly isToolTipSupported: boolean;
    openMessageBox(mbType: MessageBoxType, message: HTMLElement | string, icon: MessageBoxIconType): Promise<MessageBoxValue>;
    outputActivityMessage(messageText: HTMLElement | string, percentComplete: number): boolean;
    outputMessage(message: NotifyMessageDetails): void;
    outputPrompt(prompt: string): void;
    outputPromptByKey(key: string): void;
    // @alpha
    setToolAssistance(instructions: ToolAssistanceInstructions | undefined): void;
    setupActivityMessage(details: ActivityMessageDetails): boolean;
    protected _showToolTip(el: HTMLElement, message: HTMLElement | string, pt?: XAndY, options?: ToolTipOptions): void;
    updatePointerMessage(displayPoint: XAndY, relativePosition: RelativePosition): void;
}

// @public
export class Backstage extends React_2.Component<BackstageProps, BackstageState> {
    constructor(props: BackstageProps);
    static readonly backstageToggleCommand: CommandItemDef;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: BackstageProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    static hide(): void;
    // (undocumented)
    static isBackstageVisible: boolean;
    // (undocumented)
    static readonly onBackstageEvent: BackstageEvent;
    // (undocumented)
    render(): React_2.ReactNode;
    static show(): void;
    // @internal (undocumented)
    readonly state: BackstageState;
}

// @beta
export class BackstageComposer extends React_2.Component<BackstageProps, BackstageComposerState> {
    constructor(props: BackstageProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    getBackstageItemNodes(): React_2.ReactNode[];
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BackstageComposerState>;
}

// @public
export class BackstageEvent extends UiEvent<BackstageEventArgs> {
}

// @public
export interface BackstageEventArgs {
    // (undocumented)
    isVisible: boolean;
}

// @beta
export class BackstageItemManager {
    static createCommandLauncherItemSpec(itemId: string, groupPriority: number, itemPriority: number, execute: () => void, label: string, subTitle?: string, toolTip?: string, iconSpec?: string): ActionItemSpec;
    static createCustomBackstageItemSpec(providerId: string, itemId: string, groupPriority: number, itemPriority: number, label: string, subTitle?: string, toolTip?: string, iconSpec?: string): CustomItemSpec;
    static createFrontstageLauncherItemSpec(frontstageId: string, groupPriority: number, itemPriority: number, label: string, subTitle?: string, toolTip?: string, iconSpec?: string): StageLauncher;
    static getBackstageItemProvider(providerId: string): BackstageItemProvider | undefined;
    static getBackstageItemSpecs(): BackstageItemSpec[];
    static readonly hasRegisteredProviders: boolean;
    static readonly onBackstageItemProviderRegisteredEvent: BeEvent<(ev: BackstageItemProviderRegisteredEventArgs) => void>;
    static register(itemProvider: BackstageItemProvider): void;
    static unregister(itemProviderId: string): void;
}

// @public
export interface BackstageItemProps extends LabelProps, DescriptionProps, TooltipProps, IconProps {
    isActive?: boolean;
    isEnabled?: boolean;
    stateFunc?: (state: Readonly<BackstageItemState>) => BackstageItemState;
    stateSyncIds?: string[];
}

// @beta
export interface BackstageItemProvider {
    readonly id: string;
    provideBackstageItems: () => BackstageItemSpec[];
    provideCustomBackstageItem?: (itemSpec: CustomItemSpec) => React_2.ReactNode;
}

// @beta
export interface BackstageItemProviderRegisteredEventArgs {
    // (undocumented)
    providerId: string;
}

// @beta
export interface BackstageItemSpec {
    badge?: BadgeType;
    condition?: ConditionalDisplaySpecification;
    groupPriority: number;
    icon?: string;
    itemId: string;
    itemPriority: number;
    itemType: BackstageItemType;
    label: string;
    subtitle?: string;
    toolTip?: string;
}

// @public
export interface BackstageItemState {
    // (undocumented)
    iconSpec: IconSpec;
    // (undocumented)
    isActive?: boolean;
    // (undocumented)
    isEnabled: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    subtitle: string;
    // (undocumented)
    tooltip: string;
}

// @beta
export enum BackstageItemType {
    ActionItem = 1,
    CustomItem = 3,
    StageLauncher = 2
}

// @public
export interface BackstageProps extends CommonProps {
    // (undocumented)
    accessToken?: AccessToken;
    // (undocumented)
    header?: React_2.ReactNode;
    // (undocumented)
    isVisible?: boolean;
    // (undocumented)
    onClose?: () => void;
    // (undocumented)
    showOverlay?: boolean;
}

// @beta
export enum BadgeType {
    None = 0,
    TechnicalPreview = 1
}

// @public
export interface BaseItemState {
    // (undocumented)
    isActive?: boolean;
    // (undocumented)
    isEnabled?: boolean;
    // (undocumented)
    isPressed?: boolean;
    // (undocumented)
    isVisible?: boolean;
}

// @public
export interface BooleanListenerProps {
    boolFunc: () => boolean;
    defaultValue?: boolean;
    eventIds: string[];
}

// @public
export class BooleanSyncUiListener extends React_2.Component<BooleanListenerProps, BooleanListenerState> {
    constructor(props: BooleanListenerProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: BooleanListenerState;
}

// @alpha
export class CardContainer extends React_2.Component<CardContainerProps> {
    static readonly onCardSelectedEvent: CardSelectedEvent;
    // @internal (undocumented)
    render(): JSX.Element;
}

// @alpha
export interface CardContainerProps extends CommonProps {
    // (undocumented)
    cards: CardInfo[];
    // (undocumented)
    connection: IModelConnection;
    // (undocumented)
    searchValue: string;
}

// @alpha
export interface CardInfo {
    // (undocumented)
    iconSpec: string;
    // (undocumented)
    index: number;
    // (undocumented)
    isActive: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    viewId: any;
}

// @alpha
export class CardSelectedEvent extends UiEvent<CardSelectedEventArgs> {
}

// @alpha
export interface CardSelectedEventArgs {
    // (undocumented)
    id: any;
    // (undocumented)
    index: number;
}

// @alpha
export class CategoryTree extends React_2.Component<CategoryTreeProps, CategoryTreeState> {
    constructor(props: CategoryTreeProps);
    // @internal (undocumented)
    componentDidMount(): Promise<void>;
    // (undocumented)
    componentDidUpdate(prevProps: CategoryTreeProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface CategoryTreeProps {
    activeView?: Viewport;
    allViewports?: boolean;
    clearAll?: boolean;
    iModel: IModelConnection;
    selectAll?: boolean;
    showSearchBox?: boolean;
}

// @alpha
export interface CategoryTreeState {
    // (undocumented)
    activeView?: Viewport;
    // (undocumented)
    categories: Category[];
    // (undocumented)
    checkboxInfo: (node: TreeNodeItem) => CheckBoxInfo | Promise<CheckBoxInfo>;
    // (undocumented)
    dataProvider?: PresentationTreeDataProvider;
    // (undocumented)
    filterInfo?: FilterInfo;
    // (undocumented)
    isLoading: boolean;
    // (undocumented)
    selectedNodes: string[];
}

// @internal
export interface ChangeSetInfo {
    // (undocumented)
    changeSetId?: string;
    // (undocumented)
    description: string;
    // (undocumented)
    largeThumbnail?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    pushDate: Date;
    // (undocumented)
    smallThumbnail?: string;
    // (undocumented)
    userCreated?: string;
}

// @beta
export const COLOR_THEME_DEFAULT = ColorTheme.Light;

// @beta
export enum ColorTheme {
    // (undocumented)
    Dark = "dark",
    // (undocumented)
    Light = "light"
}

// @internal (undocumented)
export enum ColumnType {
    // (undocumented)
    Empty = 3,
    // (undocumented)
    Label = 0,
    // (undocumented)
    Record = 1,
    // (undocumented)
    RecordSpan = 2
}

// @public
export type CombinedReducerState<R> = {
    readonly [K in keyof R]: R[K] extends FunctionType ? StateType<R[K]> : never;
};

// @public
export const combineReducers: CombineReducersFunction;

// @public
export type CombineReducersFunction = <A>(reducers: A) => (state: CombinedReducerState<A>, action: ReducerMapActions<A>) => CombinedReducerState<A>;

// @public
export interface CommandHandler {
    // (undocumented)
    execute?: (args?: any) => any;
    // (undocumented)
    getCommandArgs?: () => any[];
    // (undocumented)
    parameters?: any;
}

// @public
export class CommandItemDef extends ActionButtonItemDef {
    constructor(commandItemProps: CommandItemProps);
    // (undocumented)
    commandId: string;
    // (undocumented)
    static commandIdPrefix: string;
    // (undocumented)
    readonly id: string;
    }

// @public
export interface CommandItemProps extends ItemProps, CommandHandler {
    // (undocumented)
    commandId?: string;
}

// @public
export class CommandLaunchBackstageItem extends React_2.PureComponent<CommandLaunchBackstageItemProps, BackstageItemState> {
    constructor(props: CommandLaunchBackstageItemProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(_prevProps: CommandLaunchBackstageItemProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    execute: () => void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BackstageItemState>;
    }

// @public
export interface CommandLaunchBackstageItemProps extends BackstageItemProps, CommandHandler {
    commandId: string;
}

// @beta
export interface ConditionalDisplaySpecification {
    // (undocumented)
    syncEventIds: string[];
    // (undocumented)
    testFunc: () => boolean;
    // (undocumented)
    type: ConditionalDisplayType;
}

// @beta
export enum ConditionalDisplayType {
    // (undocumented)
    EnableState = 1,
    // (undocumented)
    Visibility = 0
}

// @beta
export class ConditionalItemDef extends ItemDefBase {
    constructor(props: ConditionalItemProps);
    // (undocumented)
    conditionalId: string;
    // (undocumented)
    static conditionalIdPrefix: string;
    // (undocumented)
    getVisibleItems(): ActionButtonItemDef[];
    // (undocumented)
    handleSyncUiEvent(args: SyncUiEventArgs): boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    items: AnyItemDef[];
    // (undocumented)
    resolveItems(force?: boolean): void;
    }

// @beta
export interface ConditionalItemProps extends ItemProps {
    // (undocumented)
    conditionalId?: string;
    // (undocumented)
    items: AnyItemDef[];
}

// @public
export class ConfigurableBase implements ConfigurableUiElement {
    constructor(info: ConfigurableCreateInfo, options: any);
    readonly classId: string;
    readonly name: string;
    // @internal (undocumented)
    readonly uniqueId: string;
    }

// @public
export class ConfigurableCreateInfo {
    constructor(classId: string, uniqueId: string, id: string);
    // (undocumented)
    readonly classId: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly uniqueId: string;
}

// @public
export enum ConfigurableUiActionId {
    // (undocumented)
    SetSnapMode = "configurableui:set_snapmode",
    // (undocumented)
    SetTheme = "configurableui:set_theme",
    // (undocumented)
    SetToolPrompt = "configurableui:set_toolprompt",
    // (undocumented)
    SetWidgetOpacity = "configurableui:set_widget_opacity"
}

// @public
export const ConfigurableUiActions: {
    setSnapMode: (snapMode: number) => import("../utils/redux-ts").ActionWithPayload<ConfigurableUiActionId.SetSnapMode, number>;
    setToolPrompt: (toolPrompt: string) => import("../utils/redux-ts").ActionWithPayload<ConfigurableUiActionId.SetToolPrompt, string>;
    setTheme: (theme: string) => import("../utils/redux-ts").ActionWithPayload<ConfigurableUiActionId.SetTheme, string>;
    setWidgetOpacity: (opacity: number) => import("../utils/redux-ts").ActionWithPayload<ConfigurableUiActionId.SetWidgetOpacity, number>;
};

// @public
export type ConfigurableUiActionsUnion = ActionsUnion<typeof ConfigurableUiActions>;

// @public
export const ConfigurableUiContent: any;

// @public
export interface ConfigurableUiContentProps extends CommonProps {
    // (undocumented)
    appBackstage?: React_2.ReactNode;
    // (undocumented)
    placeholder: string;
}

// @public
export abstract class ConfigurableUiControl extends ConfigurableBase {
    constructor(info: ConfigurableCreateInfo, options: any);
    readonly controlId: string;
    abstract getType(): ConfigurableUiControlType;
    // @internal (undocumented)
    initialize(): void;
    readonly isReady: Promise<void>;
    onFrontstageDeactivated(): void;
    onFrontstageReady(): void;
    onInitialize(): void;
}

// @public
export type ConfigurableUiControlConstructor = new (info: ConfigurableCreateInfo, options: any) => ConfigurableUiElement;

// @public
export enum ConfigurableUiControlType {
    // (undocumented)
    Content = "ContentControl",
    // (undocumented)
    NavigationAid = "NavigationAidControl",
    // (undocumented)
    StatusBarWidget = "StatusBarWidgetControl",
    // (undocumented)
    ToolUiProvider = "ToolUiProvider",
    // (undocumented)
    Viewport = "ViewportContentControl",
    // (undocumented)
    Widget = "WidgetControl"
}

// @public
export interface ConfigurableUiElement {
    // (undocumented)
    classId: string;
    // (undocumented)
    name: string;
    // (undocumented)
    uniqueId: string;
}

// @public
export class ConfigurableUiManager {
    static addFrontstageProvider(frontstageProvider: FrontstageProvider): void;
    static createControl(classId: string, uniqueId: string, options?: any): ConfigurableUiElement | undefined;
    static findFrontstageDef(id?: string): FrontstageDef | undefined;
    // @internal
    static getConstructorClassId(constructor: ConfigurableUiControlConstructor): string | undefined;
    static initialize(): void;
    static isControlRegistered(classId: string): boolean;
    static loadContentGroup(groupProps: ContentGroupProps): void;
    static loadContentGroups(groupPropsList: ContentGroupProps[]): void;
    static loadContentLayout(layoutProps: ContentLayoutProps): void;
    static loadContentLayouts(layoutPropsList: ContentLayoutProps[]): void;
    static loadKeyboardShortcuts(shortcutList: KeyboardShortcutProps[]): void;
    static loadTasks(taskPropsList: TaskPropsList): void;
    static loadWorkflow(workflowProps: WorkflowProps): void;
    static loadWorkflows(workflowPropsList: WorkflowPropsList): void;
    static registerControl(classId: string, constructor: ConfigurableUiControlConstructor): void;
    static unregisterControl(classId: string): void;
}

// @public
export function ConfigurableUiReducer(state: ConfigurableUiState | undefined, _action: ConfigurableUiActionsUnion): ConfigurableUiState;

// @public
export interface ConfigurableUiState {
    // (undocumented)
    snapMode: number;
    // (undocumented)
    theme: string;
    // (undocumented)
    toolPrompt: string;
    // (undocumented)
    widgetOpacity: number;
}

// @beta
export type ContentCallback = (content: ContentProps) => void;

// @public
export class ContentControl extends ConfigurableUiControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    getType(): ConfigurableUiControlType;
    readonly isViewport: boolean;
    readonly navigationAidControl: string;
    onActivated(): void;
    onDeactivated(): void;
    reactElement: React_2.ReactNode;
    readonly viewport: ScreenViewport | undefined;
}

// @public
export class ContentControlActivatedEvent extends UiEvent<ContentControlActivatedEventArgs> {
}

// @public
export interface ContentControlActivatedEventArgs {
    // (undocumented)
    activeContentControl: ContentControl;
    // (undocumented)
    oldContentControl?: ContentControl;
}

// @public
export class ContentGroup {
    constructor(groupProps: ContentGroupProps);
    clearContentControls(): void;
    // (undocumented)
    contentPropsList: ContentProps[];
    getContentControl(contentProps: ContentProps, index: number): ContentControl | undefined;
    getContentControlById(id: string): ContentControl | undefined;
    getContentControls(): ContentControl[];
    getContentNodes(): React_2.ReactNode[];
    getControlFromElement(node: React_2.ReactNode): ContentControl | undefined;
    // @internal
    getViewports(): Array<ScreenViewport | undefined>;
    // (undocumented)
    groupId: string;
    onFrontstageDeactivated(): void;
    onFrontstageReady(): void;
    refreshContentNodes(): void;
    // @beta
    toJSON(contentCallback?: ContentCallback): ContentGroupProps;
}

// @public
export class ContentGroupManager {
    // (undocumented)
    static addGroup(groupId: string, group: ContentGroup): void;
    // (undocumented)
    static findGroup(groupId: string): ContentGroup | undefined;
    // (undocumented)
    static loadGroup(groupProps: ContentGroupProps): void;
    // (undocumented)
    static loadGroups(groupPropsList: ContentGroupProps[]): void;
}

// @public
export interface ContentGroupProps {
    contents: ContentProps[];
    id?: string;
}

// @public
export class ContentLayout extends React_2.Component<ContentLayoutComponentProps, ContentLayoutState> {
    constructor(props: ContentLayoutComponentProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<ContentLayoutState>;
    }

// @public
export class ContentLayoutActivatedEvent extends UiEvent<ContentLayoutActivatedEventArgs> {
}

// @public
export interface ContentLayoutActivatedEventArgs {
    // (undocumented)
    contentGroup: ContentGroup;
    // (undocumented)
    contentLayout: ContentLayoutDef;
}

// @public
export interface ContentLayoutComponentProps extends CommonProps {
    // (undocumented)
    contentGroup: ContentGroup;
    // (undocumented)
    contentLayout: ContentLayoutDef;
    // (undocumented)
    isInFooterMode: boolean;
}

// @public
export class ContentLayoutDef {
    constructor(layoutProps: ContentLayoutProps);
    // @internal (undocumented)
    static createSplit(fragmentDef: LayoutFragmentProps): LayoutSplit | undefined;
    descriptionKey: string;
    fillLayoutContainer(contentNodes: React_2.ReactNode[], resizable: boolean): React_2.ReactNode | undefined;
    getUsedContentIndexes(): number[];
    id: string;
    priority: number;
    // (undocumented)
    readonly rootSplit: LayoutSplit | undefined;
    // @beta
    toJSON(): ContentLayoutProps;
}

// @public
export class ContentLayoutManager {
    static readonly activeContentGroup: ContentGroup | undefined;
    static readonly activeLayout: ContentLayoutDef | undefined;
    static addLayout(layoutId: string, layoutDef: ContentLayoutDef): void;
    static findLayout(layoutId: string): ContentLayoutDef | undefined;
    static loadLayout(layoutProps: ContentLayoutProps): void;
    static loadLayouts(layoutPropsList: ContentLayoutProps[]): void;
    static refreshActiveLayout(): void;
    static setActiveLayout(contentLayoutDef: ContentLayoutDef, contentGroup: ContentGroup): Promise<void>;
}

// @public
export interface ContentLayoutProps extends LayoutFragmentProps {
    descriptionKey?: string;
    id?: string;
    priority?: number;
}

// @public
export interface ContentProps {
    applicationData?: any;
    classId: string | ConfigurableUiControlConstructor;
    id?: string;
}

// @public
export class ContentViewManager {
    static contentSupportsCamera(content: ContentControl | undefined): boolean;
    static getActiveContent(): React.ReactNode | undefined;
    static getActiveContentControl(): ContentControl | undefined;
    static isContent3dView(content: ContentControl | undefined): boolean;
    static isContentDrawingView(content: ContentControl | undefined): boolean;
    static isContentOrthographicView(content: ContentControl | undefined): boolean;
    static isContentSheetView(content: ContentControl | undefined): boolean;
    static isContentSpatialView(content: ContentControl | undefined): boolean;
    static readonly isMouseDown: boolean;
    static readonly onActiveContentChangedEvent: ActiveContentChangedEvent;
    static readonly onMouseDownChangedEvent: MouseDownChangedEvent;
    static refreshActiveContent(activeContent: React.ReactNode): void;
    static setActiveContent(activeContent?: React.ReactNode, forceEventProcessing?: boolean): void;
    static setMouseDown(mouseDown: boolean): void;
}

// @public
export class CoreTools {
    // (undocumented)
    static readonly fitViewCommand: ToolItemDef;
    // (undocumented)
    static readonly flyViewCommand: ToolItemDef;
    // @beta
    static readonly keyinBrowserButtonItemDef: CustomItemDef;
    // (undocumented)
    static readonly panViewCommand: ToolItemDef;
    // (undocumented)
    static readonly rotateViewCommand: ToolItemDef;
    // (undocumented)
    static readonly sectionByPlaneCommand: ToolItemDef;
    // (undocumented)
    static readonly selectElementCommand: ToolItemDef;
    // (undocumented)
    static readonly toggleCameraViewCommand: ToolItemDef;
    // (undocumented)
    static readonly viewRedoCommand: ToolItemDef;
    // (undocumented)
    static readonly viewUndoCommand: ToolItemDef;
    // (undocumented)
    static readonly walkViewCommand: ToolItemDef;
    // (undocumented)
    static readonly windowAreaCommand: ToolItemDef;
    // (undocumented)
    static readonly zoomViewCommand: ToolItemDef;
}

// @public
export function createAction<T extends string>(type: T): Action<T>;

// @public
export function createAction<T extends string, P>(type: T, payload: P): ActionWithPayload<T, DeepReadonly<P>>;

// @internal (undocumented)
export enum CubeHover {
    // (undocumented)
    Active = 2,
    // (undocumented)
    Hover = 1,
    // (undocumented)
    None = 0
}

// @alpha
export class CubeNavigationAid extends React_2.Component<CubeNavigationAidProps, CubeNavigationAidState> {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    readonly state: Readonly<CubeNavigationAidState>;
}

// @alpha
export class CubeNavigationAidControl extends NavigationAidControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    getSize(): string | undefined;
    // (undocumented)
    static navigationAidId: string;
}

// @alpha
export interface CubeNavigationAidProps extends CommonProps {
    // @internal (undocumented)
    animationTime?: number;
    // @internal (undocumented)
    contentControlOverride?: ContentControl | undefined;
    // (undocumented)
    iModelConnection: IModelConnection;
    // @internal (undocumented)
    onAnimationEnd?: () => void;
}

// @beta
export enum CursorDirection {
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    BottomLeft = 257,
    // (undocumented)
    BottomRight = 17,
    // (undocumented)
    Left = 256,
    // (undocumented)
    None = 0,
    // (undocumented)
    Right = 16,
    // (undocumented)
    Top = 4096,
    // (undocumented)
    TopLeft = 4352,
    // (undocumented)
    TopRight = 4112
}

// @beta
export enum CursorDirectionParts {
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    Left = 256,
    // (undocumented)
    Right = 16,
    // (undocumented)
    Top = 4096
}

// @beta
export class CursorInformation {
    // @internal
    static clearCursorDirections(): void;
    static readonly cursorDirection: CursorDirection;
    static cursorPosition: PointProps;
    static readonly cursorX: number;
    static readonly cursorY: number;
    static getRelativePositionFromCursorDirection(cursorDirection: CursorDirection): RelativePosition;
    static handleMouseMove(point: PointProps): void;
    static readonly onCursorUpdatedEvent: CursorUpdatedEvent;
}

// @beta
export class CursorPopup extends React_2.Component<CursorPopupProps, CursorPopupState> {
    // @internal
    constructor(props: CursorPopupProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static fadeOutTime: number;
    // @internal (undocumented)
    static getPopupRect(pt: PointProps, offset: PointProps, popupSize: SizeProps | undefined, relativePosition: RelativePosition): RectangleProps;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @beta
export const CursorPopupContent: React_2.FunctionComponent<CommonDivProps>;

// @internal
export class CursorPopupFadeOutEvent extends UiEvent<CursorPopupFadeOutEventArgs> {
}

// @internal
export interface CursorPopupFadeOutEventArgs {
    // (undocumented)
    id: string;
}

// @beta
export class CursorPopupManager {
    static close(id: string, apply: boolean, fadeOut?: boolean): void;
    // @internal (undocumented)
    static readonly onCursorPopupFadeOutEvent: CursorPopupFadeOutEvent;
    // @internal (undocumented)
    static readonly onCursorPopupsChangedEvent: CursorPopupsChangedEvent;
    // @internal (undocumented)
    static readonly onCursorPopupUpdatePositionEvent: CursorPopupUpdatePositionEvent;
    static open(id: string, content: React_2.ReactNode, pt: PointProps, offset: PointProps, relativePosition: RelativePosition, priority?: number, options?: CursorPopupOptions): void;
    // (undocumented)
    static readonly popupCount: number;
    // (undocumented)
    static readonly popups: CursorPopupInfo[];
    static update(id: string, content: React_2.ReactNode, pt: PointProps, offset: PointProps, relativePosition: RelativePosition, priority?: number): void;
    static updatePosition(pt: PointProps): void;
    }

// @beta
export interface CursorPopupOptions {
    onApply?: () => void;
    onClose?: () => void;
    shadow?: boolean;
    title?: string;
}

// @beta
export interface CursorPopupProps extends CommonProps {
    // (undocumented)
    content: React_2.ReactNode;
    // (undocumented)
    id: string;
    // (undocumented)
    offset: PointProps;
    onSizeKnown?: (size: SizeProps) => void;
    // (undocumented)
    pt: PointProps;
    // (undocumented)
    relativePosition: RelativePosition;
    // (undocumented)
    shadow?: boolean;
    // (undocumented)
    title?: string;
}

// @beta
export class CursorPopupRenderer extends React_2.Component<any, CursorPopupRendererState> {
    constructor(props: any);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    }

// @internal
export enum CursorPopupShow {
    // (undocumented)
    FadeOut = 1,
    // (undocumented)
    Open = 0
}

// @internal
export class CursorPopupUpdatePositionEvent extends UiEvent<CursorPopupUpdatePositionEventArgs> {
}

// @internal
export interface CursorPopupUpdatePositionEventArgs {
    // (undocumented)
    pt: PointProps;
}

// @alpha (undocumented)
export class CursorPrompt {
    constructor(timeOut: number, fadeOut: boolean);
    // @internal
    close(fadeOut: boolean): void;
    // (undocumented)
    display(toolIconSpec: string, instruction: ToolAssistanceInstruction, offset?: PointProps, relativePosition?: RelativePosition): void;
    }

// @beta
export class CursorUpdatedEvent extends UiEvent<CursorUpdatedEventArgs> {
}

// @beta
export interface CursorUpdatedEventArgs {
    // (undocumented)
    direction: CursorDirection;
    // (undocumented)
    newPt: PointProps;
    // (undocumented)
    oldPt: PointProps;
}

// @beta
export class CustomItemDef extends ActionButtonItemDef {
    constructor(props: CustomItemProps);
    // (undocumented)
    customId: string;
    // (undocumented)
    static customIdPrefix: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    reactElement: React_2.ReactNode;
    // (undocumented)
    toolbarReactNode(index?: number): React_2.ReactNode;
}

// @beta
export interface CustomItemProps extends ItemProps {
    // (undocumented)
    customId?: string;
    // (undocumented)
    reactElement: React.ReactNode;
}

// @beta
export interface CustomItemSpec extends BackstageItemSpec {
    // (undocumented)
    customItemProviderId: string;
    // (undocumented)
    readonly itemType: BackstageItemType.CustomItem;
}

// @public
export type DeepReadonly<T> = T extends ReadonlyArray<infer R> ? (R extends object ? DeepReadonlyArray<R> : ReadonlyArray<R>) : T extends FunctionType ? T : T extends object ? DeepReadonlyObject<T> : T;

// @public
export interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {
}

// @public
export type DeepReadonlyObject<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

// @internal
export class DefaultToolSettingsProvider extends ToolUiProvider {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    execute(): void;
    // (undocumented)
    labelMap: Map<string, TsLabel>;
    // (undocumented)
    onInitialize(): void;
    // (undocumented)
    rows: TsRow[];
    // (undocumented)
    valueMap: Map<string, ToolSettingsPropertyRecord>;
}

// @public
export interface DescriptionProps {
    description?: string | StringGetter;
    descriptionKey?: string;
}

// @public
export class DialogChangedEvent extends UiEvent<DialogChangedEventArgs> {
}

// @public
export interface DialogChangedEventArgs {
    // (undocumented)
    activeDialog: React_2.ReactNode | undefined;
    // (undocumented)
    dialogCount: number;
}

// @public
export interface DialogInfo {
    // (undocumented)
    id: string;
    // (undocumented)
    reactNode: React_2.ReactNode;
}

// @internal
export class DialogManagerBase {
    constructor(onDialogChangedEvent: DialogChangedEvent);
    // (undocumented)
    readonly activeDialog: React_2.ReactNode | undefined;
    // (undocumented)
    closeDialog(dialog?: React_2.ReactNode): void;
    // (undocumented)
    readonly dialogCount: number;
    // (undocumented)
    readonly dialogs: DialogInfo[];
    // (undocumented)
    emitDialogChangedEvent(): void;
    // (undocumented)
    readonly onDialogChangedEvent: DialogChangedEvent;
    // (undocumented)
    openDialog(dialog: React_2.ReactNode, id?: string): void;
    // (undocumented)
    pushDialog(dialogInfo: DialogInfo): void;
    // (undocumented)
    removeDialog(dialog: React_2.ReactNode): void;
    // (undocumented)
    update(): void;
}

// @internal
export class DialogRendererBase extends React_2.PureComponent<DialogRendererProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface DialogRendererProps {
    // (undocumented)
    dialogManager: DialogManagerBase;
}

// @beta
export class DragDropLayerChangedEvent extends UiEvent<DragDropLayerChangedEventArgs> {
}

// @beta
export interface DragDropLayerChangedEventArgs {
    type: string | undefined;
}

// @beta
export class DragDropLayerManager {
    static getActiveLayer(): React_2.ComponentClass<DragLayerProps<any>, any> | React_2.FunctionComponent<DragLayerProps<any>> | undefined;
    static getType(): string | undefined;
    // (undocumented)
    static readonly onDragDropLayerChangedEvent: DragDropLayerChangedEvent;
    static registerTypeLayer(type: string, layer: React_2.ComponentType<DragLayerProps>): void;
    static setType(type: string | undefined): void;
}

// @beta
export const DragDropLayerRenderer: typeof DragDropLayerRendererComponent & DndComponentClass<{}>;

// @beta
export class DragDropLayerRendererComponent extends React_2.Component<DragDropLayerRendererProps> {
    constructor(props: DragDropLayerRendererProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @beta
export interface DragDropLayerRendererProps extends CommonProps {
    // (undocumented)
    args?: DragSourceArguments;
    // @internal (undocumented)
    clientOffset?: {
        x: number;
        y: number;
    };
    // (undocumented)
    dragging?: boolean;
    // @internal (undocumented)
    initialClientOffset?: {
        x: number;
        y: number;
    };
    // @internal (undocumented)
    initialSourceClientOffset?: {
        x: number;
        y: number;
    };
    // (undocumented)
    item?: any;
    // (undocumented)
    itemType?: string;
    // @internal (undocumented)
    sourceClientOffset?: {
        x: number;
        y: number;
    };
}

// @alpha
export class DrawingNavigationAid extends React_2.Component<DrawingNavigationAidProps, DrawingNavigationAidState> {
    constructor(props: DrawingNavigationAidProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static findRotatedWindowDimensions: (extents: Vector3d, rotation: Matrix3d) => Vector3d;
    // @internal (undocumented)
    static getDefaultClosedMapSize: () => Vector3d;
    // @internal (undocumented)
    static getDefaultOpenedMapSize: (paddingX?: number, paddingY?: number) => Vector3d;
    // @internal (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<DrawingNavigationAidState>;
    }

// @alpha
export class DrawingNavigationAidControl extends NavigationAidControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    getSize(): string | undefined;
    // (undocumented)
    static navigationAidId: string;
}

// @alpha
export interface DrawingNavigationAidProps extends CommonProps {
    // @internal (undocumented)
    animationTime?: number;
    // @internal (undocumented)
    closeSize?: Vector3d;
    // @internal (undocumented)
    contentControlOverride?: ContentControl | undefined;
    // (undocumented)
    iModelConnection: IModelConnection;
    // @internal (undocumented)
    initialMapMode?: MapMode;
    // @internal (undocumented)
    initialRotateMinimapWithView?: boolean;
    // @internal (undocumented)
    initialView?: ViewState;
    // @internal (undocumented)
    onAnimationEnd?: () => void;
    // @internal (undocumented)
    openSize?: Vector3d;
    // @internal (undocumented)
    screenViewportOverride?: typeof ScreenViewport;
    // @internal (undocumented)
    viewManagerOverride?: ViewManager;
}

// @internal (undocumented)
export class DrawingNavigationCanvas extends React_2.Component<DrawingNavigationCanvasProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(oldProps: DrawingNavigationCanvasProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    }

// @internal (undocumented)
export interface DrawingNavigationCanvasProps {
    // (undocumented)
    canvasSizeOverride?: boolean;
    // (undocumented)
    extents: Vector3d;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    rotation: Matrix3d;
    // (undocumented)
    screenViewportOverride?: typeof ScreenViewport;
    // (undocumented)
    view: ViewState | undefined;
    // (undocumented)
    viewId?: string;
    // (undocumented)
    viewManagerOverride?: ViewManager;
    // (undocumented)
    zoom: number;
}

// @public
export class ElementTooltip extends React_2.Component<CommonProps, ElementTooltipState> {
    constructor(props: CommonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static hideTooltip(): void;
    // (undocumented)
    static readonly isTooltipVisible: boolean;
    // (undocumented)
    static readonly onElementTooltipChangedEvent: ElementTooltipChangedEvent;
    // (undocumented)
    render(): JSX.Element | null;
    // (undocumented)
    static showTooltip(el: HTMLElement, message: HTMLElement | string, pt?: XAndY, options?: ToolTipOptions): void;
    // @internal (undocumented)
    readonly state: Readonly<ElementTooltipState>;
    }

// @public
export class ElementTooltipChangedEvent extends UiEvent<ElementTooltipChangedEventArgs> {
}

// @public
export interface ElementTooltipChangedEventArgs {
    // (undocumented)
    el?: HTMLElement;
    // (undocumented)
    isTooltipVisible: boolean;
    // (undocumented)
    message: HTMLElement | string;
    // (undocumented)
    options?: ToolTipOptions;
    // (undocumented)
    pt?: XAndY;
}

// @beta
export class ExpandableSection extends React_2.PureComponent<ExpandableSectionProps, ExpandableSectionState> {
    constructor(props: ExpandableSectionProps);
    render(): JSX.Element;
}

// @beta
export interface ExpandableSectionProps extends CommonProps {
    // (undocumented)
    expanded?: boolean;
    // (undocumented)
    title?: string;
}

// @internal (undocumented)
export class FaceCell extends React_2.Component<FaceCellProps> {
    // (undocumented)
    render(): React_2.ReactNode;
    }

// @internal (undocumented)
export interface FaceCellProps extends React_2.AllHTMLAttributes<HTMLDivElement> {
    // (undocumented)
    center?: boolean;
    // (undocumented)
    face: Face;
    // (undocumented)
    hoverMap: {
        [key: string]: CubeHover;
    };
    // (undocumented)
    onFaceCellClick: (vector: Vector3d, face: Face) => void;
    // (undocumented)
    onFaceCellHoverChange: (vector: Vector3d, state: CubeHover) => void;
    // (undocumented)
    vector: Vector3d;
}

// @alpha
export interface FilterInfo {
    // (undocumented)
    activeMatchIndex?: number;
    // (undocumented)
    filter?: string;
    // (undocumented)
    filtering?: boolean;
    // (undocumented)
    matchesCount?: number;
}

// @beta
export const FrameworkReducer: (state: import("./utils/redux-ts").CombinedReducerState<{
    configurableUiState: typeof ConfigurableUiReducer;
    sessionState: typeof SessionStateReducer;
}>, action: import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./configurableui/state").ConfigurableUiActionId.SetSnapMode, number>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./configurableui/state").ConfigurableUiActionId.SetToolPrompt, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./configurableui/state").ConfigurableUiActionId.SetTheme, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./configurableui/state").ConfigurableUiActionId.SetWidgetOpacity, number>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetNumItemsSelected, number>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetAvailableSelectionScopes, import("./utils/redux-ts").DeepReadonlyArray<import("./SessionState").PresentationSelectionScope>>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetSelectionScope, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetActiveIModelId, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetDefaultIModelViewportControlId, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetDefaultViewId, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetDefaultRulesetId, string>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetIModelConnection, any>> | import("./utils/redux-ts").DeepReadonlyObject<import("./utils/redux-ts").ActionWithPayload<import("./SessionState").SessionStateActionId.SetAccessToken, any>>) => import("./utils/redux-ts").CombinedReducerState<{
    configurableUiState: typeof ConfigurableUiReducer;
    sessionState: typeof SessionStateReducer;
}>;

// @internal
export class FrameworkStagePanel extends React_2.PureComponent<FrameworkStagePanelProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface FrameworkStagePanelProps {
    // (undocumented)
    allowedZones?: ZoneLocation[];
    // (undocumented)
    changeHandler: StagePanelChangeHandler;
    // (undocumented)
    draggedWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    getWidgetContentRef: (id: WidgetZoneId) => React_2.Ref<HTMLDivElement>;
    // (undocumented)
    initialSize?: number;
    // (undocumented)
    isTargeted: boolean;
    // (undocumented)
    location: StagePanelLocation;
    // (undocumented)
    panel: NineZoneStagePanelManagerProps;
    // (undocumented)
    renderPane: (index: number) => React_2.ReactNode;
    // (undocumented)
    resizable: boolean;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgetCount: number;
    // (undocumented)
    widgets: ZonesManagerWidgetsProps;
    // (undocumented)
    widgetTabs: WidgetTabs;
}

// @beta
export interface FrameworkState {
    // (undocumented)
    configurableUiState: ConfigurableUiState;
    // (undocumented)
    sessionState: SessionState;
}

// @internal
export class FrameworkZone extends React_2.PureComponent<FrameworkZoneProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface FrameworkZoneProps extends CommonProps {
    // (undocumented)
    activeTabIndex: number;
    // (undocumented)
    draggedWidget: DraggedWidgetManagerProps | undefined;
    // (undocumented)
    dropTarget: ZoneTargetType | undefined;
    // (undocumented)
    fillZone?: boolean;
    // (undocumented)
    getWidgetContentRef: (id: WidgetZoneId) => React_2.Ref<HTMLDivElement>;
    // (undocumented)
    isHidden: boolean;
    // (undocumented)
    openWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    targetChangeHandler: TargetChangeHandler;
    // (undocumented)
    targetedBounds?: RectangleProps;
    // (undocumented)
    widget: WidgetManagerProps | undefined;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgetElement: React_2.ReactNode;
    // (undocumented)
    widgetTabs: WidgetTabs;
    // (undocumented)
    zone: ZoneManagerProps;
}

// @public
export class Frontstage extends React_2.Component<FrontstageProps, FrontstageState> {
    // @internal
    constructor(props: FrontstageProps);
    // @internal
    componentDidMount(): Promise<void>;
    // (undocumented)
    componentDidUpdate(): void;
    // @internal
    componentWillUnmount(): void;
    static initializeFrontstageDef(frontstageDef: FrontstageDef, props: FrontstageProps): void;
    // @internal
    render(): React_2.ReactNode;
    }

// @public
export class FrontstageActivatedEvent extends UiEvent<FrontstageActivatedEventArgs> {
}

// @public
export interface FrontstageActivatedEventArgs {
    // (undocumented)
    activatedFrontstageDef: FrontstageDef;
    // (undocumented)
    deactivatedFrontstageDef?: FrontstageDef;
}

// @public
export class FrontstageComposer extends React_2.Component<CommonProps, FrontstageComposerState> implements WidgetChangeHandler, TargetChangeHandler, ZoneDefProvider, StagePanelChangeHandler, NineZoneChangeHandler {
    constructor(props: CommonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getGhostOutlineBounds(zoneId: WidgetZoneId): RectangleProps | undefined;
    // (undocumented)
    getZoneDef(zoneId: number): ZoneDef | undefined;
    // @alpha (undocumented)
    handlePanelInitialize(panelLocation: StagePanelLocation, size: number): void;
    // @alpha (undocumented)
    handlePanelPaneTargetChange(panelLocation: StagePanelLocation, paneIndex: number | undefined): void;
    // @alpha (undocumented)
    handlePanelResize(panelLocation: StagePanelLocation, resizeBy: number): void;
    // @alpha (undocumented)
    handlePanelTargetChange(panelLocation: StagePanelLocation | undefined): void;
    // (undocumented)
    handleResize: (zoneId: WidgetZoneId, resizeBy: number, handle: ResizeHandle, filledHeightDiff: number) => void;
    // (undocumented)
    handleTabClick: (widgetId: WidgetZoneId, tabIndex: number) => void;
    // (undocumented)
    handleTabDrag: (dragged: PointProps) => void;
    // (undocumented)
    handleTabDragEnd: () => void;
    // (undocumented)
    handleTabDragStart: (widgetId: WidgetZoneId, tabIndex: number, initialPosition: PointProps, widgetBounds: RectangleProps) => void;
    // (undocumented)
    handleTargetChanged(zoneId: WidgetZoneId, type: ZoneTargetType, isTargeted: boolean): void;
    // @alpha (undocumented)
    handleTogglePanelCollapse(panelLocation: StagePanelLocation): void;
    // (undocumented)
    handleWidgetStateChange(widgetId: WidgetZoneId, tabIndex: number, isOpening: boolean): void;
    // (undocumented)
    handleZonesBoundsChange(bounds: RectangleProps): void;
    // (undocumented)
    mergeZones(toMergeId: WidgetZoneId, targetId: WidgetZoneId): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    setZoneAllowsMerging(zoneId: WidgetZoneId, allowsMerging: boolean): void;
    // @internal (undocumented)
    readonly state: Readonly<FrontstageComposerState>;
}

// @public
export class FrontstageDeactivatedEvent extends UiEvent<FrontstageDeactivatedEventArgs> {
}

// @public
export interface FrontstageDeactivatedEventArgs {
    // (undocumented)
    activatedFrontstageDef?: FrontstageDef;
    // (undocumented)
    deactivatedFrontstageDef: FrontstageDef;
}

// @public
export class FrontstageDef {
    constructor();
    // (undocumented)
    applicationData?: any;
    // (undocumented)
    bottomCenter?: ZoneDef;
    // (undocumented)
    bottomLeft?: ZoneDef;
    // @alpha (undocumented)
    bottomMostPanel?: StagePanelDef;
    // @alpha (undocumented)
    bottomPanel?: StagePanelDef;
    // (undocumented)
    bottomRight?: ZoneDef;
    // (undocumented)
    centerLeft?: ZoneDef;
    // (undocumented)
    centerRight?: ZoneDef;
    readonly contentControls: ContentControl[];
    // (undocumented)
    contentGroup?: ContentGroup;
    // (undocumented)
    contentGroupId: string;
    // (undocumented)
    contentLayoutDef?: ContentLayoutDef;
    // (undocumented)
    contextToolbarEnabled: boolean;
    // (undocumented)
    defaultContentId: string;
    // (undocumented)
    defaultLayout?: ContentLayoutDef;
    // (undocumented)
    defaultLayoutId: string;
    // (undocumented)
    defaultTool?: ToolItemDef;
    findWidgetDef(id: string): WidgetDef | undefined;
    // (undocumented)
    frontstageProvider?: FrontstageProvider;
    // @alpha
    getStagePanelDef(location: StagePanelLocation): StagePanelDef | undefined;
    getZoneDef(zoneId: number): ZoneDef | undefined;
    // (undocumented)
    hubEnabled: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    inheritZoneStates: boolean;
    initializeFromProvider(frontstageProvider: FrontstageProvider): void;
    // (undocumented)
    isInFooterMode: boolean;
    // @alpha (undocumented)
    leftPanel?: StagePanelDef;
    // (undocumented)
    nineZone?: NineZoneManagerProps;
    onActivated(): void;
    onDeactivated(): void;
    onFrontstageReady(): void;
    // @alpha
    readonly panelDefs: StagePanelDef[];
    // @alpha (undocumented)
    rightPanel?: StagePanelDef;
    setActiveContent(): boolean;
    setActiveView(newContent: ContentControl, oldContent?: ContentControl): void;
    setActiveViewFromViewport(viewport: ScreenViewport): boolean;
    setContentLayoutAndGroup(contentLayoutDef: ContentLayoutDef, contentGroup: ContentGroup): void;
    startDefaultTool(): void;
    // (undocumented)
    topCenter?: ZoneDef;
    // (undocumented)
    topLeft?: ZoneDef;
    // @alpha (undocumented)
    topMostPanel?: StagePanelDef;
    // @alpha (undocumented)
    topPanel?: StagePanelDef;
    // (undocumented)
    topRight?: ZoneDef;
    waitUntilReady(): Promise<void>;
    readonly zoneDefs: ZoneDef[];
}

// @public
export class FrontstageLaunchBackstageItem extends React_2.PureComponent<FrontstageLaunchBackstageItemProps, BackstageItemState> {
    constructor(props: FrontstageLaunchBackstageItemProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(_prevProps: FrontstageLaunchBackstageItemProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    execute: () => void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BackstageItemState>;
    }

// @public
export interface FrontstageLaunchBackstageItemProps extends BackstageItemProps {
    frontstageId: string;
}

// @public
export class FrontstageManager {
    static readonly activeFrontstageDef: FrontstageDef | undefined;
    static readonly activeFrontstageId: string;
    static readonly activeModalFrontstage: ModalFrontstageInfo | undefined;
    static readonly activeNestedFrontstage: FrontstageDef | undefined;
    static readonly activeToolId: string;
    static readonly activeToolInformation: ToolInformation | undefined;
    static readonly activeToolSettingsNode: React.ReactNode | undefined;
    static addFrontstageProvider(frontstageProvider: FrontstageProvider): void;
    static clearFrontstageDefs(): void;
    static closeModalFrontstage(): void;
    static closeNestedFrontstage(): Promise<void>;
    // @internal
    static ensureToolInformationIsSet(toolId: string): void;
    static findFrontstageDef(id?: string): FrontstageDef | undefined;
    static findWidget(widgetId: string): WidgetDef | undefined;
    static initialize(): void;
    // @internal (undocumented)
    static isInitialized: boolean;
    static readonly isLoading: boolean;
    static readonly modalFrontstageCount: number;
    static readonly nestedFrontstageCount: number;
    static readonly NineZoneManager: NineZoneManager;
    static readonly onContentControlActivatedEvent: ContentControlActivatedEvent;
    static readonly onContentLayoutActivatedEvent: ContentLayoutActivatedEvent;
    static readonly onFrontstageActivatedEvent: FrontstageActivatedEvent;
    static readonly onFrontstageDeactivatedEvent: FrontstageDeactivatedEvent;
    static readonly onFrontstageReadyEvent: FrontstageReadyEvent;
    static readonly onModalFrontstageChangedEvent: ModalFrontstageChangedEvent;
    static readonly onNavigationAidActivatedEvent: NavigationAidActivatedEvent;
    static readonly onToolActivatedEvent: ToolActivatedEvent;
    static readonly onToolIconChangedEvent: ToolIconChangedEvent;
    static readonly onWidgetStateChangedEvent: WidgetStateChangedEvent;
    static openModalFrontstage(modalFrontstage: ModalFrontstageInfo): void;
    static openNestedFrontstage(nestedFrontstage: FrontstageDef): Promise<void>;
    static setActiveFrontstage(frontstageId: string): Promise<void>;
    static setActiveFrontstageDef(frontstageDef: FrontstageDef | undefined): Promise<void>;
    static setActiveLayout(contentLayoutDef: ContentLayoutDef, contentGroup: ContentGroup): Promise<void>;
    static setActiveNavigationAid(navigationAidId: string, iModelConnection: IModelConnection): void;
    static setActiveTool(tool: Tool): void;
    static setActiveToolId(toolId: string): void;
    static setWidgetState(widgetId: string, state: WidgetState): boolean;
    static updateModalFrontstage(): void;
}

// @public
export interface FrontstageProps extends CommonProps {
    applicationData?: any;
    bottomCenter?: React_2.ReactElement<ZoneProps>;
    bottomLeft?: React_2.ReactElement<ZoneProps>;
    // @alpha
    bottomMostPanel?: React_2.ReactElement<StagePanelProps>;
    // @alpha
    bottomPanel?: React_2.ReactElement<StagePanelProps>;
    bottomRight?: React_2.ReactElement<ZoneProps>;
    centerLeft?: React_2.ReactElement<ZoneProps>;
    centerRight?: React_2.ReactElement<ZoneProps>;
    contentGroup: string | ContentGroup;
    defaultContentId?: string;
    defaultLayout: string | ContentLayoutDef;
    defaultTool: ToolItemDef;
    id: string;
    isInFooterMode?: boolean;
    // @alpha
    leftPanel?: React_2.ReactElement<StagePanelProps>;
    // @alpha
    rightPanel?: React_2.ReactElement<StagePanelProps>;
    // @internal (undocumented)
    runtimeProps?: FrontstageRuntimeProps;
    topCenter?: React_2.ReactElement<ZoneProps>;
    topLeft?: React_2.ReactElement<ZoneProps>;
    // @alpha
    topMostPanel?: React_2.ReactElement<StagePanelProps>;
    // @alpha
    topPanel?: React_2.ReactElement<StagePanelProps>;
    topRight?: React_2.ReactElement<ZoneProps>;
}

// @public
export abstract class FrontstageProvider {
    abstract readonly frontstage: React_2.ReactElement<FrontstageProps>;
    readonly frontstageDef: FrontstageDef | undefined;
    initializeDef(): FrontstageDef;
}

// @public
export class FrontstageReadyEvent extends UiEvent<FrontstageReadyEventArgs> {
}

// @public
export interface FrontstageReadyEventArgs {
    // (undocumented)
    frontstageDef: FrontstageDef;
}

// @internal
export interface FrontstageRuntimeProps {
    // (undocumented)
    frontstageDef: FrontstageDef;
    // (undocumented)
    nineZone: NineZoneManagerProps;
    // (undocumented)
    nineZoneChangeHandler: NineZoneChangeHandler;
    // (undocumented)
    stagePanelChangeHandler: StagePanelChangeHandler;
    // (undocumented)
    targetChangeHandler: TargetChangeHandler;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgetTabs: WidgetTabs;
    // (undocumented)
    zoneDefProvider: ZoneDefProvider;
}

// @public
export enum FunctionKey {
    // (undocumented)
    F1 = "F1",
    // (undocumented)
    F10 = "F10",
    // (undocumented)
    F11 = "F11",
    // (undocumented)
    F12 = "F12",
    // (undocumented)
    F2 = "F2",
    // (undocumented)
    F3 = "F3",
    // (undocumented)
    F4 = "F4",
    // (undocumented)
    F5 = "F5",
    // (undocumented)
    F6 = "F6",
    // (undocumented)
    F7 = "F7",
    // (undocumented)
    F8 = "F8",
    // (undocumented)
    F9 = "F9"
}

// @public
export type FunctionType = (...args: any[]) => any;

// @public
export const getBackstageItemStateFromProps: (props: BackstageItemProps) => BackstageItemState;

// @internal (undocumented)
export const getNestedStagePanelKey: (location: StagePanelLocation) => NestedStagePanelKey<NestedStagePanelsManagerProps>;

// @internal (undocumented)
export const getStagePanelType: (location: StagePanelLocation) => StagePanelType;

// @public
export const GroupButton: React_2.FunctionComponent<GroupButtonProps>;

// @public
export interface GroupButtonProps extends GroupItemProps, CommonProps {
}

// @public
export class GroupItemDef extends ActionButtonItemDef {
    constructor(groupItemProps: GroupItemProps);
    // (undocumented)
    direction: Direction;
    // (undocumented)
    directionExplicit: boolean;
    // (undocumented)
    execute(): void;
    // (undocumented)
    getItemById(id: string): ItemDefBase | undefined;
    // (undocumented)
    getItemByIndex(index: number): ItemDefBase | undefined;
    // (undocumented)
    groupId: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly itemCount: number;
    // (undocumented)
    items: AnyItemDef[];
    // (undocumented)
    itemsInColumn: number;
    // @internal (undocumented)
    overflow: boolean;
    // (undocumented)
    resolveItems(force?: boolean): void;
    // (undocumented)
    toolbarReactNode(index?: number): React_2.ReactNode;
}

// @public
export interface GroupItemProps extends ItemProps {
    // (undocumented)
    direction?: Direction;
    // (undocumented)
    groupId?: string;
    // (undocumented)
    items: AnyItemDef[];
    // (undocumented)
    itemsInColumn?: number;
}

// @internal (undocumented)
export enum HitBoxX {
    // (undocumented)
    Left = -1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Right = 1
}

// @internal (undocumented)
export enum HitBoxY {
    // (undocumented)
    Back = 1,
    // (undocumented)
    Front = -1,
    // (undocumented)
    None = 0
}

// @internal (undocumented)
export enum HitBoxZ {
    // (undocumented)
    Bottom = -1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Top = 1
}

// @public
export const Icon: React_2.FunctionComponent<IconProps>;

// @public
export interface IconProps {
    iconSpec?: IconSpec;
}

// @public
export type IconSpec = string | React_2.ReactNode;

// @internal
export interface IModelInfo {
    // (undocumented)
    createdDate: Date;
    // (undocumented)
    description: string;
    // (undocumented)
    name: string;
    // (undocumented)
    projectInfo: ProjectInfo;
    // (undocumented)
    status: string;
    // (undocumented)
    thumbnail?: string;
    // (undocumented)
    wsgId: string;
}

// @internal
export enum IModelScope {
    // (undocumented)
    All = 2,
    // (undocumented)
    Favorites = 0,
    // (undocumented)
    MostRecentlyUsed = 1
}

// @internal
export interface IModelServices {
    getChangeSets(accessToken: AccessToken, iModelId: string): Promise<ChangeSetInfo[]>;
    getIModels(accessToken: AccessToken, projectInfo: ProjectInfo, top: number, skip: number): Promise<IModelInfo[]>;
    getThumbnail(accessToken: AccessToken, projectId: string, iModelId: string): Promise<string | undefined>;
    getUser(accessToken: AccessToken, iModelId: string, userId: string): Promise<IModelUserInfo[]>;
    getUsers(accessToken: AccessToken, iModelId: string): Promise<IModelUserInfo[]>;
    getVersions(accessToken: AccessToken, iModelId: string): Promise<VersionInfo[]>;
    openIModel(contextId: string, iModelId: string, openMode?: OpenMode, changeSetId?: string): Promise<IModelConnection>;
}

// @internal
export interface IModelUserInfo {
    // (undocumented)
    email: string;
    // (undocumented)
    firstName: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    lastName: string;
}

// @internal
export const INACTIVITY_TIME_DEFAULT = 3500;

// @public
export class InputFieldMessage extends React_2.PureComponent<InputFieldMessageProps, InputFieldMessageState> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    readonly state: Readonly<InputFieldMessageState>;
}

// @public
export class InputFieldMessageAddedEvent extends UiEvent<InputFieldMessageEventArgs> {
}

// @public
export interface InputFieldMessageEventArgs {
    // (undocumented)
    detailedMessage: HTMLElement | string;
    // (undocumented)
    messageText: HTMLElement | string;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    target: Element;
}

// @public
export class InputFieldMessageRemovedEvent extends UiEvent<{}> {
}

// @alpha
export enum InputStatus {
    // (undocumented)
    Invalid = 1,
    // (undocumented)
    Valid = 0
}

// @public
export abstract class ItemDefBase {
    constructor(itemProps: ItemProps);
    // (undocumented)
    applicationData?: any;
    // (undocumented)
    betaBadge: boolean;
    // (undocumented)
    iconElement?: React.ReactNode;
    // (undocumented)
    iconSpec?: string | React.ReactNode;
    // (undocumented)
    abstract readonly id: string;
    // (undocumented)
    static initializeDef(me: ItemDefBase, itemProps: ItemProps): void;
    // (undocumented)
    isActive: boolean;
    // (undocumented)
    isEnabled: boolean;
    // (undocumented)
    isPressed: boolean;
    // (undocumented)
    isVisible: boolean;
    readonly label: string;
    setLabel(v: string | StringGetter): void;
    setTooltip(v: string | StringGetter): void;
    // (undocumented)
    stateFunc?: (state: Readonly<BaseItemState>) => BaseItemState;
    // (undocumented)
    stateSyncIds: string[];
    readonly tooltip: string;
    // (undocumented)
    readonly trayId: undefined;
}

// @public
export class ItemList extends Array<ItemDefBase> {
    constructor(items?: ItemDefBase[]);
    // (undocumented)
    addItem(item: ItemDefBase): void;
    // (undocumented)
    addItems(items: ItemDefBase[]): void;
    // (undocumented)
    readonly items: ItemDefBase[];
}

// @public
export class ItemMap extends Map<string, ItemDefBase> {
    constructor(items?: ItemDefBase[]);
    // (undocumented)
    addItem(item: ItemDefBase): void;
    // (undocumented)
    addItems(items: ItemDefBase[]): void;
}

// @public
export interface ItemProps extends IconProps, LabelProps, SyncUiProps, TooltipProps {
    applicationData?: any;
    betaBadge?: boolean;
    isActive?: boolean;
    isEnabled?: boolean;
    isPressed?: boolean;
    isVisible?: boolean;
}

// @public
export interface ItemPropsList {
    // @beta (undocumented)
    items?: AnyItemProps[];
}

// @public
export class KeyboardShortcut extends ItemDefBase {
    constructor(props: KeyboardShortcutProps);
    // (undocumented)
    getShortcut(mapKey: string): KeyboardShortcut | undefined;
    // (undocumented)
    readonly id: string;
    readonly isAltKeyRequired: boolean;
    readonly isCtrlKeyRequired: boolean;
    readonly isFunctionKey: boolean;
    readonly isShiftKeyRequired: boolean;
    readonly isSpecialKey: boolean;
    // (undocumented)
    readonly item: ActionButtonItemDef | undefined;
    // (undocumented)
    itemPicked(): void;
    readonly key: string;
    // (undocumented)
    readonly keyMapKey: string;
    // (undocumented)
    readonly shortcutContainer: KeyboardShortcutContainer;
    }

// @public
export class KeyboardShortcutContainer {
    // (undocumented)
    areKeyboardShortcutsAvailable(): boolean;
    // (undocumented)
    emptyData(): void;
    // (undocumented)
    findKey(keyMapKey: string): KeyboardShortcut | undefined;
    // (undocumented)
    static generateKeyMapKey(keyboardKey: string, isAltKeyRequired: boolean, isCtrlKeyRequired: boolean, isShiftKeyRequired: boolean): string;
    // (undocumented)
    getAvailableKeyboardShortcuts(): KeyboardShortcut[];
    // (undocumented)
    registerKey(keyMapKey: string, inShortcut: KeyboardShortcut): KeyboardShortcut | undefined;
    // (undocumented)
    showShortcutsMenu(): void;
}

// @public
export class KeyboardShortcutManager {
    // (undocumented)
    static closeShortcutsMenu(): void;
    // (undocumented)
    static readonly cursorX: number;
    // (undocumented)
    static readonly cursorY: number;
    // (undocumented)
    static displayShortcutsMenu(): void;
    // (undocumented)
    static getShortcut(keyMapKey: string): KeyboardShortcut | undefined;
    // (undocumented)
    static readonly isFocusOnHome: boolean;
    // (undocumented)
    static loadKeyboardShortcut(shortcutProps: KeyboardShortcutProps): void;
    // (undocumented)
    static loadKeyboardShortcuts(shortcutList: KeyboardShortcutProps[]): void;
    // (undocumented)
    static processKey(keyboardKey: string, isAltKeyPressed?: boolean, isCtrlKeyPressed?: boolean, isShiftKeyPressed?: boolean): boolean;
    // (undocumented)
    static setFocusToHome(): void;
    // (undocumented)
    static readonly shortcutContainer: KeyboardShortcutContainer;
    }

// @public
export class KeyboardShortcutMenu extends React_2.PureComponent<CommonProps, KeyboardShortcutMenuState> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    static readonly onKeyboardShortcutMenuEvent: KeyboardShortcutMenuEvent;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: KeyboardShortcutMenuState;
}

// @public
export class KeyboardShortcutMenuEvent extends UiEvent<KeyboardShortcutMenuState> {
}

// @public
export interface KeyboardShortcutMenuState {
    // (undocumented)
    menuVisible: boolean;
    // (undocumented)
    menuX: number;
    // (undocumented)
    menuY: number;
    // (undocumented)
    shortcuts?: KeyboardShortcut[];
}

// @public
export interface KeyboardShortcutProps extends ItemProps {
    isAltKeyRequired?: boolean;
    isCtrlKeyRequired?: boolean;
    isShiftKeyRequired?: boolean;
    item?: ActionButtonItemDef;
    key: string | FunctionKey | SpecialKey;
    shortcuts?: KeyboardShortcutProps[];
}

// @alpha
export class KeyinBrowser extends React_2.PureComponent<KeyinBrowserProps, KeyinBrowserState> {
    // @internal
    constructor(props: any);
    // @internal (undocumented)
    render(): React_2.ReactNode;
    }

// @alpha
export interface KeyinBrowserProps extends CommonProps {
    // (undocumented)
    onExecute?: () => void;
}

// @public
export interface LabelProps {
    label?: string | StringGetter;
    labelKey?: string;
}

// @public
export interface LayoutFragmentProps {
    horizontalSplit?: LayoutHorizontalSplitProps;
    verticalSplit?: LayoutVerticalSplitProps;
}

// @public
export interface LayoutHorizontalSplitProps extends LayoutSplitPropsBase {
    bottom: LayoutFragmentProps | number;
    minSizeBottom?: number;
    minSizeTop?: number;
    top: LayoutFragmentProps | number;
}

// @public
export interface LayoutSplit {
    // (undocumented)
    createContentContainer(contentNodes: React_2.ReactNode[], resizable: boolean): React_2.ReactNode;
    // (undocumented)
    isLocked: boolean;
}

// @public
export interface LayoutSplitPropsBase {
    id?: string;
    lock?: boolean;
    percentage: number;
}

// @public
export interface LayoutVerticalSplitProps extends LayoutSplitPropsBase {
    left: LayoutFragmentProps | number;
    minSizeLeft?: number;
    minSizeRight?: number;
    right: LayoutFragmentProps | number;
}

// @beta
export interface ListItem {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    children?: ListItem[];
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    type?: ListItemType;
}

// @beta
export enum ListItemType {
    // (undocumented)
    Container = 2,
    // (undocumented)
    Item = 0,
    // (undocumented)
    Separator = 1
}

// @beta
export class ListPicker extends React_2.Component<ListPickerPropsExtended> {
    constructor(props: ListPickerPropsExtended);
    isSpecialItem(item: ListItem): boolean;
    // (undocumented)
    static readonly Key_All: number;
    // (undocumented)
    static readonly Key_Invert: number;
    // (undocumented)
    static readonly Key_None: number;
    // (undocumented)
    static readonly Key_Separator: number;
    render(): JSX.Element;
}

// @beta
export class ListPickerBase extends React_2.PureComponent<ListPickerProps, ListPickerState> {
    constructor(props: any);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    getExpandedContent(): React_2.ReactNode;
    isExpanded: () => boolean;
    minimize: () => void;
    render(): JSX.Element;
    }

// @beta
export class ListPickerItem extends React_2.PureComponent<ListPickerItemProps> {
    render(): JSX.Element;
}

// @beta
export interface ListPickerItemProps extends CommonProps {
    // (undocumented)
    isActive?: boolean;
    // (undocumented)
    isFocused?: boolean;
    // (undocumented)
    key: any;
    // (undocumented)
    label?: string;
    // (undocumented)
    onClick?: () => void;
}

// @beta
export interface ListPickerProps {
    // (undocumented)
    iconSpec?: string | React_2.ReactNode;
    // (undocumented)
    items: ListItem[];
    // (undocumented)
    onExpanded?: (expand: boolean) => void;
    // (undocumented)
    onSizeKnown?: (size: SizeProps) => void;
    // (undocumented)
    setEnabled: (item: ListItem, enabled: boolean) => any;
    // (undocumented)
    title: string;
}

// @beta
export interface ListPickerPropsExtended extends ListPickerProps {
    // (undocumented)
    disableAllFunc?: () => void;
    // (undocumented)
    enableAllFunc?: () => void;
    // (undocumented)
    invertFunc?: () => void;
}

// @alpha
export enum MapMode {
    // (undocumented)
    Closed = "map-closed",
    // (undocumented)
    Opened = "map-opened"
}

// @public
export class MarkupTools {
    // (undocumented)
    static readonly arrowToolDef: ToolItemDef;
    // (undocumented)
    static readonly cloudToolDef: ToolItemDef;
    // (undocumented)
    static readonly distanceToolDef: ToolItemDef;
    // (undocumented)
    static readonly ellipseToolDef: ToolItemDef;
    // (undocumented)
    static readonly lineToolDef: ToolItemDef;
    // (undocumented)
    static readonly placeTextToolDef: ToolItemDef;
    // (undocumented)
    static readonly polygonToolDef: ToolItemDef;
    // (undocumented)
    static readonly rectangleToolDef: ToolItemDef;
    // (undocumented)
    static readonly selectToolDef: ToolItemDef;
    // (undocumented)
    static readonly sketchToolDef: ToolItemDef;
    // (undocumented)
    static readonly symbolToolDef: ToolItemDef;
}

// @public
export class MessageAddedEvent extends UiEvent<MessageAddedEventArgs> {
}

// @public
export interface MessageAddedEventArgs {
    // (undocumented)
    message: NotifyMessageDetails;
}

// @public
export class MessageCenterField extends React_2.Component<MessageCenterFieldProps, MessageCenterState> {
    constructor(p: MessageCenterFieldProps);
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    readonly state: Readonly<MessageCenterState>;
    }

// @public
export interface MessageCenterFieldProps extends StatusFieldProps {
    targetRef?: React_2.Ref<HTMLElement>;
}

// @public
export class MessageManager {
    static addMessage(message: NotifyMessageDetails): void;
    static addToMessageCenter(message: NotifyMessageDetails): void;
    static clearMessages(): void;
    static displayInputFieldMessage(target: HTMLElement, messageText: HTMLElement | string, detailedMessage?: HTMLElement | string, priority?: OutputMessagePriority): void;
    static endActivityMessage(isCompleted: boolean): boolean;
    static getIconClassName(details: NotifyMessageDetails): string;
    static getIconType(details: NotifyMessageDetails): MessageBoxIconType;
    static getSeverity(details: NotifyMessageDetails): MessageSeverity;
    static hideInputFieldMessage(): void;
    static readonly messages: Readonly<NotifyMessageDetails[]>;
    static readonly onActivityMessageCancelledEvent: ActivityMessageCancelledEvent;
    static readonly onActivityMessageUpdatedEvent: ActivityMessageUpdatedEvent;
    // (undocumented)
    static readonly onInputFieldMessageAddedEvent: InputFieldMessageAddedEvent;
    // (undocumented)
    static readonly onInputFieldMessageRemovedEvent: InputFieldMessageRemovedEvent;
    static readonly onMessageAddedEvent: MessageAddedEvent;
    // @alpha
    static readonly onToolAssistanceChangedEvent: ToolAssistanceChangedEvent;
    static openMessageBox(mbType: MessageBoxType, message: HTMLElement | string, icon: MessageBoxIconType): Promise<MessageBoxValue>;
    static outputPrompt(prompt: string): void;
    static setMaxCachedMessages(max: number): void;
    // @alpha
    static setToolAssistance(instructions: ToolAssistanceInstructions | undefined): void;
    static setupActivityMessageDetails(details: ActivityMessageDetails): boolean;
    static setupActivityMessageValues(message: HTMLElement | string, percentage: number, restored?: boolean): boolean;
    // @internal (undocumented)
    static showAlertMessageBox(messageDetails: NotifyMessageDetails): void;
    }

// @public
export class ModalDialogChangedEvent extends DialogChangedEvent {
}

// @public
export class ModalDialogManager {
    static readonly activeDialog: React_2.ReactNode | undefined;
    static closeDialog(dialog?: React_2.ReactNode): void;
    static readonly dialogCount: number;
    // @internal (undocumented)
    static readonly dialogManager: DialogManagerBase;
    static readonly dialogs: import("./DialogManagerBase").DialogInfo[];
    static readonly onModalDialogChangedEvent: ModalDialogChangedEvent;
    static openDialog(dialog: React_2.ReactNode, id?: string): void;
    static update(): void;
}

// @public
export class ModalDialogRenderer extends React_2.PureComponent<CommonProps> {
    constructor(props: CommonProps);
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export class ModalFrontstage extends React_2.Component<ModalFrontstageProps> {
    constructor(props: ModalFrontstageProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public
export class ModalFrontstageChangedEvent extends UiEvent<ModalFrontstageChangedEventArgs> {
}

// @public
export interface ModalFrontstageChangedEventArgs {
    // (undocumented)
    modalFrontstageCount: number;
}

// @public
export interface ModalFrontstageInfo {
    // (undocumented)
    appBarRight?: React.ReactNode;
    // (undocumented)
    content: React.ReactNode;
    // (undocumented)
    title: string;
}

// @public
export interface ModalFrontstageProps extends CommonProps {
    appBarRight?: React_2.ReactNode;
    closeModal: () => any;
    isOpen?: boolean;
    navigateBack: () => any;
    title: string;
}

// @public
export class ModelessDialog extends React_2.Component<ModelessDialogProps> {
    constructor(props: ModelessDialogProps);
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export class ModelessDialogChangedEvent extends DialogChangedEvent {
}

// @public
export class ModelessDialogManager {
    static readonly activeDialog: React_2.ReactNode | undefined;
    static closeDialog(id: string): void;
    static readonly dialogCount: number;
    // @internal (undocumented)
    static readonly dialogManager: DialogManagerBase;
    static readonly dialogs: import("./DialogManagerBase").DialogInfo[];
    static getDialogZIndex(id: string): number;
    static handlePointerDownEvent(_event: React_2.PointerEvent, id: string, updateFunc: () => void): void;
    static readonly onModelessDialogChangedEvent: ModelessDialogChangedEvent;
    static openDialog(dialog: React_2.ReactNode, id: string): void;
    static update(): void;
}

// @public
export interface ModelessDialogProps extends DialogProps {
    // (undocumented)
    dialogId: string;
}

// @public
export class ModelessDialogRenderer extends React_2.PureComponent<CommonProps> {
    constructor(props: CommonProps);
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal @deprecated
export class ModelSelectorWidget extends React_2.Component<ModelSelectorWidgetProps, ModelSelectorWidgetState> {
    constructor(props: ModelSelectorWidgetProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @internal
export class ModelSelectorWidgetControl extends WidgetControl {
    constructor(info: ConfigurableCreateInfo, options: any);
}

// @public
export class MouseDownChangedEvent extends UiEvent<MouseDownChangedEventArgs> {
}

// @public
export interface MouseDownChangedEventArgs {
    // (undocumented)
    mouseDown: boolean;
}

// @internal (undocumented)
export class NavCubeFace extends React_2.Component<NavCubeFaceProps> {
    // (undocumented)
    static faceCellToPos: (face: Face, x: number, y: number) => Vector3d;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal (undocumented)
export interface NavCubeFaceProps extends React_2.AllHTMLAttributes<HTMLDivElement> {
    // (undocumented)
    face: Face;
    // (undocumented)
    hoverMap: {
        [key: string]: CubeHover;
    };
    // (undocumented)
    label: string;
    // (undocumented)
    onFaceCellClick: (vector: Vector3d, face: Face) => void;
    // (undocumented)
    onFaceCellHoverChange: (vector: Vector3d, state: CubeHover) => void;
}

// @public
export class NavigationAidActivatedEvent extends UiEvent<NavigationAidActivatedEventArgs> {
}

// @public
export interface NavigationAidActivatedEventArgs {
    // (undocumented)
    iModelConnection: IModelConnection;
    // (undocumented)
    navigationAidId: string;
}

// @public
export class NavigationAidControl extends ConfigurableUiControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    getSize(): string | undefined;
    getType(): ConfigurableUiControlType;
    reactElement: React_2.ReactNode;
    }

// @public
export class NavigationWidget extends React_2.Component<NavigationWidgetPropsEx, NavigationWidgetState> {
    constructor(props: NavigationWidgetPropsEx);
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: NavigationWidgetPropsEx, _prevState: NavigationWidgetState): void;
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<NavigationWidgetState>;
}

// @public
export class NavigationWidgetDef extends ToolbarWidgetDefBase {
    constructor(props: NavigationWidgetProps);
    // (undocumented)
    readonly reactElement: React_2.ReactNode;
    // (undocumented)
    renderCornerItem(): React_2.ReactNode;
    // (undocumented)
    updateNavigationAid(navigationAidId: string, imodel?: IModelConnection): void;
}

// @public
export interface NavigationWidgetProps extends ToolbarWidgetProps {
    // (undocumented)
    navigationAidId?: string;
}

// @public
export interface NavigationWidgetPropsEx extends NavigationWidgetProps, CommonProps {
    // (undocumented)
    horizontalToolbar?: React_2.ReactNode;
    // (undocumented)
    iModelConnection?: IModelConnection;
    // (undocumented)
    verticalToolbar?: React_2.ReactNode;
}

// @public
export class NestedFrontstage {
    static readonly backToPreviousFrontstageCommand: CommandItemDef;
}

// @public
export interface NineZoneChangeHandler {
    // (undocumented)
    handleZonesBoundsChange(bounds: RectangleProps): void;
}

// @public
export class PointerMessage extends React_2.Component<PointerMessageProps, PointerMessageState> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static hideMessage(): void;
    // (undocumented)
    static readonly onPointerMessageChangedEvent: PointerMessageChangedEvent;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    static showMessage(message: NotifyMessageDetails): void;
    // (undocumented)
    readonly state: Readonly<PointerMessageState>;
    // (undocumented)
    static updateMessage(displayPoint: XAndY, relativePosition: RelativePosition): void;
    }

// @public
export class PointerMessageChangedEvent extends UiEvent<PointerMessageChangedEventArgs> {
}

// @public
export interface PointerMessageChangedEventArgs {
    // (undocumented)
    detailedMessage?: HTMLElement | string;
    // (undocumented)
    isVisible: boolean;
    // (undocumented)
    message: HTMLElement | string;
    // (undocumented)
    messageDetails?: NotifyMessageDetails;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    pt?: XAndY;
    // (undocumented)
    relativePosition?: RelativePosition;
    // (undocumented)
    viewport?: HTMLElement;
}

// @public
export interface PointerMessageProps extends CommonProps {
    message?: string;
}

// @public
export class PopupButton extends React_2.Component<PopupButtonProps, BaseItemState> {
    constructor(props: PopupButtonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    readonly label: string;
    minimize: () => void;
    render(): JSX.Element | null;
    }

// @public
export type PopupButtonChildrenRenderProp = (args: PopupButtonChildrenRenderPropArgs) => React_2.ReactNode;

// @public
export interface PopupButtonChildrenRenderPropArgs {
    // (undocumented)
    closePanel: () => void;
}

// @public
export interface PopupButtonProps extends ItemProps, CommonProps {
    // (undocumented)
    children?: React_2.ReactNode | PopupButtonChildrenRenderProp;
    // (undocumented)
    noPadding?: boolean;
    // (undocumented)
    onExpanded?: (expand: boolean) => void;
    // (undocumented)
    onSizeKnown?: (size: SizeProps) => void;
}

// @beta
export interface PresentationSelectionScope {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
}

// @internal
export interface ProjectInfo {
    // (undocumented)
    name: string;
    // (undocumented)
    projectNumber: string;
    // (undocumented)
    readStatus: ProjectReadStatus;
    // (undocumented)
    wsgId: string;
}

// @internal
export enum ProjectReadStatus {
    // (undocumented)
    DoneReading = 2,
    // (undocumented)
    NotRead = 0,
    // (undocumented)
    Reading = 1
}

// @internal
export enum ProjectScope {
    // (undocumented)
    All = 3,
    // (undocumented)
    Favorites = 0,
    // (undocumented)
    Invited = 2,
    // (undocumented)
    MostRecentlyUsed = 1
}

// @internal
export interface ProjectServices {
    getProjects(accessToken: AccessToken, projectScope: ProjectScope, top: number, skip: number, filter?: string): Promise<ProjectInfo[]>;
}

// @public
export const PromptField: any;

// @public
export class PropsHelper {
    static getIcon(iconSpec: string | React_2.ReactNode): JSX.Element | undefined;
    static getStringFromSpec(spec: string | StringGetter): string;
    static getStringSpec(explicitValue: string | StringGetter | undefined, stringKey?: string): string | StringGetter;
    static isShallowEqual(newObj: any, prevObj: any): boolean;
}

// @alpha
export class RealityDataPicker extends React_2.Component<RealityDataPickerProps, RealityDataPickerState> {
    constructor(props: RealityDataPickerProps);
    // (undocumented)
    readonly attachedModels: AttachedRealityModel[];
    componentDidMount(): Promise<void>;
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @alpha
export class RealityDataPickerControl extends WidgetControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    static readonly iconSpec: string;
    // (undocumented)
    static readonly label: string;
}

// @public
export type Reducer<S, A> = (state: S, action: A) => S;

// @public
export type ReducerActions<R> = R extends Reducer<any, infer X> ? (X extends ActionWithPayload<infer T, infer P> ? DeepReadonly<ActionWithPayload<T, P>> : X extends Action<infer T2> ? DeepReadonly<Action<T2>> : X) : R;

// @public
export type ReducerMapActions<R> = ReducerActions<R[keyof R]>;

// @internal (undocumented)
export interface RotationData {
    // (undocumented)
    iconClassName: string;
    // (undocumented)
    label: string;
}

// @internal (undocumented)
export const RULESET: Ruleset;

// @beta
export class SavedView {
    static emphasizeElementsFromProps(vp: ScreenViewport, savedViewProps: SavedViewProps): boolean;
    static emphasizeElementsToProps(vp: ScreenViewport, savedViewProps: SavedViewProps): void;
    static viewStateFromProps(iModelConnection: IModelConnection, savedViewProps: SavedViewProps): Promise<ViewState | undefined>;
    static viewStateToProps(viewState: ViewState): SavedViewProps;
}

// @beta
export class SavedViewLayout {
    static emphasizeElementsFromProps(contentGroup: ContentGroup, savedProps: SavedViewLayoutProps): boolean;
    static viewLayoutToProps(contentLayoutDef: ContentLayoutDef, contentGroup: ContentGroup, emphasizeElements?: boolean, contentCallback?: ContentCallback): SavedViewLayoutProps;
    static viewStatesFromProps(iModelConnection: IModelConnection, savedProps: SavedViewLayoutProps): Promise<Array<ViewState | undefined>>;
}

// @beta
export interface SavedViewLayoutProps {
    // (undocumented)
    contentGroupProps: ContentGroupProps;
    // (undocumented)
    contentLayoutProps: ContentLayoutProps;
    // (undocumented)
    savedViews: SavedViewProps[];
}

// @beta
export interface SavedViewProps {
    // (undocumented)
    bisBaseClass: string;
    // (undocumented)
    categorySelectorProps: CategorySelectorProps;
    // (undocumented)
    displayStyleProps: DisplayStyleProps;
    // (undocumented)
    emphasizeElementsProps?: EmphasizeElementsProps;
    // (undocumented)
    modelSelectorProps?: ModelSelectorProps;
    // (undocumented)
    sheetAttachments?: Id64Array;
    // (undocumented)
    sheetProps?: SheetProps;
    // (undocumented)
    viewDefinitionProps: ViewDefinitionProps;
}

// @alpha
export class ScheduleAnimationTimelineDataProvider extends BaseTimelineDataProvider {
    constructor(viewState: ViewState, viewport?: ScreenViewport);
    // (undocumented)
    loadTimelineData(): Promise<boolean>;
    // (undocumented)
    onAnimationFractionChanged: (animationFraction: number) => void;
    // (undocumented)
    onPlaybackSettingChanged: (settings: PlaybackSettings) => void;
    }

// @public
export const SelectionInfoField: any;

// @public
export const SelectionScopeField: any;

// @public
export class SeparatorBackstageItem extends React_2.PureComponent<BackstageItemProps> {
    constructor(separatorBackstageItemDef: BackstageItemProps);
    // (undocumented)
    render(): React_2.ReactNode;
    }

// @beta
export interface SessionState {
    // (undocumented)
    accessToken: any | undefined;
    // (undocumented)
    activeSelectionScope: string;
    // (undocumented)
    availableSelectionScopes: PresentationSelectionScope[];
    // (undocumented)
    defaultIModelViewportControlId: string | undefined;
    // (undocumented)
    defaultRulesetId: string | undefined;
    // (undocumented)
    defaultViewId: string | undefined;
    // (undocumented)
    iModelConnection: any | undefined;
    // (undocumented)
    iModelId: string;
    // (undocumented)
    numItemsSelected: number;
}

// @beta
export enum SessionStateActionId {
    // (undocumented)
    SetAccessToken = "sessionstate:set-access-token",
    // (undocumented)
    SetActiveIModelId = "sessionstate:set-active-imodelid",
    // (undocumented)
    SetAvailableSelectionScopes = "sessionstate:set-available-selection-scopes",
    // (undocumented)
    SetDefaultIModelViewportControlId = "sessionstate:set-default-viewportid",
    // (undocumented)
    SetDefaultRulesetId = "sessionstate:set-default-rulesetid",
    // (undocumented)
    SetDefaultViewId = "sessionstate:set-default-viewid",
    // (undocumented)
    SetIModelConnection = "sessionstate:set-imodel-connection",
    // (undocumented)
    SetNumItemsSelected = "sessionstate:set-num-items-selected",
    // (undocumented)
    SetSelectionScope = "sessionstate:set-selection-scope"
}

// @beta
export const SessionStateActions: {
    setNumItemsSelected: (numSelected: number) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetNumItemsSelected, number>;
    setAvailableSelectionScopes: (availableSelectionScopes: PresentationSelectionScope[]) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetAvailableSelectionScopes, import("./utils/redux-ts").DeepReadonlyArray<PresentationSelectionScope>>;
    setSelectionScope: (activeSelectionScope: string) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetSelectionScope, string>;
    setActiveIModelId: (iModelId: string) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetActiveIModelId, string>;
    setDefaultIModelViewportControlId: (iModelViewportControlId: string) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetDefaultIModelViewportControlId, string>;
    setDefaultViewId: (viewId: string) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetDefaultViewId, string>;
    setDefaultRulesetId: (rulesetid: string) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetDefaultRulesetId, string>;
    setIModelConnection: (iModelConnection: any) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetIModelConnection, any>;
    setAccessToken: (accessToken: any) => import("./utils/redux-ts").ActionWithPayload<SessionStateActionId.SetAccessToken, any>;
};

// @beta
export type SessionStateActionsUnion = ActionsUnion<typeof SessionStateActions>;

// @beta
export function SessionStateReducer(state: SessionState | undefined, _action: SessionStateActionsUnion): DeepReadonly<SessionState>;

// @alpha
export class SheetCard extends React_2.Component<SheetCardProps, SheetCardState> {
    constructor(props: SheetCardProps);
    // (undocumented)
    render(): JSX.Element;
}

// @alpha
export interface SheetCardProps {
    // (undocumented)
    iconSpec: string;
    // (undocumented)
    index: number;
    // (undocumented)
    isActive: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    onClick: () => void;
}

// @alpha
export interface SheetData {
    // (undocumented)
    name: string;
    // (undocumented)
    viewId: string;
}

// @alpha
export class SheetNavigationAid extends React_2.Component<SheetNavigationProps, SheetNavigationState> {
    constructor(props: SheetNavigationProps);
    componentDidMount(): Promise<void>;
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<SheetNavigationState>;
    }

// @alpha
export class SheetNavigationAidControl extends NavigationAidControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    getSize(): string | undefined;
    // (undocumented)
    static navigationAidId: string;
}

// @alpha
export interface SheetNavigationProps extends CommonProps {
    // (undocumented)
    iModelConnection: IModelConnection;
}

// @alpha
export class SheetsModalFrontstage implements ModalFrontstageInfo {
    constructor(sheets: SheetData[], connection: IModelConnection, currentIndex: number);
    readonly appBarRight: React_2.ReactNode;
    readonly content: React_2.ReactNode;
    // (undocumented)
    title: string;
}

// @public
export class SignIn extends React_2.PureComponent<SignInProps> {
    constructor(props: SignInProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface SignInProps extends CommonProps {
    onOffline?: () => void;
    onRegister?: () => void;
    onSignedIn: () => void;
    // @internal (undocumented)
    onStartSignIn?: () => void;
}

// @public
export class SignOutModalFrontstage implements ModalFrontstageInfo {
    constructor(accessToken: AccessToken, onSignOut?: () => void);
    // (undocumented)
    readonly content: React_2.ReactNode;
    // (undocumented)
    title: string;
    }

// @public
export const SnapModeField: any;

// @alpha
export class SolarTimelineDataProvider extends BaseSolarDataProvider {
    constructor(viewState: ViewState, viewport?: ScreenViewport, longitude?: number, latitude?: number);
    // (undocumented)
    onTimeChanged: (time: Date) => void;
    // (undocumented)
    shadowColor: ColorDef;
    // (undocumented)
    readonly shouldShowTimeline: boolean;
    // (undocumented)
    protected _viewState: ViewState;
}

// @alpha
export class SpatialContainmentTree extends React_2.Component<SpatialContainmentTreeProps, SpatialContainmentTreeState> {
    constructor(props: SpatialContainmentTreeProps);
    // @internal (undocumented)
    componentDidMount(): Promise<void>;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface SpatialContainmentTreeProps {
    // (undocumented)
    iModel: IModelConnection;
}

// @alpha
export interface SpatialContainmentTreeState {
    // (undocumented)
    dataProvider?: IPresentationTreeDataProvider;
    // (undocumented)
    initialized: false;
}

// @public
export enum SpecialKey {
    // (undocumented)
    ArrowDown = "ArrowDown",
    // (undocumented)
    ArrowLeft = "ArrowLeft",
    // (undocumented)
    ArrowRight = "ArrowRight",
    // (undocumented)
    ArrowUp = "ArrowUp",
    // (undocumented)
    Backspace = "Backspace",
    // (undocumented)
    Delete = "Delete",
    // (undocumented)
    End = "End",
    // (undocumented)
    Enter = "Enter",
    // (undocumented)
    Escape = "Escape",
    // (undocumented)
    Home = "Home",
    // (undocumented)
    Insert = "Insert",
    // (undocumented)
    PageDown = "PageDown",
    // (undocumented)
    PageUp = "PageUp",
    // (undocumented)
    Space = " ",
    // (undocumented)
    Tab = "Tab"
}

// @internal (undocumented)
export class SplitterPaneTarget extends React_2.PureComponent<SplitterPaneTargetProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal (undocumented)
export interface SplitterPaneTargetProps {
    // (undocumented)
    onTargetChanged: (paneIndex: number | undefined) => void;
    // (undocumented)
    paneIndex: number;
}

// @beta
export interface StageLauncher extends BackstageItemSpec {
    // (undocumented)
    readonly itemType: BackstageItemType.StageLauncher;
    // (undocumented)
    stageId: string;
}

// @beta
export interface StageLauncher extends BackstageItemSpec {
    // (undocumented)
    readonly itemType: BackstageItemType.StageLauncher;
    // (undocumented)
    stageId: string;
}

// @alpha
export class StagePanel extends React_2.Component<StagePanelProps> {
    // (undocumented)
    static readonly defaultProps: StagePanelDefaultProps;
    // (undocumented)
    static initializeStagePanelDef(panelDef: StagePanelDef, props: StagePanelProps, panelLocation: StagePanelLocation): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export interface StagePanelChangeHandler {
    // @alpha (undocumented)
    handlePanelInitialize(panelLocation: StagePanelLocation, size: number): void;
    // @alpha (undocumented)
    handlePanelPaneTargetChange(panelLocation: StagePanelLocation, paneIndex: number | undefined): void;
    // @alpha (undocumented)
    handlePanelResize(panelLocation: StagePanelLocation, resizeBy: number): void;
    // @alpha (undocumented)
    handlePanelTargetChange(panelLocation: StagePanelLocation | undefined): void;
    // @alpha (undocumented)
    handleTogglePanelCollapse(panelLocation: StagePanelLocation): void;
}

// @alpha
export class StagePanelDef extends WidgetHost {
    constructor();
    applicationData?: any;
    location: StagePanelLocation;
    panelState: StagePanelState;
    resizable: boolean;
    size: number | undefined;
}

// @alpha
export type StagePanelDefaultProps = Pick<StagePanelProps, "resizable">;

// @alpha
export enum StagePanelLocation {
    // (undocumented)
    Bottom = 4,
    // (undocumented)
    BottomMost = 5,
    // (undocumented)
    Left = 2,
    // (undocumented)
    Right = 3,
    // (undocumented)
    Top = 0,
    // (undocumented)
    TopMost = 1
}

// @alpha
export interface StagePanelProps {
    allowedZones?: ZoneLocation[];
    applicationData?: any;
    defaultState?: StagePanelState;
    resizable: boolean;
    // @internal (undocumented)
    runtimeProps?: StagePanelRuntimeProps;
    size?: number;
    widgets?: Array<React_2.ReactElement<WidgetProps>>;
}

// @internal
export interface StagePanelRuntimeProps {
    // (undocumented)
    draggedWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    getWidgetContentRef: (id: WidgetZoneId) => React_2.Ref<HTMLDivElement>;
    // (undocumented)
    isTargeted: boolean;
    // (undocumented)
    panel: NineZoneStagePanelManagerProps;
    // (undocumented)
    panelDef: StagePanelDef;
    // (undocumented)
    stagePanelChangeHandler: StagePanelChangeHandler;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgets: ZonesManagerWidgetsProps;
    // (undocumented)
    widgetTabs: WidgetTabs;
    // (undocumented)
    zoneDefProvider: ZoneDefProvider;
}

// @alpha
export enum StagePanelState {
    // (undocumented)
    Minimized = 1,
    // (undocumented)
    Off = 0,
    // (undocumented)
    Open = 2,
    // (undocumented)
    Popup = 3
}

// @public
export class StandardMessageBox extends React_2.PureComponent<StandardMessageBoxProps, StandardMessageBoxState> {
    constructor(props: StandardMessageBoxProps);
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<StandardMessageBoxState>;
}

// @public
export interface StandardMessageBoxProps extends CommonProps {
    iconType: MessageBoxIconType;
    messageBoxType: MessageBoxType;
    onResult?: (result: MessageBoxValue) => void;
    opened: boolean;
    title: string;
}

// @alpha
export class StandardRotationNavigationAid extends React_2.Component<CommonProps, StandardRotationNavigationAidState> {
    constructor(props: any);
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<StandardRotationNavigationAidState>;
    }

// @alpha
export class StandardRotationNavigationAidControl extends NavigationAidControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    static navigationAidId: string;
}

// @public
export type StateType<R extends Reducer<any, any>> = DeepReadonly<ReturnType<R>>;

// @public
export class StatusBar extends React_2.Component<StatusBarProps, StatusBarState> {
    constructor(props: StatusBarProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    static severityToStatus(severity: MessageSeverity): Status;
    // @internal (undocumented)
    readonly state: Readonly<StatusBarState>;
    }

// @beta
export const StatusBarCenterSection: React_2.FunctionComponent<CommonDivProps>;

// @public
export type StatusBarFieldId = string | null;

// @beta
export const StatusBarLeftSection: React_2.FunctionComponent<CommonDivProps>;

// @public
export interface StatusBarProps extends CommonProps {
    // (undocumented)
    isInFooterMode: boolean;
    // (undocumented)
    widgetControl?: StatusBarWidgetControl;
}

// @beta
export const StatusBarRightSection: React_2.FunctionComponent<CommonDivProps>;

// @beta
export const StatusBarSpaceBetween: React_2.FunctionComponent<CommonDivProps>;

// @public
export abstract class StatusBarWidgetControl extends WidgetControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    abstract getReactNode(args: StatusBarWidgetControlArgs): React.ReactNode;
    getType(): ConfigurableUiControlType;
}

// @public
export interface StatusBarWidgetControlArgs {
    isInFooterMode: boolean;
    onOpenWidget: (widget: StatusBarFieldId) => void;
    openWidget: StatusBarFieldId;
    toastTargetRef: React.Ref<HTMLElement>;
}

// @internal
export class StatusBarZone extends React_2.PureComponent<StatusBarZoneProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface StatusBarZoneProps extends CommonProps {
    // (undocumented)
    dropTarget: ZoneTargetType | undefined;
    // (undocumented)
    isHidden: boolean;
    // (undocumented)
    isInFooterMode: boolean;
    // (undocumented)
    targetChangeHandler: TargetChangeHandler;
    // (undocumented)
    targetedBounds: RectangleProps | undefined;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgetControl?: StatusBarWidgetControl;
    // (undocumented)
    zoneProps: ZoneManagerProps;
}

// @public
export interface StatusFieldProps extends CommonProps {
    isInFooterMode: boolean;
    onOpenWidget: (widget: StatusBarFieldId) => void;
    openWidget: StatusBarFieldId;
}

// @public
export type StringGetter = () => string;

// @public
export interface SupportsViewSelectorChange {
    processViewSelectorChange(iModel: IModelConnection, viewDefinitionId: Id64String, viewState: ViewState, name: string): Promise<void>;
    supportsViewSelectorChange: boolean;
}

// @public
export class SyncToolSettingsPropertiesEvent extends UiEvent<SyncToolSettingsPropertiesEventArgs> {
}

// @public
export interface SyncToolSettingsPropertiesEventArgs {
    // (undocumented)
    syncProperties: ToolSettingsPropertySyncItem[];
    // (undocumented)
    toolId: string;
}

// @public
export class SyncUiEvent extends UiEvent<SyncUiEventArgs> {
}

// @public
export interface SyncUiEventArgs {
    // (undocumented)
    eventIds: Set<string>;
}

// @public
export class SyncUiEventDispatcher {
    static clearConnectionEvents(iModelConnection: IModelConnection): void;
    static dispatchImmediateSyncUiEvent(eventId: string): void;
    static dispatchSyncUiEvent(eventId: string): void;
    static dispatchSyncUiEvents(eventIds: string[]): void;
    static hasEventOfInterest(eventIds: Set<string>, idsOfInterest: string[]): boolean;
    static initialize(): void;
    static initializeConnectionEvents(iModelConnection: IModelConnection): void;
    static readonly onSyncUiEvent: SyncUiEvent;
    // @internal
    static setTimeoutPeriod(period: number): void;
    static readonly syncEventIds: Set<string>;
    }

// @public
export enum SyncUiEventId {
    ActiveContentChanged = "activecontentchanged",
    ActiveViewportChanged = "activeviewportchanged",
    // @deprecated
    BackstageCloseEvent = "backstagecloseevent",
    BackstageEvent = "backstageevent",
    ContentControlActivated = "contentcontrolactivated",
    ContentLayoutActivated = "contentlayoutactivated",
    FrontstageActivating = "frontstageactivating",
    FrontstageReady = "frontstageready",
    ModalDialogChanged = "modaldialogchanged",
    ModalFrontstageChanged = "modalfrontstagechanged",
    NavigationAidActivated = "navigationaidactivated",
    SelectionSetChanged = "selectionsetchanged",
    TaskActivated = "taskactivated",
    ToolActivated = "toolactivated",
    WidgetStateChanged = "widgetstatechanged",
    WorkflowActivated = "workflowactivated"
}

// @public
export interface SyncUiProps {
    // (undocumented)
    stateFunc?: (state: Readonly<BaseItemState>) => BaseItemState;
    // (undocumented)
    stateSyncIds?: string[];
}

// @public
export interface TargetChangeHandler {
    // (undocumented)
    handleTargetChanged(zoneId: WidgetZoneId, type: ZoneTargetType, isTargeted: boolean): void;
}

// @public
export class Task extends ItemDefBase {
    constructor(taskProps: TaskProps);
    // (undocumented)
    readonly id: string;
    // (undocumented)
    isActive: boolean;
    // (undocumented)
    onActivated(): Promise<void>;
    // (undocumented)
    primaryStageId: string;
    // (undocumented)
    taskId: string;
}

// @public
export class TaskActivatedEvent extends UiEvent<TaskActivatedEventArgs> {
}

// @public
export interface TaskActivatedEventArgs {
    // (undocumented)
    task?: Task;
    // (undocumented)
    taskId?: string;
    // (undocumented)
    workflow: Workflow;
    // (undocumented)
    workflowId: string;
}

// @public
export class TaskLaunchBackstageItem extends React_2.PureComponent<TaskLaunchBackstageItemProps, BackstageItemState> {
    constructor(props: TaskLaunchBackstageItemProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(_prevProps: TaskLaunchBackstageItemProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    execute: () => void;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BackstageItemState>;
    }

// @public
export interface TaskLaunchBackstageItemProps extends BackstageItemProps {
    taskId: string;
    workflowId: string;
}

// @public
export class TaskManager {
    // (undocumented)
    static addTask(taskId: string, task: Task): void;
    // (undocumented)
    static findTask(taskId: string): Task | undefined;
    // (undocumented)
    static loadTaskDef(taskDef: TaskProps): void;
    // (undocumented)
    static loadTaskDefs(taskDefs: TaskProps[]): void;
    // (undocumented)
    static loadTasks(taskListDef: TaskPropsList): void;
    }

// @public
export interface TaskProps extends ItemProps {
    // (undocumented)
    id: string;
    // (undocumented)
    primaryStageId: string;
}

// @public
export interface TaskPropsList {
    // (undocumented)
    tasks: TaskProps[];
}

// @beta
export const ThemeManager: any;

// @internal
export class TileLoadingIndicator extends React_2.PureComponent<CommonProps, TileLoadingIndicatorState> {
    constructor(props: CommonProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    render(): JSX.Element;
    }

// @public
export class ToolActivatedEvent extends UiEvent<ToolActivatedEventArgs> {
}

// @public
export interface ToolActivatedEventArgs {
    // (undocumented)
    toolId: string;
}

// @alpha
export class ToolAssistanceChangedEvent extends UiEvent<ToolAssistanceChangedEventArgs> {
}

// @alpha
export interface ToolAssistanceChangedEventArgs {
    // (undocumented)
    instructions: ToolAssistanceInstructions | undefined;
}

// @beta
export class ToolAssistanceField extends React_2.Component<ToolAssistanceFieldProps, ToolAssistanceFieldState> {
    constructor(p: ToolAssistanceFieldProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static readonly defaultProps: ToolAssistanceFieldDefaultProps;
    // @internal (undocumented)
    static getInstructionImage(instruction: ToolAssistanceInstruction): React_2.ReactNode;
    // @internal (undocumented)
    render(): React_2.ReactNode;
    }

// @internal
export type ToolAssistanceFieldDefaultProps = Pick<ToolAssistanceFieldProps, "includePromptAtCursor" | "uiSettings" | "cursorPromptTimeout" | "fadeOutCursorPrompt" | "defaultPromptAtCursor">;

// @beta
export interface ToolAssistanceFieldProps extends StatusFieldProps {
    cursorPromptTimeout: number;
    defaultPromptAtCursor: boolean;
    fadeOutCursorPrompt: boolean;
    includePromptAtCursor: boolean;
    uiSettings: UiSettings;
}

// @internal
export class Toolbar extends React_2.Component<ToolbarProps, State> {
    constructor(props: ToolbarProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element | null;
    }

// @beta
export class ToolbarButtonHelper {
    static getAppButton(): HTMLButtonElement | null;
    static getToolbarButtonByTitle(title: string): HTMLButtonElement | null;
    static searchHorizontalToolbarsByTitle(title: string): HTMLButtonElement | null;
    // (undocumented)
    static searchToolbarsByTitle(title: string, horizontal: boolean): HTMLButtonElement | null;
    static searchVerticalToolbarsByTitle(title: string): HTMLButtonElement | null;
}

// @internal
export interface ToolbarProps extends CommonProps, NoChildrenProps {
    expandsTo?: Direction;
    items: ItemList;
    orientation: Orientation;
    panelAlignment?: ToolbarPanelAlignment;
    toolbarId?: string;
}

// @public
export class ToolbarWidgetDefBase extends WidgetDef {
    constructor(def: ToolbarWidgetProps);
    // (undocumented)
    protected _cachedHorizontalItems?: ItemList;
    // (undocumented)
    protected _cachedVerticalItems?: ItemList;
    // (undocumented)
    protected createCachedHorizontalItemList(toolbarId: string): void;
    // (undocumented)
    protected createCachedVerticalItemList(toolbarId: string): void;
    protected createMergedItemList(originalItemList: ItemList | undefined, insertSpecs: ToolbarItemInsertSpec[]): ItemList;
    // (undocumented)
    generateMergedItemLists(): void;
    protected getItemHierarchy(parentNode: UiItemNode, items: ItemDefBase[]): void;
    // (undocumented)
    horizontalDirection: Direction;
    // (undocumented)
    horizontalItems?: ItemList;
    // (undocumented)
    horizontalPanelAlignment: ToolbarPanelAlignment;
    // (undocumented)
    renderHorizontalToolbar: () => React_2.ReactNode;
    // (undocumented)
    renderVerticalToolbar: () => React_2.ReactNode;
    // (undocumented)
    verticalDirection: Direction;
    // (undocumented)
    verticalItems?: ItemList;
    // (undocumented)
    verticalPanelAlignment: ToolbarPanelAlignment;
    // (undocumented)
    widgetBaseName: string;
}

// @public
export interface ToolbarWidgetProps extends WidgetProps {
    // (undocumented)
    horizontalDirection?: Direction;
    // (undocumented)
    horizontalItems?: ItemList;
    // (undocumented)
    verticalDirection?: Direction;
    // (undocumented)
    verticalItems?: ItemList;
}

// @public
export class ToolButton extends React_2.Component<ToolButtonProps, BaseItemState> {
    constructor(props: ToolItemProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    readonly label: string;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<BaseItemState>;
}

// @public
export interface ToolButtonProps extends ToolItemProps, CommonProps {
}

// @public
export class ToolIconChangedEvent extends UiEvent<ToolIconChangedEventArgs> {
}

// @public
export interface ToolIconChangedEventArgs {
    // (undocumented)
    iconSpec: string;
}

// @public
export class ToolInformation {
    constructor(toolId: string);
    // (undocumented)
    toolId: string;
    readonly toolUiProvider: ToolUiProvider | undefined;
    }

// @public
export class ToolItemDef extends ActionButtonItemDef {
    constructor(toolItemProps: ToolItemProps);
    static getItemDefForTool(tool: typeof Tool, iconSpec?: string, args?: any[]): ToolItemDef;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    toolId: string;
}

// @public
export interface ToolItemProps extends ItemProps, CommandHandler {
    // (undocumented)
    toolId: string;
}

// @internal
export class ToolSettingsZone extends React_2.PureComponent<ToolSettingsZoneProps, ToolSettingsZoneState> {
    constructor(props: ToolSettingsZoneProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // (undocumented)
    readonly state: Readonly<ToolSettingsZoneState>;
}

// @internal
export interface ToolSettingsZoneProps extends CommonProps {
    // (undocumented)
    bounds: RectangleProps;
    // (undocumented)
    isClosed: boolean;
    // (undocumented)
    isHidden: boolean;
}

// @public
export interface TooltipProps {
    tooltip?: string | StringGetter;
    tooltipKey?: string;
}

// @internal
export class ToolUiManager {
    static readonly activeToolDescription: string;
    static activeToolLabel: string;
    static clearToolSettingsData(): void;
    static initialize(): void;
    static initializeDataForTool(tool: InteractiveTool): void;
    static initializeToolSettingsData(toolSettingsProperties: ToolSettingsPropertyRecord[] | undefined, toolId?: string, toolLabel?: string, toolDescription?: string): boolean;
    static readonly onSyncToolSettingsProperties: SyncToolSettingsPropertiesEvent;
    static readonly toolIdForToolSettings: string;
    static readonly toolSettingsProperties: ToolSettingsPropertyRecord[];
    static useDefaultToolSettingsProvider: boolean;
    }

// @public
export class ToolUiProvider extends ConfigurableUiControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    getType(): ConfigurableUiControlType;
    toolSettingsNode: React_2.ReactNode;
    }

// @public
export class ToolWidget extends React_2.Component<ToolWidgetPropsEx, ToolWidgetState> {
    constructor(props: ToolWidgetPropsEx);
    // (undocumented)
    componentDidUpdate(prevProps: ToolWidgetPropsEx, _prevState: ToolWidgetState): void;
    // (undocumented)
    render(): React_2.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<ToolWidgetState>;
}

// @public
export class ToolWidgetDef extends ToolbarWidgetDefBase {
    constructor(props: ToolWidgetProps);
    // (undocumented)
    readonly reactElement: React_2.ReactNode;
    // (undocumented)
    renderCornerItem(): React_2.ReactNode | undefined;
}

// @public
export interface ToolWidgetProps extends ToolbarWidgetProps {
    // (undocumented)
    appButton?: CommandItemDef;
}

// @public
export interface ToolWidgetPropsEx extends ToolWidgetProps, CommonProps {
    // (undocumented)
    button?: React_2.ReactNode;
    // (undocumented)
    horizontalToolbar?: React_2.ReactNode;
    // (undocumented)
    verticalToolbar?: React_2.ReactNode;
}

// @internal (undocumented)
export class TsCol {
    constructor(columnIndex: number);
    // (undocumented)
    readonly columnIndex: number;
    // (undocumented)
    columnSpan: number;
    // (undocumented)
    name: string;
    // (undocumented)
    type: ColumnType;
}

// @internal (undocumented)
export class TsLabel {
    constructor(label: string, isDisabled?: boolean | undefined);
    // (undocumented)
    isDisabled?: boolean | undefined;
    // (undocumented)
    readonly label: string;
}

// @internal (undocumented)
export class TsRow {
    constructor(priority: number, numColumns: number);
    // (undocumented)
    cols: TsCol[];
    // (undocumented)
    priority: number;
}

// @public
export class UiFramework {
    // (undocumented)
    static dispatchActionToStore(type: string, payload: any, immediateSync?: boolean): void;
    // @beta
    static readonly frameworkState: FrameworkState | undefined;
    // @beta (undocumented)
    static readonly frameworkStateKey: string;
    // (undocumented)
    static getAccessToken(): AccessToken | undefined;
    // (undocumented)
    static getAccudrawSnapMode(): SnapMode;
    // (undocumented)
    static getActiveIModelId(): string;
    // (undocumented)
    static getActiveSelectionScope(): string;
    // @beta (undocumented)
    static getAvailableSelectionScopes(): PresentationSelectionScope[];
    // @beta (undocumented)
    static getColorTheme(): string;
    // (undocumented)
    static getDefaultIModelViewportControlId(): string | undefined;
    // (undocumented)
    static getDefaultRulesetId(): string | undefined;
    // (undocumented)
    static getDefaultViewId(): string | undefined;
    // (undocumented)
    static getIModelConnection(): IModelConnection | undefined;
    // @beta (undocumented)
    static getIsUiVisible(): boolean;
    // @beta (undocumented)
    static getWidgetOpacity(): number;
    static readonly i18n: I18N;
    static readonly i18nNamespace: string;
    // @internal (undocumented)
    static readonly iModelServices: IModelServices;
    static initialize(store: Store<any>, i18n: I18N, oidcConfig?: OidcFrontendClientConfiguration, frameworkStateKey?: string): Promise<any>;
    // @internal
    static initializeEx(store: Store<any>, i18n: I18N, oidcConfig?: OidcFrontendClientConfiguration, frameworkStateKey?: string, projectServices?: ProjectServices, iModelServices?: IModelServices): Promise<any>;
    // @beta (undocumented)
    static isMobile(): boolean;
    // @internal (undocumented)
    static loggerCategory(obj: any): string;
    // @beta (undocumented)
    static readonly oidcClient: IOidcFrontendClient;
    // @beta
    static readonly onUiVisibilityChanged: UiVisibilityChangedEvent;
    // @internal (undocumented)
    static readonly packageName: string;
    // @internal (undocumented)
    static readonly projectServices: ProjectServices;
    // (undocumented)
    static setAccessToken(accessToken: AccessToken, immediateSync?: boolean): void;
    // (undocumented)
    static setAccudrawSnapMode(snapMode: SnapMode): void;
    // (undocumented)
    static setActiveIModelId(iModelId: string): void;
    // (undocumented)
    static setActiveSelectionScope(selectionScopeId: string): void;
    // @beta (undocumented)
    static setColorTheme(theme: string): void;
    // (undocumented)
    static setDefaultIModelViewportControlId(iModelViewportControlId: string, immediateSync?: boolean): void;
    // (undocumented)
    static setDefaultRulesetId(viewId: string, immediateSync?: boolean): void;
    // (undocumented)
    static setDefaultViewId(viewId: string, immediateSync?: boolean): void;
    // (undocumented)
    static setIModelConnection(iModelConnection: IModelConnection | undefined, immediateSync?: boolean): void;
    // @beta (undocumented)
    static setIsUiVisible(visible: boolean): void;
    // @beta (undocumented)
    static setWidgetOpacity(opacity: number): void;
    static readonly store: Store<any>;
    static terminate(): void;
    // @internal
    static translate(key: string | string[], options?: TranslationOptions): string;
}

// @alpha
export class UiShowHideManager {
    // (undocumented)
    static autoHideUi: boolean;
    // (undocumented)
    static handleContentMouseMove(_event?: React.MouseEvent<HTMLElement, MouseEvent>): void;
    // (undocumented)
    static handleFrontstageReady(): void;
    // (undocumented)
    static handleWidgetMouseEnter(_event?: React.MouseEvent<HTMLElement, MouseEvent>): void;
    // (undocumented)
    static inactivityTime: number;
    // (undocumented)
    static isUiVisible: boolean;
    // (undocumented)
    static showHideFooter: boolean;
    // (undocumented)
    static showHidePanels: boolean;
    }

// @beta
export class UiVisibilityChangedEvent extends UiEvent<UiVisibilityEventArgs> {
}

// @beta
export interface UiVisibilityEventArgs {
    // (undocumented)
    visible: boolean;
}

// @alpha
export class ValidationTextbox extends React_2.PureComponent<ValidationTextboxProps, ValidationTextboxState> {
    constructor(props: ValidationTextboxProps);
    // @internal (undocumented)
    render(): React_2.ReactNode;
    }

// @internal
export interface VersionInfo {
    // (undocumented)
    changeSetId?: string;
    // (undocumented)
    createdDate: Date;
    // (undocumented)
    description: string;
    // (undocumented)
    largeThumbnail?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    smallThumbnail?: string;
    // (undocumented)
    userCreated?: string;
}

// @beta
export interface ViewLayout {
    // (undocumented)
    contentGroup: ContentGroup;
    // (undocumented)
    contentLayoutDef: ContentLayoutDef;
    // (undocumented)
    viewStates: Array<ViewState | undefined>;
}

// @public
export class ViewportContentControl extends ContentControl implements SupportsViewSelectorChange {
    constructor(info: ConfigurableCreateInfo, options: any);
    getReactElementForViewSelectorChange(_iModel: IModelConnection, _viewDefinitionId: Id64String, _viewState: ViewState, _name: string): React.ReactNode;
    getType(): ConfigurableUiControlType;
    readonly isReady: Promise<void>;
    readonly isViewport: boolean;
    readonly navigationAidControl: string;
    onActivated(): void;
    processViewSelectorChange(iModel: IModelConnection, viewDefinitionId: Id64String, viewState: ViewState, name: string): Promise<void>;
    setIsReady(): void;
    readonly supportsViewSelectorChange: boolean;
    viewport: ScreenViewport | undefined;
    }

// @beta
export class ViewSelector extends React_2.Component<ViewSelectorProps, ViewSelectorState> {
    constructor(props: ViewSelectorProps);
    // (undocumented)
    componentDidMount(): Promise<void>;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static readonly defaultProps: ViewSelectorDefaultProps;
    loadViews(): Promise<void>;
    static readonly onViewSelectorChangedEvent: ViewSelectorChangedEvent;
    render(): JSX.Element;
    static updateShowSettings(showSpatials: boolean, showDrawings: boolean, showSheets: boolean, showUnknown: boolean): void;
    updateState(viewId?: any): Promise<void>;
}

// @beta
export class ViewSelectorChangedEvent extends UiEvent<ViewSelectorChangedEventArgs> {
}

// @beta
export interface ViewSelectorChangedEventArgs {
    // (undocumented)
    iModelConnection: IModelConnection;
    // (undocumented)
    name: string;
    // (undocumented)
    viewDefinitionId: Id64String;
    // (undocumented)
    viewState: ViewState;
}

// @beta
export type ViewSelectorDefaultProps = Pick<ViewSelectorProps, "showSpatials" | "showDrawings" | "showSheets" | "showUnknown">;

// @beta
export interface ViewSelectorProps {
    // (undocumented)
    imodel?: IModelConnection;
    // (undocumented)
    listenForShowUpdates?: boolean;
    // (undocumented)
    showDrawings: boolean;
    // (undocumented)
    showSheets: boolean;
    // (undocumented)
    showSpatials: boolean;
    // (undocumented)
    showUnknown: boolean;
}

// @public
export class ViewUtilities {
    static getBisBaseClass(classFullName: string): string;
    static is3dView(viewport: ScreenViewport): boolean;
    static isDrawing(classname: string): boolean;
    static isDrawingView(viewport: ScreenViewport): boolean;
    static isOrthographic(classname: string): boolean;
    static isOrthographicView(viewport: ScreenViewport): boolean;
    static isSheet(classname: string): boolean;
    static isSheetView(viewport: ScreenViewport): boolean;
    static isSpatial(classname: string): boolean;
    static isSpatialView(viewport: ScreenViewport): boolean;
    static viewSupportsCamera(viewport: ScreenViewport): boolean;
}

// @alpha
export class VisibilityComponent extends React_2.Component<VisibilityComponentProps, VisibilityTreeState_2> {
    constructor(props: any);
    // (undocumented)
    componentDidMount(): Promise<void>;
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface VisibilityComponentProps {
    activeTreeRef?: React_2.Ref<HTMLDivElement>;
    activeViewport?: Viewport;
    iModelConnection: IModelConnection;
}

// @internal (undocumented)
export class VisibilityHandler implements IDisposable {
    constructor(props: VisibilityHandlerProps);
    // (undocumented)
    changeVisibility(node: TreeNodeItem, on: boolean): Promise<void>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getDisplayStatus(node: TreeNodeItem): VisibilityStatus | Promise<VisibilityStatus>;
    // (undocumented)
    onVisibilityChange: () => void;
    }

// @internal (undocumented)
export interface VisibilityHandlerProps {
    // (undocumented)
    dataProvider: IPresentationTreeDataProvider;
    // (undocumented)
    onVisibilityChange: () => void;
    // (undocumented)
    viewport: Viewport;
}

// @internal (undocumented)
export interface VisibilityStatus {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    isDisplayed: boolean;
    // (undocumented)
    tooltip?: string;
}

// @public
export class VisibilityTree extends React_2.PureComponent<VisibilityTreeProps, VisibilityTreeState> {
    constructor(props: VisibilityTreeProps);
    // (undocumented)
    componentDidUpdate(prevProps: VisibilityTreeProps, _prevState: VisibilityTreeState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static getDerivedStateFromProps(nextProps: VisibilityTreeProps, state: VisibilityTreeState): Partial<VisibilityTreeState> | null;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export interface VisibilityTreeProps {
    activeView?: Viewport;
    // @internal
    dataProvider?: IPresentationTreeDataProvider;
    imodel: IModelConnection;
    // @alpha
    rootElementRef?: React_2.Ref<HTMLDivElement>;
    selectionMode?: SelectionMode;
    // @internal
    visibilityHandler?: VisibilityHandler;
}

// @alpha
export class VisibilityWidget extends WidgetControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    // (undocumented)
    static readonly iconSpec: string;
    // (undocumented)
    static readonly label: string;
    // (undocumented)
    restoreTransientState(): boolean;
    // (undocumented)
    saveTransientState(): void;
}

// @public
export class Widget extends React_2.Component<WidgetProps> {
    constructor(props: WidgetProps);
    // (undocumented)
    render(): null;
}

// @beta
export const WIDGET_OPACITY_DEFAULT = 0.9;

// @public
export interface WidgetChangeHandler {
    // (undocumented)
    handleResize(zoneId: WidgetZoneId, resizeBy: number, handle: ResizeHandle, filledHeightDiff: number): void;
    // (undocumented)
    handleTabClick(widgetId: WidgetZoneId, tabIndex: number): void;
    // (undocumented)
    handleTabDrag(dragged: PointProps): void;
    // (undocumented)
    handleTabDragEnd(): void;
    // (undocumented)
    handleTabDragStart(widgetId: WidgetZoneId, tabIndex: number, initialPosition: PointProps, widgetBounds: RectangleProps): void;
    // (undocumented)
    handleWidgetStateChange(widgetId: WidgetZoneId, tabIndex: number, isOpening: boolean): void;
}

// @public
export class WidgetControl extends ConfigurableUiControl {
    constructor(info: ConfigurableCreateInfo, options: any);
    getType(): ConfigurableUiControlType;
    onWidgetStateChanged(): void;
    reactElement: React_2.ReactNode;
    restoreTransientState(): boolean;
    saveTransientState(): void;
    setWidgetState(state: WidgetState): void;
    widgetDef: WidgetDef;
    }

// @public
export class WidgetDef {
    constructor(widgetProps: WidgetProps);
    // (undocumented)
    readonly activeState: WidgetState;
    // (undocumented)
    applicationData?: any;
    // (undocumented)
    betaBadge?: boolean;
    // (undocumented)
    canOpen(): boolean;
    // (undocumented)
    classId: string | ConfigurableUiControlConstructor | undefined;
    // (undocumented)
    fillZone: boolean;
    // (undocumented)
    getWidgetControl(type: ConfigurableUiControlType): WidgetControl | undefined;
    // (undocumented)
    iconSpec?: string | React_2.ReactNode;
    // (undocumented)
    id: string;
    // (undocumented)
    static initializeFromWidgetProps(widgetProps: WidgetProps, me: WidgetDef): void;
    // (undocumented)
    readonly isActive: boolean;
    // (undocumented)
    isFloating: boolean;
    // (undocumented)
    isFloatingStateSupported: boolean;
    // (undocumented)
    isFloatingStateWindowResizable: boolean;
    // (undocumented)
    isFreeform: boolean;
    // (undocumented)
    isStatusBar: boolean;
    // (undocumented)
    isToolSettings: boolean;
    // (undocumented)
    readonly isVisible: boolean;
    readonly label: string;
    // (undocumented)
    priority: number;
    // (undocumented)
    reactElement: React_2.ReactNode;
    setLabel(v: string | StringGetter): void;
    setTooltip(v: string | StringGetter): void;
    // (undocumented)
    setUpSyncSupport(props: WidgetProps): void;
    // (undocumented)
    setWidgetState(newState: WidgetState): void;
    // (undocumented)
    state: WidgetState;
    // (undocumented)
    stateChanged: boolean;
    // (undocumented)
    stateFunc?: (state: Readonly<WidgetState>) => WidgetState;
    // (undocumented)
    syncEventIds: string[];
    readonly tooltip: string;
    // (undocumented)
    readonly widgetControl: WidgetControl | undefined;
    // (undocumented)
    widgetType: WidgetType;
}

// @internal
export class WidgetDefFactory {
    static create(widgetProps: WidgetProps): WidgetDef;
}

// @public
export class WidgetHost {
    constructor();
    addWidgetDef(widgetDef: WidgetDef): void;
    findWidgetDef(id: string): WidgetDef | undefined;
    getSingleWidgetDef(): WidgetDef | undefined;
    readonly widgetCount: number;
    readonly widgetDefs: WidgetDef[];
    }

// @public
export interface WidgetProps extends IconProps {
    applicationData?: any;
    betaBadge?: boolean;
    classId?: string | ConfigurableUiControlConstructor;
    control?: ConfigurableUiControlConstructor;
    defaultState?: WidgetState;
    element?: React_2.ReactNode;
    fillZone?: boolean;
    iconSpec?: string | React_2.ReactNode;
    id?: string;
    isFloatingStateSupported?: boolean;
    isFloatingStateWindowResizable?: boolean;
    isFreeform?: boolean;
    isStatusBar?: boolean;
    isToolSettings?: boolean;
    label?: string | StringGetter;
    labelKey?: string;
    priority?: number;
    stateFunc?: (state: Readonly<WidgetState>) => WidgetState;
    syncEventIds?: string[];
    tooltip?: string | StringGetter;
    tooltipKey?: string;
}

// @internal
export class WidgetStack extends React_2.PureComponent<WidgetStackProps> {
    // (undocumented)
    render(): React_2.ReactNode;
    }

// @internal
export interface WidgetStackProps extends CommonProps {
    // (undocumented)
    activeTabIndex: number;
    // (undocumented)
    draggedWidget: DraggedWidgetManagerProps | undefined;
    // (undocumented)
    fillZone: boolean;
    // (undocumented)
    getWidgetContentRef: (id: WidgetZoneId) => React_2.Ref<HTMLDivElement>;
    // (undocumented)
    horizontalAnchor: HorizontalAnchor;
    // (undocumented)
    isCollapsed: boolean;
    // (undocumented)
    isFloating: boolean;
    // (undocumented)
    isInStagePanel: boolean;
    // (undocumented)
    openWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    verticalAnchor: VerticalAnchor;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgets: ReadonlyArray<WidgetZoneId>;
    // (undocumented)
    widgetTabs: WidgetTabs;
}

// @internal
export class WidgetStackTab extends React_2.PureComponent<WidgetStackTabProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export class WidgetStackTabGroup extends React_2.PureComponent<WidgetStackTabGroupProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface WidgetStackTabGroupProps {
    // (undocumented)
    activeTabIndex: number;
    // (undocumented)
    draggedWidget: DraggedWidgetManagerProps | undefined;
    // (undocumented)
    horizontalAnchor: HorizontalAnchor;
    // (undocumented)
    isCollapsed: boolean;
    // (undocumented)
    isProtruding: boolean;
    // (undocumented)
    isStacked: boolean;
    // (undocumented)
    onTabClick: (widgetId: WidgetZoneId, tabIndex: number) => void;
    // (undocumented)
    onTabDrag: (dragged: PointProps) => void;
    // (undocumented)
    onTabDragEnd: () => void;
    // (undocumented)
    onTabDragStart: (widgetId: WidgetZoneId, tabIndex: number, initialPosition: PointProps, firstTabBounds: RectangleProps) => void;
    // (undocumented)
    openWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    tabs: ReadonlyArray<WidgetTab>;
    // (undocumented)
    verticalAnchor: VerticalAnchor;
    // (undocumented)
    widgetId: WidgetZoneId;
}

// @internal
export interface WidgetStackTabProps {
    // (undocumented)
    horizontalAnchor: HorizontalAnchor;
    // (undocumented)
    iconSpec?: string | React_2.ReactNode;
    // (undocumented)
    index: number;
    // (undocumented)
    isBetaBadgeVisible: boolean;
    // (undocumented)
    isCollapsed: boolean;
    // (undocumented)
    isProtruding: boolean;
    // (undocumented)
    lastPosition: PointProps | undefined;
    // (undocumented)
    mode: TabMode;
    // (undocumented)
    onClick: (index: number) => void;
    // (undocumented)
    onDrag: (dragged: PointProps) => void;
    // (undocumented)
    onDragEnd: () => void;
    // (undocumented)
    onDragStart: (index: number, initialPosition: PointProps) => void;
    // (undocumented)
    tabRef?: React_2.Ref<Tab>;
    // (undocumented)
    title: string;
    // (undocumented)
    verticalAnchor: VerticalAnchor;
}

// @internal
export class WidgetStackTabs extends React_2.PureComponent<WidgetStackTabsProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface WidgetStackTabsProps {
    // (undocumented)
    activeTabIndex: number;
    // (undocumented)
    draggedWidget: DraggedWidgetManagerProps | undefined;
    // (undocumented)
    horizontalAnchor: HorizontalAnchor;
    // (undocumented)
    isCollapsed: boolean;
    // (undocumented)
    isProtruding: boolean;
    // (undocumented)
    onTabClick: (widgetId: WidgetZoneId, tabIndex: number) => void;
    // (undocumented)
    onTabDrag: (dragged: PointProps) => void;
    // (undocumented)
    onTabDragEnd: () => void;
    // (undocumented)
    onTabDragStart: (widgetId: WidgetZoneId, tabIndex: number, initialPosition: PointProps, firstTabBounds: RectangleProps) => void;
    // (undocumented)
    openWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    verticalAnchor: VerticalAnchor;
    // (undocumented)
    widgets: ReadonlyArray<WidgetZoneId>;
    // (undocumented)
    widgetTabs: WidgetTabs;
}

// @public
export enum WidgetState {
    Closed = 1,
    Floating = 3,
    Hidden = 2,
    Open = 0,
    Unloaded = 4
}

// @public
export class WidgetStateChangedEvent extends UiEvent<WidgetStateChangedEventArgs> {
}

// @public
export interface WidgetStateChangedEventArgs {
    // (undocumented)
    widgetDef: WidgetDef;
    // (undocumented)
    widgetState: WidgetState;
}

// @internal
export interface WidgetTab {
    // (undocumented)
    readonly betaBadge: boolean;
    // (undocumented)
    readonly iconSpec?: string | React_2.ReactNode;
    // (undocumented)
    readonly title: string;
}

// @internal
export type WidgetTabs = {
    readonly [id in WidgetZoneId]: ReadonlyArray<WidgetTab>;
};

// @public
export enum WidgetType {
    // (undocumented)
    FreeFrom = 2,
    // (undocumented)
    Navigation = 1,
    // (undocumented)
    Rectangular = 3,
    // (undocumented)
    StatusBar = 5,
    // (undocumented)
    Tool = 0,
    // (undocumented)
    ToolSettings = 4
}

// @public
export class Workflow extends ItemDefBase {
    constructor(workflowDef: WorkflowProps);
    readonly activeTask: Task | undefined;
    activeTaskId: string | null;
    defaultTaskId: string;
    getSortedTasks(): Task[];
    getTask(taskId: string): Task | undefined;
    readonly id: string;
    isActive: boolean;
    isDefault: boolean;
    readonly lastActiveTask: Task | undefined;
    setActiveTask(task: Task): void;
    workflowId: string;
}

// @public
export class WorkflowActivatedEvent extends UiEvent<WorkflowActivatedEventArgs> {
}

// @public
export interface WorkflowActivatedEventArgs {
    // (undocumented)
    workflow?: Workflow;
    // (undocumented)
    workflowId?: string;
}

// @public
export class WorkflowManager {
    static readonly activeTask: Task | undefined;
    static readonly activeTaskId: string;
    static readonly activeWorkflow: Workflow | undefined;
    static readonly activeWorkflowId: string;
    static addWorkflow(workflowId: string, workflow: Workflow): void;
    static readonly defaultWorkflowId: string;
    static findWorkflow(workflowId: string): Workflow | undefined;
    // (undocumented)
    static getSortedWorkflows(): Workflow[];
    static loadWorkflow(workflowProps: WorkflowProps): void;
    static loadWorkflows(workflowPropsList: WorkflowPropsList): void;
    static readonly onTaskActivatedEvent: TaskActivatedEvent;
    static readonly onWorkflowActivatedEvent: WorkflowActivatedEvent;
    static removeWorkflow(workflow: Workflow): boolean;
    static setActiveWorkflow(workflow: Workflow | undefined): void;
    static setActiveWorkflowAndTask(workflow: Workflow, task: Task): Promise<void>;
    static setDefaultWorkflowId(id: string): void;
    }

// @public
export interface WorkflowProps extends ItemProps {
    // (undocumented)
    defaultTaskId: string;
    // (undocumented)
    id: string;
    // (undocumented)
    isDefault?: boolean;
    // (undocumented)
    tasks: string[];
}

// @public
export interface WorkflowPropsList {
    // (undocumented)
    defaultWorkflowId: string;
    // (undocumented)
    workflows: WorkflowProps[];
}

// @public
export class Zone extends React_2.Component<ZoneProps> {
    constructor(props: ZoneProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static initializeZoneDef(zoneDef: ZoneDef, props: ZoneProps): void;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export class ZoneDef extends WidgetHost {
    constructor();
    allowsMerging: boolean;
    applicationData?: any;
    readonly isStatusBar: boolean;
    readonly isToolSettings: boolean;
    mergeWithZone?: ZoneLocation;
    readonly shouldFillZone: boolean;
    zoneState: ZoneState;
}

// @public
export interface ZoneDefProvider {
    // (undocumented)
    getZoneDef(zoneId: number): ZoneDef | undefined;
}

// @public
export enum ZoneLocation {
    // (undocumented)
    BottomCenter = 8,
    // (undocumented)
    BottomLeft = 7,
    // (undocumented)
    BottomRight = 9,
    // (undocumented)
    CenterLeft = 4,
    // (undocumented)
    CenterRight = 6,
    // (undocumented)
    TopCenter = 2,
    // (undocumented)
    TopLeft = 1,
    // (undocumented)
    TopRight = 3
}

// @public
export interface ZoneProps extends CommonProps {
    allowsMerging?: boolean;
    applicationData?: any;
    defaultState?: ZoneState;
    mergeWithZone?: ZoneLocation;
    // @internal (undocumented)
    runtimeProps?: ZoneRuntimeProps;
    widgets?: Array<React_2.ReactElement<WidgetProps>>;
}

// @internal
export interface ZoneRuntimeProps {
    // (undocumented)
    activeTabIndex: number;
    // (undocumented)
    draggedWidget: DraggedWidgetManagerProps | undefined;
    // (undocumented)
    dropTarget: ZoneTargetType | undefined;
    // (undocumented)
    getWidgetContentRef: (id: WidgetZoneId) => React_2.Ref<HTMLDivElement>;
    // (undocumented)
    ghostOutline: RectangleProps | undefined;
    // (undocumented)
    isHidden: boolean;
    // (undocumented)
    isInFooterMode: boolean;
    // (undocumented)
    openWidgetId: WidgetZoneId | undefined;
    // (undocumented)
    targetChangeHandler: TargetChangeHandler;
    // (undocumented)
    widget: WidgetManagerProps | undefined;
    // (undocumented)
    widgetChangeHandler: WidgetChangeHandler;
    // (undocumented)
    widgetTabs: WidgetTabs;
    // (undocumented)
    zone: ZoneManagerProps;
    // (undocumented)
    zoneDef: ZoneDef;
    // (undocumented)
    zoneDefProvider: ZoneDefProvider;
}

// @public
export enum ZoneState {
    // (undocumented)
    Floating = 4,
    // (undocumented)
    Minimized = 1,
    // (undocumented)
    Off = 0,
    // (undocumented)
    Open = 2,
    // (undocumented)
    Popup = 3
}

// @internal
export class ZoneTargets extends React_2.Component<ZoneTargetsProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @internal
export interface ZoneTargetsProps extends CommonProps {
    // (undocumented)
    dropTarget: ZoneTargetType | undefined;
    // (undocumented)
    targetChangeHandler: TargetChangeHandler;
    // (undocumented)
    zoneId: WidgetZoneId;
}


// (No @packageDocumentation comment for this package)

```
